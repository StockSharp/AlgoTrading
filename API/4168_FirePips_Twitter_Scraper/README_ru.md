# Стратегия FirePips Twitter Scraper

## Обзор
**FirePips Twitter Scraper Strategy** — это точный порт скрипта MetaTrader `firepips_.mq4` на платформу StockSharp. Исходный MQ4
файл не являлся торговым советником: он использовал WinInet для загрузки публичной страницы FirePips в Twitter, искал в HTML
вхождения заданного идентификатора ордера и сохранял полученный ответ на диск для последующего анализа. В версии на C# тот же
процесс перенесён в StockSharp, благодаря чему его можно запускать по расписанию, контролировать через системный журнал и,
при необходимости, сочетать с другими компонентами инфраструктуры.

В отличие от классических стратегий, этот порт не подписывается на рыночные данные и не выставляет заявки. Он сосредоточен на
надёжном HTTP-взаимодействии, детерминированной обработке текста и подробной телеметрии, эквивалентной сообщениям `Alert` и
`Print` из MQL. Стратегию можно запускать в Designer, Shell или Runner, чтобы периодически делать снимок страницы FirePips и
убедиться, что искомый идентификатор (по умолчанию `"Order ID: 7"`) присутствует в контенте.

## Последовательность работы
1. **Запуск** — метод `OnStarted` сразу же планирует асинхронную задачу, чтобы не блокировать пользовательский интерфейс во
   время HTTP-запроса. Сообщения о ходе выполнения выводятся через `AddInfoLog`, повторяя поведение `Alert` в MetaTrader.
2. **HTTP-загрузка** — стратегия создаёт `HttpClient` с пользовательским тайм-аутом и скачивает указанный URL. Любой неуспешный
   код состояния или исключение транспортного уровня перехватывается и передаётся в `AddErrorLog`, как это делал блок `Alert`
   при ошибке в MQ4.
3. **Проверка контента** — если тело ответа пустое, выводится предупреждение и процесс завершает работу досрочно, имитируя
   `Alert("Nicht nur ein paar daten")` из оригинального скрипта.
4. **Поисковый цикл** — загруженная строка анализируется последовательно, как в MQL `StringFind`: каждое совпадение подстроки
   фиксируется, и его позиция (индекс символа с нуля) записывается в журнал. Это соответствует сообщениям
   `Print("order 7 found atz=", index)`.
5. **Сохранение файла** — ответ записывается в файл с именем, заданным пользователем, в кодировке UTF-8. Тем самым воспроизводится
   пара вызовов `FileOpen` и `FileWrite` из исходной реализации.
6. **Извлечение токена** — стратегия анализирует первый токен до разделителя `;`, копируя попытку прочитать тип ордера из файла,
   которая присутствовала в ветке CSV-парсинга MQ4. Успешные преобразования к целому числу заносятся в журнал; в противном случае
   выводится пояснение, почему числовое значение не найдено.
7. **Завершение** — по окончании работы (или при ошибке) вызывается `Stop()`, что приводит к выполнению `OnStopped` и записи
   финального сообщения.

## Параметры
| Имя | Тип | Значение по умолчанию | Описание |
| --- | --- | --- | --- |
| `RequestUrl` | `string` | `http://twitter.com/FirePips` | Загружаемый адрес. Полностью повторяет жёстко заданную цель WinInet в скрипте. |
| `SearchText` | `string` | `Order ID: 7` | Подстрока для поиска в HTML. Каждое совпадение порождает информационную запись. |
| `OutputFileName` | `string` | `SavedFromInternet.htm` | Имя локального файла, куда сохраняется ответ. Относительные пути трактуются относительно текущей рабочей папки. |
| `RequestTimeout` | `int` | `30000` | Тайм-аут HTTP в миллисекундах. Ограничивает время ожидания медленного запроса. |

Все настройки оформлены через `StrategyParam<T>`, поэтому их можно изменять из интерфейса StockSharp или использовать в оптимизаторе
для перебора различных комбинаций (например, разных идентификаторов или альтернативных URL).

## Соответствие оригиналу
- **WinInet против HttpClient** — вызовы `InternetOpenA`, `InternetOpenUrlA` и `InternetReadFile` заменены на `HttpClient` с
  автоматическим освобождением ресурсов в блоках `using`.
- **Управление циклом** — в MQ4 использовался цикл с опросом `IsStopped()`. StockSharp-версия полагается на кооперативное
  завершение и после скачивания вызывает `Stop()`, избавляясь от активного ожидания.
- **Поиск строк** — последовательный `StringFind` перенесён в метод `FindOccurrences`, который сохраняет чувствительность к
  регистру и исключает перекрывающиеся совпадения.
- **Работа с файлами** — вместо нескольких режимов `FileOpen` применяется `File.WriteAllText`, записывающий весь ответ за один
  вызов. Логика извлечения первого целочисленного токена сохранена.
- **Диагностика** — все ветви `Alert` преобразованы в структурированные лог-сообщения: ошибки передаются в `AddErrorLog`,
  предупреждения — в `AddWarningLog`, информационные данные — в `AddInfoLog`.

## Рекомендации по использованию
- Если требуется регулярное скачивание, запускайте стратегию через StockSharp Runner: он может перезапускать задачу с заданным
  интервалом и использовать те же параметры.
- Настройте `RequestUrl` и `SearchText`, чтобы отслеживать другие идентификаторы FirePips или даже посторонние сервисы. Логика
  не зависит от источника, пока ответ представлен текстом.
- Для рабочих сценариев имеет смысл перенаправить `OutputFileName` в отдельный каталог (например, `%APPDATA%/FirePips` или
  `/var/stocksharp/firepips`), чтобы упорядочить снимки.
- Можно связать данный скрейпер со второй стратегией StockSharp, которая анализирует сохранённый файл и реагирует на новые номера
  ордеров, если требуется автоматизация обработки сигналов FirePips.
- Просматривайте сообщения в журнале StockSharp, чтобы убедиться, что поисковый цикл нашёл ожидаемые совпадения.

## Отличия от исходной реализации
- Новый вариант использует асинхронный неблокирующий подход; в MQ4 применялся блокирующий цикл с `Sleep(1)`.
- Файл сохраняется в кодировке UTF-8, что устраняет локализационные проблемы, возможные при ANSI-кодировке MetaTrader.
- Сетевые ошибки сопровождаются подробными текстами исключений, а не обобщёнными сообщениями «Error with InternetOpenUrlA()»,
  что упрощает диагностику проблем с прокси или брандмауэрами.
- После завершения загрузки стратегия автоматически вызывает `Stop()`, поэтому не нужно вручную закрывать скрипт, как в MetaTrader.
