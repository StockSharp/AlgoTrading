# 订单计数策略

## 概述
该策略是 MetaTrader 专家顾问 **Count_Orders.mq4** 的 StockSharp 版本。原始 EA 通过 `Comment()` 函数实时显示当前运行的
多单和空单数量，并在启动时自动生成三笔演示交易，以便用户立刻看到统计信息。移植后的策略保持了相同的目标：
它在 StockSharp 中持续记录买单与卖单的活动数量，并在日志中输出统计结果，同时也会按原脚本的节奏提交演示订单，
帮助你立即验证计数逻辑。

策略不依赖技术指标或价格模式，所有行为都由事件驱动：在启动阶段完成手数归一化，随后异步派发示例交易，并通过
`OnOrderChanged` 事件更新内部的订单计数器。

## 工作流程
1. **参数校准**：启动后先根据品种的 `VolumeStep`、`VolumeMin` 与 `VolumeMax` 调整用户输入的手数，并在日志中说明是否
   进行了修正。
2. **演示交易序列**：按照“买、买、卖”的顺序提交三笔市价单，默认在每次提交之间等待 2000 毫秒，以复刻 MQL 脚本
   中的 `Sleep()` 行为，同时不会阻塞策略线程。
3. **保护单设置**：每次进场后尝试根据 MetaTrader 的点数距离调用 `SetStopLoss` 与 `SetTakeProfit`。如果当前还没有有效的
   报价，保护单会被跳过，并在日志中给出提示。
4. **订单计数**：每当 StockSharp 报告订单状态变化时，将该订单加入或移出对应的 `HashSet`（多单或空单集合），并调用
   `AddInfoLog` 输出“总订单数/买单/卖单”的最新统计。
5. **优雅停止**：`CancellationTokenSource` 会在策略停止时取消未完成的异步延迟，确保不会留下后台任务。

## 参数
| 名称 | 说明 |
| --- | --- |
| **Magic Number** | 写入 `Order.UserOrderId` 的魔术号，对应原脚本的 `MAGICMA` 输入，用于在报表中区分这三笔演示交易。 |
| **Stop-Loss Points** | 止损距离（MetaTrader 点）。设置为 0 时不挂出止损。 |
| **Take-Profit Points** | 止盈距离（MetaTrader 点）。设置为 0 时不挂出止盈。 |
| **Trade Volume** | 每笔演示交易的手数。会根据品种的最小手数和步长进行归一化。 |
| **Slippage** | 从 MQL 保留下来的滑点参数。StockSharp 的市价单不会使用该值，但为了兼容仍然提供。 |
| **Wait Time (ms)** | 演示订单之间的等待时间（毫秒）。设为 0 时三笔订单会连续发送。 |

## 实现细节
- 类位于 `StockSharp.Samples.Strategies` 命名空间，并按照仓库要求全部使用制表符缩进。
- 在 `OnStarted` 中调用 `StartProtection()`，确保后续的 `SetStopLoss` / `SetTakeProfit` 可以集中管理保护单。
- 使用 `Task.Run` 承载演示交易流程，通过 `Task.Delay` 实现可取消的等待，并在 `OnStopped` 中取消令牌防止后台线程遗留。
- 活动买单与卖单分别存储在两个 `HashSet<Order>` 中，只统计当前仍处于 `None/Pending/Active` 状态的订单，避免重复计算
  已完成或取消的记录。
- 保护单参考价格优先使用最优报价，若报价缺失则回退到最新成交价，必要时会写入警告提示。

## 使用建议
- 策略只依赖订单事件，默认不订阅蜡烛或其他数据。只需绑定连接器并指定交易品种，启动后即可看到三笔演示交易和实时
  订单统计。
- 如果只想使用计数功能，可将 **Trade Volume** 设为 0 或在启动后立即停止策略，这样就不会发送任何真实订单。
- 若市场暂时没有报价，日志可能提示无法挂出止损/止盈。等待行情到来后再重新启动或手动下单即可。

## 移植要点
- 原脚本中的 `OrdersCount()` 循环被替换为基于 `OnOrderChanged` 的事件跟踪，符合 StockSharp 的事件驱动架构。
- `Comment()` 输出被转换为 `AddInfoLog`，可以在策略日志面板或外部日志文件中查看。
- 阻塞式的 `Sleep()` 改为异步延迟，避免冻结策略线程，同时保留原有的时间间隔语义。
