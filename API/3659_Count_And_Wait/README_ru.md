# Стратегия Count And Wait

## Обзор
**Count And Wait Strategy** повторяет поведение исходных примеров MetaTrader «Count and Pass» и «Pass Wait then Pass». Стратегия считает количество тиковых сообщений, полученных от торговой площадки. После достижения настраиваемого порога подсчёта она фиксирует событие в журнале, при необходимости переходит в фазу ожидания на второе количество тиков и затем сбрасывает счётчики, начиная новый цикл. Логику удобно использовать как шаблон для случаев, когда требуется дождаться заданного числа обновлений рынка перед выполнением действия.

## Параметры
- **Count Limit** – количество тиков, которые должны прийти до того, как стратегия объявит о завершении цикла. Значение по умолчанию `50` соответствует входному параметру `count` из оригинального скрипта.
- **Wait Limit** – количество тиков ожидания после срабатывания действия, прежде чем счётчики будут сброшены. Значение по умолчанию `0`. Ноль отключает фазу ожидания и полностью повторяет работу скрипта «Count and Pass». Любое положительное значение включает ожидание и соответствует параметру `wait` из «Pass Wait then Pass».

Оба параметра представлены как `StrategyParam<int>`, поэтому их можно оптимизировать или менять из пользовательского интерфейса.

## Логика работы
1. При старте стратегия подписывается на поток сделок для выбранного инструмента.
2. Каждый входящий тик увеличивает счётчик до тех пор, пока не достигнуто значение `Count Limit`.
3. Когда лимит достигнут, в журнал записывается сообщение «Count limit X reached. Executing cycle action.», счётчик ожидания обнуляется и стратегия либо сразу перезапускает цикл (если `Wait Limit` равен нулю), либо переходит в фазу ожидания.
4. Во время ожидания стратегия увеличивает счётчик ожидания на каждый тик, пока не будет получено `Wait Limit` тиков. После этого в журнал заносится «Wait limit X reached. Restarting counting phase.», и оба счётчика сбрасываются.
5. Цикл повторяется, пока стратегия активна.

Стратегия не создаёт заявок автоматически и сохраняет структуру исходных MQL-примеров, где предполагается вставка пользовательского кода в блоки «Your code goes here». При желании можно заменить логирование на отправку заявок или любое другое действие, которое должно выполняться после детерминированного числа тиков.

## Особенности конверсии
- В MetaTrader использовались глобальные счётчики внутри `OnTick`. В порте на StockSharp поля класса обновляются в колбэке `SubscribeTrades().Bind(ProcessTrade)`, что гарантирует обработку каждого тика один раз.
- Вызовы `Alert` и `Comment` заменены на `LogInfo`, чтобы давать обратную связь через встроенную систему логирования StockSharp без обязательной регистрации сделок.
- Семантика параметров полностью сохранена, поэтому для переключения между двумя исходными примерами достаточно изменить только значение `Wait Limit`.
