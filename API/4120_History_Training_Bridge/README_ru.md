# Стратегия History Training Bridge
[English](README.md) | [中文](README_cn.md)

Стратегия представляет собой порт на StockSharp высокоуровневого скрипта MetaTrader `MQL/9196/HistTraining/HistTraining/HistoryTrain.mq4`. Оригинальный советник опрашивает DLL `SharedVarsDLLv2.dll` и реагирует на целочисленные флаги, которые выставляет внешнее обучающее приложение:

- `GetInt(97) == 1` &rarr; открыть покупку с объёмом `GetFloat(1)` по текущей цене Ask.
- `GetInt(98) == 1` &rarr; открыть продажу с объёмом `GetFloat(1)` по текущей цене Bid.
- `GetInt(99) == 1` вместе с `GetInt(20)` &rarr; закрыть ордер с указанным «магическим» номером.
- `GetInt(30) == 1` &rarr; закрыть все сделки и сбросить флаги в общей памяти.

После каждого действия MQL-эксперт возвращает в DLL диагностическую информацию (последний номер, направление, цена). Реализация на StockSharp воспроизводит ту же схему, но делает это через параметры стратегии и высокоуровневые методы, учитывая отличия платформы (неттинг вместо хеджирования, характерного для MetaTrader).

## Последовательность команд

1. **Подписка на Level 1** – вызывается `SubscribeLevel1()`, чтобы отслеживать лучшие цены Bid/Ask. Значения сохраняются для отображения диагностической информации, аналогично тому, как MQL сохранял Ask/Bid перед отправкой ордера.
2. **Таймер 200&nbsp;мс** – метод `ProcessPendingRequests` имитирует цикл опроса DLL и преобразует изменения параметров в конкретные торговые команды.
3. **Выполнение команд**
   - `RequestBuy` / `RequestSell`: регистрация рыночных ордеров через `CreateMarketOrder` + `RegisterOrder`. Если текущая позиция противоположная, автоматически добавляется объём для переворота, как и в MQL, где новый ордер закрывал предыдущий.
   - `RequestCloseSelected`: закрывает часть позиции, которая связана с `TargetOrderNumber`. Для каждого входа хранится собственный объём, поэтому дополнительные доливки можно закрывать по отдельности.
   - `RequestCloseAll`: полностью закрывает позицию и очищает внутренний реестр ордеров.
4. **Диагностика** – после обработки команды обновляются:
   - `LastOrderNumber` – счётчик, начинающийся с 0, когда открытых позиций нет (аналог переменной `magn`).
   - `LastActionCode` – 1 (покупка), 2 (продажа), 3 (частичное закрытие), 4 (полное закрытие), 0 в состоянии ожидания.
   - `LastTradePrice` – последняя цена исполнения (берётся как из Bid/Ask, так и из `OnNewMyTrade`).

## Параметры

| Параметр | Назначение |
|----------|------------|
| `DefaultVolume` | Аналог `GetFloat(1)` – базовый объём сделки. Значение должно быть строго положительным. |
| `RequestBuy` | Внешний переключатель для открытия лонга. После исполнения автоматически сбрасывается в `false`. |
| `RequestSell` | Переключатель для открытия шорта. |
| `RequestCloseSelected` | При активации закрывает часть позиции, соответствующую `TargetOrderNumber`. |
| `RequestCloseAll` | Закрывает всю позицию и очищает реестр открытых команд. |
| `TargetOrderNumber` | Аналог `GetInt(20)` – идентификатор позиции для `RequestCloseSelected`. |
| `LastOrderNumber` | Только для чтения; отражает последний присвоенный номер (аналог `SetInt(10, magn)`). |
| `LastActionCode` | Только для чтения; повторяет `SetInt(11, direction)` и дополняет его кодами закрытия. |
| `LastTradePrice` | Только для чтения; аналог `SetFloat(10, price)` из оригинального кода. |

## Особенности реализации

- Используются только высокоуровневые методы StockSharp (`StartProtection`, `SubscribeLevel1`, `CreateMarketOrder`, `RegisterOrder`). Никаких низкоуровневых вызовов или собственных коллекций.
- Все команды отправляются только если `IsFormedAndOnlineAndAllowTrading()` возвращает `true`, чтобы избежать заявок до готовности подключения.
- Комментарии ордеров имеют формат `HistoryTraining:Entry:<n>` / `HistoryTraining:Exit:<n>`, что упрощает анализ сделок в журнале.
- При смене направления (например, шорт &rarr; лонг) противоположные записи из реестра удаляются автоматически, потому что в StockSharp позиция неттинговая.
- Если `DefaultVolume` задан некорректно (неположительное значение), команда игнорируется, и в журнал записывается предупреждение.

## Отличия от варианта на MQL

- **Неттинговая позиция** – MetaTrader может удерживать несколько хеджирующих ордеров, StockSharp учитывает суммарную позицию. Закрытие «отдельного» входа уменьшает общий объём на записанную величину, что явно описано в документации и логах.
- **Параметры вместо DLL** – вместо `SharedVarsDLLv2.dll` управляющее приложение меняет параметры `Request*` через UI, скрипты или автотесты.
- **Дополнительная диагностика** – `LastTradePrice` обновляется при каждом фактическом исполнении, поэтому интерфейс отражает фактическую цену с учётом проскальзывания.
- **Таймерный опрос** – повторяет частоту опроса DLL, не блокируя цикл сообщений StockSharp.

## Рекомендации по использованию

1. Задайте `DefaultVolume` и привяжите стратегию к нужной бумаге и портфелю.
2. Подключите внешний контроллер (кнопки, тренировочный модуль, автотест) и переключайте параметры `Request*` для выдачи команд.
3. Следите за `LastOrderNumber`, `LastActionCode` и `LastTradePrice`, чтобы подтверждать исполнение каждой операции.
4. Для частичного выхода укажите `TargetOrderNumber`, полученный после открытия, и активируйте `RequestCloseSelected`.
5. Используйте `RequestCloseAll` как аварийную остановку или синхронизацию с обучающей системой.

Python-версия намеренно не создавалась. Реализация ограничивается файлом `CS/HistoryTrainingBridgeStrategy.cs`.
