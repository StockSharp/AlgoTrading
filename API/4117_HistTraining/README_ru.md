# Стратегия HistTraining

## Обзор
- Полностью воспроизводит советник MetaTrader 4 `HistoryTrain.mq4`, который ожидал сигналы от внешнего обучающего модуля.
- Вместо чтения глобальных целых переменных с номерами 97, 98 и 99 C#‑версия использует три булевых параметра (`BuyTrigger`, `SellTrigger`, `CloseTrigger`).
- Подписка на минутные свечи служит только «сердцебиением» – на закрытии каждой свечи проверяются переключатели.
- Стратегия не строит индикаторы и не фильтрует цену: каждое действие инициируется внешним процессом, который меняет параметры.

## Параметры
| Имя | Описание |
| --- | --- |
| `OrderVolume` | Объём рыночной заявки. По умолчанию `0.1`, что соответствует фиксированному лоту в MQL‑коде. |
| `BuyTrigger` | Если стратегия без позиции и параметр установлен в `true`, отправляется рыночная покупка и флаг сбрасывается в `false`. |
| `SellTrigger` | Если стратегия без позиции и параметр установлен в `true`, отправляется рыночная продажа и флаг сбрасывается в `false`. |
| `CloseTrigger` | Если открыта позиция и параметр установлен в `true`, вызывается `ClosePosition()` для её закрытия, после чего флаг возвращается в `false`. |
| `CandleType` | Тип свечей, задающий частоту опроса. По умолчанию – минутный таймфрейм, т.к. советнику требуется только периодический вызов. |

## Торговая логика
1. В `OnStarted` стратегия подписывается на выбранные свечи и активирует `StartProtection()`, чтобы безопасно принять существующие позиции.
2. На каждой закрывшейся свече (`CandleStates.Finished`):
   - Если `BuyTrigger == true` и `Position == 0`, отправляется покупка объёмом `OrderVolume`, затем флаг очищается.
   - Если `SellTrigger == true` и `Position == 0`, отправляется продажа объёмом `OrderVolume`, затем флаг очищается.
   - Если `CloseTrigger == true` и `Position != 0`, вызывается `ClosePosition()` и флаг очищается.
3. Порядок проверки (покупка → продажа → закрытие) повторяет оригинальный советник. Поэтому, если открытие и закрытие включены одновременно, позиция будет немедленно закрыта в том же цикле.

## Работа с ручными сигналами
- Источник сигналов в MQL – глобальные переменные, которые изменял другой модуль (`SetInt@8`/`GetInt@4`). В портированной версии эту роль выполняют параметры стратегии.
- Внешнее приложение, кнопка в UI, скрипт или оптимизатор могут переключать булевы параметры. Если действие не выполнено (например, уже есть позиция), параметр остаётся `true`, и следующая итерация повторит попытку.
- Поскольку внутренняя логика не содержит риск‑менеджмента, его следует добавить отдельно (стоп‑лосс, тейк‑профит, ограничения по времени и т.д.).

## Особенности портирования
- Вызовы `BuyMarket`/`SellMarket` выполняются ровно один раз на срабатывание, что соответствует `OrderSend` с фиксированным объёмом 0.1 лота.
- Закрытие позиции реализовано через `ClosePosition()`, что заменяет две ветки `OrderClose` из исходника.
- Для опроса используется `SubscribeCandles(CandleType)`; индикаторы не добавляются в `Strategy.Indicators`, что соответствует требованиям репозитория.
- Параметры размещены в группе «Manual signals» и помечены как недоступные для оптимизации (`SetCanOptimize(false)`).
- В коде оставлены английские комментарии, поясняющие связь между флагами и исходными глобальными переменными.

## Отличия от MQL‑версии
- Глобальные переменные MetaTrader заменены параметрами `StrategyParam<bool>`.
- Управление тикетами и синхронизацией портфеля выполняет StockSharp, поэтому `OrderSelect` не нужен.
- В MT4 функция `start()` вызывалась на каждом тике; здесь тот же эффект достигается за счёт свечей‑триггеров.
- Объём можно менять во время работы через свойство `OrderVolume`, тогда как оригинал торговал строго 0.1 лота.

## Дополнительные замечания
- Python‑реализация специально не создавалась, как и соответствующая папка.
- Тесты не изменялись – все доработки находятся только в новой директории стратегии.
- Для интеграции с обучающими/реплей‑модулями переключайте параметры незадолго до закрытия следующей свечи, чтобы имитировать работу исторического тренажёра.
