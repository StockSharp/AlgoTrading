using System;
using System.Linq;
using System.Collections.Generic;

using Ecng.Common;
using Ecng.Collections;
using Ecng.Serialization;

using StockSharp.Algo.Indicators;
using StockSharp.Algo.Strategies;
using StockSharp.BusinessEntities;
using StockSharp.Messages;

namespace StockSharp.Samples.Strategies;

/// <summary>
/// Combined strategy that trades using BykovTrend V2 and ColorX2MA signals.
/// The BykovTrend block monitors Williams %R based color transitions to detect trend shifts.
/// The ColorX2MA block double-smooths price data and reacts to slope changes.
/// </summary>
public class BykovTrendColorX2MaStrategy : Strategy
{
	private readonly StrategyParam<DataType> _bykovCandleType;
	private readonly StrategyParam<int> _bykovWilliamsPeriod;
	private readonly StrategyParam<int> _bykovRisk;
	private readonly StrategyParam<int> _bykovSignalBar;
	private readonly StrategyParam<bool> _bykovAllowLongEntries;
	private readonly StrategyParam<bool> _bykovAllowShortEntries;
	private readonly StrategyParam<bool> _bykovAllowLongExits;
	private readonly StrategyParam<bool> _bykovAllowShortExits;

	private readonly StrategyParam<DataType> _colorCandleType;
	private readonly StrategyParam<SmoothingMethod> _colorFirstMethod;
	private readonly StrategyParam<int> _colorFirstLength;
	private readonly StrategyParam<int> _colorFirstPhase;
	private readonly StrategyParam<SmoothingMethod> _colorSecondMethod;
	private readonly StrategyParam<int> _colorSecondLength;
	private readonly StrategyParam<int> _colorSecondPhase;
	private readonly StrategyParam<AppliedPriceMode> _colorAppliedPrice;
	private readonly StrategyParam<int> _colorSignalBar;
	private readonly StrategyParam<bool> _colorAllowLongEntries;
	private readonly StrategyParam<bool> _colorAllowShortEntries;
	private readonly StrategyParam<bool> _colorAllowLongExits;
	private readonly StrategyParam<bool> _colorAllowShortExits;

	private readonly List<int> _bykovColorHistory = new();
	private readonly List<int> _colorTrendHistory = new();

	private WilliamsR _bykovWilliams = null!;
	private IIndicator _colorFirstMa = null!;
	private IIndicator _colorSecondMa = null!;
	private decimal? _colorPreviousValue;
	private int _bykovTrendState;

	/// <summary>
	/// Supported smoothing methods for ColorX2MA.
	/// </summary>
	public enum SmoothingMethod
	{
		/// <summary>
		/// Simple Moving Average.
		/// </summary>
		Sma,

		/// <summary>
		/// Exponential Moving Average.
		/// </summary>
		Ema,

		/// <summary>
		/// Smoothed Moving Average (RMA).
		/// </summary>
		Smma,

		/// <summary>
		/// Linear Weighted Moving Average.
		/// </summary>
		Lwma,

		/// <summary>
		/// Jurik Moving Average.
		/// </summary>
		Jurik
	}

/// <summary>
/// Applied price options matching the original indicator.
/// </summary>
public enum AppliedPriceMode
{
	/// <summary>
	/// Closing price.
	/// </summary>
	Close,

	/// <summary>
	/// Opening price.
	/// </summary>
	Open,

	/// <summary>
	/// Highest price.
	/// </summary>
	High,

	/// <summary>
	/// Lowest price.
	/// </summary>
	Low,

	/// <summary>
	/// Median price (High + Low) / 2.
	/// </summary>
	Median,

	/// <summary>
	/// Typical price (High + Low + Close) / 3.
	/// </summary>
	Typical,

	/// <summary>
	/// Weighted close price (2 * Close + High + Low) / 4.
	/// </summary>
	Weighted,

	/// <summary>
	/// Simple average of Open and Close.
	/// </summary>
	Simple,

	/// <summary>
	/// Quarted price (Open + Close + High + Low) / 4.
	/// </summary>
	Quarted,

	/// <summary>
	/// Trend-following price that favors extremes.
	/// </summary>
	TrendFollow0,

	/// <summary>
	/// Trend-following price that blends extremes with the close.
	/// </summary>
	TrendFollow1,

	/// <summary>
	/// DeMark price variation.
	/// </summary>
	Demark
}

/// <summary>
/// Candle type used for BykovTrend calculations.
/// </summary>
public DataType BykovTrendCandleType
{
	get => _bykovCandleType.Value;
	set => _bykovCandleType.Value = value;
}

/// <summary>
/// Williams %R period for BykovTrend.
/// </summary>
public int BykovWilliamsPeriod
{
	get => _bykovWilliamsPeriod.Value;
	set => _bykovWilliamsPeriod.Value = value;
}

/// <summary>
/// Risk factor that shifts the Williams %R thresholds.
/// </summary>
public int BykovRisk
{
	get => _bykovRisk.Value;
	set => _bykovRisk.Value = value;
}

/// <summary>
/// Number of completed candles to delay BykovTrend signals.
/// </summary>
public int BykovSignalBar
{
	get => _bykovSignalBar.Value;
	set => _bykovSignalBar.Value = value;
}

/// <summary>
/// Enable long entries generated by BykovTrend.
/// </summary>
public bool BykovAllowLongEntries
{
	get => _bykovAllowLongEntries.Value;
	set => _bykovAllowLongEntries.Value = value;
}

/// <summary>
/// Enable short entries generated by BykovTrend.
/// </summary>
public bool BykovAllowShortEntries
{
	get => _bykovAllowShortEntries.Value;
	set => _bykovAllowShortEntries.Value = value;
}

/// <summary>
/// Allow long position exits on BykovTrend downticks.
/// </summary>
public bool BykovAllowLongExits
{
	get => _bykovAllowLongExits.Value;
	set => _bykovAllowLongExits.Value = value;
}

/// <summary>
/// Allow short position exits on BykovTrend upticks.
/// </summary>
public bool BykovAllowShortExits
{
	get => _bykovAllowShortExits.Value;
	set => _bykovAllowShortExits.Value = value;
}

/// <summary>
/// Candle type used for ColorX2MA calculations.
/// </summary>
public DataType ColorCandleType
{
	get => _colorCandleType.Value;
	set => _colorCandleType.Value = value;
}

/// <summary>
/// Smoothing method for the first moving average.
/// </summary>
public SmoothingMethod ColorFirstMethod
{
	get => _colorFirstMethod.Value;
	set => _colorFirstMethod.Value = value;
}

/// <summary>
/// Length of the first smoothing stage.
/// </summary>
public int ColorFirstLength
{
	get => _colorFirstLength.Value;
	set => _colorFirstLength.Value = value;
}

/// <summary>
/// Phase parameter for the first smoothing stage (kept for compatibility).
/// </summary>
public int ColorFirstPhase
{
	get => _colorFirstPhase.Value;
	set => _colorFirstPhase.Value = value;
}

/// <summary>
/// Smoothing method for the second moving average.
/// </summary>
public SmoothingMethod ColorSecondMethod
{
	get => _colorSecondMethod.Value;
	set => _colorSecondMethod.Value = value;
}

/// <summary>
/// Length of the second smoothing stage.
/// </summary>
public int ColorSecondLength
{
	get => _colorSecondLength.Value;
	set => _colorSecondLength.Value = value;
}

/// <summary>
/// Phase parameter for the second smoothing stage (kept for compatibility).
/// </summary>
public int ColorSecondPhase
{
	get => _colorSecondPhase.Value;
	set => _colorSecondPhase.Value = value;
}

/// <summary>
/// Applied price used by ColorX2MA.
/// </summary>
public AppliedPriceMode ColorAppliedPrice
{
	get => _colorAppliedPrice.Value;
	set => _colorAppliedPrice.Value = value;
}

/// <summary>
/// Number of completed candles to delay ColorX2MA signals.
/// </summary>
public int ColorSignalBar
{
	get => _colorSignalBar.Value;
	set => _colorSignalBar.Value = value;
}

/// <summary>
/// Enable long entries generated by ColorX2MA.
/// </summary>
public bool ColorAllowLongEntries
{
	get => _colorAllowLongEntries.Value;
	set => _colorAllowLongEntries.Value = value;
}

/// <summary>
/// Enable short entries generated by ColorX2MA.
/// </summary>
public bool ColorAllowShortEntries
{
	get => _colorAllowShortEntries.Value;
	set => _colorAllowShortEntries.Value = value;
}

/// <summary>
/// Allow long position exits on ColorX2MA downtrends.
/// </summary>
public bool ColorAllowLongExits
{
	get => _colorAllowLongExits.Value;
	set => _colorAllowLongExits.Value = value;
}

/// <summary>
/// Allow short position exits on ColorX2MA uptrends.
/// </summary>
public bool ColorAllowShortExits
{
	get => _colorAllowShortExits.Value;
	set => _colorAllowShortExits.Value = value;
}

/// <summary>
/// Initialize parameters.
/// </summary>
public BykovTrendColorX2MaStrategy()
{
	_bykovCandleType = Param(nameof(BykovTrendCandleType), TimeSpan.FromHours(4).TimeFrame())
	.SetDisplay("BykovTrend Candle", "Timeframe for BykovTrend analysis", "BykovTrend");

	_bykovWilliamsPeriod = Param(nameof(BykovWilliamsPeriod), 9)
	.SetGreaterThanZero()
	.SetDisplay("Williams %R Period", "Williams %R length used by BykovTrend", "BykovTrend")
	.SetCanOptimize(true)
	.SetOptimize(5, 30, 1);

	_bykovRisk = Param(nameof(BykovRisk), 3)
	.SetDisplay("Risk Offset", "Shifts Williams %R thresholds (33 - Risk)", "BykovTrend")
	.SetRange(0, 30)
	.SetCanOptimize(true);

	_bykovSignalBar = Param(nameof(BykovSignalBar), 1)
	.SetDisplay("Signal Bar", "Delay in completed candles before acting", "BykovTrend")
	.SetRange(0, 5);

	_bykovAllowLongEntries = Param(nameof(BykovAllowLongEntries), true)
	.SetDisplay("Enable Long Entries", "Allow BykovTrend bullish entries", "BykovTrend");

	_bykovAllowShortEntries = Param(nameof(BykovAllowShortEntries), true)
	.SetDisplay("Enable Short Entries", "Allow BykovTrend bearish entries", "BykovTrend");

	_bykovAllowLongExits = Param(nameof(BykovAllowLongExits), true)
	.SetDisplay("Allow Long Exits", "Close long positions on BykovTrend downturns", "BykovTrend");

	_bykovAllowShortExits = Param(nameof(BykovAllowShortExits), true)
	.SetDisplay("Allow Short Exits", "Close short positions on BykovTrend upturns", "BykovTrend");

	_colorCandleType = Param(nameof(ColorCandleType), TimeSpan.FromHours(4).TimeFrame())
	.SetDisplay("ColorX2MA Candle", "Timeframe for ColorX2MA analysis", "ColorX2MA");

	_colorFirstMethod = Param(nameof(ColorFirstMethod), SmoothingMethod.Sma)
	.SetDisplay("First MA Method", "Smoothing method for the first stage", "ColorX2MA");

	_colorFirstLength = Param(nameof(ColorFirstLength), 12)
	.SetGreaterThanZero()
	.SetDisplay("First MA Length", "Length of the first smoothing stage", "ColorX2MA")
	.SetCanOptimize(true)
	.SetOptimize(5, 30, 1);

	_colorFirstPhase = Param(nameof(ColorFirstPhase), 15)
	.SetDisplay("First MA Phase", "Compatibility parameter for JJMA phase", "ColorX2MA");

	_colorSecondMethod = Param(nameof(ColorSecondMethod), SmoothingMethod.Jurik)
	.SetDisplay("Second MA Method", "Smoothing method for the second stage", "ColorX2MA");

	_colorSecondLength = Param(nameof(ColorSecondLength), 5)
	.SetGreaterThanZero()
	.SetDisplay("Second MA Length", "Length of the second smoothing stage", "ColorX2MA")
	.SetCanOptimize(true)
	.SetOptimize(3, 20, 1);

	_colorSecondPhase = Param(nameof(ColorSecondPhase), 15)
	.SetDisplay("Second MA Phase", "Compatibility parameter for JJMA phase", "ColorX2MA");

	_colorAppliedPrice = Param(nameof(ColorAppliedPrice), AppliedPriceMode.Close)
	.SetDisplay("Applied Price", "Price source for ColorX2MA", "ColorX2MA");

	_colorSignalBar = Param(nameof(ColorSignalBar), 1)
	.SetDisplay("ColorX2MA Signal Bar", "Delay in completed candles before acting", "ColorX2MA")
	.SetRange(0, 5);

	_colorAllowLongEntries = Param(nameof(ColorAllowLongEntries), true)
	.SetDisplay("Enable Long Entries", "Allow ColorX2MA bullish entries", "ColorX2MA");

	_colorAllowShortEntries = Param(nameof(ColorAllowShortEntries), true)
	.SetDisplay("Enable Short Entries", "Allow ColorX2MA bearish entries", "ColorX2MA");

	_colorAllowLongExits = Param(nameof(ColorAllowLongExits), true)
	.SetDisplay("Allow Long Exits", "Close long positions on ColorX2MA downturns", "ColorX2MA");

	_colorAllowShortExits = Param(nameof(ColorAllowShortExits), true)
	.SetDisplay("Allow Short Exits", "Close short positions on ColorX2MA upturns", "ColorX2MA");
}

/// <inheritdoc />
public override IEnumerable<(Security sec, DataType dt)> GetWorkingSecurities()
{
	yield return (Security, BykovTrendCandleType);
	yield return (Security, ColorCandleType);
}

/// <inheritdoc />
protected override void OnReseted()
{
	base.OnReseted();

	_bykovColorHistory.Clear();
	_colorTrendHistory.Clear();
	_colorPreviousValue = null;
	_bykovTrendState = 0;
}

/// <inheritdoc />
protected override void OnStarted(DateTimeOffset time)
{
	base.OnStarted(time);

	_bykovWilliams = new WilliamsR { Length = BykovWilliamsPeriod };
	_colorFirstMa = CreateMovingAverage(ColorFirstMethod, ColorFirstLength);
	_colorSecondMa = CreateMovingAverage(ColorSecondMethod, ColorSecondLength);
	_colorPreviousValue = null;

	var bykovSubscription = SubscribeCandles(BykovTrendCandleType);
	bykovSubscription
	.BindEx(_bykovWilliams, ProcessBykovTrend)
	.Start();

	var colorSubscription = SubscribeCandles(ColorCandleType);
	colorSubscription
	.Bind(ProcessColorX2Ma)
	.Start();

	var area = CreateChartArea();
	if (area != null)
	{
		DrawCandles(area, bykovSubscription);
		DrawIndicator(area, _colorSecondMa);
		DrawOwnTrades(area);
	}
}

private void ProcessBykovTrend(ICandleMessage candle, IIndicatorValue williamsValue)
{
	if (candle.State != CandleStates.Finished)
	return;

	if (!IsFormedAndOnlineAndAllowTrading())
	return;

	if (!williamsValue.IsFinal)
	return;

	var williams = williamsValue.ToDecimal();
	var color = CalculateBykovColor(candle, williams);

	_bykovColorHistory.Add(color);

	var (hasValues, currentColor, previousColor) = GetColorsForSignal(_bykovColorHistory, BykovSignalBar);
	if (!hasValues)
	return;

	HandleBykovSignals(candle, currentColor, previousColor);
}

private void ProcessColorX2Ma(ICandleMessage candle)
{
	if (candle.State != CandleStates.Finished)
	return;

	if (!IsFormedAndOnlineAndAllowTrading())
	return;

	var price = GetAppliedPrice(candle, ColorAppliedPrice);
	var firstValue = _colorFirstMa.Process(price, candle.CloseTime, true).ToNullableDecimal();
	if (firstValue is null)
	return;

	var secondValue = _colorSecondMa.Process(firstValue.Value, candle.CloseTime, true).ToNullableDecimal();
	if (secondValue is null)
	return;

	if (!_colorSecondMa.IsFormed)
	{
		_colorPreviousValue = secondValue;
		_colorTrendHistory.Add(0);
		return;
	}

	if (_colorPreviousValue is null)
	{
		_colorPreviousValue = secondValue;
		_colorTrendHistory.Add(0);
		return;
	}

	var color = 0;
	if (secondValue.Value > _colorPreviousValue.Value)
		color = 1;
	else if (secondValue.Value < _colorPreviousValue.Value)
		color = 2;

	_colorTrendHistory.Add(color);
	_colorPreviousValue = secondValue;

	var (hasValues, currentColor, previousColor) = GetColorsForSignal(_colorTrendHistory, ColorSignalBar);
	if (!hasValues)
		return;

	HandleColorSignals(candle, currentColor, previousColor);
}

private int CalculateBykovColor(ICandleMessage candle, decimal williams)
{
	var risk = Math.Clamp(BykovRisk, 0, 33);
	var threshold = 33 - risk;

	if (williams < -100 + threshold)
	_bykovTrendState = -1;
	else if (williams > -threshold)
	_bykovTrendState = 1;

	if (_bykovTrendState > 0)
	return candle.ClosePrice >= candle.OpenPrice ? 0 : 1;

	if (_bykovTrendState < 0)
	return candle.ClosePrice <= candle.OpenPrice ? 4 : 3;

	return 2;
}

private void HandleBykovSignals(ICandleMessage candle, int currentColor, int previousColor)
{
	if (currentColor < 2)
	{
		if (BykovAllowShortExits && Position < 0)
		{
			var volume = Math.Abs(Position);
			if (volume > 0)
			{
				BuyMarket(volume);
				LogInfo($"BykovTrend short exit at {candle.ClosePrice}. Color={currentColor}.");
			}
		}

		if (BykovAllowLongEntries && previousColor > 1 && Position <= 0)
		{
			var volume = Volume + Math.Abs(Position);
			if (volume > 0)
			{
				BuyMarket(volume);
				LogInfo($"BykovTrend long entry at {candle.ClosePrice}. PrevColor={previousColor}, Color={currentColor}.");
			}
		}
	}
	else if (currentColor > 2)
	{
		if (BykovAllowLongExits && Position > 0)
		{
			var volume = Math.Abs(Position);
			if (volume > 0)
			{
				SellMarket(volume);
				LogInfo($"BykovTrend long exit at {candle.ClosePrice}. Color={currentColor}.");
			}
		}

		if (BykovAllowShortEntries && previousColor < 3 && Position >= 0)
		{
			var volume = Volume + Math.Abs(Position);
			if (volume > 0)
			{
				SellMarket(volume);
				LogInfo($"BykovTrend short entry at {candle.ClosePrice}. PrevColor={previousColor}, Color={currentColor}.");
			}
		}
	}
}

private void HandleColorSignals(ICandleMessage candle, int currentColor, int previousColor)
{
	if (currentColor == 1)
	{
		if (ColorAllowShortExits && Position < 0)
		{
			var volume = Math.Abs(Position);
			if (volume > 0)
			{
				BuyMarket(volume);
				LogInfo($"ColorX2MA short exit at {candle.ClosePrice}. Color={currentColor}.");
			}
		}

		if (ColorAllowLongEntries && previousColor != 1 && Position <= 0)
		{
			var volume = Volume + Math.Abs(Position);
			if (volume > 0)
			{
				BuyMarket(volume);
				LogInfo($"ColorX2MA long entry at {candle.ClosePrice}. PrevColor={previousColor}, Color={currentColor}.");
			}
		}
	}
	else if (currentColor == 2)
	{
		if (ColorAllowLongExits && Position > 0)
		{
			var volume = Math.Abs(Position);
			if (volume > 0)
			{
				SellMarket(volume);
				LogInfo($"ColorX2MA long exit at {candle.ClosePrice}. Color={currentColor}.");
			}
		}

		if (ColorAllowShortEntries && previousColor != 2 && Position >= 0)
		{
			var volume = Volume + Math.Abs(Position);
			if (volume > 0)
			{
				SellMarket(volume);
				LogInfo($"ColorX2MA short entry at {candle.ClosePrice}. PrevColor={previousColor}, Color={currentColor}.");
			}
		}
	}
}

private static (bool hasValues, int currentColor, int previousColor) GetColorsForSignal(List<int> history, int signalBar)
{
	var currentIndex = history.Count - 1 - signalBar;
	if (currentIndex < 0)
	return (false, 0, 0);

	var previousIndex = currentIndex - 1;
	if (previousIndex < 0)
	return (false, 0, 0);

	return (true, history[currentIndex], history[previousIndex]);
}

private static IIndicator CreateMovingAverage(SmoothingMethod method, int length)
{
	return method switch
	{
		SmoothingMethod.Sma => new SMA { Length = length },
		SmoothingMethod.Ema => new EMA { Length = length },
		SmoothingMethod.Smma => new SMMA { Length = length },
		SmoothingMethod.Lwma => new WMA { Length = length },
		SmoothingMethod.Jurik => new JurikMovingAverage { Length = length },
		_ => new SMA { Length = length }
	};
}

private static decimal GetAppliedPrice(ICandleMessage candle, AppliedPriceMode mode)
{
	return mode switch
	{
		AppliedPriceMode.Close => candle.ClosePrice,
		AppliedPriceMode.Open => candle.OpenPrice,
		AppliedPriceMode.High => candle.HighPrice,
		AppliedPriceMode.Low => candle.LowPrice,
		AppliedPriceMode.Median => (candle.HighPrice + candle.LowPrice) / 2m,
		AppliedPriceMode.Typical => (candle.HighPrice + candle.LowPrice + candle.ClosePrice) / 3m,
		AppliedPriceMode.Weighted => (2m * candle.ClosePrice + candle.HighPrice + candle.LowPrice) / 4m,
		AppliedPriceMode.Simple => (candle.OpenPrice + candle.ClosePrice) / 2m,
		AppliedPriceMode.Quarted => (candle.OpenPrice + candle.ClosePrice + candle.HighPrice + candle.LowPrice) / 4m,
		AppliedPriceMode.TrendFollow0 => candle.ClosePrice > candle.OpenPrice ? candle.HighPrice : (candle.ClosePrice < candle.OpenPrice ? candle.LowPrice : candle.ClosePrice),
		AppliedPriceMode.TrendFollow1 => candle.ClosePrice > candle.OpenPrice ? (candle.HighPrice + candle.ClosePrice) / 2m : (candle.ClosePrice < candle.OpenPrice ? (candle.LowPrice + candle.ClosePrice) / 2m : candle.ClosePrice),
		AppliedPriceMode.Demark => CalculateDemarkPrice(candle),
		_ => candle.ClosePrice
	};
}

private static decimal CalculateDemarkPrice(ICandleMessage candle)
{
	var sum = candle.HighPrice + candle.LowPrice + candle.ClosePrice;

	if (candle.ClosePrice < candle.OpenPrice)
	sum = (sum + candle.LowPrice) / 2m;
	else if (candle.ClosePrice > candle.OpenPrice)
	sum = (sum + candle.HighPrice) / 2m;
	else
	sum = (sum + candle.ClosePrice) / 2m;

	return ((sum - candle.LowPrice) + (sum - candle.HighPrice)) / 2m;
}
}