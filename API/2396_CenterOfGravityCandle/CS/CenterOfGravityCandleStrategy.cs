using System;
using System.Collections.Generic;

using StockSharp.Algo;
using StockSharp.Algo.Indicators;
using StockSharp.Algo.Strategies;
using StockSharp.BusinessEntities;
using StockSharp.Localization;
using StockSharp.Messages;

namespace StockSharp.Samples.Strategies;

/// <summary>
/// Strategy that trades synthetic candles generated by the Center of Gravity Candle indicator.
/// The algorithm reproduces the MetaTrader version: synthetic candle colors drive entries and exits.
/// </summary>
public class CenterOfGravityCandleStrategy : Strategy
{
	private readonly StrategyParam<decimal> _moneyManagement;
	private readonly StrategyParam<CenterOfGravityMarginMode> _marginMode;
	private readonly StrategyParam<int> _stopLossPips;
	private readonly StrategyParam<int> _takeProfitPips;
	private readonly StrategyParam<bool> _enableBuyOpen;
	private readonly StrategyParam<bool> _enableSellOpen;
	private readonly StrategyParam<bool> _enableBuyClose;
	private readonly StrategyParam<bool> _enableSellClose;
	private readonly StrategyParam<DataType> _candleType;
	private readonly StrategyParam<int> _period;
	private readonly StrategyParam<int> _smoothPeriod;
	private readonly StrategyParam<CenterOfGravityMaMethod> _maMethod;
	private readonly StrategyParam<int> _signalBar;

	private CenterOfGravityCandleIndicator? _indicator;
	private readonly List<CenterOfGravityCandleColor> _colorHistory = new();

	private decimal _point;
	private bool _pendingBuyOpen;
	private bool _pendingSellOpen;
	private bool _pendingBuyClose;
	private bool _pendingSellClose;

	/// <summary>
	/// Initializes a new instance of <see cref="CenterOfGravityCandleStrategy"/>.
	/// </summary>
	public CenterOfGravityCandleStrategy()
	{
		_moneyManagement = Param(nameof(MoneyManagement), 0.1m)
		.SetDisplay("Money Management", "Fraction of capital used for volume calculation (negative = fixed lot)", "Risk")
		.SetCanOptimize(true)
		.SetOptimize(0.05m, 0.5m, 0.05m);

		_marginMode = Param(nameof(MarginMode), CenterOfGravityMarginMode.Lot)
		.SetDisplay("Margin Mode", "Interpretation of the money management value", "Risk");

		_stopLossPips = Param(nameof(StopLossPips), 1000)
		.SetDisplay("Stop Loss", "Stop loss distance in price steps", "Protection")
		.SetNotNegative();

		_takeProfitPips = Param(nameof(TakeProfitPips), 2000)
		.SetDisplay("Take Profit", "Take profit distance in price steps", "Protection")
		.SetNotNegative();

		_enableBuyOpen = Param(nameof(EnableBuyOpen), true)
		.SetDisplay("Open Long", "Allow opening long positions", "Signals");

		_enableSellOpen = Param(nameof(EnableSellOpen), true)
		.SetDisplay("Open Short", "Allow opening short positions", "Signals");

		_enableBuyClose = Param(nameof(EnableBuyClose), true)
		.SetDisplay("Close Long", "Allow closing long positions on bearish signal", "Signals");

		_enableSellClose = Param(nameof(EnableSellClose), true)
		.SetDisplay("Close Short", "Allow closing short positions on bullish signal", "Signals");

		_candleType = Param(nameof(CandleType), TimeSpan.FromHours(6).TimeFrame())
		.SetDisplay("Candle Type", "Timeframe for indicator calculation", "General");

		_period = Param(nameof(Period), 10)
		.SetDisplay("Center of Gravity Period", "Base period of the indicator", "Indicator")
		.SetGreaterThanZero()
		.SetCanOptimize(true)
		.SetOptimize(5, 30, 1);

		_smoothPeriod = Param(nameof(SmoothPeriod), 3)
		.SetDisplay("Smoothing Period", "Length of the post-processing moving average", "Indicator")
		.SetGreaterThanZero()
		.SetCanOptimize(true)
		.SetOptimize(1, 10, 1);

		_maMethod = Param(nameof(MaMethod), CenterOfGravityMaMethod.Simple)
		.SetDisplay("Smoothing Method", "Moving average type used for smoothing", "Indicator");

		_signalBar = Param(nameof(SignalBar), 1)
		.SetDisplay("Signal Bar", "Shift of the synthetic candle used for signals", "Indicator")
		.SetNotNegative();
	}

	/// <summary>
	/// Money management factor. Negative values are interpreted as fixed lot size.
	/// </summary>
	public decimal MoneyManagement
	{
		get => _moneyManagement.Value;
		set => _moneyManagement.Value = value;
	}

	/// <summary>
	/// How the money management factor is interpreted.
	/// </summary>
	public CenterOfGravityMarginMode MarginMode
	{
		get => _marginMode.Value;
		set => _marginMode.Value = value;
	}

	/// <summary>
	/// Stop loss distance expressed in price steps.
	/// </summary>
	public int StopLossPips
	{
		get => _stopLossPips.Value;
		set => _stopLossPips.Value = value;
	}

	/// <summary>
	/// Take profit distance expressed in price steps.
	/// </summary>
	public int TakeProfitPips
	{
		get => _takeProfitPips.Value;
		set => _takeProfitPips.Value = value;
	}

	/// <summary>
	/// Allows opening long positions.
	/// </summary>
	public bool EnableBuyOpen
	{
		get => _enableBuyOpen.Value;
		set => _enableBuyOpen.Value = value;
	}

	/// <summary>
	/// Allows opening short positions.
	/// </summary>
	public bool EnableSellOpen
	{
		get => _enableSellOpen.Value;
		set => _enableSellOpen.Value = value;
	}

	/// <summary>
	/// Allows closing existing long positions on bearish signals.
	/// </summary>
	public bool EnableBuyClose
	{
		get => _enableBuyClose.Value;
		set => _enableBuyClose.Value = value;
	}

	/// <summary>
	/// Allows closing existing short positions on bullish signals.
	/// </summary>
	public bool EnableSellClose
	{
		get => _enableSellClose.Value;
		set => _enableSellClose.Value = value;
	}

	/// <summary>
	/// Candle type used by the indicator.
	/// </summary>
	public DataType CandleType
	{
		get => _candleType.Value;
		set => _candleType.Value = value;
	}

	/// <summary>
	/// Base period of the Center of Gravity algorithm.
	/// </summary>
	public int Period
	{
		get => _period.Value;
		set => _period.Value = value;
	}

	/// <summary>
	/// Smoothing period applied to the synthetic candle series.
	/// </summary>
	public int SmoothPeriod
	{
		get => _smoothPeriod.Value;
		set => _smoothPeriod.Value = value;
	}

	/// <summary>
	/// Moving average method used for smoothing.
	/// </summary>
	public CenterOfGravityMaMethod MaMethod
	{
		get => _maMethod.Value;
		set => _maMethod.Value = value;
	}

	/// <summary>
	/// Bar shift used for generating trading signals.
	/// </summary>
	public int SignalBar
	{
		get => _signalBar.Value;
		set => _signalBar.Value = value;
	}

	/// <inheritdoc />
	public override IEnumerable<(Security sec, DataType dt)> GetWorkingSecurities()
	{
		return [(Security, CandleType)];
	}

	/// <inheritdoc />
	protected override void OnReseted()
	{
		base.OnReseted();

		_indicator?.Reset();
		_colorHistory.Clear();
		_point = 1m;
		_pendingBuyOpen = false;
		_pendingSellOpen = false;
		_pendingBuyClose = false;
		_pendingSellClose = false;
	}

	/// <inheritdoc />
	protected override void OnStarted(DateTimeOffset time)
	{
		base.OnStarted(time);

		_point = Security?.PriceStep ?? 1m;
		if (_point <= 0m)
			_point = 1m;

		_indicator = new CenterOfGravityCandleIndicator
		{
			Length = Period,
			SmoothLength = SmoothPeriod,
			Method = MaMethod,
			Point = _point,
		};

		var subscription = SubscribeCandles(CandleType);
		subscription
		.BindEx(_indicator, ProcessCandle)
		.Start();

		var takeProfitUnit = TakeProfitPips > 0 ? new Unit(TakeProfitPips * _point, UnitTypes.Absolute) : new Unit(0m);
		var stopLossUnit = StopLossPips > 0 ? new Unit(StopLossPips * _point, UnitTypes.Absolute) : new Unit(0m);
		StartProtection(takeProfit: takeProfitUnit, stopLoss: stopLossUnit, useMarketOrders: true);

		var area = CreateChartArea();
		if (area != null)
			{
			DrawCandles(area, subscription);
			DrawIndicator(area, _indicator);
			DrawOwnTrades(area);
		}
	}

	private void ProcessCandle(ICandleMessage candle, IIndicatorValue indicatorValue)
	{
		if (candle.State != CandleStates.Finished)
			return;

		if (_indicator == null)
			return;

		_indicator.Length = Period;
		_indicator.SmoothLength = SmoothPeriod;
		_indicator.Method = MaMethod;
		_indicator.Point = _point;

		if (indicatorValue is not CenterOfGravityCandleValue cogValue || !cogValue.IsFormed)
			return;

		_colorHistory.Add(cogValue.Color);
		var maxHistory = SignalBar + 2;
		while (_colorHistory.Count > maxHistory)
		_colorHistory.RemoveAt(0);

		if (_colorHistory.Count <= SignalBar + 1)
			return;

		var currentIndex = _colorHistory.Count - 1 - SignalBar;
		if (currentIndex < 0 || currentIndex >= _colorHistory.Count)
			return;

		var currentColor = _colorHistory[currentIndex];
		var previousColor = currentIndex > 0 ? _colorHistory[currentIndex - 1] : currentColor;

		if (currentColor == CenterOfGravityCandleColor.Bullish && previousColor != CenterOfGravityCandleColor.Bullish)
			{
			if (EnableBuyOpen)
				_pendingBuyOpen = true;

			if (EnableSellClose)
				_pendingSellClose = true;
		}
		else if (currentColor == CenterOfGravityCandleColor.Bearish && previousColor != CenterOfGravityCandleColor.Bearish)
			{
			if (EnableSellOpen)
				_pendingSellOpen = true;

			if (EnableBuyClose)
				_pendingBuyClose = true;
		}

		ExecuteSignals(candle);
	}

	private void ExecuteSignals(ICandleMessage candle)
	{
		if (!IsFormedAndOnlineAndAllowTrading())
			return;

		if (_pendingBuyClose)
			{
			if (Position > 0)
				SellMarket(Position);

			_pendingBuyClose = false;
		}

		if (_pendingSellClose)
			{
			if (Position < 0)
				BuyMarket(Math.Abs(Position));

			_pendingSellClose = false;
		}

		if (_pendingBuyOpen)
			{
			if (Position <= 0)
				{
				var volume = CalculateVolume(candle.ClosePrice);
				if (volume > 0m)
					BuyMarket(volume);
			}

			_pendingBuyOpen = false;
		}

		if (_pendingSellOpen)
			{
			if (Position >= 0)
				{
				var volume = CalculateVolume(candle.ClosePrice);
				if (volume > 0m)
					SellMarket(volume);
			}

			_pendingSellOpen = false;
		}
	}

	private decimal CalculateVolume(decimal price)
	{
		var mm = MoneyManagement;

		if (MarginMode == CenterOfGravityMarginMode.Lot)
			return AlignVolume(mm != 0m ? Math.Abs(mm) : Volume);

		if (Portfolio == null || price <= 0m)
			return AlignVolume(Volume);

		if (mm <= 0m)
			return AlignVolume(Volume);

		var capital = Portfolio.CurrentValue;
		if (capital <= 0m)
			return AlignVolume(Volume);

		var riskCapital = capital * mm;
		decimal volume;

		if ((MarginMode == CenterOfGravityMarginMode.LossFreeMargin || MarginMode == CenterOfGravityMarginMode.LossBalance) && StopLossPips > 0)
			{
			var stopValue = StopLossPips * _point;
			volume = stopValue > 0m ? riskCapital / stopValue : Volume;
		}
		else
		{
			volume = riskCapital / price;
		}

		if (volume <= 0m)
			volume = Volume;

		return AlignVolume(volume);
	}

	private decimal AlignVolume(decimal volume)
	{
		if (volume <= 0m)
			volume = Volume > 0m ? Volume : 1m;

		if (Security?.VolumeStep is decimal step && step > 0m)
			volume = Math.Round(volume / step) * step;

		if (Security?.MinVolume is decimal min && min > 0m && volume < min)
			volume = min;

		if (Security?.MaxVolume is decimal max && max > 0m && volume > max)
			volume = max;

		return volume;
	}
}

/// <summary>
/// Indicator that recreates the MetaTrader Center of Gravity Candle calculation.
/// </summary>
public class CenterOfGravityCandleIndicator : BaseIndicator<CenterOfGravityCandleValue>
{
	private SimpleMovingAverage? _openSma;
	private SimpleMovingAverage? _highSma;
	private SimpleMovingAverage? _lowSma;
	private SimpleMovingAverage? _closeSma;
	private LinearWeightedMovingAverage? _openLwma;
	private LinearWeightedMovingAverage? _highLwma;
	private LinearWeightedMovingAverage? _lowLwma;
	private LinearWeightedMovingAverage? _closeLwma;
	private LengthIndicator<decimal>? _openSmooth;
	private LengthIndicator<decimal>? _highSmooth;
	private LengthIndicator<decimal>? _lowSmooth;
	private LengthIndicator<decimal>? _closeSmooth;
	private CenterOfGravityMaMethod _currentMethod;
	private int _currentSmoothLength;

	/// <summary>
	/// Main calculation period.
	/// </summary>
	public int Length { get; set; } = 10;

	/// <summary>
	/// Smoothing period applied to the synthetic candle series.
	/// </summary>
	public int SmoothLength { get; set; } = 3;

	/// <summary>
	/// Moving average method for smoothing.
	/// </summary>
	public CenterOfGravityMaMethod Method { get; set; } = CenterOfGravityMaMethod.Simple;

	/// <summary>
	/// Price step used to normalize the product of the moving averages.
	/// </summary>
	public decimal Point { get; set; } = 1m;

	/// <inheritdoc />
	public override bool IsFormed => _openSmooth?.IsFormed == true && _highSmooth?.IsFormed == true && _lowSmooth?.IsFormed == true && _closeSmooth?.IsFormed == true;

	/// <inheritdoc />
	protected override IIndicatorValue OnProcess(IIndicatorValue input)
	{
		if (input is not ICandleMessage candle || candle.State != CandleStates.Finished)
			return new CenterOfGravityCandleValue(this, input, 0m, 0m, 0m, 0m, CenterOfGravityCandleColor.Neutral, false);

		EnsureInitialized();

		var time = candle.CloseTime;
		var point = Point > 0m ? Point : 1m;

		var openSmaVal = _openSma!.Process(candle.OpenPrice, time, true);
		var openLwmaVal = _openLwma!.Process(candle.OpenPrice, time, true);
		var highSmaVal = _highSma!.Process(candle.HighPrice, time, true);
		var highLwmaVal = _highLwma!.Process(candle.HighPrice, time, true);
		var lowSmaVal = _lowSma!.Process(candle.LowPrice, time, true);
		var lowLwmaVal = _lowLwma!.Process(candle.LowPrice, time, true);
		var closeSmaVal = _closeSma!.Process(candle.ClosePrice, time, true);
		var closeLwmaVal = _closeLwma!.Process(candle.ClosePrice, time, true);

		if (!_openSma.IsFormed || !_openLwma.IsFormed || !_highSma.IsFormed || !_highLwma.IsFormed || !_lowSma.IsFormed || !_lowLwma.IsFormed || !_closeSma.IsFormed || !_closeLwma.IsFormed)
			return new CenterOfGravityCandleValue(this, input, 0m, 0m, 0m, 0m, CenterOfGravityCandleColor.Neutral, false);

		var openProduct = openSmaVal.GetValue<decimal>() * openLwmaVal.GetValue<decimal>() / point;
		var highProduct = highSmaVal.GetValue<decimal>() * highLwmaVal.GetValue<decimal>() / point;
		var lowProduct = lowSmaVal.GetValue<decimal>() * lowLwmaVal.GetValue<decimal>() / point;
		var closeProduct = closeSmaVal.GetValue<decimal>() * closeLwmaVal.GetValue<decimal>() / point;

		var openSmoothVal = _openSmooth!.Process(openProduct, time, true);
		var highSmoothVal = _highSmooth!.Process(highProduct, time, true);
		var lowSmoothVal = _lowSmooth!.Process(lowProduct, time, true);
		var closeSmoothVal = _closeSmooth!.Process(closeProduct, time, true);

		if (!_openSmooth.IsFormed || !_highSmooth.IsFormed || !_lowSmooth.IsFormed || !_closeSmooth.IsFormed)
			return new CenterOfGravityCandleValue(this, input, 0m, 0m, 0m, 0m, CenterOfGravityCandleColor.Neutral, false);

		var openValue = openSmoothVal.GetValue<decimal>();
		var closeValue = closeSmoothVal.GetValue<decimal>();
		var highCandidate = Math.Max(openValue, closeValue);
		var lowCandidate = Math.Min(openValue, closeValue);
		var highValue = Math.Max(highCandidate, highSmoothVal.GetValue<decimal>());
		var lowValue = Math.Min(lowCandidate, lowSmoothVal.GetValue<decimal>());

		var color = CenterOfGravityCandleColor.Neutral;
		if (openValue < closeValue)
			color = CenterOfGravityCandleColor.Bullish;
		else if (openValue > closeValue)
			color = CenterOfGravityCandleColor.Bearish;

		return new CenterOfGravityCandleValue(this, input, openValue, highValue, lowValue, closeValue, color, true);
	}

	/// <inheritdoc />
	public override void Reset()
	{
		base.Reset();

		_openSma?.Reset();
		_highSma?.Reset();
		_lowSma?.Reset();
		_closeSma?.Reset();
		_openLwma?.Reset();
		_highLwma?.Reset();
		_lowLwma?.Reset();
		_closeLwma?.Reset();
		_openSmooth?.Reset();
		_highSmooth?.Reset();
		_lowSmooth?.Reset();
		_closeSmooth?.Reset();
	}

	private void EnsureInitialized()
	{
		var length = Math.Max(1, Length);
		var smoothLength = Math.Max(1, SmoothLength);

		_openSma ??= new SimpleMovingAverage();
		_highSma ??= new SimpleMovingAverage();
		_lowSma ??= new SimpleMovingAverage();
		_closeSma ??= new SimpleMovingAverage();
		_openLwma ??= new LinearWeightedMovingAverage();
		_highLwma ??= new LinearWeightedMovingAverage();
		_lowLwma ??= new LinearWeightedMovingAverage();
		_closeLwma ??= new LinearWeightedMovingAverage();

		_openSma.Length = length;
		_highSma.Length = length;
		_lowSma.Length = length;
		_closeSma.Length = length;
		_openLwma.Length = length;
		_highLwma.Length = length;
		_lowLwma.Length = length;
		_closeLwma.Length = length;

		if (_openSmooth == null || _currentSmoothLength != smoothLength || _currentMethod != Method)
			{
			_openSmooth = CreateSmoothingIndicator();
			_highSmooth = CreateSmoothingIndicator();
			_lowSmooth = CreateSmoothingIndicator();
			_closeSmooth = CreateSmoothingIndicator();
			_currentSmoothLength = smoothLength;
			_currentMethod = Method;
		}
		else
		{
			_openSmooth.Length = smoothLength;
			_highSmooth!.Length = smoothLength;
			_lowSmooth!.Length = smoothLength;
			_closeSmooth!.Length = smoothLength;
		}
	}

	private LengthIndicator<decimal> CreateSmoothingIndicator()
	{
		return Method switch
		{
			CenterOfGravityMaMethod.Exponential => new ExponentialMovingAverage { Length = SmoothLength },
			CenterOfGravityMaMethod.Smoothed => new SmoothedMovingAverage { Length = SmoothLength },
			CenterOfGravityMaMethod.LinearWeighted => new LinearWeightedMovingAverage { Length = SmoothLength },
			_ => new SimpleMovingAverage { Length = SmoothLength },
		};
	}
}

/// <summary>
/// Indicator value describing the synthetic candle and its color.
/// </summary>
public class CenterOfGravityCandleValue : ComplexIndicatorValue
{
	public CenterOfGravityCandleValue(IIndicator indicator, IIndicatorValue input, decimal open, decimal high, decimal low, decimal close, CenterOfGravityCandleColor color, bool isFormed)
	: base(indicator, input, (nameof(Open), open), (nameof(High), high), (nameof(Low), low), (nameof(Close), close), (nameof(Color), color))
	{
		IsFormed = isFormed;
	}

	/// <summary>
	/// Synthetic open value.
	/// </summary>
	public decimal Open => (decimal)GetValue(nameof(Open));

	/// <summary>
	/// Synthetic high value.
	/// </summary>
	public decimal High => (decimal)GetValue(nameof(High));

	/// <summary>
	/// Synthetic low value.
	/// </summary>
	public decimal Low => (decimal)GetValue(nameof(Low));

	/// <summary>
	/// Synthetic close value.
	/// </summary>
	public decimal Close => (decimal)GetValue(nameof(Close));

	/// <summary>
	/// Candle color mapped to trading decisions.
	/// </summary>
	public CenterOfGravityCandleColor Color => (CenterOfGravityCandleColor)GetValue(nameof(Color));

	/// <summary>
	/// Indicates whether the indicator produced a valid value.
	/// </summary>
	public bool IsFormed { get; }
}

/// <summary>
/// Synthetic candle color used as trading signal.
/// </summary>
public enum CenterOfGravityCandleColor
{
	/// <summary>
	/// Bearish candle (open above close).
	/// </summary>
	Bearish = 0,

	/// <summary>
	/// Neutral candle (open equals close).
	/// </summary>
	Neutral = 1,

	/// <summary>
	/// Bullish candle (open below close).
	/// </summary>
	Bullish = 2,
}

/// <summary>
/// Moving average methods available for smoothing the synthetic candles.
/// </summary>
public enum CenterOfGravityMaMethod
{
	/// <summary>
	/// Simple moving average.
	/// </summary>
	Simple,

	/// <summary>
	/// Exponential moving average.
	/// </summary>
	Exponential,

	/// <summary>
	/// Smoothed moving average.
	/// </summary>
	Smoothed,

	/// <summary>
	/// Linear weighted moving average.
	/// </summary>
	LinearWeighted,
}

/// <summary>
/// Modes that define how the money management value is interpreted.
/// </summary>
public enum CenterOfGravityMarginMode
{
	/// <summary>
	/// Portion of account equity is used (approximates free margin).
	/// </summary>
	FreeMargin,

	/// <summary>
	/// Portion of current balance is used.
	/// </summary>
	Balance,

	/// <summary>
	/// Risk is computed from free margin and stop loss distance.
	/// </summary>
	LossFreeMargin,

	/// <summary>
	/// Risk is computed from balance and stop loss distance.
	/// </summary>
	LossBalance,

	/// <summary>
	/// Money management value represents a fixed lot size.
	/// </summary>
	Lot,
}
