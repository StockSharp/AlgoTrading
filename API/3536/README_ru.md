# Стратегия «Новая свеча»

## Общее описание

Пример демонстрирует, как определять появление новой свечи в StockSharp с помощью высокоуровневой подписки на свечи. Это конверсия эксперта MQL `NewBar.mq5`, который показывает, как реагировать на старт свежей свечи на графике.

Стратегия не совершает реальных сделок. Вместо этого она выводит в лог сообщения в следующих ситуациях:

- Первый апдейт после запуска стратегии (аналог условия `dtBarPrevious == WRONG_VALUE` в MQL).
- Первый тик каждой последующей свечи.
- Дополнительные тики, пока текущая свеча всё ещё формируется.
- Момент закрытия свечи.

## Основная логика

1. Подписаться на выбранную серию свечей через `SubscribeCandles` и привязать обработчик `ProcessCandle`.
2. Отслеживать время открытия текущей свечи. Если время изменилось — началась новая свеча.
3. При первом поступлении данных вызвать `HandleFirstObservation`, имитируя ситуацию, когда советник подключён в середине свечи.
4. Для каждой новой свечи использовать `HandleNewBar`, куда можно добавить торговые правила.
5. Пока свеча активна, вызывать `HandleSameBarTick` для обработки тиков внутри свечи.
6. Когда состояние становится `CandleStates.Finished`, выполнить `HandleBarClosed`.

Все вспомогательные методы снабжены комментариями на английском языке, поэтому шаблон легко расширить собственной логикой.

## Параметры

| Параметр | Описание | Значение по умолчанию |
|----------|----------|------------------------|
| `CandleType` | Серия свечей, по которой отслеживаются события новой свечи. | Таймфрейм 1 минута |

## Расширение шаблона

- Разместите логику открытия позиций в `HandleNewBar`, чтобы срабатывать ровно один раз в начале свечи.
- Добавьте проверки внутри `HandleSameBarTick`, если нужна реакция на внутрисвечные тики.
- Используйте `HandleBarClosed` для фиксации прибыли или переноса стопов при закрытии свечи.

## Отличия от оригинального MQL-скрипта

- Вместо ручного опроса времени через `iTime` применяется высокоуровневый API подписки на свечи.
- В коде присутствуют отдельные методы, повторяющие блоки комментариев из MQL, чтобы было понятно, где размещать пользовательские правила.
- Для информирования используется встроенный логгер `Log`, что делает вывод структурированным и удобным для дальнейшего анализа.
