using System;
using System.Linq;
using System.Collections.Generic;

using Ecng.Common;
using Ecng.Collections;
using Ecng.Serialization;

using StockSharp.Algo.Indicators;
using StockSharp.Algo.Strategies;
using StockSharp.BusinessEntities;
using StockSharp.Messages;

using System.Reflection;

namespace StockSharp.Samples.Strategies;

/// <summary>
/// Strategy converted from the MetaTrader expert Exp_X2MACandle_MMRec.
/// The logic relies on smoothed candle colors generated by a double moving average pipeline
/// to control entries and exits with basic money management rules.
/// </summary>
public class ExpX2MaCandleMmRecStrategy : Strategy
{
	private readonly StrategyParam<DataType> _candleType;
	private readonly StrategyParam<SmoothMethods> _firstMethod;
	private readonly StrategyParam<int> _firstLength;
	private readonly StrategyParam<int> _firstPhase;
	private readonly StrategyParam<SmoothMethods> _secondMethod;
	private readonly StrategyParam<int> _secondLength;
	private readonly StrategyParam<int> _secondPhase;
	private readonly StrategyParam<int> _gapPoints;
	private readonly StrategyParam<int> _signalBar;
	private readonly StrategyParam<bool> _allowLongEntry;
	private readonly StrategyParam<bool> _allowShortEntry;
	private readonly StrategyParam<bool> _allowLongExit;
	private readonly StrategyParam<bool> _allowShortExit;
	private readonly StrategyParam<decimal> _normalVolume;
	private readonly StrategyParam<decimal> _reducedVolume;
	private readonly StrategyParam<int> _historyDepth;
	private readonly StrategyParam<int> _lossTrigger;

	private readonly TradeHistory _buyHistory = new();
	private readonly TradeHistory _sellHistory = new();
	private readonly List<int> _colorHistory = new();

	private ActiveTrade _activeTrade;
	private DateTimeOffset? _lastLongSignalTime;
	private DateTimeOffset? _lastShortSignalTime;

	/// <summary>
	/// Timeframe used for candle subscriptions.
	/// </summary>
	public DataType CandleType
	{
		get => _candleType.Value;
		set => _candleType.Value = value;
	}

	/// <summary>
	/// Method for the first smoothing stage.
	/// </summary>
	public SmoothMethods FirstMethod
	{
		get => _firstMethod.Value;
		set => _firstMethod.Value = value;
	}

	/// <summary>
	/// Length for the first smoothing stage.
	/// </summary>
	public int FirstLength
	{
		get => _firstLength.Value;
		set => _firstLength.Value = value;
	}

	/// <summary>
	/// Phase for the first smoothing stage (used by Jurik based averaging).
	/// </summary>
	public int FirstPhase
	{
		get => _firstPhase.Value;
		set => _firstPhase.Value = value;
	}

	/// <summary>
	/// Method for the second smoothing stage.
	/// </summary>
	public SmoothMethods SecondMethod
	{
		get => _secondMethod.Value;
		set => _secondMethod.Value = value;
	}

	/// <summary>
	/// Length for the second smoothing stage.
	/// </summary>
	public int SecondLength
	{
		get => _secondLength.Value;
		set => _secondLength.Value = value;
	}

	/// <summary>
	/// Phase for the second smoothing stage.
	/// </summary>
	public int SecondPhase
	{
		get => _secondPhase.Value;
		set => _secondPhase.Value = value;
	}

	/// <summary>
	/// Gap threshold in price steps used to flatten candle bodies.
	/// </summary>
	public int GapPoints
	{
		get => _gapPoints.Value;
		set => _gapPoints.Value = value;
	}

	/// <summary>
	/// Shift (in closed candles) used for signal evaluation.
	/// </summary>
	public int SignalBar
	{
		get => _signalBar.Value;
		set => _signalBar.Value = value;
	}

	/// <summary>
	/// Allow opening long positions.
	/// </summary>
	public bool AllowLongEntry
	{
		get => _allowLongEntry.Value;
		set => _allowLongEntry.Value = value;
	}

	/// <summary>
	/// Allow opening short positions.
	/// </summary>
	public bool AllowShortEntry
	{
		get => _allowShortEntry.Value;
		set => _allowShortEntry.Value = value;
	}

	/// <summary>
	/// Allow closing long positions.
	/// </summary>
	public bool AllowLongExit
	{
		get => _allowLongExit.Value;
		set => _allowLongExit.Value = value;
	}

	/// <summary>
	/// Allow closing short positions.
	/// </summary>
	public bool AllowShortExit
	{
		get => _allowShortExit.Value;
		set => _allowShortExit.Value = value;
	}

	/// <summary>
	/// Default trade volume.
	/// </summary>
	public decimal NormalVolume
	{
		get => _normalVolume.Value;
		set => _normalVolume.Value = value;
	}

	/// <summary>
	/// Reduced trade volume used after a series of losses.
	/// </summary>
	public decimal ReducedVolume
	{
		get => _reducedVolume.Value;
		set => _reducedVolume.Value = value;
	}

	/// <summary>
	/// Number of recent trades to check when counting losses.
	/// </summary>
	public int HistoryDepth
	{
		get => _historyDepth.Value;
		set => _historyDepth.Value = value;
	}

	/// <summary>
	/// Minimum amount of losses inside the window required to switch to the reduced volume.
	/// </summary>
	public int LossTrigger
	{
		get => _lossTrigger.Value;
		set => _lossTrigger.Value = value;
	}

	/// <summary>
	/// Initializes a new instance of <see cref="ExpX2MaCandleMmRecStrategy"/>.
	/// </summary>
	public ExpX2MaCandleMmRecStrategy()
	{
		_candleType = Param(nameof(CandleType), TimeSpan.FromHours(6).TimeFrame())
		.SetDisplay("Candle Type", "Timeframe for the smoothed candle indicator", "General");

		_firstMethod = Param(nameof(FirstMethod), SmoothMethods.Simple)
		.SetDisplay("Primary Method", "Method for the first smoothing stage", "Indicator");

		_firstLength = Param(nameof(FirstLength), 12)
		.SetGreaterThanZero()
		.SetDisplay("Primary Length", "Length for the first smoothing stage", "Indicator");

		_firstPhase = Param(nameof(FirstPhase), 15)
		.SetDisplay("Primary Phase", "Phase for Jurik based smoothing", "Indicator");

		_secondMethod = Param(nameof(SecondMethod), SmoothMethods.Jurik)
		.SetDisplay("Secondary Method", "Method for the second smoothing stage", "Indicator");

		_secondLength = Param(nameof(SecondLength), 5)
		.SetGreaterThanZero()
		.SetDisplay("Secondary Length", "Length for the second smoothing stage", "Indicator");

		_secondPhase = Param(nameof(SecondPhase), 15)
		.SetDisplay("Secondary Phase", "Phase for Jurik based smoothing", "Indicator");

		_gapPoints = Param(nameof(GapPoints), 10)
		.SetNotNegative()
		.SetDisplay("Gap Points", "Absolute gap (in price steps) to flatten candle bodies", "Indicator");

		_signalBar = Param(nameof(SignalBar), 1)
		.SetNotNegative()
		.SetDisplay("Signal Bar", "Bar shift used when reading indicator colors", "Indicator");

		_allowLongEntry = Param(nameof(AllowLongEntry), true)
		.SetDisplay("Allow Long Entry", "Enable long entries", "Trading");

		_allowShortEntry = Param(nameof(AllowShortEntry), true)
		.SetDisplay("Allow Short Entry", "Enable short entries", "Trading");

		_allowLongExit = Param(nameof(AllowLongExit), true)
		.SetDisplay("Allow Long Exit", "Enable closing long positions", "Trading");

		_allowShortExit = Param(nameof(AllowShortExit), true)
		.SetDisplay("Allow Short Exit", "Enable closing short positions", "Trading");

		_normalVolume = Param(nameof(NormalVolume), 0.1m)
		.SetGreaterThanZero()
		.SetDisplay("Normal Volume", "Base trade volume", "Money Management");

		_reducedVolume = Param(nameof(ReducedVolume), 0.01m)
		.SetGreaterThanZero()
		.SetDisplay("Reduced Volume", "Lower volume used after losses", "Money Management");

		_historyDepth = Param(nameof(HistoryDepth), 3)
		.SetNotNegative()
		.SetDisplay("History Depth", "Number of closed trades inspected for losses", "Money Management");

		_lossTrigger = Param(nameof(LossTrigger), 2)
		.SetNotNegative()
		.SetDisplay("Loss Trigger", "Loss count required to switch to the reduced volume", "Money Management");
	}

	/// <inheritdoc />
	public override IEnumerable<(Security sec, DataType dt)> GetWorkingSecurities()
	{
	return [(Security, CandleType)];
	}

	/// <inheritdoc />
	protected override void OnReseted()
	{
	base.OnReseted();

	_buyHistory.Clear();
	_sellHistory.Clear();
	_colorHistory.Clear();
	_activeTrade = null;
	_lastLongSignalTime = null;
	_lastShortSignalTime = null;
	}

	/// <inheritdoc />
	protected override void OnStarted(DateTimeOffset time)
	{
	base.OnStarted(time);

	var gap = GetGapValue();

	var indicator = new X2MaCandleColorIndicator(
	FirstMethod,
	FirstLength,
	FirstPhase,
	SecondMethod,
	SecondLength,
	SecondPhase,
	gap);

	var subscription = SubscribeCandles(CandleType);
	subscription
	.Bind(indicator, ProcessCandle)
	.Start();
	}

	private decimal GetGapValue()
	{
	var step = Security?.StepPrice ?? 1m;
	return step * GapPoints;
	}

	private void ProcessCandle(ICandleMessage candle, decimal indicatorColor)
	{
	if (candle.State != CandleStates.Finished)
	return;

	_colorHistory.Insert(0, (int)indicatorColor);

	var keep = Math.Max(SignalBar + 2, 10);
	while (_colorHistory.Count > keep)
	_colorHistory.RemoveAt(_colorHistory.Count - 1);

	if (_colorHistory.Count <= SignalBar + 1)
	return;

	if (!IsFormedAndOnlineAndAllowTrading())
	return;

	var previousColor = _colorHistory[SignalBar];
	var olderColor = _colorHistory[SignalBar + 1];

	var timeFrame = CandleType.Arg is TimeSpan span ? span : TimeSpan.Zero;
	var signalTime = candle.CloseTime ?? candle.OpenTime + timeFrame;

	var openLong = false;
	var closeShort = false;
	var openShort = false;
	var closeLong = false;

	if (olderColor == 2)
	{
	if (AllowLongEntry && previousColor != 2)
	openLong = true;

	if (AllowShortExit)
	closeShort = true;
	}

	if (olderColor == 0)
	{
	if (AllowShortEntry && previousColor != 0)
	openShort = true;

	if (AllowLongExit)
	closeLong = true;
	}

	if (closeLong && Position > 0)
	{
	RegisterClosedTrade(Sides.Buy, candle.ClosePrice);
	ClosePosition();
	}

	if (closeShort && Position < 0)
	{
	RegisterClosedTrade(Sides.Sell, candle.ClosePrice);
	ClosePosition();
	}

	if (openLong && Position <= 0 && _lastLongSignalTime != signalTime)
	{
	var volume = GetVolume(Sides.Buy);
	BuyMarket(volume);
	_activeTrade = new ActiveTrade
	{
	Side = Sides.Buy,
	EntryPrice = candle.ClosePrice,
	Volume = volume
	};
	_lastLongSignalTime = signalTime;
	}

	if (openShort && Position >= 0 && _lastShortSignalTime != signalTime)
	{
	var volume = GetVolume(Sides.Sell);
	SellMarket(volume);
	_activeTrade = new ActiveTrade
	{
	Side = Sides.Sell,
	EntryPrice = candle.ClosePrice,
	Volume = volume
	};
	_lastShortSignalTime = signalTime;
	}
	}

	private decimal GetVolume(Sides side)
	{
	if (LossTrigger <= 0)
	return NormalVolume;

	var history = side == Sides.Buy ? _buyHistory : _sellHistory;
	return history.Losses >= LossTrigger ? ReducedVolume : NormalVolume;
	}

	private void RegisterClosedTrade(Sides side, decimal exitPrice)
	{
	if (_activeTrade is null || _activeTrade.Side != side)
	return;

	var entry = _activeTrade.EntryPrice;
	var isLoss = side == Sides.Buy ? exitPrice < entry : exitPrice > entry;

	var history = side == Sides.Buy ? _buyHistory : _sellHistory;
	history.Add(isLoss, HistoryDepth);

	_activeTrade = null;
	}

	/// <summary>
	/// Supported smoothing methods.
	/// </summary>
	public enum SmoothMethods
	{
	/// <summary>
	/// Simple moving average.
	/// </summary>
	Simple,

	/// <summary>
	/// Exponential moving average.
	/// </summary>
	Exponential,

	/// <summary>
	/// Smoothed moving average (RMA).
	/// </summary>
	Smoothed,

	/// <summary>
	/// Linear weighted moving average.
	/// </summary>
	Weighted,

	/// <summary>
	/// Jurik moving average.
	/// </summary>
	Jurik
	}

	private sealed class ActiveTrade
	{
	public required Sides Side { get; init; }

	public required decimal EntryPrice { get; init; }

	public required decimal Volume { get; init; }
	}

	private sealed class TradeHistory
	{
	private readonly Queue<bool> _results = new();
	private int _losses;

	public int Losses => _losses;

	public void Add(bool isLoss, int limit)
	{
	_results.Enqueue(isLoss);
	if (isLoss)
	_losses++;

	while (limit > 0 && _results.Count > limit)
	{
	if (_results.Dequeue())
	_losses--;
	}
	}

	public void Clear()
	{
	_results.Clear();
	_losses = 0;
	}
	}

	private sealed class X2MaCandleColorIndicator : LengthIndicator<decimal>
	{
	private readonly MovingAveragePipeline _open;
	private readonly MovingAveragePipeline _high;
	private readonly MovingAveragePipeline _low;
	private readonly MovingAveragePipeline _close;
	private readonly decimal _gap;
	private decimal? _previousClose;

	public X2MaCandleColorIndicator(
	SmoothMethods firstMethod,
	int firstLength,
	int firstPhase,
	SmoothMethods secondMethod,
	int secondLength,
	int secondPhase,
	decimal gap)
	{
	_open = new MovingAveragePipeline(firstMethod, firstLength, firstPhase, secondMethod, secondLength, secondPhase);
	_high = new MovingAveragePipeline(firstMethod, firstLength, firstPhase, secondMethod, secondLength, secondPhase);
	_low = new MovingAveragePipeline(firstMethod, firstLength, firstPhase, secondMethod, secondLength, secondPhase);
	_close = new MovingAveragePipeline(firstMethod, firstLength, firstPhase, secondMethod, secondLength, secondPhase);
	_gap = gap;
	}

	/// <inheritdoc />
	protected override IIndicatorValue OnProcess(IIndicatorValue input)
	{
	if (!input.IsFinal)
	return new DecimalIndicatorValue(this, default, input.Time);

	var candle = input.GetValue<ICandleMessage>();
	var time = input.Time ?? candle.CloseTime ?? candle.OpenTime;

	var open = _open.Process(candle.OpenPrice, time);
	var close = _close.Process(candle.ClosePrice, time);
	var high = _high.Process(candle.HighPrice, time);
	var low = _low.Process(candle.LowPrice, time);

	if (open is null || close is null || high is null || low is null)
	return new DecimalIndicatorValue(this, default, input.Time);

	var smoothedOpen = open.Value;
	var smoothedClose = close.Value;

	if (_previousClose is null)
	_previousClose = smoothedClose;

	if (Math.Abs(smoothedOpen - smoothedClose) <= _gap && _previousClose is decimal prevClose)
	smoothedOpen = prevClose;

	_previousClose = smoothedClose;

	var color = smoothedOpen < smoothedClose ? 2m : smoothedOpen > smoothedClose ? 0m : 1m;

	return new DecimalIndicatorValue(this, color, input.Time);
	}

	private sealed class MovingAveragePipeline
	{
	private readonly IIndicator _first;
	private readonly IIndicator _second;

	public MovingAveragePipeline(
	SmoothMethods firstMethod,
	int firstLength,
	int firstPhase,
	SmoothMethods secondMethod,
	int secondLength,
	int secondPhase)
	{
	_first = CreateMovingAverage(firstMethod, firstLength, firstPhase);
	_second = CreateMovingAverage(secondMethod, secondLength, secondPhase);
	}

	public decimal? Process(decimal value, DateTimeOffset time)
	{
	var firstValue = _first.Process(value, time);
	if (!firstValue.IsFinal)
	return null;

	var intermediate = firstValue.ToDecimal();

	var secondValue = _second.Process(intermediate, time);
	return secondValue.IsFinal ? secondValue.ToDecimal() : null;
	}

	private static IIndicator CreateMovingAverage(SmoothMethods method, int length, int phase)
	{
	return method switch
	{
	SmoothMethods.Simple => new SimpleMovingAverage { Length = Math.Max(1, length) },
	SmoothMethods.Exponential => new ExponentialMovingAverage { Length = Math.Max(1, length) },
	SmoothMethods.Smoothed => new SmoothedMovingAverage { Length = Math.Max(1, length) },
	SmoothMethods.Weighted => new WeightedMovingAverage { Length = Math.Max(1, length) },
	SmoothMethods.Jurik => CreateJurik(length, phase),
	_ => new SimpleMovingAverage { Length = Math.Max(1, length) }
	};
	}

	private static IIndicator CreateJurik(int length, int phase)
	{
	var jurik = new JurikMovingAverage { Length = Math.Max(1, length) };
	var property = jurik.GetType().GetProperty("Phase", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
	if (property != null)
	{
	var value = Math.Max(-100, Math.Min(100, phase));
	property.SetValue(jurik, value);
	}

	return jurik;
	}
	}
	}
}

