# Стратегия Parabolic SAR EA

## Обзор
**Parabolic SAR EA Strategy** — это перенос эксперта MetaTrader `Parabolic SAR EA.mq5` из каталога `MQL/23039` на высокоуровневый API StockSharp. Исходный советник отслеживает разворот точек Parabolic SAR на заданном таймфрейме и открывает рыночные сделки с фиксированными уровнями Stop Loss и Take Profit, выраженными в «пунктах» MetaTrader (с поправкой на трёх- и пятизнаковую котировку). Версия на C# подписывается на свечи, подключает встроенный индикатор `ParabolicSar` и повторяет покадровую логику принятия решений с учётом требований проекта.

## Торговая логика
1. **Подготовка данных**
   - Стратегия подписывается на выбранный пользователем тип свечей (по умолчанию 30-минутные) и настраивает Parabolic SAR с параметрами ускорения и максимума.
   - Значения индикатора поступают в стратегию через высокоуровневый колбэк `Bind` для каждой свечи.
2. **Фильтрация сигналов**
   - Сигнал на покупку: значение Parabolic SAR на закрывшейся свече строго ниже минимума свечи.
   - Сигнал на продажу: значение Parabolic SAR на закрывшейся свече строго выше максимума свечи.
   - Условия проверяются только на завершённых свечах (`CandleStates.Finished`), что соответствует обработке «нового бара» в MQL.
3. **Управление позицией**
   - Перед входом противоположные позиции закрываются за счёт увеличения объёма рыночного ордера на абсолютную величину текущей позиции. Это эквивалентно связке `ClosePosition` + `OpenPosition` в оригинальном коде.
   - После каждого входа заново рассчитываются уровни стоп-лосса и тейк-профита с использованием того же правила пересчёта пунктов MetaTrader (для 3/5 знаков множитель равен 10 × `PriceStep`).
4. **Защитные выходы**
   - На каждой закрывшейся свече стратегия проверяет достижение сохранённых уровней стоп-лосса или тейк-профита. При срабатывании выполняется рыночное закрытие и очистка целевых уровней.
   - Логика защитных выходов выполняется раньше обработки новых сигналов на той же свече, имитируя брокерские стоп-заявки в MetaTrader.

## Индикаторы и данные
- Используется встроенный индикатор `ParabolicSar` (параметры `SarStep` и `SarMaximum`).
- Подписка на свечи выполняется через `SubscribeCandles` без добавления индикатора в `Strategy.Indicators`, что соответствует правилам проекта.
- Торговля разрешена только когда `IsFormedAndOnlineAndAllowTrading()` возвращает true, т.е. подключение активно и коннектор разрешает выставление заявок.

## Параметры
| Имя | Значение по умолчанию | Описание |
| --- | --- | --- |
| `TradeVolume` | `1` | Объём рыночных заявок в лотах. При изменении параметра обновляется `Strategy.Volume`. |
| `StopLossPips` | `50` | Дистанция стоп-лосса в пунктах MetaTrader. Для инструментов с 3 или 5 знаками один пункт равен `PriceStep × 10`, иначе — `PriceStep`. Значение `0` отключает стоп. |
| `TakeProfitPips` | `50` | Дистанция тейк-профита в пунктах MetaTrader с теми же правилами пересчёта. Значение `0` отключает тейк-профит. |
| `SarStep` | `0.02` | Шаг ускорения Parabolic SAR. |
| `SarMaximum` | `0.2` | Максимальное значение ускорения Parabolic SAR. |
| `CandleType` | `30-минутный таймфрейм` | Тип свечей, используемый для расчётов. Поддерживаются любые `DataType` на базе `TimeFrame`. |

## Управление рисками и особенности поведения
- Стоп-лосс и тейк-профит пересчитываются после каждого входа и хранятся во внутреннем состоянии стратегии; биржевые стоп-заявки не выставляются.
- Если в рамках одной свечи достигаются оба уровня, в первую очередь выполняется проверка стоп-лосса — аналогично оригинальному эксперту.
- Если коннектор не предоставляет валидный `PriceStep`, используется запасное значение `0.0001`, чтобы избежать нулевой дистанции защитных ордеров.
- Стратегия ведёт только одну чистую позицию, не использует усреднение или пирамидинг и переворачивается при каждом пересечении Parabolic SAR с ценой.

## Особенности конверсии
- В MQL параметр `InpBarCurrent` равен 1, поэтому проверяется предыдущая закрывшаяся свеча. В версии StockSharp это обеспечивается обработкой только свечей в состоянии `Finished`.
- Проверка доступности объёма (`CheckVolumeValue`) в MetaTrader заменена на требование положительного `TradeVolume`; остальные ограничения контролируются торговым коннектором.
- Python-версия намеренно не создавалась в рамках текущей задачи.
