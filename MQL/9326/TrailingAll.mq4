//+------------------------------------------------------------------+
//|                                                  TrailingAll.mq4 |
//|                                                              I_D |
//|             Софт для управления капиталом: http://www.mymmk.com/ |
//+------------------------------------------------------------------+
#property copyright "I_D / Юрий Дзюбан"
#property link      "http://www.mymmk.com/ Софт для управления капиталом"
#property library

static datetime sdtPrevtime = 0;

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО ФРАКТАЛАМ                                            |
//| Функции передаётся тикет позиции, количество баров в фрактале,   |
//| и отступ (пунктов) - расстояние от макс. (мин.) свечи, на        |
//| которое переносится стоплосс (от 0), trlinloss - тралить ли в    |
//| зоне убытков      
//| Функция тралит стоплосс по экстремумам фракталов заданого размера 
//| (т.е. кол-ва баров в составе фрактала) на заданном таймфрейме. 
//| Фрактал, как известно, в "классическом" виде (Вильямса, если не ошибаюсь) - 
//| это комбинация из 5 баров, но мне подумалось, а почему бы не использовать и другие "размеры" - 
//| начиная от 3 баров и выше, включая парные кол-ва баров (в последнем случае кол-во баров после экстремума, 
//| по мере движения "в прошлое", будет больше, чем до экстремума).
//+------------------------------------------------------------------+
//| Параметры:
//| ticket - уникальный порядковый номер ордера(выбранный перед вызовом функции с помощью OrderSelect());
//| tmfrm - таймфрейм, по барам которого осуществляется трейлинг (варианты - 1, 5, 15, 30, 60, 240, 1440, 10080, 43200);
//| bars_n - количество баров в составе фрактала (не меньше 3);
//| indent - отступ (пунктов) от экстремума последнего фрактала, на котором будет размещен стоплосс (не меньше 0);
//| trlinloss - указатель того, следует ли передвигать стоплосс на "лоссовом" участке, т.е. в интервале между 
//| начальным стоплоссом и курсом открытия (true - тралим, false - трейлинг начинается только при условии, 
//| что новый стоплосс "лучше" курса открытия, "в профите").
//+------------------------------------------------------------------+
//| Не раз встречал на нескольких из основных рунетовских форумов Форекс-тематики утверждения относительно того, 
//| что "хорош трейлинг по фракталам на более низком таймфрейме". 
//| Поскольку фракталы, по сути, обозначают локальные экстремумы, трейлинг по ним, также, в принципе, 
//| можно назвать трейлингом по локальным экстремумам. Идея не новая и вполне здравая, 
//| использовавшаяся многими изветными трейдерами (тем же Вильямсом, если не ошибаюсь). 
//| Позволяет переживать откаты и неплохо "выбирать" заметные движения, неважно (по личному опыту) работает во флэте. 
//| Подобно предыдущей, данная функция "тралит" по сформировавшимся барам. При желании можно динамически 
//| (в пределах "жизни" позиции) изменять параметры, например, при быстром "приросте" профите (например, при сильном тренде),
//|  "загрублять" её чувствительность, переходя на более крупный таймфрейм или увеличивая кол-во баров во фрактале,
//|  или, наоборот, при спадах волатильности повышать чувствительность, переходя на более мелкий таймфрейм или уменьшая
//|  кол-во баров во фрактале. Возможны и другие варианты.
//+------------------------------------------------------------------+
void TrailingByFractals(int ticket,int tmfrm,int frktl_bars,int indent,bool trlinloss)
   {
   int i, z; // counters
   int extr_n; // номер ближайшего экстремума frktl_bars-барного фрактала 
   double temp; // служебная переменная
   int after_x, be4_x; // свечей после и до пика соответственно
   int ok_be4, ok_after; // флаги соответствия условию (1 - неправильно, 0 - правильно)
   int sell_peak_n, buy_peak_n; // номера экстремумов ближайших фракталов на продажу (для поджатия дл.поз.) и покупку соответсвенно   
   
   // проверяем переданные значения
   if ((frktl_bars<=3) || (indent<0) || (ticket==0) || ((tmfrm!=1) && (tmfrm!=5) && (tmfrm!=15) && (tmfrm!=30) && (tmfrm!=60) && (tmfrm!=240) && (tmfrm!=1440) && (tmfrm!=10080) && (tmfrm!=43200)) || (!OrderSelect(ticket,SELECT_BY_TICKET)))
      {
      Print("Трейлинг функцией TrailingByFractals() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 
   
   temp = frktl_bars;
      
   if (MathMod(frktl_bars,2)==0)
   extr_n = temp/2;
   else                
   extr_n = MathRound(temp/2);
      
   // баров до и после экстремума фрактала
   after_x = frktl_bars - extr_n;
   if (MathMod(frktl_bars,2)!=0)
   be4_x = frktl_bars - extr_n;
   else
   be4_x = frktl_bars - extr_n - 1;    
   
   // если длинная позиция (OP_BUY), находим ближайший фрактал на продажу (т.е. экстремум "вниз")
   if (OrderType()==OP_BUY)
      {
      // находим последний фрактал на продажу
      for (i=extr_n;i<iBars(Symbol(),tmfrm);i++)
         {
         ok_be4 = 0; ok_after = 0;
         
         for (z=1;z<=be4_x;z++)
            {
            if (iLow(Symbol(),tmfrm,i)>=iLow(Symbol(),tmfrm,i-z)) 
               {
               ok_be4 = 1;
               break;
               }
            }
            
         for (z=1;z<=after_x;z++)
            {
            if (iLow(Symbol(),tmfrm,i)>iLow(Symbol(),tmfrm,i+z)) 
               {
               ok_after = 1;
               break;
               }
            }            
         
         if ((ok_be4==0) && (ok_after==0))                
            {
            sell_peak_n = i; 
            break;
            }
         }
     
      // если тралить в убытке
      if (trlinloss==true)
         {
         // если новый стоплосс лучше имеющегося (в т.ч. если стоплосс == 0, не выставлен)
         if (iLow(Symbol(),tmfrm,sell_peak_n)-indent*Point>OrderStopLoss())
         OrderModify(ticket,OrderOpenPrice(),iLow(Symbol(),tmfrm,sell_peak_n)-indent*Point,OrderTakeProfit(),OrderExpiration());
         }
      // если тралить только в профите, то
      else
      // если новый стоплосс лучше имеющегося И курса открытия
      if ((iLow(Symbol(),tmfrm,sell_peak_n)-indent*Point>OrderStopLoss()) && (iLow(Symbol(),tmfrm,sell_peak_n)-indent*Point>OrderOpenPrice()))
      OrderModify(ticket,OrderOpenPrice(),iLow(Symbol(),tmfrm,sell_peak_n)-indent*Point,OrderTakeProfit(),OrderExpiration());         
      }
      
   // если короткая позиция (OP_SELL), находим ближайший фрактал на покупку (т.е. экстремум "вверх")
   if (OrderType()==OP_SELL)
      {
      // находим последний фрактал на продажу
      for (i=extr_n;i<iBars(Symbol(),tmfrm);i++)
         {
         ok_be4 = 0; ok_after = 0;
         
         for (z=1;z<=be4_x;z++)
            {
            if (iHigh(Symbol(),tmfrm,i)<=iHigh(Symbol(),tmfrm,i-z)) 
               {
               ok_be4 = 1;
               break;
               }
            }
            
         for (z=1;z<=after_x;z++)
            {
            if (iHigh(Symbol(),tmfrm,i)<iHigh(Symbol(),tmfrm,i+z)) 
               {
               ok_after = 1;
               break;
               }
            }            
         
         if ((ok_be4==0) && (ok_after==0))                
            {
            buy_peak_n = i;
            break;
            }
         }        
      
      // если тралить в убытке
      if (trlinloss==true)
         {
         if ((iHigh(Symbol(),tmfrm,buy_peak_n)+(indent+MarketInfo(Symbol(),MODE_SPREAD))*Point<OrderStopLoss()) || (OrderStopLoss()==0))
         OrderModify(ticket,OrderOpenPrice(),iHigh(Symbol(),tmfrm,buy_peak_n)+(indent+MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }      
      // если тралить только в профите, то
      else
         {
         // если новый стоплосс лучше имеющегося И курса открытия
         if ((((iHigh(Symbol(),tmfrm,buy_peak_n)+(indent+MarketInfo(Symbol(),MODE_SPREAD))*Point<OrderStopLoss()) || (OrderStopLoss()==0))) && (iHigh(Symbol(),tmfrm,buy_peak_n)+(indent+MarketInfo(Symbol(),MODE_SPREAD))*Point<OrderOpenPrice()))
         OrderModify(ticket,OrderOpenPrice(),iHigh(Symbol(),tmfrm,buy_peak_n)+(indent+MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО ТЕНЯМ N СВЕЧЕЙ                                       |
//| Функции передаётся тикет позиции, количество баров, по теням     |
//| которых необходимо трейлинговать (от 1 и больше) и отступ        |
//| (пунктов) - расстояние от макс. (мин.) свечи, на которое         |
//| переносится стоплосс (от 0), trlinloss - тралить ли в лоссе      |
//----Функция реализует подтягивание стоплосса по минимальному из low (для длинных позиций) или максимальному high 
//(для коротких) заданного количества баров, на текущем или отличном от текущего таймфрейме.
//----------------------------------------------------------------------------------------------------------------------   
//Параметры:
//ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//tmfrm - таймфрейм, по барам которого осуществляется трейлинг (варианты - 1, 5, 15, 30, 60, 240, 1440, 10080, 43200);
//bars_n - количество баров, которые используются для определения уровня стоплосса (не меньше 1);
//indent - отступ (пунктов) от выбранного high/low, на котором будет размещен стоплосс (не меньше 0);
//trlinloss - указатель того, следует ли передвигать стоплосс на "лоссовом" участке, т.е. 
//в интервале между начальным стоплоссом и курсом открытия (true - тралим, false - трейлинг начинается только при условии, 
//что новый стоплосс "лучше" курса открытия, "в профите").
//----------------------------------------------------------------------------------------------------------------------
//Данный вид трейлинга был впервые встречен мной в описании тактики В. Баришпольца "Пробой средней на дневках", в которой предлагалось трейлинговать стоплосс по лоу (для покупок) или хай (продаж) последних 2 баров (свечей) на дневном таймфрейме. Тралит данный алгоритм иногда на удивление "красиво" (попробуйте "пройтись" по графику "глазами"), позволяет переживать откаты (глубина зависит от заданного количества баров, bars_n) и периоды ослабления волатильности. (По определению) срабатывает по закрытию очередного бара, даже если вы используете его на каждом тике. Я использую его преимущественно на дневках, тралю по 2-4 (наиболее часто) последним барам.

//+------------------------------------------------------------------+
void TrailingByShadows(int ticket,int tmfrm,int bars_n, int indent,bool trlinloss)
   { 
   int i; // counter
   double new_extremum;
   
   // проверяем переданные значения
   if ((bars_n<1) || (indent<0) || (ticket==0) || ((tmfrm!=1) && (tmfrm!=5) && (tmfrm!=15) && (tmfrm!=30) && (tmfrm!=60) && (tmfrm!=240) && (tmfrm!=1440) && (tmfrm!=10080) && (tmfrm!=43200)) || (!OrderSelect(ticket,SELECT_BY_TICKET)))
      {
      Print("Трейлинг функцией TrailingByShadows() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 
   
   // если длинная позиция (OP_BUY), находим минимум bars_n свечей
   if (OrderType()==OP_BUY)
      {
      for(i=1;i<=bars_n;i++)
         {
         if (i==1) new_extremum = iLow(Symbol(),tmfrm,i);
         else 
         if (new_extremum>iLow(Symbol(),tmfrm,i)) new_extremum = iLow(Symbol(),tmfrm,i);
         }         
      
      // если тралим и в зоне убытков
      if (trlinloss==true)
         {
         // если найденное значение "лучше" текущего стоплосса позиции, переносим 
         if (((new_extremum - indent*Point)>OrderStopLoss()) || (OrderStopLoss()==0))
         OrderModify(ticket,OrderOpenPrice(),new_extremum - indent*Point,OrderTakeProfit(),OrderExpiration());
         }
      else
         {
         // если новый стоплосс не только лучше предыдущего, но и курса открытия позиции
         if ((((new_extremum - indent*Point)>OrderStopLoss()) || (OrderStopLoss()==0)) && ((new_extremum - indent*Point)>OrderOpenPrice()))
         OrderModify(ticket,OrderOpenPrice(),new_extremum-indent*Point,OrderTakeProfit(),OrderExpiration());         
         }
      }
      
   // если короткая позиция (OP_SELL), находим минимум bars_n свечей
   if (OrderType()==OP_SELL)
      {
      for(i=1;i<=bars_n;i++)
         {
         if (i==1) new_extremum = iHigh(Symbol(),tmfrm,i);
         else 
         if (new_extremum<iHigh(Symbol(),tmfrm,i)) new_extremum = iHigh(Symbol(),tmfrm,i);
         }         
           
      // если тралим и в зоне убытков
      if (trlinloss==true)
         {
         // если найденное значение "лучше" текущего стоплосса позиции, переносим 
         if (((new_extremum + (indent + MarketInfo(Symbol(),MODE_SPREAD))*Point)<OrderStopLoss()) || (OrderStopLoss()==0))
         OrderModify(ticket,OrderOpenPrice(),new_extremum + (indent + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }
      else
         {
         // если новый стоплосс не только лучше предыдущего, но и курса открытия позиции
         if ((((new_extremum + (indent + MarketInfo(Symbol(),MODE_SPREAD))*Point)<OrderStopLoss()) || (OrderStopLoss()==0)) && ((new_extremum + (indent + MarketInfo(Symbol(),MODE_SPREAD))*Point)<OrderOpenPrice()))
         OrderModify(ticket,OrderOpenPrice(),new_extremum + (indent + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());         
         }      
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ СТАНДАРТНЫЙ-СТУПЕНЧАСТЫЙ                                |
//| Функции передаётся тикет позиции, расстояние от курса открытия,  |
//| на котором трейлинг запускается (пунктов) и "шаг", с которым он  |
//| переносится (пунктов)                                            |
//| Пример: при +30 стоп на +10, при +40 - стоп на +20 и т.д.        |
//+------------------------------------------------------------------+
//| Данный вид трейлинга является доработкой стандартного. Если не ошибаюсь, в своё время похожий был написан KimIV'ом 
//| (но поскольку "свое - роднее",... :) Отличается от стандартного трейлинга тем, что перенос стоплосса осуществляется не 
//| "попунктово" (например, при трейлинге на расстоянии 30 пунктов при +31 стоплосс будет пенемещен на +1, при +32 - на +2 
//| и т.д.), а "шагами" заданной длины (например, при трейлинге на расстоянии в 40 пунктов и "шаге" в 10 при достижении +40
//|  стоплосс будет перемещен на +10, дальше до момента достижения профитом +50 (40 п. + шаг) ничего не поменяется (т.о. мы 
//| даём цене определённую свободу, в чем, собственно, и суть данного алгоритма), и только при +50 стоплосс с +10 будет 
//| перенесен на шаг - с +10 на +20, при +60 - на +30 п. и т.д.
//+------------------------------------------------------------------+
//| Параметры:
//| ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| trldistance - расстояние от текущего курса (пунктов), на котором "тралим" (не меньше MarketInfo(Symbol(),MODE_STOPLEVEL));
//| trlstep - "шаг" изменения стоплосса (пунктов) (не меньше 1).
//+------------------------------------------------------------------+
//| При trlstep=1 данная функция не будет отличаться от стандартного трейлинга. Основная "фишка" данного алгоритма, 
//| повторюсь, в предоставлении курсу некоторой "свободы движений" - стоплосс подтягивается только после того, как цена 
//| "побродив, определилась". Данный алгоритм трейлинга я впервые встретил в описании правил тактики "Скользящие каналы"
//|  уже упоминавшегося В.Баришпольца.
//+------------------------------------------------------------------+
void TrailingStairs(int ticket,int trldistance,int trlstep)
   {  
   double nextstair; // ближайшее значение курса, при котором будем менять стоплосс

   // проверяем переданные значения
   if ((trldistance<MarketInfo(Symbol(),MODE_STOPLEVEL)) || (trlstep<1) || (trldistance<trlstep) || (ticket==0) || (!OrderSelect(ticket,SELECT_BY_TICKET,MODE_TRADES)))
      {
      Print("Трейлинг функцией TrailingStairs() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 
   
   // если длинная позиция (OP_BUY)
   if (OrderType()==OP_BUY)
      {
      // расчитываем, при каком значении курса следует скорректировать стоплосс
      // если стоплосс ниже открытия или равен 0 (не выставлен), то ближайший уровень = курс открытия + trldistance + спрэд
      if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice()))
      nextstair = OrderOpenPrice() + trldistance*Point;
         
      // иначе ближайший уровень = текущий стоплосс + trldistance + trlstep + спрэд
      else
      nextstair = OrderStopLoss() + trldistance*Point;

      // если текущий курс (Bid) >= nextstair и новый стоплосс точно лучше текущего, корректируем последний
      if (Bid>=nextstair)
      if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice())) 
      OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + trlstep*Point,OrderTakeProfit(),OrderExpiration());
      else
      OrderModify(ticket,OrderOpenPrice(),OrderStopLoss() + trlstep*Point,OrderTakeProfit(),OrderExpiration());
      }
      
   // если короткая позиция (OP_SELL)
   if (OrderType()==OP_SELL)
      { 
      // расчитываем, при каком значении курса следует скорректировать стоплосс
      // если стоплосс ниже открытия или равен 0 (не выставлен), то ближайший уровень = курс открытия + trldistance + спрэд
      if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice()))
      nextstair = OrderOpenPrice() - (trldistance + MarketInfo(Symbol(),MODE_SPREAD))*Point;
      
      // иначе ближайший уровень = текущий стоплосс + trldistance + trlstep + спрэд
      else
      nextstair = OrderStopLoss() - (trldistance + MarketInfo(Symbol(),MODE_SPREAD))*Point;
       
      // если текущий курс (Аск) >= nextstair и новый стоплосс точно лучше текущего, корректируем последний
      if (Ask<=nextstair)
      if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice()))
      OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() - (trlstep + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
      else
      OrderModify(ticket,OrderOpenPrice(),OrderStopLoss()- (trlstep + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ СТАНДАРТНЫЙ-"УДАВКА"                                    |
//| Функции передаётся тикет позиции, исходный трейлинг (пунктов) и  |
//| 2 "уровня" (значения профита, пунктов), при которых трейлинг     |
//| сокращаем, и соответствующие значения трейлинга (пунктов)        |
//| Пример: исходный трейлинг 30 п., при +50 - 20 п., +80 и больше - |
//| на расстоянии в 10 пунктов.                                      |
//+------------------------------------------------------------------+
//| Безоткатных движений неограниченной длины, как известно, не бывает (эх...). И совершив определённый "рывок" 
//| (среднее значение которого можно попытаться определить, например, статистически), курс, как правило, формирует 
//| консолидацию или откат. Идея данного алгоритма сопровождения - по мере увеличения профита сокращать дистанцию 
//| трейлинга таким образом, чтобы подходя к участку вероятного разворота/консолидации "застолбить" побольше профита. 
//| Помимо работы на упомянутых выше "рывках" (которые обычно имеют место на новостях или при пробое исторических уровней),
//| функцию также можно использовать при работе в каналах, сокращая дистанцию трейлинга при подходе к противоположной 
//| (относительно открытия) границе канала.
//+------------------------------------------------------------------+
//| Параметры:
//| ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| trl_dist_1 - исходное расстояние трейлинга (пунктов) (не меньше MarketInfo(Symbol(),MODE_STOPLEVEL), 
//| больше trl_dist_2 и trl_dist_3);
//| level_1 - уровень профита (пунктов), при достижении которого дистанция трейлинга будет сокращена 
//| с trl_dist_1 до trl_dist_2 (меньше level_2; больше trl_dist_1);
//| trl dist_2 - расстояние трейлинга (пунктов) после достижения курсом уровня профита в level_1 пунктов 
//| (не меньше MarketInfo(Symbol(),MODE_STOPLEVEL));
//| level_2 - уровень профита (пунктов), при достижении которого дистанция трейлинга будет сокращена 
//| с trl_dist_2 до trl_dist_3 пунктов (больше trl_dist_1 и больше level_1);
//| trl dist_3 - расстояние трейлинга (пунктов) после достижения курсом уровня профита в level_2 пунктов (
//| не меньше MarketInfo(Symbol(),MODE_STOPLEVEL)).
//+------------------------------------------------------------------+
//| К примеру, при параметрах "ticket#, 30, 50, 20, 70, 10" мы исходно тралим на расстоянии в 30 пунктов, как только курс 
//| отойдет от курса открытия на 50 пунктов, начинаем тралить "плотнее" - на расстоянии в 20 п., а если ему удалось 
//| преодолеть 70 п. в направлении увеличения профита, "затягиваем" (откуда и название) расстояние трала до 10 п. 
//| (что с высокой вероятностью приведет к скорому закрытию позиции).
//+------------------------------------------------------------------+
void TrailingUdavka(int ticket,int trl_dist_1,int level_1,int trl_dist_2,int level_2,int trl_dist_3)
   { 
   double newstop = 0; // новый стоплосс
   double trldist; // расстояние трейлинга (в зависимости от "пройденного" может = trl_dist_1, trl_dist_2 или trl_dist_3)

   // проверяем переданные значения
   if ((trl_dist_1<MarketInfo(Symbol(),MODE_STOPLEVEL)) || (trl_dist_2<MarketInfo(Symbol(),MODE_STOPLEVEL)) || (trl_dist_3<MarketInfo(Symbol(),MODE_STOPLEVEL)) || 
   (level_1<=trl_dist_1) || (level_2<=trl_dist_1) || (level_2<=level_1) || (ticket==0) || (!OrderSelect(ticket,SELECT_BY_TICKET,MODE_TRADES)))
      {
      Print("Трейлинг функцией TrailingUdavka() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 
   
   // если длинная позиция (OP_BUY)
   if (OrderType()==OP_BUY)
      {
      // если профит <=trl_dist_1, то trldist=trl_dist_1, если профит>trl_dist_1 && профит<=level_1*Point ...
      if ((Bid-OrderOpenPrice())<=level_1*Point) trldist = trl_dist_1;
      if (((Bid-OrderOpenPrice())>level_1*Point) && ((Bid-OrderOpenPrice())<=level_2*Point)) trldist = trl_dist_2;
      if ((Bid-OrderOpenPrice())>level_2*Point) trldist = trl_dist_3; 
            
      // если стоплосс = 0 или меньше курса открытия, то если тек.цена (Bid) больше/равна дистанции курс_открытия+расст.трейлинга
      if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice()))
         {
         if (Bid>(OrderOpenPrice() + trldist*Point))
         newstop = Bid -  trldist*Point;
         }

      // иначе: если текущая цена (Bid) больше/равна дистанции текущий_стоплосс+расстояние трейлинга, 
      else
         {
         if (Bid>(OrderStopLoss() + trldist*Point))
         newstop = Bid -  trldist*Point;
         }
      
      // модифицируем стоплосс
      if (newstop>OrderStopLoss())   
      OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());
      }
      
   // если короткая позиция (OP_SELL)
   if (OrderType()==OP_SELL)
      { 
      // если профит <=trl_dist_1, то trldist=trl_dist_1, если профит>trl_dist_1 && профит<=level_1*Point ...
      if ((OrderOpenPrice()-(Ask + MarketInfo(Symbol(),MODE_SPREAD)*Point))<=level_1*Point) trldist = trl_dist_1;
      if (((OrderOpenPrice()-(Ask + MarketInfo(Symbol(),MODE_SPREAD)*Point))>level_1*Point) && ((OrderOpenPrice()-(Ask + MarketInfo(Symbol(),MODE_SPREAD)*Point))<=level_2*Point)) trldist = trl_dist_2;
      if ((OrderOpenPrice()-(Ask + MarketInfo(Symbol(),MODE_SPREAD)*Point))>level_2*Point) trldist = trl_dist_3; 
      
      // если стоплосс = 0 или меньше курса открытия, то если тек.цена (Ask) больше/равна дистанции курс_открытия+расст.трейлинга
      if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice()))
         {
         if (Ask<(OrderOpenPrice() - (trldist + MarketInfo(Symbol(),MODE_SPREAD))*Point))
         newstop = Ask + trldist*Point;
         }

      // иначе: если текущая цена (Bid) больше/равна дистанции текущий_стоплосс+расстояние трейлинга, 
      else
         {
         if (Ask<(OrderStopLoss() - (trldist + MarketInfo(Symbol(),MODE_SPREAD))*Point))
         newstop = Ask +  trldist*Point;
         }
               
       // модифицируем стоплосс
      if (newstop>0)
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice()))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());
         else
            {
            if (newstop<OrderStopLoss())   
            OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());
            }
         }
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО ВРЕМЕНИ                                              |
//| Функции передаётся тикет позиции, интервал (минут), с которым,   |
//| передвигается стоплосс и шаг трейлинга (на сколько пунктов       |
//| перемещается стоплосс, trlinloss - тралим ли в убытке            |
//| (т.е. с определённым интервалом подтягиваем стоп до курса        |
//| открытия, а потом и в профите, либо только в профите)            |
//+------------------------------------------------------------------+
//| Тралим по времени, безотносительно к текущему результату по позиции и раскладу на рынке. 
//| Через заданные интервалы времени (целых минут) пытаемся (по возможности) переместить стоплосс на заданный шаг. 
//| Использование данного трейлинга отдельно не было (для меня, по крайней мере, возможно, для кого-то окажется иначе) 
//| особо успешным, однако в комбинации с другими видами трала или при включении по определённому условию, возможно, 
//| он может быть полезен.
//+------------------------------------------------------------------+
//| Параметры:
//| ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| interval - количество целых минут с момента открытия позиции, по истечению которых пытаемся переместить стоплосс 
//| на шаг trlstep пунктов;
//| trlstep - шаг (пунктов), на который пытаемся перемещать стоплосс через каждые interval минут;
//| trlinloss - в данном случае если trlinloss==true, то тралим от стоплосса, иначе от курса открытия 
//| (если стоплосс не был установлен, ==0, тралим всегда от курса открытия).
//+------------------------------------------------------------------+
void TrailingByTime(int ticket,int interval,int trlstep,bool trlinloss)
   {  
   // проверяем переданные значения
   if ((ticket==0) || (interval<1) || (trlstep<1) || !OrderSelect(ticket,SELECT_BY_TICKET))
      {
      Print("Трейлинг функцией TrailingByTime() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      }
      
   double minpast; // кол-во полных минут от открытия позиции до текущего момента 
   double times2change; // кол-во интервалов interval с момента открытия позиции (т.е. сколько раз должен был быть перемещен стоплосс) 
   double newstop; // новое значение стоплосса (учитывая кол-во переносов, которые должны были иметь место)
   
   // определяем, сколько времени прошло с момента открытия позиции
   minpast = (TimeCurrent() - OrderOpenTime()) / 60;
      
   // сколько раз нужно было передвинуть стоплосс
   times2change = MathFloor(minpast / interval);
         
   // если длинная позиция (OP_BUY)
   if (OrderType()==OP_BUY)
      {
      // если тралим в убытке, то отступаем от стоплосса (если он не 0, если 0 - от открытия)
      if (trlinloss==true)
         {
         if (OrderStopLoss()==0) newstop = OrderOpenPrice() + times2change*(trlstep*Point);
         else newstop = OrderStopLoss() + times2change*(trlstep*Point); 
         }
      else
      // иначе - от курса открытия позиции
      newstop = OrderOpenPrice() + times2change*(trlstep*Point); 
         
      if (times2change>0)
         {
         if ((newstop>OrderStopLoss()) && (Bid>=(newstop + MarketInfo(Symbol(),MODE_STOPLEVEL)*Point)))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());
         }
      }
      
   // если короткая позиция (OP_SELL)
   if (OrderType()==OP_SELL)
      {
      // если тралим в убытке, то отступаем от стоплосса (если он не 0, если 0 - от открытия)
      if (trlinloss==true)
         {
         if (OrderStopLoss()==0) newstop = OrderOpenPrice() - times2change*(trlstep*Point) - MarketInfo(Symbol(),MODE_SPREAD)*Point;
         else newstop = OrderStopLoss() - times2change*(trlstep*Point) - MarketInfo(Symbol(),MODE_SPREAD)*Point;
         }
      else
      newstop = OrderOpenPrice() - times2change*(trlstep*Point) - MarketInfo(Symbol(),MODE_SPREAD)*Point;
                
      if (times2change>0)
         {
         if (((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice())) && (Ask<=(newstop - MarketInfo(Symbol(),MODE_STOPLEVEL)*Point)))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());     
         else
         if ((newstop<OrderStopLoss()) && (Ask<=(newstop - MarketInfo(Symbol(),MODE_STOPLEVEL)*Point)))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());     
         }
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО ATR (Average True Range, Средний истинный диапазон)  |
//| Функции передаётся тикет позиции, период АТR и коэффициент, на   |
//| который умножается ATR. Т.о. стоплосс "тянется" на расстоянии    |
//| ATR х N от текущего курса; перенос - на новом баре (т.е. от цены |
//| открытия очередного бара)                                        |

//| ATR - (Average True Range, Средний Истинный Диапазон) - один из индикаторов волатильности; 
//| чем больше значение, тем, соответственно, выше средняя волатильность за заданный период (индикатора) времени; 
//| измерятеся в пунктах. Трейлинг по ATR в большинстве случаев позволяет изменять стоплосс соответственно 
//| ("адекватно", "адаптивно") характеру поведения курса - при высокой волатильности (выраженных рывках) курс "отпускаем", 
//| при "топтании на месте" поджимаем более "плотно". В трейлинге используется 2 ATR, которым предлагается задавать отличные 
//| периоды - один короткий (напр., 5), другой - длинный (напр., 20). Для расчета стоплосса используется всегда большее 
//| из значений 2 ATR - это сделано для того, чтобы несколько низковолатильных баров подряд (например, перед выходом новостей) 
//| не сделали наш стоплосс слишком близким к текущему курсу.

//| Параметры:
//| ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| atr_timeframe - таймфрейм, на котором рассчитываем значение ATR (варианты - 1, 5, 15, 30, 60, 240, 1440, 10080, 43200);
//| atr1_period - период первого ATR (больше 0; может быть равен atr2_period, но лучше отличен от последнего, почему - см. выше);
//| atr1_shift - для первого ATR сдвиг "окна", в котором рассчитывается значение ATR, относительно текущего бара на указанное 
//| количество баров назад (неотрицательное целое число);
//| atr2_period - период второго ATR (больше 0);
//| atr2_shift - для второго ATR сдвиг "окна", в котором рассчитывается значение ATR, относительно текущего бара на указанное 
//| количество баров назад (неотрицательное целое число);
//| coeff - стоплосс считаем как ATR*coeff, т.е. это коэффициент, определяющий, на расстоянии скольких ATR от текущего курса 
//| следует разместить стоплосс;
//| trlinloss - указатель того, следует ли передвигать стоплосс на "лоссовом" участке, т.е. в интервале между начальным 
//| стоплоссом и курсом открытия (true - тралим, false - трейлинг начинается только при условии, что новый стоплосс "лучше" 
//| курса открытия, "в профите").

//| Также довольно популярный способ трейлинга, (в большинстве случаев выгодно) отличающийся от стандартного "адаптивностью" 
//| к текущей ситуации на рынке.

//+------------------------------------------------------------------+
void TrailingByATR(int ticket,int atr_timeframe,int atr1_period,int atr1_shift,int atr2_period,int atr2_shift,double coeff,bool trlinloss)
   {      
   // проверяем переданные значения
   //Print("ticket: ",ticket,", atr1_period: ",atr1_period,", atr2_period: ",atr2_period,", coeff: ",coeff,", OrderSelect(ticket,SELECT_BY_TICKET): ",OrderSelect(ticket,SELECT_BY_TICKET),", atr_timeframe: ",atr_timeframe,", atr1_shift: ",atr1_shift,", atr2_shift: ",atr2_shift);
   if ((ticket==0) || (atr1_period<1) || (atr2_period<1) || (coeff<=0) || (!OrderSelect(ticket,SELECT_BY_TICKET)) || 
   ((atr_timeframe!=1) && (atr_timeframe!=5) && (atr_timeframe!=15) && (atr_timeframe!=30) && (atr_timeframe!=60) && 
   (atr_timeframe!=240) && (atr_timeframe!=1440) && (atr_timeframe!=10080) && (atr_timeframe!=43200)) || (atr1_shift<0) || (atr2_shift<0))
      {
      Print("Трейлинг функцией TrailingByATR() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      }
   
   double curr_atr1; // текущее значение ATR - 1
   double curr_atr2; // текущее значение ATR - 2
   double best_atr; // большее из значений ATR
   double atrXcoeff; // результат умножения большего из ATR на коэффициент
   double newstop; // новый стоплосс
   
   // текущее значение ATR-1, ATR-2
   curr_atr1 = iATR(Symbol(),atr_timeframe,atr1_period,atr1_shift);
   curr_atr2 = iATR(Symbol(),atr_timeframe,atr2_period,atr2_shift);
   
   // большее из значений
   best_atr = MathMax(curr_atr1,curr_atr2);
   
   // после умножения на коэффициент
   atrXcoeff = best_atr * coeff;
              
   // если длинная позиция (OP_BUY)
   if (OrderType()==OP_BUY)
      {
      // откладываем от текущего курса (новый стоплосс)
      newstop = Bid - atrXcoeff;
      
      // если trlinloss==true (т.е. следует тралить в зоне лоссов), то
      if (trlinloss==true)
         {
         // проверяем, является ли он лучше текущего стоплосса, если да, то последний корректируем
         if (newstop>OrderStopLoss())
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());      
         }
      else
         {
         Print("Bid: ",Bid,", atrXcoeff: ",atrXcoeff,", newstop: ",newstop);
         // иначе тралить начинаем только тогда, когда стоплосс лучше курса открытия (в профите)
         if ((newstop>OrderStopLoss()) && (newstop>OrderOpenPrice()))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration());         
         }
      }
      
   // если короткая позиция (OP_SELL)
   if (OrderType()==OP_SELL)
      {
      // откладываем от текущего курса (новый стоплосс)
      newstop = Ask + (atrXcoeff + MarketInfo(Symbol(),MODE_SPREAD)*Point);
      
      // если trlinloss==true (т.е. следует тралить в зоне лоссов), то
      if (trlinloss==true)      
         {
         // если стоплосс неопределен, то тралим в любом случае
         if (OrderStopLoss()==0)
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration()); 
         // если стоплосс в убытке или в профите, тралим только если новый стоп лучше старого
         else
            {
            if (newstop<OrderStopLoss())
            OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration()); 
            }
         }
      else
         {
         // если стоплосс неопределен, то тралим, если стоп лучше открытия
         if ((OrderStopLoss()==0) && (newstop<OrderOpenPrice()-MarketInfo(Symbol(),MODE_STOPLEVEL)*Point))
         OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration()); 
         // если стоп не равен 0, то меняем его, если он лучше предыдущего и курса открытия
         else
            {
            if ((newstop<OrderStopLoss()) && (newstop<OrderOpenPrice()-MarketInfo(Symbol(),MODE_STOPLEVEL)*Point))
            OrderModify(ticket,OrderOpenPrice(),newstop,OrderTakeProfit(),OrderExpiration()); 
            }
         }
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ RATCHET БАРИШПОЛЬЦА                                     |
//| При достижении профитом уровня 1 стоплосс - в +1, при достижении |
//| профитом уровня 2 профита - стоплосс - на уровень 1, когда       |
//| профит достигает уровня 3 профита, стоплосс - на уровень 2       |
//| (дальше можно трейлить другими методами)                         |
//| при работе в лоссовом участке - тоже 3 уровня, но схема работы   |
//| с ними несколько иная, а именно: если мы опустились ниже уровня, |
//| а потом поднялись выше него (пример для покупки), то стоплосс    |
//| ставим на следующий, более глубокий уровень (например, уровни    |
//| -5, -10 и -25, стоплосс -40; если опустились ниже -10, а потом   |
//| поднялись выше -10, то стоплосс - на -25, если поднимемся выще   |
//| -5, то стоплосс перенесем на -10, при -2 (спрэд) стоп на -5      |
//| работаем только с одной позицией одновременно                    |

//| Храповой (англ. ratchet) ключ, колесо - тот, который "проворачивается только в одном направлении". 
//| Название - моё, в описании Баришпольца упоминается как "вторая тактика трейлинга" (в противовес "первой", со "стандартными"
//|  - дальними стоплоссами), в исполнении KimIV - т.н. "трехуровневый" трейлинг. Суть: быстрый перенос в безубыток и ступенчатый 
//| трейлинг при небольшом профите (дальше предлагается применять иные виды трейлинга, например, стандартный, можно мой 
//| стандартный-"ступенчастый" или какой-нибудь другой из вышеописанных). Целесообразность такого трала - "абсолютное 
//| большинство позиций по крайней мере некоторое время дают профит", поэтому при первой возможности переносим стоплосс 
//| в безубыток; если преждевременно "закроет", но сигналы к открытию сохраняются, возможен повторный вход; а вообще 
//| получаем большое кол-во сделок, закрытых в безубыток, и несколько, возможно, с хорошим профитом - на тех сделках, 
//| где после открытия последовало сильное движение в профитном направлении. Автор подчеркивает, что данный трейлинг не является
//|  "пипсовочным", а предназначен для достижения торговли с низким % убыточных сделок.

//| Параметры:
//| ticket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| pf_level_1 - уровень профита (пунктов), при котором стоплосс переносим в безубыток + 1 пункт;
//| pf_level_2 - уровень профита (пунктов), при котором стоплосс переносим с +1 на расстояние pf_level_1 пунктов от курса открытия;
//| pf_level_3 - уровень профита (пунктов), при котором стоплосс переносим с pf_level_1 на pf_level_2 пунктов от курса открытия 
//| (на этом действия функции заканчиваются);
//| ls_level_1 - расстояние от курса открытия в сторону "лосса", на котором будет установлен стоплосс при достижении профитом 
//| позиции +1 (т.е. при +1 стоплосс будет поджат на ls_level_1);
//| ls_level_2 - расстояние от курса открытия в "лоссе", на котором будет установлен стоплосс при условии, что курс сначала 
//| опускался ниже ls_level_1, а потом поднялся выше (т.е. имели лосс, но он начал уменьшаться - не допустим его повторного 
//| увеличения);
//| ls_level_3 - расстояние от курса открытия "минусе", на котором будет установлен стоплосс при условии, что курс снижался 
//| ниже ls_level_2, а потом поднялся выше;
//| trlinloss - указатель того, следует ли передвигать стоплосс на "лоссовом" участке, т.е. в интервале между начальным 
//| стоплоссом и курсом открытия (true - тралим, false - трейлинг начинается только при условии, что новый стоплосс "лучше" 
//| курса открытия, "в профите").

//| Автором идеи предлагалось на EURUSD использовать следующие значения: "5, 10, 25", т.е. при +5 
//| (т.е. "отбили" спрэд и ещё 5 пунктов прошли в профит) стоплосс переносим на +1 (при ручной торговле предлагается 
//| "держать" его "в голове", дабы не искушать лишний раз диллера), при +10 п. стоплосс переносится на +5, при +25 п. 
//| профита стоплосс - на +10 и курс "отпускаем" (можно поджимать другими способами). Аналогичная часть функции для 
//| лоссового интервала автором не описана, была придумана читателями его рассылки в ходе обсуждения. Существуют сведения, 
//| что автор (весьма успешно) применяет данную методику при торговле на счете своего инвестиционного проекта, что, вероятно, 
//| является одним из факторов очень высокого % профитов в его торговле. В то же время следует отметить, что данный алгоритм 
//| трейлинга довольно специфичен и может подойти не всем.
//+------------------------------------------------------------------+
void TrailingRatchetB(int ticket,int pf_level_1,int pf_level_2,int pf_level_3,int ls_level_1,int ls_level_2,int ls_level_3,bool trlinloss)
   {
   Print("RatchetB");
   
   // проверяем переданные значения
   if ((ticket==0) || (!OrderSelect(ticket,SELECT_BY_TICKET)) || (pf_level_2<=pf_level_1) || (pf_level_3<=pf_level_2) || 
   (pf_level_3<=pf_level_1) || (pf_level_2-pf_level_1<=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point) || (pf_level_3-pf_level_2<=MarketInfo(Symbol(),MODE_STOPLEVEL)*Point) ||
   (pf_level_1<=MarketInfo(Symbol(),MODE_STOPLEVEL)))
      {
      Print("Трейлинг функцией TrailingRatchetB() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      }
                
   // если длинная позиция (OP_BUY)
   if (OrderType()==OP_BUY)
      {
      double dBid = MarketInfo(Symbol(),MODE_BID);
      
      // Работаем на участке профитов
      
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_3+спрэд", стоплосс переносим в "pf_level_2+спрэд"
      if ((dBid-OrderOpenPrice())>=pf_level_3*Point)
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice() + pf_level_2 *Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + pf_level_2*Point,OrderTakeProfit(),OrderExpiration());
         }
      else
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_2+спрэд", стоплосс переносим в "pf_level_1+спрэд"
      if ((dBid-OrderOpenPrice())>=pf_level_2*Point)
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice() + pf_level_1*Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + pf_level_1*Point,OrderTakeProfit(),OrderExpiration());
         }
      else        
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_1+спрэд", стоплосс переносим в +1 ("открытие + спрэд")
      if ((dBid-OrderOpenPrice())>=pf_level_1*Point)
      // если стоплосс не определен или хуже чем "открытие+1"
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()<OrderOpenPrice() + 1*Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + 1*Point,OrderTakeProfit(),OrderExpiration());
         }

      // Работаем на участке лоссов
      if (trlinloss==true)      
         {
         // Глобальная переменная терминала содержит значение самого уровня убытка (ls_level_n), ниже которого опускался курс
         // (если он после этого поднимается выше, устанавливаем стоплосс на ближайшем более глубоком уровне убытка (если это не начальный стоплосс позиции)
         // Создаём глобальную переменную (один раз)
         if(!GlobalVariableCheck("zeticket")) 
            {
            GlobalVariableSet("zeticket",ticket);
            // при создании присвоим ей "0"
            GlobalVariableSet("dpstlslvl",0);
            }
         // если работаем с новой сделкой (новый тикет), затираем значение dpstlslvl
         if (GlobalVariableGet("zeticket")!=ticket)
            {
            GlobalVariableSet("dpstlslvl",0);
            GlobalVariableSet("zeticket",ticket);
            }
      
         // убыточным считаем участок ниже курса открытия и до первого уровня профита
         if ((dBid-OrderOpenPrice())<pf_level_1*Point)         
            {
            // если (текущий_курс лучше/равно открытие) и (dpstlslvl>=ls_level_1), стоплосс - на ls_level_1
            if (dBid>=OrderOpenPrice()) 
            if ((OrderStopLoss()==0) || (OrderStopLoss()<(OrderOpenPrice()-ls_level_1*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice()-ls_level_1*Point,OrderTakeProfit(),OrderExpiration());
      
            // если (текущий_курс лучше уровня_убытка_1) и (dpstlslvl>=ls_level_1), стоплосс - на ls_level_2
            if ((dBid>=OrderOpenPrice()-ls_level_1*Point) && (GlobalVariableGet("dpstlslvl")>=ls_level_1))
            if ((OrderStopLoss()==0) || (OrderStopLoss()<(OrderOpenPrice()-ls_level_2*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice()-ls_level_2*Point,OrderTakeProfit(),OrderExpiration());
      
            // если (текущий_курс лучше уровня_убытка_2) и (dpstlslvl>=ls_level_2), стоплосс - на ls_level_3
            if ((dBid>=OrderOpenPrice()-ls_level_2*Point) && (GlobalVariableGet("dpstlslvl")>=ls_level_2))
            if ((OrderStopLoss()==0) || (OrderStopLoss()<(OrderOpenPrice()-ls_level_3*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice()-ls_level_3*Point,OrderTakeProfit(),OrderExpiration());
      
            // проверим/обновим значение наиболее глубокой "взятой" лоссовой "ступеньки"
            // если "текущий_курс-курс открытия+спрэд" меньше 0, 
            if ((dBid-OrderOpenPrice()+MarketInfo(Symbol(),MODE_SPREAD)*Point)<0)
            // проверим, не меньше ли он того или иного уровня убытка
               {
               if (dBid<=OrderOpenPrice()-ls_level_3*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_3)
               GlobalVariableSet("dpstlslvl",ls_level_3);
               else
               if (dBid<=OrderOpenPrice()-ls_level_2*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_2)
               GlobalVariableSet("dpstlslvl",ls_level_2);   
               else
               if (dBid<=OrderOpenPrice()-ls_level_1*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_1)
               GlobalVariableSet("dpstlslvl",ls_level_1);
               }
            } // end of "if ((dBid-OrderOpenPrice())<pf_level_1*Point)"
         } // end of "if (trlinloss==true)"
      }
      
   // если короткая позиция (OP_SELL)
   if (OrderType()==OP_SELL)
      {
      double dAsk = MarketInfo(Symbol(),MODE_ASK);
      
      // Работаем на участке профитов
      
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_3+спрэд", стоплосс переносим в "pf_level_2+спрэд"
      if ((OrderOpenPrice()-dAsk)>=pf_level_3*Point)
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice() - (pf_level_2 + MarketInfo(Symbol(),MODE_SPREAD))*Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() - (pf_level_2 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }
      else
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_2+спрэд", стоплосс переносим в "pf_level_1+спрэд"
      if ((OrderOpenPrice()-dAsk)>=pf_level_2*Point)
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice() - (pf_level_1 + MarketInfo(Symbol(),MODE_SPREAD))*Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() - (pf_level_1 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }
      else        
      // если разница "текущий_курс-курс_открытия" больше чем "pf_level_1+спрэд", стоплосс переносим в +1 ("открытие + спрэд")
      if ((OrderOpenPrice()-dAsk)>=pf_level_1*Point)
      // если стоплосс не определен или хуже чем "открытие+1"
         {
         if ((OrderStopLoss()==0) || (OrderStopLoss()>OrderOpenPrice() - (1 + MarketInfo(Symbol(),MODE_SPREAD))*Point))
         OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() - (1 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
         }

      // Работаем на участке лоссов
      if (trlinloss==true)      
         {
         // Глобальная переменная терминала содержит значение самого уровня убытка (ls_level_n), ниже которого опускался курс
         // (если он после этого поднимается выше, устанавливаем стоплосс на ближайшем более глубоком уровне убытка (если это не начальный стоплосс позиции)
         // Создаём глобальную переменную (один раз)
         if(!GlobalVariableCheck("zeticket")) 
            {
            GlobalVariableSet("zeticket",ticket);
            // при создании присвоим ей "0"
            GlobalVariableSet("dpstlslvl",0);
            }
         // если работаем с новой сделкой (новый тикет), затираем значение dpstlslvl
         if (GlobalVariableGet("zeticket")!=ticket)
            {
            GlobalVariableSet("dpstlslvl",0);
            GlobalVariableSet("zeticket",ticket);
            }
      
         // убыточным считаем участок ниже курса открытия и до первого уровня профита
         if ((OrderOpenPrice()-dAsk)<pf_level_1*Point)         
            {
            // если (текущий_курс лучше/равно открытие) и (dpstlslvl>=ls_level_1), стоплосс - на ls_level_1
            if (dAsk<=OrderOpenPrice()) 
            if ((OrderStopLoss()==0) || (OrderStopLoss()>(OrderOpenPrice() + (ls_level_1 + MarketInfo(Symbol(),MODE_SPREAD))*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + (ls_level_1 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
      
            // если (текущий_курс лучше уровня_убытка_1) и (dpstlslvl>=ls_level_1), стоплосс - на ls_level_2
            if ((dAsk<=OrderOpenPrice() + (ls_level_1 + MarketInfo(Symbol(),MODE_SPREAD))*Point) && (GlobalVariableGet("dpstlslvl")>=ls_level_1))
            if ((OrderStopLoss()==0) || (OrderStopLoss()>(OrderOpenPrice() + (ls_level_2 + MarketInfo(Symbol(),MODE_SPREAD))*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + (ls_level_2 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
      
            // если (текущий_курс лучше уровня_убытка_2) и (dpstlslvl>=ls_level_2), стоплосс - на ls_level_3
            if ((dAsk<=OrderOpenPrice() + (ls_level_2 + MarketInfo(Symbol(),MODE_SPREAD))*Point) && (GlobalVariableGet("dpstlslvl")>=ls_level_2))
            if ((OrderStopLoss()==0) || (OrderStopLoss()>(OrderOpenPrice() + (ls_level_3 + MarketInfo(Symbol(),MODE_SPREAD))*Point)))
            OrderModify(ticket,OrderOpenPrice(),OrderOpenPrice() + (ls_level_3 + MarketInfo(Symbol(),MODE_SPREAD))*Point,OrderTakeProfit(),OrderExpiration());
      
            // проверим/обновим значение наиболее глубокой "взятой" лоссовой "ступеньки"
            // если "текущий_курс-курс открытия+спрэд" меньше 0, 
            if ((OrderOpenPrice()-dAsk+MarketInfo(Symbol(),MODE_SPREAD)*Point)<0)
            // проверим, не меньше ли он того или иного уровня убытка
               {
               if (dAsk>=OrderOpenPrice()+(ls_level_3+MarketInfo(Symbol(),MODE_SPREAD))*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_3)
               GlobalVariableSet("dpstlslvl",ls_level_3);
               else
               if (dAsk>=OrderOpenPrice()+(ls_level_2+MarketInfo(Symbol(),MODE_SPREAD))*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_2)
               GlobalVariableSet("dpstlslvl",ls_level_2);   
               else
               if (dAsk>=OrderOpenPrice()+(ls_level_1+MarketInfo(Symbol(),MODE_SPREAD))*Point)
               if (GlobalVariableGet("dpstlslvl")<ls_level_1)
               GlobalVariableSet("dpstlslvl",ls_level_1);
               }
            } // end of "if ((dBid-OrderOpenPrice())<pf_level_1*Point)"
         } // end of "if (trlinloss==true)"
      }      
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО ЦЕНВОМУ КАНАЛУ                                       |
//| Добавлен по совету Nickolay Zhilin (aka rebus)                   |
//| Функции передаётся тикет позиции, период (кол-во баров) для      | 
//| рассчета верхней и нижней границ канала, отступ (пунктов), на    |
//| котором размещается стоплосс от границы канала                   |
//| Трейлинг по закрывшимся барам.                                   |
//+------------------------------------------------------------------+
//| Параметры:
//| iTicket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| iBars_n - период канала (кол-во баров, среди котрых ищем наибольший хай и наименьший лоу - верхнюю и нижнюю 
//| границы канала соответственно);
//| iIndent - отступ (пунктов), с которым устанавливаем стоплосс от границы канала.
//+------------------------------------------------------------------+
//| В принципе, по конечному результату трейлинг по ценовому каналу практически совпадает с трейлингом по теням свечей (см. выше),
//|  а также в некоторой степени напоминает трейлинг по фракталам, хоть и отличается по "концепции" и "целесообразности".
//+------------------------------------------------------------------+
void TrailingByPriceChannel(int iTicket,int iBars_n,int iIndent)
   {     
   
   // проверяем переданные значения
   if ((iBars_n<1) || (iIndent<0) || (iTicket==0) || (!OrderSelect(iTicket,SELECT_BY_TICKET)))
      {
      Print("Трейлинг функцией TrailingByPriceChannel() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 
   
   double   dChnl_max; // верхняя граница канала
   double   dChnl_min; // нижняя граница канала
   
   // определяем макс.хай и мин.лоу за iBars_n баров начиная с [1] (= верхняя и нижняя границы ценового канала)
   dChnl_max = High[iHighest(Symbol(),0,2,iBars_n,1)] + (iIndent+MarketInfo(Symbol(),MODE_SPREAD))*Point;
   dChnl_min = Low[iLowest(Symbol(),0,1,iBars_n,1)] - iIndent*Point;   
   
   // если длинная позиция, и её стоплосс хуже (ниже нижней границы канала либо не определен, ==0), модифицируем его
   if (OrderType()==OP_BUY)
      {
      if (OrderStopLoss()<dChnl_min)
      OrderModify(iTicket,OrderOpenPrice(),dChnl_min,OrderTakeProfit(),OrderExpiration());         
      }
   
   // если позиция - короткая, и её стоплосс хуже (выше верхней границы канала или не определён, ==0), модифицируем его
   if (OrderType()==OP_SELL)
      {
      if ((OrderStopLoss()==0) || (OrderStopLoss()>dChnl_max))
      OrderModify(iTicket,OrderOpenPrice(),dChnl_max,OrderTakeProfit(),OrderExpiration());         
      }
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ ПО СКОЛЬЗЯЩЕМУ СРЕДНЕМУ                                 |
//| Функции передаётся тикет позиции и параметры средней (таймфрейм, | 
//| период, тип, сдвиг относительно графика, метод сглаживания,      |
//| составляющая OHCL для построения, № бара, на котором берется     |
//| значение средней. 
//+------------------------------------------------------------------+
//| Идея, в принципе, "в полушаге" от трейлинга по ценовому каналу. Функции передаётся тикет позиции, необходимый таймфрейм, 
//| отступ от средней (пунтов), на котором устанавливается стоплосс и собственно параметры среднего (аналогично стандартным 
//| в iMA()). Учитывая природу мувингов, несложно догадаться, что данный алгоритм может давать весьма неплохое поджатие при тренде,
//|  во флэте, однако, "путаясь" с курсом и часто приводя к преждевременному закрытию. Впрочем, можно попытаться менять параметры
//|  трала (в частности, период и метод усреднения) адекватно рыночной ситуации (учитывая волатильность, например).
//+------------------------------------------------------------------+
//| Параметры:
//| iTicket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| iTmFrme - период чарта, на котором будет расчитываться мувинг; допустимые варианты ввода: 1 (M1), 5 (M5), 15 (M15), 30 (M30), 60 (H1), 240 (H4), 1440 (D), 10080 (W), 43200 (MN);
//| iMAPeriod - период усреднения для вычисления скользящего среднего;
//| iMAShift - сдвиг индикатора относительно ценового графика;
//| iMAMethod - метод усреднения; допустимые варианты ввода: 0 (MODE_SMA), 1 (MODE_EMA), 2 (MODE_SMMA), 3 (MODE_LWMA);
//| iApplPrice - используемая цена; варианты ввода: 0 (PRICE_CLOSE), 1 (PRICE_OPEN), 2 (PRICE_HIGH), 3 (PRICE_LOW), 4 (PRICE_MEDIAN), 5 (PRICE_TYPICAL), 6 (PRICE_WEIGHTED);
//| iShift - сдвиг относительно текущего бара на указанное количество периодов назад;
//| iIndent - отступ (пунктов) от значения среднего при размещении стоплосса.
//+------------------------------------------------------------------+

//    Допустимые варианты ввода:   
//    iTmFrme:    1 (M1), 5 (M5), 15 (M15), 30 (M30), 60 (H1), 240 (H4), 1440 (D), 10080 (W), 43200 (MN);
//    iMAPeriod:  2-infinity, целые числа; 
//    iMAShift:   целые положительные или отрицательные числа, а также 0;
//    MAMethod:   0 (MODE_SMA), 1 (MODE_EMA), 2 (MODE_SMMA), 3 (MODE_LWMA);
//    iApplPrice: 0 (PRICE_CLOSE), 1 (PRICE_OPEN), 2 (PRICE_HIGH), 3 (PRICE_LOW), 4 (PRICE_MEDIAN), 5 (PRICE_TYPICAL), 6 (PRICE_WEIGHTED)
//    iShift:     0-Bars, целые числа;
//    iIndent:    0-infinity, целые числа;


extern int        iTmFrme      =  0;
extern int        iMAPeriod    =  0;
extern int        iMAShift     =  0;
extern int        MAMethod     =  0;
extern int        iApplPrice   =  0;
extern int        iShift       =  0;
extern int        iIndent      =  0;


void TrailingByMA(int iTicket,int iTmFrme,int iMAPeriod,int iMAShift,int MAMethod,int iApplPrice,int iShift,int iIndent)
   {     
   
   // проверяем переданные значения
   if ((iTicket==0) || (!OrderSelect(iTicket,SELECT_BY_TICKET)) || ((iTmFrme!=1) && (iTmFrme!=5) && (iTmFrme!=15) && (iTmFrme!=30) && (iTmFrme!=60) && (iTmFrme!=240) && (iTmFrme!=1440) && (iTmFrme!=10080) && (iTmFrme!=43200)) ||
   (iMAPeriod<2) || (MAMethod<0) || (MAMethod>3) || (iApplPrice<0) || (iApplPrice>6) || (iShift<0) || (iIndent<0))
      {
      Print("Трейлинг функцией TrailingByMA() невозможен из-за некорректности значений переданных ей аргументов.");
      return(0);
      } 

   double   dMA; // значение скользящего среднего с переданными параметрами
   
   // определим значение МА с переданными функции параметрами
   dMA = iMA(Symbol(),iTmFrme,iMAPeriod,iMAShift,MAMethod,iApplPrice,iShift);
         
   // если длинная позиция, и её стоплосс хуже значения среднего с отступом в iIndent пунктов, модифицируем его
   if (OrderType()==OP_BUY)
      {
      if (OrderStopLoss()<dMA-iIndent*Point)
      OrderModify(iTicket,OrderOpenPrice(),dMA-iIndent*Point,OrderTakeProfit(),OrderExpiration());         
      }
   
   // если позиция - короткая, и её стоплосс хуже (выше верхней границы канала или не определён, ==0), модифицируем его
   if (OrderType()==OP_SELL)
      {
      if ((OrderStopLoss()==0) || (OrderStopLoss()>dMA+(MarketInfo(Symbol(),MODE_SPREAD)+iIndent)*Point))
      OrderModify(iTicket,OrderOpenPrice(),dMA+(MarketInfo(Symbol(),MODE_SPREAD)+iIndent)*Point,OrderTakeProfit(),OrderExpiration());         
      }
   }
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| ТРЕЙЛИНГ "ПОЛОВИНЯЩИЙ"                                           |
//| По закрытии очередного периода (бара) подтягиваем стоплосс на    |
//| половину (но можно и любой иной коэффициент) дистанции, прой-    |
//| денной курсом (т.е., например, по закрытии суток профит +55 п. - |
//| стоплосс переносим в 55/2=27 п. Если по закрытии след.           |
//| суток профит достиг, допустим, +80 п., то стоплосс переносим на  |
//| половину (напр.) расстояния между тек. стоплоссом и курсом на    |
//| закрытии бара - 27 + (80-27)/2 = 27 + 53/2 = 27 + 26 = 53 п.     |
//| iTicket - тикет позиции; iTmFrme - таймфрейм (в минутах, цифрами |
//| dCoeff - "коэффициент поджатия", в % от 0.01 до 1 (в последнем   |
//| случае стоплосс будет перенесен (если получится) вплотную к тек. |
//| курсу и позиция, скорее всего, сразу же закроется)               |
//| bTrlinloss - стоит ли тралить на лоссовом участке - если да, то  |
//| по закрытию очередного бара расстояние между стоплоссом (в т.ч.  |
//| "до" безубытка) и текущим курсом будет сокращаться в dCoeff раз  |
//| чтобы посл. вариант работал, обязательно должен быть определён   |
//| стоплосс (не равен 0)                                            |

//| Идея следующая: по закрытию очередного бара уменьшаем расстояние между стоплоссом и текущим курсом в dCoeff раз 
//| (исходно я взял 0,5, т.е. наполовину, откуда и название). Т.е., допустим, открыта покупка со стоплоссом в 40 пунктов. 
//| По закрытию бара, на котором был совершен вход в рынок, Bid оказался выше курса открытия на 42 пункта. 
//| Если мы выбрали вариант трала только "в профите" (bTrlinloss==true), то берем расстояние от курса открытия до текущего курса 
//| - 42 п., множим его на dCoeff (например, 0.5), и получив 21 п., переносим стоплосс в +21. Пусть при закрытии следующего бара 
//| профит составил +71 п. Тогда разница между текущим стоплоссом и курсом: 71-21=50, половина от найденного значения - 50*0.5=25,
//|  и новый стоплосс должен быть установлен на 25 п. выше предыдущего (21+25=46 п. от курса открытия).
//+------------------------------------------------------------------+
//| При описанном вариант трейлинга, "в профите" (bTrlinloss==true), стоплосс переносится лишь при условии, что новый стоплосс 
//| будет "лучше" курса открытия. Если же установить bTrlinloss равным false, то трал будет осуществляться и на "лоссовом" 
//| участке (т.е. интервале между курсом открытия и стоплоссом, который, кстати, должен быть обязательно определён (не равен 0),
//|  чтобы данный элемент сработал). Т.е., если взять вышеописанный вариант, то по закрытии первого бара стоплосс будет перемещен
//|  на 0.5 дистанции не между открытием и текущим курсом, а между стоплоссом и текущим курсом (при стоплоссе в 40 п. и профите 
//| в 42 п. это расстояние составит (40+42)/2 = 82/2 = 41 п., стоплосс будет установлен в +1 п. от курса открытия. На втором баре, 
//| при профите в 71 п.: а) 71 - 1 = 70, б) 70*0.5 = 35, в) 1 + 35 = 36 п. Как видим, такой вариант будет стартовать с большей 
//| "дистанции" и несколько отставать от первого. Его основная функция - поджатие стоплосса при негативном развитии событий. 
//| Например, если по закрытию первого бара профит составил -10 п., то при bTrlinloss==true мы: а) найдем расстояние от курса до
//|  стоплосса, |-40 + (-10)| = 30 п., б) рассчитаем половину этого значения - 30*0.5 = 15 п. и в) переместим стоплосс в сторону 
//| профита на это расстояние: -40 + 15 = -25.
//+------------------------------------------------------------------+
//| При трейлинге в лоссе увеличивается количество преждевременных закрытий (причем с небольшим убытком), 
//| однако страхуемся от получения больших лоссов.
//+------------------------------------------------------------------+
//| Параметры:
//| iTicket - уникальный порядковый номер ордера (выбранный перед вызовом функции с помощью OrderSelect());
//| iTmFrme - период чарта, по барам которого будет осуществляться трейлинг; допустимые варианты ввода: 1 (M1), 5 (M5), 15 (M15), 30 (M30), 60 (H1), 240 (H4), 1440 (D), 10080 (W), 43200 (MN);
//+------------------------------------------------------------------+
//| dCoeff - коэффициент, определяющий то, в сколько раз будет сокращено расстояние между курсом на момент закрытия бара 
//| и текущим стоплоссом;
//| bTrlinloss - указатель того, следует ли осуществлять трейлинг на лоссовом участке.
//+------------------------------------------------------------------+

void TrailingFiftyFifty(int iTicket,int iTmFrme,double dCoeff,bool bTrlinloss)
   { 
   // активируем трейлинг только по закрытии бара
   if (sdtPrevtime == iTime(Symbol(),iTmFrme,0)) return(0);
   else
      {
      sdtPrevtime = iTime(Symbol(),iTmFrme,0);             
      
      // проверяем переданные значения
      if ((iTicket==0) || (!OrderSelect(iTicket,SELECT_BY_TICKET)) || 
      ((iTmFrme!=1) && (iTmFrme!=5) && (iTmFrme!=15) && (iTmFrme!=30) && (iTmFrme!=60) && (iTmFrme!=240) && 
      (iTmFrme!=1440) && (iTmFrme!=10080) && (iTmFrme!=43200)) || (dCoeff<0.01) || (dCoeff>1.0))
         {
         Print("Трейлинг функцией TrailingFiftyFifty() невозможен из-за некорректности значений переданных ей аргументов.");
         return(0);
         }
         
      // начинаем тралить - с первого бара после открывающего (иначе при bTrlinloss сразу же после открытия 
      // позиции стоплосс будет перенесен на половину расстояния между стоплоссом и курсом открытия)
      // т.е. работаем только при условии, что с момента OrderOpenTime() прошло не менее iTmFrme минут      
      if (iTime(Symbol(),iTmFrme,0)>OrderOpenTime())
      {         
      
      double dBid = MarketInfo(Symbol(),MODE_BID);
      double dAsk = MarketInfo(Symbol(),MODE_ASK);
      double dNewSl;
      double dNexMove;     
      
      // для длинной позиции переносим стоплосс на dCoeff дистанции от курса открытия до Bid на момент открытия бара
      // (если такой стоплосс лучше имеющегося и изменяет стоплосс в сторону профита)
      if (OrderType()==OP_BUY)
         {
         if ((bTrlinloss) && (OrderStopLoss()!=0))
            {
            dNexMove = NormalizeDouble(dCoeff*(dBid-OrderStopLoss()),Digits);
            dNewSl = NormalizeDouble(OrderStopLoss()+dNexMove,Digits);            
            }
         else
            {
            // если стоплосс ниже курса открытия, то тралим "от курса открытия"
            if (OrderOpenPrice()>OrderStopLoss())
               {
               dNexMove = NormalizeDouble(dCoeff*(dBid-OrderOpenPrice()),Digits);                 
               //Print("dNexMove = ",dCoeff,"*(",dBid,"-",OrderOpenPrice(),")");
               dNewSl = NormalizeDouble(OrderOpenPrice()+dNexMove,Digits);
               //Print("dNewSl = ",OrderOpenPrice(),"+",dNexMove);
               }
         
            // если стоплосс выше курса открытия, тралим от стоплосса
            if (OrderStopLoss()>=OrderOpenPrice())
               {
               dNexMove = NormalizeDouble(dCoeff*(dBid-OrderStopLoss()),Digits);
               dNewSl = NormalizeDouble(OrderStopLoss()+dNexMove,Digits);
               }                                       
            }
            
         // стоплосс перемещаем только в случае, если новый стоплосс лучше текущего и если смещение - в сторону профита
         // (при первом поджатии, от курса открытия, новый стоплосс может быть лучше имеющегося, и в то же время ниже 
         // курса открытия (если dBid ниже последнего) 
         if ((dNewSl>OrderStopLoss()) && (dNexMove>0))
         OrderModify(OrderTicket(),OrderOpenPrice(),dNewSl,OrderTakeProfit(),OrderExpiration(),Red);
         }       
      
      // действия для короткой позиции   
      if (OrderType()==OP_SELL)
         {
         if ((bTrlinloss) && (OrderStopLoss()!=0))
            {
            dNexMove = NormalizeDouble(dCoeff*(OrderStopLoss()-(dAsk+MarketInfo(Symbol(),MODE_SPREAD)*Point)),Digits);
            dNewSl = NormalizeDouble(OrderStopLoss()-dNexMove,Digits);            
            }
         else
            {         
            // если стоплосс выше курса открытия, то тралим "от курса открытия"
            if (OrderOpenPrice()<OrderStopLoss())
               {
               dNexMove = NormalizeDouble(dCoeff*(OrderOpenPrice()-(dAsk+MarketInfo(Symbol(),MODE_SPREAD)*Point)),Digits);                 
               dNewSl = NormalizeDouble(OrderOpenPrice()-dNexMove,Digits);
               }
         
            // если стоплосс нижу курса открытия, тралим от стоплосса
            if (OrderStopLoss()<=OrderOpenPrice())
               {
               dNexMove = NormalizeDouble(dCoeff*(OrderStopLoss()-(dAsk+MarketInfo(Symbol(),MODE_SPREAD)*Point)),Digits);
               dNewSl = NormalizeDouble(OrderStopLoss()-dNexMove,Digits);
               }                  
            }
         
         // стоплосс перемещаем только в случае, если новый стоплосс лучше текущего и если смещение - в сторону профита
         if ((dNewSl<OrderStopLoss()) && (dNexMove>0))
         OrderModify(OrderTicket(),OrderOpenPrice(),dNewSl,OrderTakeProfit(),OrderExpiration(),Blue);
         }               
      }
      }   
   }
//+------------------------------------------------------------------+