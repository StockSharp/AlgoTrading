//@version=5
strategy("DCA v1.1", overlay=true, pyramiding=999, default_qty_type=strategy.cash, initial_capital=250, commission_value = 0.1, slippage = 1)

// Date Ranges
from_day   = input.int(defval = 1, title = "Day", minval = 1, maxval = 31, group = "From Date", inline="01")
from_month = input.int(defval = 11, title = "Month", minval = 1, maxval = 12, group = "From Date", inline="01")
from_year  = input.int(defval = 2021, title = "Year", group = "From Date", inline="01")

to_day     = input.int(defval = 1, title = "Day", minval = 1, maxval = 31, group = "To Date", inline="02")
to_month   = input.int(defval = 1, title = "Month", minval = 1, maxval = 12, group = "To Date", inline="02")
to_year    = input.int(defval = 9999, title = "Year", group = "To Date", inline="02")
start  = timestamp(from_year, from_month, from_day, 00, 00)  // backtest start window
finish = timestamp(to_year, to_month, to_day, 23, 59)        // backtest finish window
window = time >= start and time <= finish ? true : false // create function "within window of time"

source_type = input.string("Close", "Source", options = ["Close", "Open", "High", "Low", "HL2", "HLC3", "OHLC4", "Median Body", "Weighted Close", "Trend Biased", "Trend Biased Extreme"], group = "General", inline="03")
source_function(type) =>
    if type == "Close"
        close
    else if type == "Open"
        open
    else if type == "High"
        high
    else if type == "Low"
        low
    else if type == "HL2"
        hl2
    else if type == "HL3"
        hlc3
    else if type == "OHLC4"
        ohlc4
    else if type == "Median Body"
        (open + close) / 2
    else if type == "Weighted Close"
        (high + low + 2 * close) / 4
    else if type == "Trend Biased"
        close > open ? (high + close) / 2 : (low + close) / 2
    else if type == "Trend Biased Extreme"
        close > open ? high : low
truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor
// Strategy Inputs
base_order  = input.float(100.0, title='base order', group = "General", inline="03")
leverage = input.int(1, title='leverage', group = "General", inline="03")

// DCA params
dca_enabled = input.bool(true, title="DCA Enable?", group="DCA")
dca_amount = input.float(10.0, title="DCA Amount", group="DCA")
dca_frequency = input.int(30, title="DCA Frequency (in candles)", group="DCA")

// Safety Order params
safe_order_enabled = input.bool(false, title="Safety Orders Enable?", group="Safety Orders")
safe_order  = input.float(100.0, title='safe order', group = "Safety Orders")
price_deviation = input.float(15.0, title='Price deviation to open safety orders (%)', minval=0.0, group = "Safety Orders")/100
safe_order_volume_scale  = input.float(1.6, step=0.01, title='Safety order volume scale', group = "Safety Orders")
safe_order_step_scale  = input.float(1.0, step=0.01, title='Safety order step scale', group = "Safety Orders")
safe_order_step_scale_max  = input.float(1.0, step=0.01, title='MAX Safety order step scale', group = "Safety Orders")
max_safe_order = input.int(3000, title='max safe order', group = "Safety Orders")

// Exit Rules
take_profit_enable  = input.bool(false, title="Take Profit Enable? (#TODO#) (DCA-out TBD)", group = "Exit Rules")
take_profit = input.float(1000.0, title='Target Take Profit (%)', step=0.01, minval=0.0, group = "Exit Rules")/100
take_profit_grow = input.float(1.1, title='Take Profit Growth Rate With SOs', step=0.01, minval=0.0, group = "Exit Rules")/100
trailing = input.float(25.0, title='Trailing stop. Default= 0.0 (%)', step=0.01, minval=0.0, group = "Exit Rules")/100

var current_so = 0
var initial_order = 0.0
var previous_high_value = 0.0
var original_ttp_value = 0.0

// Calculate our key levels

take_profit_level = strategy.position_avg_price * (1 + take_profit)

// fix
take_profit_level_base = strategy.position_avg_price * (1 + take_profit)
take_profit_level1 = take_profit_level_base + take_profit_level_base * current_so * take_profit_grow

if take_profit_enable == false
    take_profit_level := na
plot(take_profit_level, title='Take Profit', color=#00ffaa, linewidth=2, style=plot.style_line, transp=70)

// Enhanced DASHBOARD
// Variables initialization with var ensures they keep their values between bars
var float maxtrades = 0
var float maxposition = 0.0
var float maxliquidity = 0.0
var label id = na
var label labelProfit = na
var label labelAveragePrice = na
var label labelSafetyOrder = na

if (strategy.opentrades > maxtrades)
    maxtrades := strategy.opentrades
if (strategy.position_size > maxposition)
    maxposition := strategy.position_size

currentliquidity = strategy.position_size * strategy.position_avg_price
if (currentliquidity > maxliquidity)
    maxliquidity := currentliquidity

// Function to pad strings for alignment
formatLabel(string label, string value) =>
    int maxLength = 50 // Define a base max length for padding purposes
    string paddedLabel = label + ": "
    int padLength = maxLength - str.length(paddedLabel + value)
    string padding = str.repeat(' ', math.max(padLength, 0))
    paddedLabel + padding + value

// Creating Dashboard Strings using the function
dash_str_take_profit = formatLabel("ðŸŽ¯ Take Profit", str.tostring(take_profit_level))
dash_str_contracts_in_position = formatLabel("ðŸ“„ Contracts in Position", str.tostring(strategy.position_size))
dash_str_open_trades = formatLabel("ðŸ”„ Currently Open Trades", str.tostring(strategy.opentrades))
dash_str_open_liquidity = formatLabel("ðŸ’§ Currently Liquidity Used", "$" + str.tostring(currentliquidity / leverage))
dash_str_open_average_price = formatLabel("ðŸ’° Current Average Price", "$" + str.tostring(strategy.position_avg_price))

dash_str_max_trades = formatLabel("ðŸ” Max Open Trades", str.tostring(maxtrades))
dash_str_max_position = formatLabel("ðŸ”¢ Max Contract Count", str.tostring(maxposition))
dash_str_max_liquidity = formatLabel("ðŸ’° Max Liquidity Used", "$" + str.tostring(maxliquidity / leverage))


// Assemble the dashboard string
dash_str = "âš™ï¸ Dashboard\n\n"
dash_str += dash_str_take_profit + "\n" + dash_str_contracts_in_position + "\n" + dash_str_open_trades + "\n"
dash_str += dash_str_open_liquidity +  "\n"  + dash_str_open_average_price + "\n\n" + dash_str_max_trades + "\n" + dash_str_max_position + "\n"
dash_str += dash_str_max_liquidity

// Handling label display
dash_offset = 500 * (time - time[1])
if (na(id))
    id := label.new(x=time+dash_offset, y=high, xloc=xloc.bar_time, text=dash_str, style=label.style_label_down,color=color.silver)
    label.set_text_font_family(id, font.family_monospace)
    label.set_size(id, size.large)
else
    label.set_xy(id, x=time+dash_offset, y=high)
    label.set_text(id, dash_str)

// First Position
if(strategy.position_size == 0 and window and source_function(source_type) > 0) and previous_high_value == 0.0
    strategy.entry("Long @" + str.tostring(source_function(source_type)), strategy.long, qty = base_order/source_function(source_type))
    initial_order := source_function(source_type)
    current_so := 1
    previous_high_value := 0.0
    original_ttp_value := 0

threshold = 0.0
curr_deviation = math.pow(safe_order_step_scale,current_so)
max_deviation = safe_order_step_scale_max

// track HH
var lastHigh = high
if high > lastHigh and current_so == 1
    lastHigh := high

if high > lastHigh and current_so > 1
    current_so := 1

// plot(lastHigh)

if(safe_order_step_scale == 1.0)
    threshold := lastHigh -  (lastHigh * price_deviation * safe_order_step_scale * current_so)
// else if(curr_deviation > max_deviation)
//     threshold := lastHigh - (lastHigh * price_deviation * safe_order_step_scale_max * current_so)
else
    threshold := lastHigh - (lastHigh * ((price_deviation * math.pow(safe_order_step_scale,current_so) - price_deviation) / (safe_order_step_scale - 1)))

if safe_order_enabled == false or current_so == 0
    threshold := na
plot(threshold, title='Buy More', color=#cc0000, linewidth=2, style=plot.style_line, transp=70)
plot(strategy.position_avg_price, title='Breakeven', color=#ffffff, linewidth=2, style=plot.style_line, transp=70)

// plot labels
if (na(labelProfit))
    labelProfit := label.new(x=time, y=take_profit_level, xloc=xloc.bar_time, text="Take Profit" + str.tostring(take_profit_level), style=label.style_label_up,color=color.new(color.silver,55))
else
    label.set_xy(labelProfit, x=time, y=take_profit_level)
    label.set_text(labelProfit, "Take Profit (" + str.tostring(take_profit*100) + "%) " + str.tostring(take_profit_level))

if (na(labelAveragePrice))
    labelAveragePrice := label.new(x=time, y=strategy.position_avg_price, xloc=xloc.bar_time, text="Average Price" + str.tostring(strategy.position_avg_price), style=label.style_label_up,color=color.new(color.silver,55))
else
    label.set_xy(labelAveragePrice, x=time, y=strategy.position_avg_price)
    label.set_text(labelAveragePrice, "Average Price " + str.tostring(strategy.position_avg_price))

if (na(labelSafetyOrder))
    labelSafetyOrder := label.new(x=time, y=threshold, xloc=xloc.bar_time, text="Safety Order Trigger " + str.tostring(threshold), style=label.style_label_up,color=color.new(color.silver,55))
else
    label.set_xy(labelSafetyOrder, x=time, y=threshold)
    label.set_text(labelSafetyOrder, "Safety Order Trigger " + str.tostring(threshold))



// Open DCA orders
if (dca_enabled and window and bar_index != 0 and bar_index != strategy.opentrades.entry_bar_index(0) and ((bar_index - strategy.opentrades.entry_bar_index(0)) % dca_frequency) == 0)
    strategy.entry("DCA", strategy.long, qty = dca_amount / close)

// Open Safety Orders
if safe_order_enabled and current_so > 0 and source_function(source_type) <= threshold and current_so <= max_safe_order and previous_high_value == 0.0
    strategy.entry("SO " + str.tostring(current_so) + "@" + str.tostring(source_function(source_type)), direction=strategy.long , qty = safe_order * math.pow(safe_order_volume_scale,(current_so-1))/source_function(source_type))
    current_so := current_so + 1

// Take Profit
if (take_profit_level <= source_function(source_type) and strategy.position_size > 0) or previous_high_value > 0.0
    if(trailing > 0.0)
        if(previous_high_value > 0.0)
            if source_function(source_type) >= previous_high_value
                previous_high_value := source_function(source_type)
            else
                previous_high_percent = (previous_high_value - original_ttp_value ) *1.0 / original_ttp_value
                current_high_percent =  (source_function(source_type) - original_ttp_value ) *1.0 / original_ttp_value
                if (previous_high_percent - current_high_percent) >= trailing
                    strategy.close_all(comment = "Close (trailing) @"  + str.tostring(truncate( current_high_percent * 100, 3)) + "%")
                    current_so := 0
                    previous_high_value := 0
                    original_ttp_value := 0
        else
            previous_high_value := source_function(source_type)
            original_ttp_value := source_function(source_type)
    else
        strategy.close_all(comment = "Close @" + str.tostring(source_function(source_type)))
        current_so := 0
        previous_high_value := 0
        original_ttp_value := 0