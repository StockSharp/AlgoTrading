// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Mawreez

//@version=4
study("Mawreez' RSI Divergence Detector", precision=2)

// Inputs
src = input(close, title="Source", type=input.source)
rsi_len = input(14, title="RSI Length", minval=1, type=input.integer)
min_div_len = input(3, title="Minimum Divergence Length", minval=3, type=input.integer)
max_div_len = input(28, title="Maximum Divergence Length", minval=3, type=input.integer)

//// Normalization mechanic
// Make the change in price comparable to the change in oscillator value
// Project into 0-100 range using basic stoch with length 100
// Note: any length will do, longer is better but won't work on young tickers
proj(s) => stoch(s, s, s, 100)

// Slope of line going through s and s[len]
slope(s, len) => (s - s[len]) / len

// Value of the line with slope m that starts at s after j steps back
_line(s, m, j) => s - j * m

//// Cross detection mechanic
// Crosses up or down the line with slope m after j steps back
cross_up(s, m, j)   => _line(s, m, j - 1) > s[j - 1] and _line(s, m, j) < s[j]
cross_down(s, m, j) => _line(s, m, j - 1) < s[j - 1] and _line(s, m, j) > s[j]

// Return true if the line through s and s[len] crossed s
any_cross(s, len) =>
    m = slope(s, len)
    result = false
    for i = 1 to len
        if cross_up(s, m, i) or cross_down(s, m, i)
            result := true
            break
    result

//// Above/below checking mechanics (stricter than cross detection)
//---
// /!\ This section is currently unused
//----

// Check if s is (still) above/below the line with slope m after j steps back
is_below(s, m, j) => _line(s, m, j) < s[j]
is_above(s, m, j) => _line(s, m, j) > s[j]

// Return true if all values in s are below the line through s and s[len]
all_below(s, len) =>
    m = slope(s, len)
    result = true
    for i = 1 to len
        if is_above(s, m, i)
            result := false
            break
    result

// Return true if all values in s are above the line through s and s[len]
all_above(s, len) =>
    m = slope(s, len)
    result = true
    for i = 1 to len
        if is_below(s, m, i)
            result := false
            break
    result

// Bivariate shorthands
both_below(s, t, len) => all_below(s, len) and all_below(t, len)
both_above(s, t, len) => all_above(s, len) and all_above(t, len)

//// Tops and bottoms definitions
//---
// /!\ This section is currently unused
//----

// Implementing a generalization of Williams fractals (WF) for arbitrary
// depth d, whereas conventional WF have depth 2
// Note: not supporting said depth d exceeding the minimum divergence length

// Return true if there is a top at s[j]
top(s, j, d) =>
    result = true
    for i = 1 to d
        if s[j] >= s[j - i] or s[j] <= s[j + i]
            result := false
            break
    result

// Return true if there is a bottom at s[j]
bottom(s, j, d) =>
    result = true
    for i = 1 to d
        if s[j] <= s[j - i] or s[j] >= s[j + i]
            result := false
            break
    result

// Bivariate shorthands
both_top(s, t, j, d) => top(s, j, d) and top(t, j, d)
both_bottom(s, t, j, d) => bottom(s, j, d) and bottom(t, j, d)

//// Divergence metric (single length)
div(osc, len) =>
    dsrc = src - src[len]
    dosc = osc - osc[len]

    // If changes are both negative or both positive, there is no divergence
    // In addition, ignore lines that cross their series
    if sign(dsrc) == sign(dosc) or any_cross(src, len) or any_cross(osc, len)
        0

    // Normalize changes with different signs as the divergence metric
    // Note: this may exceed 100
    else
        proj(abs(dsrc)) + proj(abs(dosc))

//// Divergence type (single length)
NONE = 0
BULLS = 1
BEARS = 2
HBULLS = 3
HBEARS = 4
div_type(osc, len) =>
    dsrc = src - src[len]
    dosc = osc - osc[len]

    if sign(dsrc) == sign(dosc) or any_cross(src, len) or any_cross(osc, len)
        NONE
    else
        if sign(dsrc) > sign(dosc)
            if change(src) < 0
                HBULLS
            else
                BEARS
        else
            if change(src) < 0
                BULLS
            else
                HBEARS

//// Oscillator of choice
osc = rsi(src, rsi_len)

//// Divergence metric (sum of single length metrics over all lengths)
total_div = 0.0
for l = min_div_len - 1 to max_div_len - 1
    total_div := total_div + div(osc, l)
total_div := total_div / (max_div_len - min_div_len + 1)

//// Divergence type (first type found over all lengths)
// One may simply prove by exhaustion that only one type of divergence can be
// present at a single point in time for any length
winner = NONE
for l = min_div_len - 1 to max_div_len - 1
    winner := div_type(osc, l)
    if winner == BULLS or winner == BEARS or winner == HBULLS or winner == HBEARS
        break

//// Color based on type of divergence
// #9fff00 is a lime/light green color, #ffc0cb is dark pink
clr = winner == NONE ? color.white : winner == BULLS ? color.green : winner == BEARS ? color.maroon : winner == HBULLS ? #9fff00 : #e75480

//// Plot as a histogram
plot(total_div, style=plot.style_columns, color=clr)