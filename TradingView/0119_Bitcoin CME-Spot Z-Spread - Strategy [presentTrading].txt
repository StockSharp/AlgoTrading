// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© PresentTrading

//The Bitcoin CME-Spot Bollinger Bands Strategy is a swing trading system designed to identify market sentiment through the spread between CME Bitcoin Futures and
//Bitfinex BTCUSD Spot prices. By applying Bollinger Bands to the spread, the strategy seeks to capture mean-reversion opportunities when prices deviate significantly
//from their historical norms. Traders enter long positions when the market is oversold and short positions when the market is overbought.
//This strategy is tailored for correlated markets and is particularly effective during periods of high volatility.

//@version=5
strategy("Bitcoin CME-Spot Bollinger Bands - Strategy [presentTrading]", overlay = false, precision=3, commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1, currency=currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value = 10, initial_capital=10000)

// User inputs for symbols
cme_symbol = input.string("CME:BTC1!", title="CME Symbol")
bitfinex_symbol = input.string("BITFINEX:BTCUSD", title="Bitfinex Symbol")

// User inputs for Bollinger Bands settings
bb_period = input.int(200, title="Bollinger Bands Period", minval=1)
bb_std_dev = input.float(2.618, title="Standard Deviation", minval=0.1)

// Fetch the close prices
cme_price = request.security(cme_symbol, timeframe.period, close, lookahead=barmerge.lookahead_off)
bitfinex_price = request.security(bitfinex_symbol, timeframe.period, close, lookahead=barmerge.lookahead_off)

// Calculate the spread
spread = cme_price - bitfinex_price

// Calculate Bollinger Bands on the spread
basis = ta.sma(spread, bb_period)
dev = bb_std_dev * ta.stdev(spread, bb_period)
upper_band = basis + dev
lower_band = basis - dev

// Long condition: Spread crosses below the lower Bollinger Band
long_condition = ta.crossover(lower_band, spread)

// Short condition: Spread crosses above the upper Bollinger Band
short_condition = ta.crossover(spread, upper_band)

// User inputs for risk management
use_risk_management = input.bool(true, title="Enable Risk Management?")
//stop_loss_pct = input.float(10.0, title="Stop Loss (%)", minval=0.1, step=0.1) / 100

// User inputs for take profit levels
take_profit_step1 = input.float(3.0, title="Take Profit Level 1 (%)", minval=0.1) / 100
take_profit_step2 = input.float(8.0, title="Take Profit Level 2 (%)", minval=0.1) / 100
take_profit_step3 = input.float(14.0, title="Take Profit Level 3 (%)", minval=0.1) / 100
take_profit_step4 = input.float(21.0, title="Take Profit Level 4 (%)", minval=0.1) / 100

// User inputs for position size to exit at each take profit level
tp_pct1 = input.float(25.0, title="Take Profit % at Level 1", minval=0.1, maxval=100) / 100
tp_pct2 = input.float(20.0, title="Take Profit % at Level 2", minval=0.1, maxval=100) / 100
tp_pct3 = input.float(15.0, title="Take Profit % at Level 3", minval=0.1, maxval=100) / 100
tp_pct4 = input.float(10.0, title="Take Profit % at Level 4", minval=0.1, maxval=100) / 100

// User input for hold days (exit after certain bars)
hold_days = input.int(20, title="Hold Days Exit (in bars)", minval=1)

// Execute trades with take profit and stop loss, only if there is a position
if long_condition
    strategy.entry("Long", strategy.long)
if short_condition
    strategy.entry("Short", strategy.short)

// Check for open long positions and execute take profits
if (strategy.position_size > 0) and use_risk_management
    // Four-step take profit exits, with user-defined percentage for each step
    strategy.exit("TP 1", "Long", limit=strategy.position_avg_price * (1 + take_profit_step1), qty=strategy.position_size * tp_pct1)
    strategy.exit("TP 2", "Long", limit=strategy.position_avg_price * (1 + take_profit_step2), qty=strategy.position_size * tp_pct2)
    strategy.exit("TP 3", "Long", limit=strategy.position_avg_price * (1 + take_profit_step3), qty=strategy.position_size * tp_pct3)
    strategy.exit("TP 4", "Long", limit=strategy.position_avg_price * (1 + take_profit_step4), qty=strategy.position_size * tp_pct4)

// Check for open short positions and execute take profits
if (strategy.position_size < 0) and use_risk_management
    // Four-step take profit exits for shorts, with user-defined percentage for each step
    strategy.exit("TP 1", "Short", limit=strategy.position_avg_price * (1 - take_profit_step1), qty=strategy.position_size * tp_pct1)
    strategy.exit("TP 2", "Short", limit=strategy.position_avg_price * (1 - take_profit_step2), qty=strategy.position_size * tp_pct2)
    strategy.exit("TP 3", "Short", limit=strategy.position_avg_price * (1 - take_profit_step3), qty=strategy.position_size * tp_pct3)
    strategy.exit("TP 4", "Short", limit=strategy.position_avg_price * (1 - take_profit_step4), qty=strategy.position_size * tp_pct4)

// Hold days exit logic, only if there is an open position
if (strategy.opentrades > 0) and (bar_index - strategy.opentrades.entry_bar_index(0) >= hold_days)
    strategy.close("Long", comment="Hold Days Exit")
    strategy.close("Short", comment="Hold Days Exit")

// Plotting
plot(spread, title="Spread", color=color.blue)
plot(upper_band, title="Upper Bollinger Band", color=color.red)
plot(lower_band, title="Lower Bollinger Band", color=color.green)