// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Anton "lejmer" Berlin

//@version=4
study("P-Square", shorttitle = "P2", precision = 8, resolution = "")



// ------------------------------------------------------------------------------------
//    Input
// ------------------------------------------------------------------------------------
//{

float source = input(close, "Data Source")
var float perc = input(84.1, "Percentile [0 to 100]", minval = 0, maxval = 100, type = input.float)
var bool use_returns = input(true, "Use the Returns of the Data Source?")
var bool calc_actual_nth_perc = input(false, "Plot the Actual Nth Percentile for Reference (Costly Operation)?")
var bool show_source = input(true, "Plot Source Data (or Its Returns) as a Scatter Plot?")

//} Input



// ------------------------------------------------------------------------------------
//    Functions
// ------------------------------------------------------------------------------------
//{

// ------------------------------------------------------------------------------------
//    Estimation of the Nth percentile of a series
//
//    Pine Script port of the following implementation of the P-Square algorithm:
//    https://github.com/viciious/psqr
//
//    Original paper:
//    https://www.cse.wustl.edu/~jain/papers/ftp/psqr.pdf
// ------------------------------------------------------------------------------------

p2(source, perc) =>
//{
    var int count = 0
    var float[] q = array.new_float(5)
    var int[] n = array.new_int(5)
    var float[] np = array.copy(q)
    var float[] dn = array.copy(np)

    float value = nz(source)

    if (perc > 0)
    //{
        if (count == 0)
        //{
            float p = perc / 100

            array.set(dn, 0, 0)
            array.set(dn, 1, p * 0.5)
            array.set(dn, 2, p)
            array.set(dn, 3, (1 + p) * 0.5)
            array.set(dn, 4, 1)

            for i = 0 to 4
            //{
                array.set(n, i, i + 1)
                array.set(np, i, array.get(dn, i) * 4 + 1)
            //}
        //}

        count := count + 1

        if (count < 5)
        //{
            array.set(q, count - 1, value)

            if (count == 5)
                array.sort(q)

            array.get(q, 2)
        //}
        else
        //{
            var int k = na

            for i = 0 to 5
            //{
                k := i

                if (k == 5)
                    break

                if (source < array.get(q, i))
                //{
                    break
                //}
            //}

            if (k == 0)
            //{
                k := 1
                array.set(q, 0, value)
            //}
            else if (k == 5)
            //{
                k := 4
                array.set(q, 4, value)
            //}

            for i = k to 4
                array.set(n, i, array.get(n, i) + 1)

            for i = 0 to 4
                array.set(np, i, array.get(np, i) + array.get(dn, i))

            for i = 1 to 3
            //{
                float d = array.get(np, i) - float(array.get(n, i))

                if ((d > 1 and array.get(n, i + 1) - array.get(n, i) > 1) or (d <= -1 and array.get(n, i - 1) - array.get(n, i) < -1))
                //{
                    int ds = int(sign(d))

                    float qi = array.get(q, i)
                    float qip1 = array.get(q, i + 1)
                    float qim1 = array.get(q, i - 1)

                    float ni = float(array.get(n, i))
                    float nip1 = float(array.get(n, i + 1))
                    float nim1 = float(array.get(n, i - 1))

                    float df = float(ds)
                    float qp = qi + df / (nip1 - nim1) * ((ni - nim1 + df) * (qip1 - qi) / (nip1 - ni) + (nip1 - ni - df) * (qi - qim1) / (ni - nim1))

                    if (array.get(q, i - 1) < qp and qp < array.get(q, i + 1))
                        array.set(q, i, qp)
                    else
                        array.set(q, i, array.get(q, i) + df * (array.get(q, i + ds) - array.get(q, i)) / float(array.get(n, i + ds) - array.get(n, i)))

                    array.set(n, i, array.get(n, i) + ds)
                //}
            //}

            array.get(q, 2)
        //}
    //}
//}

// ------------------------------------------------------------------------------------
//    Get the Nth percentile of an array using the nearest rank method
// ------------------------------------------------------------------------------------

array_percentile_nearest_rank(array_id, perc, is_sorted) =>
//{
    int array_size = array.size(array_id)
    float[] temp_array = na
    int index = na
    float result = na

    if (array_size > 0)
    //{
        temp_array := array.copy(array_id)

        if (not is_sorted)
            array.sort(temp_array, order.ascending)

        index := int(ceil((perc / 100) * (array_size - 1)))
        result := array.get(temp_array, index)
    //}

    result
//}

//} Functions



// ------------------------------------------------------------------------------------
//    Main code
// ------------------------------------------------------------------------------------
//{

float src = use_returns ? 100 * (source / source[1] - 1) : source

// Mean
float source_mean = cum(src) / (bar_index + 1)

// Standard deviation
float source_stdev = sqrt(cum(pow(src - source_mean, 2)) / max(1, bar_index))

// Estimated Nth percentile
float source_estimated_nth_perc = p2(src, perc)

// Actual Nth percentile
var float[] source_array = array.new_float()
float source_actual_nth_perc = na

if (calc_actual_nth_perc)
//{
    array.push(source_array, src)
    source_actual_nth_perc := array_percentile_nearest_rank(source_array, perc, false)
//}

//} Main code



// ------------------------------------------------------------------------------------
//    Plotting
// ------------------------------------------------------------------------------------
//{

plot(source_mean, "Mean", color = color.orange)
plot(source_estimated_nth_perc, "Estimated Nth Percentile", color = color.green)
plot(source_actual_nth_perc, "Actual Nth Percentile", color = color.white)
plot(source_stdev, "Standrad Deviation", color = color.yellow)
plot(show_source ? src : na, "Source Data", style = plot.style_circles, color = color.blue)

//} Plotting