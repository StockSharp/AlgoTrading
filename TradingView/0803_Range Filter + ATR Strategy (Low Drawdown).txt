// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Range Filter Pro V3 - Dual Entry System (Middle Line Cross + Outside Bands) + Heikin Ashi

//@version=6
strategy("Range Filter Pro V4 ", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0)

// Heikin Ashi Settings
useHeikinAshi = input.bool(false, title="Use Heikin Ashi Candles", group="Candle Type")
showHeikinAshiCandles = input.bool(false, title="Show Heikin Ashi Candles on Chart", group="Candle Type")
heikinAshiSmoothing = input.int(1, title="HA Smoothing Factor", minval=1, maxval=5, group="Candle Type")

// Heikin Ashi Calculation with proper initialization
var float ha_open = na
var float ha_close = na
var float ha_high = na
var float ha_low = na

// Always calculate HA values for consistency
ha_close := (open + high + low + close) / 4
ha_open := na(ha_open[1]) ? (open + close) / 2 : (ha_open[1] + ha_close[1]) / 2
ha_high := math.max(high, math.max(ha_open, ha_close))
ha_low := math.min(low, math.min(ha_open, ha_close))

// Optional smoothing for HA values
ha_close_smooth = ta.sma(ha_close, heikinAshiSmoothing)
ha_open_smooth = ta.sma(ha_open, heikinAshiSmoothing)
ha_high_smooth = ta.sma(ha_high, heikinAshiSmoothing)
ha_low_smooth = ta.sma(ha_low, heikinAshiSmoothing)

// Use smoothed or regular HA values
ha_o = heikinAshiSmoothing > 1 ? ha_open_smooth : ha_open
ha_c = heikinAshiSmoothing > 1 ? ha_close_smooth : ha_close
ha_h = heikinAshiSmoothing > 1 ? ha_high_smooth : ha_high
ha_l = heikinAshiSmoothing > 1 ? ha_low_smooth : ha_low

// Use Heikin Ashi or regular OHLC based on user selection
o = useHeikinAshi ? ha_o : open
c = useHeikinAshi ? ha_c : close
h = useHeikinAshi ? ha_h : high
l = useHeikinAshi ? ha_l : low

// Strategy Direction Input
tradeDirection = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"])

// Triple Entry Method Selection
useMiddleLineCross = input.bool(true, title="Enable Middle Line Cross Entry", group="Entry Methods")
useOutsideBands = input.bool(true, title="Enable Outside Bands Entry", group="Entry Methods")
useMidPointPass = input.bool(false, title="Enable Mid Point Pass Entry", group="Entry Methods")
allowSimultaneousEntries = input.bool(false, title="Allow Multiple Entries Same Bar", group="Entry Methods")
bandEntryBuffer = input.float(0.1, title="Band Entry Buffer (%)", minval=0.0, maxval=1.0, step=0.05, group="Entry Methods")
bandEntryMinDistance = input.float(0.5, title="Min Distance from Band (ATR)", minval=0.1, maxval=2.0, step=0.1, group="Entry Methods")

// Mid Point Pass Settings
midPointBuffer = input.float(0.05, title="Mid Point Pass Buffer (%)", minval=0.0, maxval=0.5, step=0.01, group="Entry Methods")
midPointMinMove = input.float(0.3, title="Min Movement for Mid Pass (ATR)", minval=0.1, maxval=1.0, step=0.1, group="Entry Methods")

// Individual Volume Confirmation Settings
useVolumeMiddleLine = input.bool(true, title="Volume Confirmation - Middle Line Cross", group="Volume Confirmation")
useVolumeOutsideBands = input.bool(true, title="Volume Confirmation - Outside Bands", group="Volume Confirmation")
useVolumeMidPointPass = input.bool(true, title="Volume Confirmation - Mid Point Pass", group="Volume Confirmation")

// Delta Volume Settings
useDeltaVolume = input.bool(false, title="Enable Delta Volume Filter", group="Volume Confirmation")
deltaVolumeMethod = input.string("Tick Direction", title="Delta Volume Method", options=["Tick Direction", "Price Action", "Volume Weighted"], group="Volume Confirmation")
deltaVolumeThreshold = input.float(0.6, title="Delta Volume Threshold (% directional)", minval=0.5, maxval=0.9, step=0.05, group="Volume Confirmation")
deltaVolumeLookback = input.int(3, title="Delta Volume Lookback (bars)", minval=1, maxval=10, group="Volume Confirmation")

// Range Filter Inputs
length = input.int(14, title="Range Filter Length", minval=5, maxval=50)
mult = input.float(2.0, title="Range Filter Multiplier", minval=0.5, maxval=3, step=0.1)
atrLength = input.int(14, title="ATR Length", minval=5, maxval=20)

// Range Filter Lock Options
lockMethod = input.string("Dynamic", title="Range Filter Lock", options=["Dynamic", "Lock to Close", "Lock on Trend Change", "Lock on High Volume", "Fixed Period Lock"])
lockPeriod = input.int(50, title="Lock Period (bars)", minval=10, maxval=200)
volumeThreshold = input.float(1.5, title="Volume Threshold (x avg)", minval=1.0, maxval=3.0, step=0.1)

// Take Profit Method
tpMethod = input.string("Swing Based RR", title="Take Profit Method", options=["Fixed ATR", "Fixed Points", "Swing Based RR", "Multiple TP Points", "Multiple TP ATR", "Momentum Based", "Trailing Only", "Hybrid"])

// Swing-Based Risk:Reward Settings
swingLookback = input.int(10, title="Swing Lookback Length", minval=5, maxval=50)
riskRewardRatio = input.float(2.0, title="Risk:Reward Ratio", minval=1.0, maxval=4.0, step=0.1)
swingBuffer = input.float(6.0, title="Swing Level Buffer (points)", minval=0.0, maxval=20.0, step=0.5)
usePartialExit = input.bool(true, title="Use 50/50 Split Exit")
moveToBreakevenAt1to1 = input.bool(false, title="Move SL to Breakeven at 1:1 RR")

// Protection Settings (Modified to prevent early exits)
useQuickProfit = input.bool(false, title="Use Quick Profit Protection")
quickProfitRatio = input.float(0.6, title="Quick Profit R:R Ratio", minval=0.3, maxval=0.9, step=0.1)
quickProfitPercent = input.int(25, title="Quick Profit % to Close", minval=15, maxval=40)
useTimeExit = input.bool(false, title="Use Time-Based Exit")
maxHoldBars = input.int(35, title="Max Hold Time (bars)", minval=5, maxval=100)
useTrailingFromEntry = input.bool(true, title="Use Trailing from Entry")
trailFromEntryOffset = input.float(0.7, title="Trail Offset (ATR)", minval=0.3, maxval=1.5, step=0.1)

// Time-Based Trading Settings
useTimeFilter = input.bool(false, title="Enable Time Filter")
useSession1 = input.bool(true, title="Use Session 1", group="Time Sessions")
session1Start = input.session("1900-0700", title="Session 1 Time", group="Time Sessions")
useSession2 = input.bool(false, title="Use Session 2", group="Time Sessions")
session2Start = input.session("0800-1600", title="Session 2 Time", group="Time Sessions")
useSession3 = input.bool(false, title="Use Session 3", group="Time Sessions")
session3Start = input.session("1400-2200", title="Session 3 Time", group="Time Sessions")
useSession4 = input.bool(false, title="Use Session 4", group="Time Sessions")
session4Start = input.session("2200-0600", title="Session 4 Time", group="Time Sessions")

// Other TP Settings
tp1Points = input.float(50.0, title="TP1 Points", minval=10.0, maxval=500.0, step=5.0)
tp1Percent = input.int(30, title="TP1 Position % to Close", minval=10, maxval=50)
tp2Points = input.float(100.0, title="TP2 Points", minval=20.0, maxval=800.0, step=10.0)
tp2Percent = input.int(30, title="TP2 Position % to Close", minval=10, maxval=50)
tp3Points = input.float(200.0, title="TP3 Points", minval=50.0, maxval=1000.0, step=25.0)
tp3Percent = input.int(40, title="TP3 Position % to Close (Remainder)", minval=20, maxval=60)
slPoints = input.float(75.0, title="Stop Loss Points", minval=20.0, maxval=500.0, step=5.0)

tp1Multiplier = input.float(1.5, title="TP1 Multiplier (ATR)", minval=0.5, maxval=3.0, step=0.1)
tp2Multiplier = input.float(2.5, title="TP2 Multiplier (ATR)", minval=1.0, maxval=4.0, step=0.1)
tp3Multiplier = input.float(4.0, title="TP3 Multiplier (ATR)", minval=2.0, maxval=6.0, step=0.1)
tpMultiplier = input.float(3.0, title="Single TP Multiplier (ATR)", minval=1.0, maxval=5.0, step=0.1)
slMultiplier = input.float(2.0, title="Stop Loss Multiplier", minval=1.0, maxval=4.0, step=0.1)

// Momentum Exit Settings
momentumLength = input.int(14, title="Momentum Length", minval=5, maxval=30)
momentumThreshold = input.float(0.2, title="Momentum Threshold", minval=0.1, maxval=1.0, step=0.1)
rsiExitLevel = input.int(87, title="RSI Exit Level (Overbought)", minval=70, maxval=95)
rsiExitLevelShort = input.int(13, title="RSI Exit Level (Oversold)", minval=5, maxval=30)
useVolumeExit = input.bool(false, title="Exit on Volume Decline")
volumeExitThreshold = input.float(0.5, title="Volume Exit Threshold", minval=0.2, maxval=0.8, step=0.1)

// Volume Confirmation Settings
useVolumeConfirmation = input.bool(true, title="Use Volume Confirmation", group="Volume Settings")
volumeMethod = input.string("Above Average", title="Volume Confirmation Method", options=["Above Average", "Increasing Volume", "Volume Surge", "Volume + Price"], group="Volume Settings")
volumeMultiplier = input.float(1.2, title="Volume Above Average (x)", minval=1.0, maxval=3.0, step=0.1, group="Volume Settings")
volumeSurgeMultiplier = input.float(2.0, title="Volume Surge Multiplier (x)", minval=1.5, maxval=4.0, step=0.1, group="Volume Settings")
volumeLookback = input.int(20, title="Volume Average Length", minval=10, maxval=50, group="Volume Settings")
minVolumeThreshold = input.int(1000, title="Minimum Volume Threshold", minval=100, maxval=10000, group="Volume Settings")

// Other Inputs
useTrailing = input.bool(true, title="Use Trailing Stop")
trailOffset = input.float(2.0, title="Trailing Stop Offset (ATR Multiplier)", minval=1.0, maxval=4.0, step=0.1)
exitOnOpposite = input.bool(true, title="Exit All On Opposite Signal")

// Visual Settings
showRangeFilter = input.bool(true, title="Show Range Filter Lines")
showTPSLLines = input.bool(true, title="Show TP/SL Lines")
showEntrySignals = input.bool(true, title="Show Entry Arrows")
showExitSignals = input.bool(false, title="Show Exit Markers")
showBandEntryLevels = input.bool(true, title="Show Band Entry Levels")
showMomentumZones = input.bool(false, title="Show Momentum Background")
showSessionStatus = input.bool(true, title="Show Session Status")
showVolumeStatus = input.bool(false, title="Show Volume Confirmation Status")
lineTransparency = input.int(30, title="Line Transparency", minval=0, maxval=80)

// Candle Color Lock Settings
useCandleColorLock = input.bool(true, title="Lock Candle Colors to Strategy", group="Candle Colors")
candleColorMethod = input.string("Range Filter + Position", title="Candle Color Method", options=["Range Filter Only", "Position Only", "Range Filter + Position", "Entry Signals"], group="Candle Colors")
candleBullishColor = input.color(#00ff88, title="Bullish Candle Color", group="Candle Colors")
candleBearishColor = input.color(#ff4444, title="Bearish Candle Color", group="Candle Colors")
candleLongPositionColor = input.color(#00ccff, title="Long Position Candle Color", group="Candle Colors")
candleShortPositionColor = input.color(#ff8800, title="Short Position Candle Color", group="Candle Colors")
candleNeutralColor = input.color(#888888, title="Neutral/Sideways Candle Color", group="Candle Colors")

// Heikin Ashi Candle Colors
heikinAshiBullColor = input.color(#26a69a, title="Heikin Ashi Bull Color", group="Candle Type")
heikinAshiBearColor = input.color(#ef5350, title="Heikin Ashi Bear Color", group="Candle Type")

// Variable declarations
var float trendLockSmooth = na
var float trendLockDev = na
var float volumeLockSmooth = na
var float volumeLockDev = na
var int volumeLockBar = na
var float periodLockSmooth = na
var float periodLockDev = na
var int lastLockBar = na

// Range Filter Calculation (using selected candle type with sync fix)
src = c  // Use selected close price
currentSmooth = ta.sma(src, length)
currentDev = mult * ta.stdev(src, length)

// ATR calculation using selected candle type
atr_calc = useHeikinAshi ? ta.atr(atrLength) : ta.atr(atrLength)
atr = atr_calc

// Ensure values are synchronized and not na
smooth = 0.0
dev = 0.0

if lockMethod == "Dynamic"
    smooth := currentSmooth
    dev := currentDev
else if lockMethod == "Lock to Close"
    var float lockedClose = na
    var float lockedSmooth = na
    var float lockedDev = na
    var int lockTimer = na

    priceChangeThreshold = atr * 1.5
    timeLockPeriod = 20

    if na(lockedClose)
        lockedClose := c
        lockedSmooth := currentSmooth
        lockedDev := currentDev
        lockTimer := bar_index

    if math.abs(c - lockedClose) > priceChangeThreshold or (bar_index - lockTimer) > timeLockPeriod
        lockedClose := c
        lockedSmooth := currentSmooth
        lockedDev := currentDev
        lockTimer := bar_index

    smooth := lockedSmooth
    dev := lockedDev
else if lockMethod == "Lock on Trend Change"
    trendChange = ta.crossover(c, currentSmooth) or ta.crossunder(c, currentSmooth)
    if na(trendLockSmooth) or trendChange
        trendLockSmooth := currentSmooth
        trendLockDev := currentDev
    smooth := trendLockSmooth
    dev := trendLockDev
else if lockMethod == "Lock on High Volume"
    avgVolume = ta.sma(volume, 20)
    highVolume = volume > avgVolume * volumeThreshold
    if highVolume or na(volumeLockSmooth)
        volumeLockSmooth := currentSmooth
        volumeLockDev := currentDev
        volumeLockBar := bar_index
    if not na(volumeLockBar) and bar_index - volumeLockBar > 10 and volume <= avgVolume
        volumeLockSmooth := currentSmooth
        volumeLockDev := currentDev
        volumeLockBar := bar_index
    smooth := volumeLockSmooth
    dev := volumeLockDev
else
    if na(lastLockBar) or bar_index - lastLockBar >= lockPeriod
        periodLockSmooth := currentSmooth
        periodLockDev := currentDev
        lastLockBar := bar_index
    smooth := periodLockSmooth
    dev := periodLockDev

upper = smooth + dev
lower = smooth - dev
isLocked = lockMethod != "Dynamic"

// Calculate enhanced entry levels for bands
upperBandEntry = upper + (upper - lower) * bandEntryBuffer
lowerBandEntry = lower - (upper - lower) * bandEntryBuffer

// Calculate mid point pass levels
midPointUpper = smooth + (smooth * midPointBuffer / 100)
midPointLower = smooth - (smooth * midPointBuffer / 100)

// Swing-based calculations (using selected candle type)
recentSwingHigh = ta.highest(h, swingLookback * 2)
recentSwingLow = ta.lowest(l, swingLookback * 2)

swingStopLong = recentSwingLow - swingBuffer
swingStopShort = recentSwingHigh + swingBuffer

minStopDistance = atr * 0.5
swingStopLong := math.min(swingStopLong, c - minStopDistance)
swingStopShort := math.max(swingStopShort, c + minStopDistance)

riskLong = na(swingStopLong) ? atr * 2.0 : c - swingStopLong
riskShort = na(swingStopShort) ? atr * 2.0 : swingStopShort - c

tp1RRLong = c + (riskLong * 1.0)
tpFinalLong = c + (riskLong * riskRewardRatio)
tp1RRShort = c - (riskShort * 1.0)
tpFinalShort = c - (riskShort * riskRewardRatio)

tpQuickLong = c + (riskLong * quickProfitRatio)
tpQuickShort = c - (riskShort * quickProfitRatio)

minRiskPointsLong = riskLong > atr * 0.5
minRiskPointsShort = riskShort > atr * 0.5

// Momentum indicators (using selected candle type)
momentum = ta.mom(c, momentumLength)
momentumMA = ta.sma(momentum, 5)
rsiExit = ta.rsi(c, 14)

volumeMA = ta.sma(volume, volumeLookback)
volumeRatio = volumeMA > 0 ? volume / volumeMA : 1.0

// Delta Volume Calculation (using selected candle type)
var float deltaVolumeBullish = 0.0
var float deltaVolumeBearish = 0.0
var float deltaVolumeRatio = 0.5

if useDeltaVolume
    if deltaVolumeMethod == "Tick Direction"
        // Estimate buying/selling pressure based on close vs open and volume
        if c > o
            deltaVolumeBullish := volume * ((c - o) / (h - l))
            deltaVolumeBearish := volume - deltaVolumeBullish
        else if c < o
            deltaVolumeBearish := volume * ((o - c) / (h - l))
            deltaVolumeBullish := volume - deltaVolumeBearish
        else
            deltaVolumeBullish := volume * 0.5
            deltaVolumeBearish := volume * 0.5

    else if deltaVolumeMethod == "Price Action"
        // Based on price movement direction and volume
        priceChange = c - c[1]
        if priceChange > 0
            deltaVolumeBullish := volume
            deltaVolumeBearish := 0
        else if priceChange < 0
            deltaVolumeBearish := volume
            deltaVolumeBullish := 0
        else
            deltaVolumeBullish := volume * 0.5
            deltaVolumeBearish := volume * 0.5

    else // Volume Weighted
        // Weighted based on position within the bar's range
        if h != l
            closePosition = (c - l) / (h - l)
            deltaVolumeBullish := volume * closePosition
            deltaVolumeBearish := volume * (1 - closePosition)
        else
            deltaVolumeBullish := volume * 0.5
            deltaVolumeBearish := volume * 0.5

    // Calculate rolling average of delta volume
    avgDeltaBullish = ta.sma(deltaVolumeBullish, deltaVolumeLookback)
    avgDeltaBearish = ta.sma(deltaVolumeBearish, deltaVolumeLookback)
    totalDeltaVolume = avgDeltaBullish + avgDeltaBearish

    if totalDeltaVolume > 0
        deltaVolumeRatio := avgDeltaBullish / totalDeltaVolume
    else
        deltaVolumeRatio := 0.5

// Enhanced Volume confirmation logic
volumeConfirmed = true
if useVolumeConfirmation
    if volumeMethod == "Above Average"
        volumeConfirmed := volume > volumeMA * volumeMultiplier and volume > minVolumeThreshold
    else if volumeMethod == "Increasing Volume"
        volumeConfirmed := volume > volume[1] and volume > volume[2] and volume > volumeMA and volume > minVolumeThreshold
    else if volumeMethod == "Volume Surge"
        volumeConfirmed := volume > volumeMA * volumeSurgeMultiplier and volume > minVolumeThreshold
    else if volumeMethod == "Volume + Price"
        priceMovement = math.abs(c - o) / o
        volumeConfirmed := volume > volumeMA * volumeMultiplier and priceMovement > 0.001 and volume > minVolumeThreshold

// Delta volume confirmation
deltaVolumeConfirmedLong = not useDeltaVolume or deltaVolumeRatio >= deltaVolumeThreshold
deltaVolumeConfirmedShort = not useDeltaVolume or deltaVolumeRatio <= (1 - deltaVolumeThreshold)

momentumWeakening = math.abs(momentum) < math.abs(momentumMA) * momentumThreshold
rsiOverbought = rsiExit > rsiExitLevel
rsiOversold = rsiExit < rsiExitLevelShort
volumeDecline = useVolumeExit and volumeRatio < volumeExitThreshold
longMomentumExit = momentumWeakening and momentum < 0
shortMomentumExit = momentumWeakening and momentum > 0

// Time Filter Logic
inSession = true
if useTimeFilter
    inSession1 = useSession1 and not na(time(timeframe.period, session1Start))
    inSession2 = useSession2 and not na(time(timeframe.period, session2Start))
    inSession3 = useSession3 and not na(time(timeframe.period, session3Start))
    inSession4 = useSession4 and not na(time(timeframe.period, session4Start))

    anySessionEnabled = useSession1 or useSession2 or useSession3 or useSession4
    inAnyEnabledSession = inSession1 or inSession2 or inSession3 or inSession4

    inSession := anySessionEnabled ? inAnyEnabledSession : false
else
    inSession := true

// TRIPLE ENTRY SYSTEM - Middle Line Cross Conditions (using selected candle type)
middleLineLongCondition = false
middleLineShortCondition = false
if useMiddleLineCross
    volumeOkMiddleLine = not useVolumeMiddleLine or volumeConfirmed
    deltaOkMiddleLong = not useDeltaVolume or deltaVolumeConfirmedLong
    deltaOkMiddleShort = not useDeltaVolume or deltaVolumeConfirmedShort

    middleLineLongCondition := ta.crossover(c, smooth) and volumeOkMiddleLine and deltaOkMiddleLong
    middleLineShortCondition := ta.crossunder(c, smooth) and volumeOkMiddleLine and deltaOkMiddleShort

// TRIPLE ENTRY SYSTEM - Outside Bands Conditions (using selected candle type)
outsideBandsLongCondition = false
outsideBandsShortCondition = false
if useOutsideBands
    validLongDistance = (c - upper) >= (atr * bandEntryMinDistance)
    validShortDistance = (lower - c) >= (atr * bandEntryMinDistance)
    volumeOkBands = not useVolumeOutsideBands or volumeConfirmed
    deltaOkBandsLong = not useDeltaVolume or deltaVolumeConfirmedLong
    deltaOkBandsShort = not useDeltaVolume or deltaVolumeConfirmedShort

    outsideBandsLongCondition := ta.crossover(c, upperBandEntry) and validLongDistance and volumeOkBands and deltaOkBandsLong
    outsideBandsShortCondition := ta.crossunder(c, lowerBandEntry) and validShortDistance and volumeOkBands and deltaOkBandsShort

// TRIPLE ENTRY SYSTEM - Mid Point Pass Conditions (using selected candle type)
midPointPassLongCondition = false
midPointPassShortCondition = false
if useMidPointPass
    // Check if price is passing through middle line area with sufficient momentum
    priceInMidZone = c >= midPointLower and c <= midPointUpper
    sufficientMove = math.abs(c - c[1]) >= (atr * midPointMinMove)
    bullishMomentum = c > c[1] and c > o
    bearishMomentum = c < c[1] and c < o
    volumeOkMidPass = not useVolumeMidPointPass or volumeConfirmed
    deltaOkMidPassLong = not useDeltaVolume or deltaVolumeConfirmedLong
    deltaOkMidPassShort = not useDeltaVolume or deltaVolumeConfirmedShort

    midPointPassLongCondition := priceInMidZone and sufficientMove and bullishMomentum and c > smooth and volumeOkMidPass and deltaOkMidPassLong
    midPointPassShortCondition := priceInMidZone and sufficientMove and bearishMomentum and c < smooth and volumeOkMidPass and deltaOkMidPassShort

// Combined Entry Logic
longCondition = false
shortCondition = false

if allowSimultaneousEntries
    longCondition := (tradeDirection == "Long Only" or tradeDirection == "Both") and (middleLineLongCondition or outsideBandsLongCondition or midPointPassLongCondition)
    shortCondition := (tradeDirection == "Short Only" or tradeDirection == "Both") and (middleLineShortCondition or outsideBandsShortCondition or midPointPassShortCondition)
else
    // Priority: Outside Bands > Mid Point Pass > Middle Line Cross
    longCondition := (tradeDirection == "Long Only" or tradeDirection == "Both") and
                     (outsideBandsLongCondition or
                      (midPointPassLongCondition and not outsideBandsLongCondition) or
                      (middleLineLongCondition and not outsideBandsLongCondition and not midPointPassLongCondition))
    shortCondition := (tradeDirection == "Short Only" or tradeDirection == "Both") and
                      (outsideBandsShortCondition or
                       (midPointPassShortCondition and not outsideBandsShortCondition) or
                       (middleLineShortCondition and not outsideBandsShortCondition and not midPointPassShortCondition))

// Apply filters
if tpMethod == "Swing Based RR"
    longCondition := longCondition and minRiskPointsLong
    shortCondition := shortCondition and minRiskPointsShort

longCondition := longCondition and inSession
shortCondition := shortCondition and inSession

// Entry signal tracking for display
var string lastEntryType = ""
if longCondition
    if outsideBandsLongCondition
        lastEntryType := "Band Long"
    else if midPointPassLongCondition
        lastEntryType := "Mid Pass Long"
    else if middleLineLongCondition
        lastEntryType := "Middle Long"

if shortCondition
    if outsideBandsShortCondition
        lastEntryType := "Band Short"
    else if midPointPassShortCondition
        lastEntryType := "Mid Pass Short"
    else if middleLineShortCondition
        lastEntryType := "Middle Short"

// Exit calculations for other methods
takeProfitLong = strategy.position_avg_price + (atr * tpMultiplier)
stopLossLong = strategy.position_avg_price - (atr * slMultiplier)
takeProfitShort = strategy.position_avg_price - (atr * tpMultiplier)
stopLossShort = strategy.position_avg_price + (atr * slMultiplier)

tp1LongPoints = strategy.position_avg_price + tp1Points
tp2LongPoints = strategy.position_avg_price + tp2Points
tp3LongPoints = strategy.position_avg_price + tp3Points
stopLossLongPoints = strategy.position_avg_price - slPoints
tp1ShortPoints = strategy.position_avg_price - tp1Points
tp2ShortPoints = strategy.position_avg_price - tp2Points
tp3ShortPoints = strategy.position_avg_price - tp3Points
stopLossShortPoints = strategy.position_avg_price + slPoints

tp1Long = strategy.position_avg_price + (atr * tp1Multiplier)
tp2Long = strategy.position_avg_price + (atr * tp2Multiplier)
tp3Long = strategy.position_avg_price + (atr * tp3Multiplier)
tp1Short = strategy.position_avg_price - (atr * tp1Multiplier)
tp2Short = strategy.position_avg_price - (atr * tp2Multiplier)
tp3Short = strategy.position_avg_price - (atr * tp3Multiplier)

// Swing-Based RR Variables
var float swingStopLongEntry = na
var float swingStopShortEntry = na
var float tp1RRLongEntry = na
var float tpFinalLongEntry = na
var float tp1RRShortEntry = na
var float tpFinalShortEntry = na
var float tpQuickLongEntry = na
var float tpQuickShortEntry = na
var bool tp1RRHitLong = false
var bool tp1RRHitShort = false
var bool tpQuickHitLong = false
var bool tpQuickHitShort = false
var float currentStopLong = na
var float currentStopShort = na
var int entryBarLong = na
var int entryBarShort = na

// Lock swing levels on entry
if longCondition and tpMethod == "Swing Based RR"
    swingStopLongEntry := na(swingStopLong) ? c - (atr * 2.0) : swingStopLong
    tp1RRLongEntry := tp1RRLong
    tpFinalLongEntry := tpFinalLong
    tpQuickLongEntry := tpQuickLong
    tp1RRHitLong := false
    tpQuickHitLong := false
    currentStopLong := swingStopLongEntry
    entryBarLong := bar_index

if shortCondition and tpMethod == "Swing Based RR"
    swingStopShortEntry := na(swingStopShort) ? c + (atr * 2.0) : swingStopShort
    tp1RRShortEntry := tp1RRShort
    tpFinalShortEntry := tpFinalShort
    tpQuickShortEntry := tpQuickShort
    tp1RRHitShort := false
    tpQuickHitShort := false
    currentStopShort := swingStopShortEntry
    entryBarShort := bar_index

// Progressive stop management (using selected candle type)
if strategy.position_size > 0 and tpMethod == "Swing Based RR"
    if useQuickProfit and not tpQuickHitLong and h >= tpQuickLongEntry
        tpQuickHitLong := true

    if moveToBreakevenAt1to1 and not tp1RRHitLong and h >= tp1RRLongEntry
        tp1RRHitLong := true
        currentStopLong := strategy.position_avg_price + swingBuffer

    if useTimeExit and bar_index - entryBarLong >= maxHoldBars
        strategy.close("Long", comment="Time Exit")

if strategy.position_size < 0 and tpMethod == "Swing Based RR"
    if useQuickProfit and not tpQuickHitShort and l <= tpQuickShortEntry
        tpQuickHitShort := true

    if moveToBreakevenAt1to1 and not tp1RRHitShort and l <= tp1RRShortEntry
        tp1RRHitShort := true
        currentStopShort := strategy.position_avg_price - swingBuffer

    if useTimeExit and bar_index - entryBarShort >= maxHoldBars
        strategy.close("Short", comment="Time Exit")

// Momentum exit logic
var bool momentumExitLong = false
var bool momentumExitShort = false
if strategy.position_size > 0
    momentumExitLong := longMomentumExit or rsiOverbought or volumeDecline
if strategy.position_size < 0
    momentumExitShort := shortMomentumExit or rsiOversold or volumeDecline

// Strategy execution
if exitOnOpposite
    if longCondition and strategy.position_size < 0
        strategy.close("Short", comment="Close Short on Long Signal")
    if shortCondition and strategy.position_size > 0
        strategy.close("Long", comment="Close Long on Short Signal")

// Enter Long positions
if longCondition
    strategy.entry("Long", strategy.long, comment=lastEntryType)
    if tpMethod == "Fixed ATR"
        strategy.exit("Exit Long", "Long", limit=takeProfitLong, stop=stopLossLong)
    else if tpMethod == "Fixed Points"
        strategy.exit("Exit Long Points", "Long", limit=tp1LongPoints, stop=stopLossLongPoints)
    else if tpMethod == "Swing Based RR"
        if useTrailingFromEntry
            strategy.exit("Trail Long", "Long", trail_points=atr * trailFromEntryOffset, trail_offset=atr * trailFromEntryOffset)
        else if useQuickProfit and usePartialExit
            strategy.exit("Quick Long", "Long", qty_percent=quickProfitPercent, limit=tpQuickLongEntry, stop=currentStopLong)
            strategy.exit("1to1 RR Long", "Long", qty_percent=40, limit=tp1RRLongEntry, stop=currentStopLong)
            strategy.exit("Final RR Long", "Long", limit=tpFinalLongEntry, stop=currentStopLong)
        else if usePartialExit
            strategy.exit("1to1 RR Long", "Long", qty_percent=50, limit=tp1RRLongEntry, stop=currentStopLong)
            strategy.exit("Final RR Long", "Long", qty_percent=50, limit=tpFinalLongEntry, stop=currentStopLong)
        else
            strategy.exit("RR Exit Long", "Long", limit=tpFinalLongEntry, stop=swingStopLongEntry)
    else if tpMethod == "Multiple TP Points"
        strategy.exit("TP1 Long", "Long", qty_percent=tp1Percent, limit=tp1LongPoints, stop=stopLossLongPoints)
        strategy.exit("TP2 Long", "Long", qty_percent=tp2Percent, limit=tp2LongPoints, stop=stopLossLongPoints)
        strategy.exit("TP3 Long", "Long", qty_percent=tp3Percent, limit=tp3LongPoints, stop=stopLossLongPoints)
    else if tpMethod == "Multiple TP ATR"
        strategy.exit("TP1 Long ATR", "Long", qty_percent=tp1Percent, limit=tp1Long, stop=stopLossLong)
        strategy.exit("TP2 Long ATR", "Long", qty_percent=tp2Percent, limit=tp2Long, stop=stopLossLong)
        strategy.exit("TP3 Long ATR", "Long", qty_percent=tp3Percent, limit=tp3Long, stop=stopLossLong)
    else if tpMethod == "Trailing Only"
        strategy.exit("Trail Long", "Long", trail_points=atr * trailOffset, trail_offset=atr * trailOffset)
    else if tpMethod == "Momentum Based"
        strategy.exit("SL Long", "Long", stop=stopLossLongPoints)
    else if tpMethod == "Hybrid"
        strategy.exit("TP1 Hybrid Long", "Long", qty_percent=25, limit=tp1LongPoints, stop=stopLossLongPoints)
        strategy.exit("TP2 Hybrid Long", "Long", qty_percent=25, limit=tp2LongPoints, stop=stopLossLongPoints)
        strategy.exit("Trail Hybrid Long", "Long", trail_points=atr * trailOffset, trail_offset=atr * trailOffset)

// Enter Short positions
if shortCondition
    strategy.entry("Short", strategy.short, comment=lastEntryType)
    if tpMethod == "Fixed ATR"
        strategy.exit("Exit Short", "Short", limit=takeProfitShort, stop=stopLossShort)
    else if tpMethod == "Fixed Points"
        strategy.exit("Exit Short Points", "Short", limit=tp1ShortPoints, stop=stopLossShortPoints)
    else if tpMethod == "Swing Based RR"
        if useTrailingFromEntry
            strategy.exit("Trail Short", "Short", trail_points=atr * trailFromEntryOffset, trail_offset=atr * trailFromEntryOffset)
        else if useQuickProfit and usePartialExit
            strategy.exit("Quick Short", "Short", qty_percent=quickProfitPercent, limit=tpQuickShortEntry, stop=currentStopShort)
            strategy.exit("1to1 RR Short", "Short", qty_percent=40, limit=tp1RRShortEntry, stop=currentStopShort)
            strategy.exit("Final RR Short", "Short", limit=tpFinalShortEntry, stop=currentStopShort)
        else if usePartialExit
            strategy.exit("1to1 RR Short", "Short", qty_percent=50, limit=tp1RRShortEntry, stop=currentStopShort)
            strategy.exit("Final RR Short", "Short", qty_percent=50, limit=tpFinalShortEntry, stop=currentStopShort)
        else
            strategy.exit("RR Exit Short", "Short", limit=tpFinalShortEntry, stop=swingStopShortEntry)
    else if tpMethod == "Multiple TP Points"
        strategy.exit("TP1 Short", "Short", qty_percent=tp1Percent, limit=tp1ShortPoints, stop=stopLossShortPoints)
        strategy.exit("TP2 Short", "Short", qty_percent=tp2Percent, limit=tp2ShortPoints, stop=stopLossShortPoints)
        strategy.exit("TP3 Short", "Short", qty_percent=tp3Percent, limit=tp3ShortPoints, stop=stopLossShortPoints)
    else if tpMethod == "Multiple TP ATR"
        strategy.exit("TP1 Short ATR", "Short", qty_percent=tp1Percent, limit=tp1Short, stop=stopLossShort)
        strategy.exit("TP2 Short ATR", "Short", qty_percent=tp2Percent, limit=tp2Short, stop=stopLossShort)
        strategy.exit("TP3 Short ATR", "Short", qty_percent=tp3Percent, limit=tp3Short, stop=stopLossShort)
    else if tpMethod == "Trailing Only"
        strategy.exit("Trail Short", "Short", trail_points=atr * trailOffset, trail_offset=atr * trailOffset)
    else if tpMethod == "Momentum Based"
        strategy.exit("SL Short", "Short", stop=stopLossShortPoints)
    else if tpMethod == "Hybrid"
        strategy.exit("TP1 Hybrid Short", "Short", qty_percent=25, limit=tp1ShortPoints, stop=stopLossShortPoints)
        strategy.exit("TP2 Hybrid Short", "Short", qty_percent=25, limit=tp2ShortPoints, stop=stopLossShortPoints)
        strategy.exit("Trail Hybrid Short", "Short", trail_points=atr * trailOffset, trail_offset=atr * trailOffset)

// Momentum exits
if (tpMethod == "Momentum Based" or tpMethod == "Hybrid") and strategy.position_size != 0
    if strategy.position_size > 0 and momentumExitLong
        strategy.close("Long", comment="Momentum Exit")
    if strategy.position_size < 0 and momentumExitShort
        strategy.close("Short", comment="Momentum Exit")

// Heikin Ashi Candle Plotting (moved to global scope with sync fix)
heikinAshiColor = (showHeikinAshiCandles and useHeikinAshi) ? (ha_c >= ha_o ? heikinAshiBullColor : heikinAshiBearColor) : na

// Force synchronization by ensuring all values exist
plot_ha_open = (showHeikinAshiCandles and useHeikinAshi and not na(ha_o)) ? ha_o : na
plot_ha_high = (showHeikinAshiCandles and useHeikinAshi and not na(ha_h)) ? ha_h : na
plot_ha_low = (showHeikinAshiCandles and useHeikinAshi and not na(ha_l)) ? ha_l : na
plot_ha_close = (showHeikinAshiCandles and useHeikinAshi and not na(ha_c)) ? ha_c : na

plotcandle(plot_ha_open, plot_ha_high, plot_ha_low, plot_ha_close,
           title="Heikin Ashi Candles",
           color=heikinAshiColor,
           wickcolor=heikinAshiColor,
           bordercolor=heikinAshiColor)

// Plotting - Fixed scaling and positioning with proper synchronization
upperColor = isLocked ? color.new(#00ff00, lineTransparency) : color.new(#00ff00, lineTransparency + 30)
lowerColor = isLocked ? color.new(#ff0000, lineTransparency) : color.new(#ff0000, lineTransparency + 30)
smoothColor = isLocked ? color.new(#0000ff, lineTransparency) : color.new(#0000ff, lineTransparency + 30)

// Main range filter plots - ensure proper price scale binding
upperPlot = plot(showRangeFilter ? upper : na, color=upperColor, title="Upper Range", linewidth=1)
lowerPlot = plot(showRangeFilter ? lower : na, color=lowerColor, title="Lower Range", linewidth=1)
smoothPlot = plot(showRangeFilter ? smooth : na, color=smoothColor, title="Smooth Line", linewidth=2)

// Fill between upper and lower for better visualization
fill(upperPlot, lowerPlot, color=color.new(#0066cc, 95), title="Range Filter Zone")

// Band entry levels - ensure proper price scale binding
upperBandPlot = plot(showBandEntryLevels and useOutsideBands ? upperBandEntry : na, color=color.new(#ff8800, 60), style=plot.style_stepline, title="Upper Band Entry")
lowerBandPlot = plot(showBandEntryLevels and useOutsideBands ? lowerBandEntry : na, color=color.new(#ff8800, 60), style=plot.style_stepline, title="Lower Band Entry")

// Mid point pass levels - ensure proper price scale binding
showMidPointLevels = input.bool(false, title="Show Mid Point Pass Levels")
plot(showMidPointLevels and useMidPointPass ? midPointUpper : na, color=color.new(#00ccff, 70), style=plot.style_circles, title="Mid Point Upper")
plot(showMidPointLevels and useMidPointPass ? midPointLower : na, color=color.new(#00ccff, 70), style=plot.style_circles, title="Mid Point Lower")

// Long position TP/SL lines - force price scale synchronization
plot(showTPSLLines and strategy.position_size > 0 and tpMethod == "Swing Based RR" and not na(currentStopLong) ? currentStopLong : na,
     color=color.new(#ff0000, 20), style=plot.style_linebr, linewidth=2, title="Stop Loss Long")
plot(showTPSLLines and strategy.position_size > 0 and tpMethod == "Swing Based RR" and useQuickProfit and not na(tpQuickLongEntry) ? tpQuickLongEntry : na,
     color=color.new(#ffff00, 40), style=plot.style_linebr, linewidth=1, title="Quick TP Long")
plot(showTPSLLines and strategy.position_size > 0 and tpMethod == "Swing Based RR" and not na(tp1RRLongEntry) ? tp1RRLongEntry : na,
     color=color.new(#ff8800, 30), style=plot.style_linebr, linewidth=1, title="1:1 TP Long")
plot(showTPSLLines and strategy.position_size > 0 and tpMethod == "Swing Based RR" and not na(tpFinalLongEntry) ? tpFinalLongEntry : na,
     color=color.new(#00ff00, 20), style=plot.style_linebr, linewidth=2, title="Final TP Long")

// Short position TP/SL lines - force price scale synchronization
plot(showTPSLLines and strategy.position_size < 0 and tpMethod == "Swing Based RR" and not na(currentStopShort) ? currentStopShort : na,
     color=color.new(#ff0000, 20), style=plot.style_linebr, linewidth=2, title="Stop Loss Short")
plot(showTPSLLines and strategy.position_size < 0 and tpMethod == "Swing Based RR" and useQuickProfit and not na(tpQuickShortEntry) ? tpQuickShortEntry : na,
     color=color.new(#ffff00, 40), style=plot.style_linebr, linewidth=1, title="Quick TP Short")
plot(showTPSLLines and strategy.position_size < 0 and tpMethod == "Swing Based RR" and not na(tp1RRShortEntry) ? tp1RRShortEntry : na,
     color=color.new(#ff8800, 30), style=plot.style_linebr, linewidth=1, title="1:1 TP Short")
plot(showTPSLLines and strategy.position_size < 0 and tpMethod == "Swing Based RR" and not na(tpFinalShortEntry) ? tpFinalShortEntry : na,
     color=color.new(#00ff00, 20), style=plot.style_linebr, linewidth=2, title="Final TP Short")

// Enhanced Entry signals with entry type identification
plotshape(showEntrySignals and longCondition and outsideBandsLongCondition, title="Band Long Signal", location=location.belowbar, style=shape.triangleup, size=size.normal, color=#ff8800, text="BAND")
plotshape(showEntrySignals and longCondition and midPointPassLongCondition and not outsideBandsLongCondition, title="Mid Pass Long Signal", location=location.belowbar, style=shape.triangleup, size=size.small, color=#00ccff, text="MID-P")
plotshape(showEntrySignals and longCondition and middleLineLongCondition and not outsideBandsLongCondition and not midPointPassLongCondition, title="Middle Long Signal", location=location.belowbar, style=shape.triangleup, size=size.small, color=#00ff00, text="MID")
plotshape(showEntrySignals and shortCondition and outsideBandsShortCondition, title="Band Short Signal", location=location.abovebar, style=shape.triangledown, size=size.normal, color=#ff8800, text="BAND")
plotshape(showEntrySignals and shortCondition and midPointPassShortCondition and not outsideBandsShortCondition, title="Mid Pass Short Signal", location=location.abovebar, style=shape.triangledown, size=size.small, color=#00ccff, text="MID-P")
plotshape(showEntrySignals and shortCondition and middleLineShortCondition and not outsideBandsShortCondition and not midPointPassShortCondition, title="Middle Short Signal", location=location.abovebar, style=shape.triangledown, size=size.small, color=#ff0000, text="MID")

// Exit signals
plotshape(showExitSignals and momentumExitLong and strategy.position_size > 0, title="Momentum Exit Long", location=location.abovebar, style=shape.xcross, size=size.tiny, color=#ff8800)
plotshape(showExitSignals and momentumExitShort and strategy.position_size < 0, title="Momentum Exit Short", location=location.belowbar, style=shape.xcross, size=size.tiny, color=#ff8800)
plotshape(showExitSignals and tpQuickHitLong and strategy.position_size > 0, title="Quick Profit Hit Long", location=location.abovebar, style=shape.circle, size=size.tiny, color=#ffff00)
plotshape(showExitSignals and tpQuickHitShort and strategy.position_size < 0, title="Quick Profit Hit Short", location=location.belowbar, style=shape.circle, size=size.tiny, color=#ffff00)
plotshape(showExitSignals and tp1RRHitLong and strategy.position_size > 0, title="1:1 Hit Breakeven Long", location=location.abovebar, style=shape.diamond, size=size.small, color=#ff8800)
plotshape(showExitSignals and tp1RRHitShort and strategy.position_size < 0, title="1:1 Hit Breakeven Short", location=location.belowbar, style=shape.diamond, size=size.small, color=#ff8800)

// Background colors for momentum zones
longMomentumZone = showMomentumZones and c > smooth and rsiExit < 70
shortMomentumZone = showMomentumZones and c < smooth and rsiExit > 30

bgcolor(longMomentumZone ? color.new(#00ff00, 95) : na, title="Long Momentum Zone")
bgcolor(shortMomentumZone ? color.new(#ff0000, 95) : na, title="Short Momentum Zone")

// Session status background
sessionActive = useTimeFilter and inSession
bgcolor(showSessionStatus and useTimeFilter and not inSession ? color.new(#888888, 95) : na, title="Outside Trading Sessions")
bgcolor(showSessionStatus and useTimeFilter and inSession ? color.new(#0000ff, 98) : na, title="Active Trading Session")

// Volume confirmation background
bgcolor(showVolumeStatus and useVolumeConfirmation and not volumeConfirmed ? color.new(#ffff00, 98) : na, title="Low Volume - No Confirmation")
bgcolor(showVolumeStatus and useVolumeConfirmation and volumeConfirmed ? color.new(#800080, 98) : na, title="Volume Confirmed")

// Delta volume background
showDeltaVolumeStatus = input.bool(false, title="Show Delta Volume Status")
bgcolor(showDeltaVolumeStatus and useDeltaVolume and deltaVolumeRatio > deltaVolumeThreshold ? color.new(#00ff88, 95) : na, title="Bullish Delta Volume")
bgcolor(showDeltaVolumeStatus and useDeltaVolume and deltaVolumeRatio < (1 - deltaVolumeThreshold) ? color.new(#ff4444, 95) : na, title="Bearish Delta Volume")

// Enhanced info table with proper positioning
if barstate.islast
    var table infoTable = table.new(position.top_right, 3, 12, bgcolor=color.new(#000000, 80), border_width=1, frame_width=2, frame_color=#0066cc)

    // Clear table on each update to prevent artifacts
    table.clear(infoTable, 0, 0, 2, 11)

    table.cell(infoTable, 0, 0, "Entry Methods", text_color=#ffffff, bgcolor=color.new(#0066cc, 70), text_size=size.small)
    table.cell(infoTable, 1, 0, "Status", text_color=#ffffff, bgcolor=color.new(#0066cc, 70), text_size=size.small)
    table.cell(infoTable, 2, 0, "Volume", text_color=#ffffff, bgcolor=color.new(#0066cc, 70), text_size=size.small)

    table.cell(infoTable, 0, 1, "Candle Type", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 1, useHeikinAshi ? "Heikin Ashi" : "Regular", text_color=useHeikinAshi ? #00ccff : #ffffff, text_size=size.small)
    table.cell(infoTable, 2, 1, useHeikinAshi ? ("HA-" + str.tostring(heikinAshiSmoothing)) : "REG", text_color=useHeikinAshi ? #00ccff : #888888, text_size=size.small)

    table.cell(infoTable, 0, 2, "Middle Line Cross", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 2, useMiddleLineCross ? "ON" : "OFF", text_color=useMiddleLineCross ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 2, useVolumeMiddleLine ? "VOL" : "---", text_color=useVolumeMiddleLine ? #00ff88 : #888888, text_size=size.small)

    table.cell(infoTable, 0, 3, "Outside Bands", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 3, useOutsideBands ? "ON" : "OFF", text_color=useOutsideBands ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 3, useVolumeOutsideBands ? "VOL" : "---", text_color=useVolumeOutsideBands ? #00ff88 : #888888, text_size=size.small)

    table.cell(infoTable, 0, 4, "Mid Point Pass", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 4, useMidPointPass ? "ON" : "OFF", text_color=useMidPointPass ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 4, useVolumeMidPointPass ? "VOL" : "---", text_color=useVolumeMidPointPass ? #00ff88 : #888888, text_size=size.small)

    table.cell(infoTable, 0, 5, "Delta Volume", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 5, useDeltaVolume ? "ON" : "OFF", text_color=useDeltaVolume ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 5, useDeltaVolume ? str.tostring(deltaVolumeRatio, "#.##") : "---", text_color=useDeltaVolume ? (deltaVolumeRatio > 0.6 ? #00ff88 : deltaVolumeRatio < 0.4 ? #ff4444 : #ffff00) : #888888, text_size=size.small)

    table.cell(infoTable, 0, 6, "Simultaneous", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 6, allowSimultaneousEntries ? "ON" : "OFF", text_color=allowSimultaneousEntries ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 6, "Multi/Bar", text_color=#888888, text_size=size.small)

    table.cell(infoTable, 0, 7, "Volume Method", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 7, volumeConfirmed ? "✓" : "✗", text_color=volumeConfirmed ? #00ff00 : #ff0000, text_size=size.small)
    table.cell(infoTable, 2, 7, str.tostring(volumeMultiplier, "#.#") + "x", text_color=#888888, text_size=size.small)

    table.cell(infoTable, 0, 8, "Risk:Reward", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 8, str.tostring(riskRewardRatio, "#.#"), text_color=#ffff00, text_size=size.small)
    table.cell(infoTable, 2, 8, "Target", text_color=#888888, text_size=size.small)

    table.cell(infoTable, 0, 9, "Quick Profit", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 9, useQuickProfit ? "ON" : "OFF", text_color=useQuickProfit ? #ff8800 : #00ff00, text_size=size.small)
    table.cell(infoTable, 2, 9, str.tostring(quickProfitRatio, "#.#") + " RR", text_color=#888888, text_size=size.small)

    table.cell(infoTable, 0, 10, "Last Entry", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 10, lastEntryType, text_color=#00ffff, text_size=size.small)
    table.cell(infoTable, 2, 10, "Type", text_color=#888888, text_size=size.small)

    table.cell(infoTable, 0, 11, "Delta Method", text_color=#ffffff, text_size=size.small)
    table.cell(infoTable, 1, 11, useDeltaVolume ? str.format("{0}", str.split(deltaVolumeMethod, " ")[0]) : "OFF", text_color=useDeltaVolume ? #00ccff : #888888, text_size=size.small)
    table.cell(infoTable, 2, 11, useDeltaVolume ? str.tostring(deltaVolumeThreshold, "#.##") : "---", text_color=#888888, text_size=size.small)