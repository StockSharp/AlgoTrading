//@version=6
strategy("BB Breakout + Momentum Squeeze [Strategy]", overlay=false, commission_type = strategy.commission.percent , commission_value = 0.05, default_qty_type=strategy.cash, default_qty_value=1000, initial_capital=1000, currency=currency.USD)

// === INPUTS ===

initial_capital = input.float(1000, "Initial Capital", group="Money Management")
risk_per_trade = input.float(1.0, "Risk % per Trade", minval=0.1, maxval=100, step=0.1, group="Money Management")

rr_ratio = input.float(1.5, "Risk Reward Ratio", minval=0.5, step=0.1, group="Money Management")


// BB Breakout Oscillator
bb_length = input.int(14, "BB Breakout Length", group="BB Breakout")
bb_mult = input.float(1.0, "BB Breakout Mult", group="BB Breakout")
src = input(close, "Source", group="BB Breakout")
bull_css = input.color(#089981, "Bullish Color", group="BB Breakout")
bear_css = input.color(#f23645, "Bearish Color", group="BB Breakout")

threshold = input.int(50, "Middle Line Threshold", minval=0, maxval=100, group="BB Breakout")


// Squeeze Inputs
squeeze_length = input.int(20, "Squeeze Length", group="Squeeze")
BB_mult = input.float(2.0, "Bollinger Band STD Mult", group="Squeeze")
KC_mult_high = input.float(1.0, "Keltner Channel #1", group="Squeeze")
KC_mult_mid = input.float(1.5, "Keltner Channel #2", group="Squeeze")
KC_mult_low = input.float(2.0, "Keltner Channel #3", group="Squeeze")

// ATR Band SL Inputs
atrLen = input.int(30, "ATR Length", group="ATR Band SL")
atrMultiplier = input.float(1.4, "ATR Multiplier", group="ATR Band SL")

// Alerts
Detect_Sqz_Start = input.bool(true, "Alert Price Action Squeeze", group="Squeeze Alerts")
Detect_Sqz_Fire = input.bool(true, "Alert Squeeze Firing", group="Squeeze Alerts")

// === BB Breakout Calculation ===
stdev = ta.stdev(src, bb_length) * bb_mult
ema = ta.ema(src, bb_length)
upper = ema + stdev
lower = ema - stdev

bull = 0.0
bear = 0.0
bull_den = 0.0
bear_den = 0.0
for i = 0 to bb_length - 1
    bull += math.max(src[i] - upper[i], 0)
    bear += math.max(lower[i] - src[i], 0)
    bull_den += math.abs(src[i] - upper[i])
    bear_den += math.abs(lower[i] - src[i])
bull := bull / bull_den * 100
bear := bear / bear_den * 100

bull_grad = color.from_gradient(bull, 0, 100, color.new(bull_css, 100), color.new(bull_css, 50))
bear_grad = color.from_gradient(bear, 0, 100, color.new(bear_css, 100), color.new(bear_css, 50))

plot_bull = plot(bull, title="Bull Power", color=bull == 0 ? na : bull_css)
plot_bear = plot(bear, title="Bear Power", color=bear == 0 ? na : bear_css)
plot_zero = plot(0, color=na)
hline(50, 'Midline', color=color.gray)
fill(plot_bull, plot_zero, color=bull_grad)
fill(plot_bear, plot_zero, color=bear_grad)

// === MOMENTUM SQUEEZE CALCULATIONS ===
BB_basis = ta.sma(close, squeeze_length)
dev = BB_mult * ta.stdev(close, squeeze_length)
BB_upper = BB_basis + dev
BB_lower = BB_basis - dev

KC_basis = ta.sma(close, squeeze_length)
devKC = ta.sma(ta.tr, squeeze_length)
KC_upper_high = KC_basis + devKC * KC_mult_high
KC_lower_high = KC_basis - devKC * KC_mult_high
KC_upper_mid = KC_basis + devKC * KC_mult_mid
KC_lower_mid = KC_basis - devKC * KC_mult_mid
KC_upper_low = KC_basis + devKC * KC_mult_low
KC_lower_low = KC_basis - devKC * KC_mult_low

NoSqz = BB_lower < KC_lower_low or BB_upper > KC_upper_low
LowSqz = BB_lower >= KC_lower_low or BB_upper <= KC_upper_low
MidSqz = BB_lower >= KC_lower_mid or BB_upper <= KC_upper_mid
HighSqz = BB_lower >= KC_lower_high or BB_upper <= KC_upper_high

sq_color = HighSqz ? color.orange : MidSqz ? color.red : LowSqz ? color.black : color.green
squeeze_dot_green = sq_color == color.green

mom = ta.linreg(close - math.avg(math.avg(ta.highest(high, squeeze_length), ta.lowest(low, squeeze_length)), ta.sma(close, squeeze_length)), squeeze_length, 0)

iff_1 = mom > nz(mom[1]) ? color.aqua : #2962ff
iff_2 = mom < nz(mom[1]) ? color.red : color.yellow
mom_color = mom > 0 ? iff_1 : iff_2

plot(mom, title='Momentum', color=mom_color, style=plot.style_columns, linewidth=2)
plot(0, title='Squeeze Dots', color=sq_color, style=plot.style_circles, linewidth=3)

if Detect_Sqz_Start and NoSqz[1] and not NoSqz
    alert("Squeeze Started", alert.freq_once_per_bar)
else if Detect_Sqz_Fire and NoSqz and not NoSqz[1]
    alert("Squeeze Fired", alert.freq_once_per_bar)


// === ATR Band Calculations for SL ===
atr = ta.atr(atrLen)
upperBand = ta.rma(close + atr * atrMultiplier, 3)
lowerBand = ta.rma(close - atr * atrMultiplier, 3)

// === ENTRY LOGIC ===
bull_cross = ta.crossover(bull, threshold)
bear_cross = ta.crossover(bear, threshold)

can_trade = strategy.opentrades == 0

// === STATE TRACKING VARIABLES ===
var float long_entry = na
var float short_entry = na
var float long_sl = na
var float short_sl = na
var float long_tp = na
var float short_tp = na
var bool in_long = false
var bool in_short = false



// === LONG ENTRY ===
if bull_cross and squeeze_dot_green
    long_entry := close
    long_sl := lowerBand
    long_tp := long_entry + (long_entry - long_sl) * rr_ratio
    in_long := true
    in_short := false
    risk_amount = strategy.equity * (risk_per_trade / 100)
    long_qty = risk_amount / math.abs(long_entry - long_sl)
    strategy.entry("Long", strategy.long, qty=long_qty, comment="ENTER-LONG_MESSAGE")

// === SHORT ENTRY ===
if bear_cross and squeeze_dot_green
    short_entry := close
    short_sl := upperBand
    short_tp := short_entry - (short_sl - short_entry) * rr_ratio
    in_short := true
    in_long := false
    risk_amount = strategy.equity * (risk_per_trade / 100)
    short_qty = risk_amount / math.abs(short_sl - short_entry)
    strategy.entry("Short", strategy.short, qty=short_qty, comment="ENTER-SHORT_MESSAGE")

// === MOVE SL TO BREAKEVEN IF PRICE MOVES IN FAVOR ===
long_half_tp = long_entry + (long_tp - long_entry) * 0.5
short_half_tp = short_entry - (short_entry - short_tp) * 0.5

long_sl_active = in_long and close >= long_half_tp
short_sl_active = in_short and close <= short_half_tp

// === LONG EXIT LOGIC ===
if in_long
    risk_amount = strategy.equity * (risk_per_trade / 100)
    long_risk = long_entry - long_sl
    long_half_tp = long_entry + (long_risk * 0.75)
    sl_to_use = high >= long_half_tp ? long_entry : long_sl
    strategy.exit("Long Exit", from_entry="Long", stop=sl_to_use, limit=long_tp, comment="EXIT-LONG_MESSAGE")

// === SHORT EXIT LOGIC ===
if in_short
    risk_amount = strategy.equity * (risk_per_trade / 100)
    short_risk = short_sl - short_entry
    short_half_tp = short_entry - (short_risk * 0.75)
    sl_to_use = low <= short_half_tp ? short_entry : short_sl
    strategy.exit("Short Exit", from_entry="Short", stop=sl_to_use, limit=short_tp, comment="EXIT-SHORT_MESSAGE")