//@version=5
strategy("Non-Repainting Renko Emulation Strategy [PineIndicators]", overlay=true, calc_on_every_tick=false, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500, initial_capital = 10000, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, commission_value = 0.01, slippage = 2)

// Parameter: Brick-Größe (z.B. 10 Punkte)
brickSize = input.float(3.0, "Brick Size", step=0.1)

// Persistente Variablen
var float renkoPrice     = na    // Aktueller Renko-Level (Schlusswert des letzten Bricks)
var float prevRenkoPrice = na    // Vorheriger Renko-Level (für Box-Berechnung)
var int   brickDir       = 0     // 1 = Aufwärts, -1 = Abwärts
var bool  newBrick       = false // Signalisiert, dass ein neuer Brick abgeschlossen wurde
var int   brickStart     = bar_index  // Beginn des aktuellen Bricks (x-Achse)

// Berechnungen nur auf abgeschlossenen Candles
if barstate.isconfirmed
    newBrick := false
    // Initialisierung: Beim ersten Candle setzen wir den Renko-Level
    if na(renkoPrice)
        renkoPrice := close
        brickStart := bar_index
    // Berechne die Differenz zum letzten Renko-Level
    diff = close - renkoPrice
    // Prüfen, ob der Unterschied mindestens der Brick-Größe entspricht
    if math.abs(diff) >= brickSize
        // Anzahl kompletter Bricks (kann > 1 sein)
        numBricks = math.floor(math.abs(diff) / brickSize)
        prevRenkoPrice := renkoPrice
        // Aktualisieren des Renko-Levels
        renkoPrice := renkoPrice + numBricks * brickSize * math.sign(diff)
        // Brick-Richtung (konvertiere math.sign-Ergebnis in int)
        brickDir := int(math.sign(diff))
        newBrick := true

        // Bestimme die obere und untere Grenze des abgeschlossenen Bricks:
        lowLevel  = brickDir == 1 ? prevRenkoPrice : renkoPrice
        highLevel = brickDir == 1 ? renkoPrice     : prevRenkoPrice

        // Zeichne einen farbigen Kasten (Box) für den Brick:
        // Parameter: left, top, right, bottom
        box.new(brickStart, highLevel, bar_index, lowLevel,border_width = 1, border_color = brickDir == 1 ? color.green : color.red, bgcolor = brickDir == 1 ? color.new(color.green, 70) : color.new(color.red, 70))

        // Setze den Start für den nächsten Brick
        brickStart := bar_index


// Handelslogik: Einstieg/Ausstieg nur, wenn ein neuer Brick abgeschlossen wurde
if barstate.isconfirmed and newBrick
    // Bei Aufwärts-Brick: Long-Signal
    if brickDir[brickSize] < brickDir and renkoPrice[brickSize] < renkoPrice[brickSize*2] and renkoPrice < renkoPrice[brickSize] and renkoPrice[brickSize*2] < renkoPrice[brickSize*3] and strategy.position_size <= 0
        // Bestehende Short-Position schließen, falls vorhanden
        strategy.entry("Long", strategy.long)

    // Bei Abwärts-Brick: Short-Signal
    else if brickDir[brickSize] > brickDir and renkoPrice[brickSize] > renkoPrice[brickSize*2] and renkoPrice > renkoPrice[brickSize] and renkoPrice[brickSize*2] > renkoPrice[brickSize*3] and strategy.position_size >= 0
        // Bestehende Long-Position schließen, falls vorhanden
        strategy.entry("Short", strategy.short)

if barstate.isconfirmed and newBrick
    if brickDir[brickSize] < brickDir
        strategy.close("Short")

    else if brickDir[brickSize] > brickDir
        strategy.close("Long")