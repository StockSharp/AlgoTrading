// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © peacefulLizard50262

//@version=6
// @description A comprehensive library for creating real-time candles with customizable timeframes and sampling methods.
// Supports both chart-time and custom-time candles with options for candlestick and Heikin-Ashi visualization.
// Allows for tick-based or time-based sampling with moving average overlay capabilities.
library("real_time_candles")

// LIBRARY {

// enums and types {

//@enum Specifies the type of candle chart to display
//@field candlestick Traditional candlestick chart showing open, high, low, close values
//@field heikin_ashi Heikin-Ashi candlestick chart for smoother price action and trend visualization
export enum CandleType
    candlestick = "Candlestick"
    heikin_ashi = "Heikin Ashi"

//@enum Price data source options for calculations
//@field Open Opening price of the candle
//@field High Highest price of the candle
//@field Low Lowest price of the candle
//@field Close Closing price of the candle
//@field HL2 Average of high and low prices
//@field HLC3 Average of high, low, and close prices
//@field OHLC4 Average of open, high, low, and close prices
//@field HLCC4 Average of high, low, and double-weighted close prices
export enum Source
    Open = "Open"
    High = "High"
    Low = "Low"
    Close = "Close"
    HL2 = "HL2"
    HLC3 = "HLC3"
    OHLC4 = "OHLC4"
    HLCC4 = "HLCC4"

//@enum Method for sampling data points to create candles
//@field Time Creates candles based on elapsed time
//@field Ticks Creates candles based on number of price updates
export enum SampleType
    Time = "Time"
    Ticks = "Ticks"

//@type Structure representing a complete candle with price data and display properties
//@field Open Opening price of the candle
//@field High Highest price of the candle
//@field Low Lowest price of the candle
//@field Close Closing price of the candle
//@field polarity Boolean indicating if candle is bullish (true) or bearish (false)
//@field series_index Sequential index identifying the candle in the series
//@field candle_color Color to use when rendering the candle
//@field ready Boolean indicating if candle data is valid and ready for use
export type Candle
    float Open = na
    float High = na
    float Low = na
    float Close = na
    bool polarity = false
    int series_index = na
    color candle_color = na
    bool ready = true

//@type Structure for storing individual price updates
//@field price The price value at this tick
//@field time_delta Time elapsed since the previous tick in milliseconds
//@field series_index Sequential index identifying this tick
export type TickData
    float price
    float time_delta
    int series_index

//@type Structure representing a custom timeframe candle with additional time metadata
//@field Open Opening price of the candle
//@field High Highest price of the candle
//@field Low Lowest price of the candle
//@field Close Closing price of the candle
//@field polarity Boolean indicating if candle is bullish (true) or bearish (false)
//@field series_index Sequential index identifying the candle in the series
//@field open_time Timestamp marking when the candle was opened (in Unix time)
//@field time_delta Duration of the candle in milliseconds
//@field candle_color Color to use when rendering the candle
export type CandleCTF
    float Open = na
    float High = na
    float Low = na
    float Close = na
    bool polarity = false
    int series_index = na
    int open_time = na
    float time_delta = na
    color candle_color = na

type CandleDrawing
    box body
    line top_wick
    line bottom_wick
    label time_tip

type PrivateSettings
    CandleType candle_type = CandleType.candlestick
    SampleType sample_type = SampleType.Time
    bool tied_open = true
    int number_of_ticks = 10
    float number_of_seconds = 20
    int timezone = -4
    color bullish_color = #1da05f80
    color bearish_color = #d40f0f80
    bool enable_average = false
    float ema_period = 9
    color avg_color = #2196f3
    int line_size = 2
    bool check_errors = true

// enums and types }

// example helpers {

sma(series float source, series int period)=>
    var float first_value = na
    if na(first_value) and not na(source)
        first_value := source
    float sum = 0
    for i = 0 to period - 1
        sum += nz(source[i], first_value)
    sum /= period
    sum

// example helpers }

// tick data generation {

// We sample the price at ever execution using varip and update the variable. Also we keep a running series index for
// update tracking. We also take the timenow delta to keep track of the update intervals. This function returns the tick
// data type that holds this data.

// @function Captures the current price as a tick data point
// @param source Optional - Price source to sample (defaults to close)
// @param na_replace Optional - Value to use when source is na
// @returns TickData structure containing price, time since last update, and sequential index
export get_tick(series float source = close, series float na_replace = na)=>
    varip float price = na
    varip int series_index = -1

    varip int old_time = 0
    varip int new_time = na
    varip float time_delta = 0

    varip TickData tick = TickData.new()

    if barstate.isrealtime
        if na(new_time)
            old_time := timenow

        price := nz(source, na_replace)
        series_index += 1
        new_time := timenow

        time_delta := new_time - old_time
        tick := TickData.new(price, time_delta, series_index)
        old_time := new_time
    tick

// tick data generation }

// { Chart Time Candles

// These functions are for plotting using plotcandle() and other uses where you want to be locked into the chart time.

// chart time candle generation {

// heikin_ashi() is dependant on candle_array(). This takes the Candle array and generates heikin ashi candles using the
// standard formula. candle_array() depends on heikin_ashi() because it provides the initialization array that prevents
// na array access during non realtime bars. This function utilizes the change in series_index to update the Candle
// array by checking if it has incremented. For more information about how we handle candle generation, please reference
// candle_array().

heikin_ashi(series Candle[] candles, simple CandleType candle_type, simple bool sync_start = false, series color bullish_color, series color bearish_color)=>
    varip Candle[] ha_candles = array.new<Candle>(1)
    var const Candle[] init = array.from(Candle.new(ready = false))

    varip Candle candle_data = Candle.new()
    varip float Open = na
    varip float High = na
    varip float Low = na
    varip float Close = na
    varip int series_index = na

    varip float old_ha_open = na
    varip float ha_open = na
    varip float ha_high = na
    varip float ha_low = na
    varip float old_ha_close = na
    varip float ha_close = na
    varip bool polarity = false
    varip int last_idx = -1
    varip color candle_color = bullish_color

    varip bool wait_for_sync = sync_start

    if barstate.isrealtime
        if wait_for_sync
            if barstate.isnew
                wait_for_sync := false

        if not wait_for_sync
            if candle_type == CandleType.heikin_ashi
                candle_data := candles.first()
                Open := candle_data.Open
                High := candle_data.High
                Low := candle_data.Low
                Close := candle_data.Close
                series_index := candle_data.series_index

                if last_idx != series_index
                    candle_data := Candle.new(ha_open, ha_high, ha_low, ha_close, polarity, series_index)
                    last_idx := series_index

                    if series_index > 0
                        if ha_candles.size() == 10000
                            ha_candles.pop()

                        ha_candles.insert(1, candle_data)
                        old_ha_open := ha_candles.get(1).Open
                        old_ha_close := ha_candles.get(1).Close
                    else
                        old_ha_open := Open
                        old_ha_close := Close

                ha_open := math.avg(old_ha_open, old_ha_close)
                ha_close := math.avg(Open, Close, High, Low)
                ha_high := math.max(High, math.max(ha_open, ha_close))
                ha_low := math.min(Low, math.min(ha_open, ha_close))
                polarity := ha_close >= ha_open
                candle_color := polarity ? bullish_color : bearish_color

                candle_data := Candle.new(ha_open, ha_high, ha_low, ha_close, polarity, series_index, candle_color)
                ha_candles.set(0, candle_data)

                ha_candles
            else
                candles
        else
            init
    else
        init

// candle_array takes the source you are transforming, along with the type of candle you want and the candle colors you
// want and generates the Candle array. We initialize the array with size 1 for a few reasons. We keep a Candle varialbe
// that we update on every realtime update. This Candle is used as the most recent candle in the series array so that we
// can always have a real time element. We constantly set index 0 with this Candle until we get a signal to make a new
// on. Once we get this signal we insert the candle behind the 0th index. After insertion we reset the candle and
// repeat. The thing that drives the candle creation is an array of tick updates. From this array we get the min/max of
// to update the high/low the Candle object. On the update signal we set the Open variable to the first tick. We also
// keep a running series index so that you can make indicators ontop of this.

// @function Creates an array of candles based on price updates
// @param source Optional - Price source to sample (defaults to close)
// @param candle_type Optional - Type of candle chart to create (candlestick or Heikin-Ashi)
// @param sync_start Optional - Whether to synchronize with the start of a new bar
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @returns Array of Candle objects ordered with most recent at index 0
export candle_array(series float source = close, simple CandleType candle_type = CandleType.candlestick, simple bool sync_start = false, series color bullish_color = #1da05f80, series color bearish_color = #d40f0f80)=>
    if barstate.isfirst and na(candle_type)
        runtime.error("In candle_array() the argument 'candle_type' must not be na.")

    var int max_candles = switch candle_type
        CandleType.candlestick => 10000
        CandleType.heikin_ashi => 3

    TickData tick = get_tick(source)

    varip Candle candle_data = Candle.new()
    varip Candle[] candles = array.new<Candle>(1)

    varip int cumulative_series_idx = -1

    varip float Open = na
    varip float High = na
    varip float Low = na
    varip float Close = na
    varip float[] price = array.new<float>()
    varip bool polarity = false
    varip int series_index = 0
    varip color candle_color = bullish_color
    varip int last_idx = 0

    varip bool wait_for_sync = sync_start

    if barstate.isrealtime
        if wait_for_sync
            if barstate.isnew
                wait_for_sync := false

        if not wait_for_sync
            bool open_condition = na(Open)

            if open_condition
                Open := tick.price

            cumulative_series_idx += 1

            price.unshift(tick.price)
            High := price.max()
            Low := price.min()
            Close := price.first()
            polarity := Close >= Open
            candle_color := polarity ? bullish_color : bearish_color

            candle_data := Candle.new(Open, High, Low, Close, polarity, series_index, candle_color)
            candles.set(0, candle_data)

            bool clear_state = barstate.isnew and not barstate.ishistory and cumulative_series_idx > 0

            if clear_state
                if candles.size() == max_candles
                    candles.pop()

                candles.insert(1, candle_data)
                price.clear()

                Open := Close
                price.push(Open)

                series_index += 1

            last_idx := tick.series_index
    heikin_ashi(candles, candle_type, sync_start, bullish_color, bearish_color)

// chart time candle generation }

// helper functions {

// These are a set of helpful functions for simplifying the use of the candle type.


// @function Provides a single candle based on the latest price data
// @param source Optional - Price source to sample (defaults to close)
// @param candle_type Optional - Type of candle chart to create (candlestick or Heikin-Ashi)
// @param wait_for_sync Optional - Whether to wait for a new bar before starting
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @returns A single Candle object representing the current state
export candle_series(series float source = close, simple CandleType candle_type = CandleType.candlestick, simple bool wait_for_sync = false, series color bullish_color = #1da05f80, series color bearish_color = #d40f0f80)=>
    if barstate.isfirst and na(candle_type)
        runtime.error("In candle_series() the argument 'candle_type' must not be na.")

    Candle[] candles = candle_array(source, candle_type, wait_for_sync, bullish_color, bearish_color)
    Candle candle = candles.first()
    candle

// @function Provides candle data as a tuple of OHLC values
// @param source Optional - Price source to sample (defaults to close)
// @param candle_type Optional - Type of candle chart to create (candlestick or Heikin-Ashi)
// @param wait_for_sync Optional - Whether to wait for a new bar before starting
// @returns Tuple [Open, High, Low, Close] representing current candle values
export candle_tuple(series float source = close, simple CandleType candle_type = CandleType.candlestick, simple bool wait_for_sync = false)=>
    Candle candle = candle_series(source, candle_type, wait_for_sync, #000000, #000000)
    [candle.Open, candle.High, candle.Low, candle.Close]

// @function Extracts a specific price component from a Candle
// @param source Type of price data to extract (Open, High, Low, Close, or composite values)
// @param na_replace Optional - Value to use when source value is na
// @returns The requested price value from the candle
export method source(series Candle self, series Source source, series float na_replace = na)=>
    var float ret = na
    ret := switch source
        Source.Open => self.Open
        Source.High => self.High
        Source.Low => self.Low
        Source.HL2 => math.avg(self.High, self.Low)
        Source.HLC3 => math.avg(self.High, self.Low, self.Close)
        Source.OHLC4 => math.avg(self.Open, self.High, self.Low, self.Close)
        Source.HLCC4 => math.avg(self.High, self.Low, self.Close, self.Close)
        => na
    nz(ret, na_replace)

// helper functions }

// } Chart Time Candles

// { Custom Time Candles

// general helpers {

method dump(CandleDrawing[] self)=>
    while self.size() > 0
        CandleDrawing dump = self.pop()
        dump.body.delete()
        dump.top_wick.delete()
        dump.bottom_wick.delete()
        dump.time_tip.delete()

method dump(line[] self)=>
    while self.size() > 0
        self.pop().delete()

method timezone(PrivateSettings self)=>
    int zone = self.timezone
    int abs_zone = math.min(12, math.abs(zone))
    string sign = zone > 0 ? "+" : zone < 0 ? "-" : ""
    string zero = abs_zone < 10 ? "0" : ""
    string Time = abs_zone > 0 ? sign + zero + str.tostring(abs_zone) : ""
    string timezone = "UTC" + Time
    timezone

ms_to_time_string(float raw_time)=>
    string time_string = ""

    var const int ms_in_second = 1000
    var const int ms_in_minute = ms_in_second * 60
    var const int ms_in_hour = ms_in_minute * 60
    var const int ms_in_day = ms_in_hour * 24

    if raw_time < ms_in_second
        time_string += str.tostring(raw_time) + "ms"

    else
        float ms = raw_time

        int days = math.floor(ms / ms_in_day)
        ms -= days * ms_in_day

        int hours = math.floor(ms / ms_in_hour)
        ms -= hours * ms_in_hour

        int minutes = math.floor(ms / ms_in_minute)
        ms -= minutes * ms_in_minute

        int seconds = math.floor(ms / ms_in_second)
        ms -= seconds * ms_in_second

        ms /= ms_in_second
        ms := math.round(ms, 3)

        string ms_string = str.tostring(ms)
        if ms > 0
            ms_string := str.replace(ms_string, "0.", ".")
        else
            ms_string := ""

        if days > 0
            time_string += str.tostring(days) + "D "
        if hours > 0
            time_string += str.tostring(hours) + "H "
        if minutes > 0
            time_string += str.tostring(minutes) + "m "
        if (seconds + ms) > 0
            time_string += str.tostring(seconds) + ms_string + "s"
    time_string

method timeframe(PrivateSettings self)=>
    var const int ms_in_second = 1000
    var const int ms_in_minute = ms_in_second * 60
    var const int ms_in_hour = ms_in_minute * 60
    var const int ms_in_day = ms_in_hour * 24

    string timeframe = ""
    if self.sample_type == SampleType.Ticks
        timeframe := "Ticks: " + str.tostring(self.number_of_ticks)
    else
        timeframe += "Timeframe: "
        float raw_time = self.number_of_seconds

        if raw_time < ms_in_second
            timeframe += str.tostring(raw_time) + "ms"
        else
            timeframe += ms_to_time_string(raw_time)
    timeframe

method make_time_string(series CandleCTF self, series string timeframe_string, series string timezone)=>
    string time_string = "Time: '" + str.format_time(self.open_time, "yy/MM/dd '|' HH:mm:ss.SSSS", timezone)
     + "\n" + "Bar Index: " + str.tostring(self.series_index)
     + "\n" + "Time Delta: " + ms_to_time_string(self.time_delta)
     + "\n" + timeframe_string
    time_string

method error(PrivateSettings self)=>
    if barstate.isfirst
        if self.check_errors
            if na(self.candle_type)
                runtime.error("candle_type must be specified.")

            if self.sample_type == SampleType.Ticks
                if self.number_of_ticks <= 0
                    runtime.error("number_of_ticks must be greater than 0.")
            else if self.sample_type == SampleType.Time
                if self.number_of_seconds <= 0
                    runtime.error("number_of_seconds must be greater than 0.")
                else
                    self.number_of_seconds *= 1000
            else
                runtime.error("sample_type must be specified, sample_type is either wrong or na.")

            if self.enable_average
                if na(self.ema_period)
                    runtime.error("ema_period must be specified.")

                if self.ema_period <= 0
                    runtime.error("ema_period must be greater than 0.")

        if na(self.timezone)
            runtime.error("timezone must be specified.")

        if self.timezone < -12 or self.timezone > 12
            runtime.error("timezone must be between -12 and 12.")

        if na(self.line_size)
            runtime.error("line_width must be specified")

// @function Extracts a specific price component from a CandleCTF
// @param source Type of price data to extract (Open, High, Low, Close, or composite values)
// @returns The requested price value from the candle as a varip
export method source(series CandleCTF self, simple Source source)=>
    varip float ret = na
    ret := switch source
        Source.Open => self.Open
        Source.High => self.High
        Source.Low => self.Low
        Source.HL2 => math.avg(self.High, self.Low)
        Source.HLC3 => math.avg(self.High, self.Low, self.Close)
        Source.OHLC4 => math.avg(self.Open, self.High, self.Low, self.Close)
        Source.HLCC4 => math.avg(self.High, self.Low, self.Close, self.Close)
        => na
    ret

// @function Converts a specific price component from each CandleCTF to a float array
// @param source Optional - Type of price data to extract (defaults to Close)
// @returns Array of float values extracted from the candles, ordered with most recent at index 0
export method candle_ctf_to_float(series CandleCTF[] self, simple Source source = Source.Close)=>
    varip float[] float_cast = array.new<float>(1, na)

    varip int current_idx = 0
    varip int previous_idx = 0
    varip bool flag = false

    if barstate.isrealtime
        if self.size() > 0
            previous_idx := current_idx
            current_idx := self.first().series_index

            flag := current_idx != previous_idx

            if flag
                float_cast.insert(1, self.get(1).source(source))
                float_cast.set(0, self.first().source(source))
            else
                float_cast.set(0, self.first().source(source))
    float_cast

// general helpers }

// ctf candle generation {

ctf_heikin_ashi(series CandleCTF[] candles, series PrivateSettings settings)=>
    varip CandleCTF[] ha_candles = array.new<CandleCTF>(1)

    varip CandleCTF candle_data = CandleCTF.new()
    varip float Open = na
    varip float High = na
    varip float Low = na
    varip float Close = na
    varip int series_index = na
    varip int open_time = na
    varip float time_delta = na
    varip color candle_color = na

    varip float old_ha_open = na
    varip float ha_open = na
    varip float ha_high = na
    varip float ha_low = na
    varip float old_ha_close = na
    varip float ha_close = na
    varip bool polarity = false
    varip int last_idx = -1

    if barstate.isrealtime
        if settings.candle_type == CandleType.heikin_ashi
            candle_data := candles.first()
            Open := candle_data.Open
            High := candle_data.High
            Low := candle_data.Low
            Close := candle_data.Close
            series_index := candle_data.series_index
            open_time := candle_data.open_time
            time_delta := candle_data.time_delta

            if last_idx != series_index
                candle_data := CandleCTF.new(ha_open, ha_high, ha_low, ha_close, polarity, series_index, open_time, time_delta, candle_color)
                last_idx := series_index

                if series_index > 0
                    ha_candles.insert(1, candle_data)
                    old_ha_open := ha_candles.get(1).Open
                    old_ha_close := ha_candles.get(1).Close
                else
                    old_ha_open := Open
                    old_ha_close := Close

            ha_open := math.avg(old_ha_open, old_ha_close)
            ha_close := math.avg(Open, Close, High, Low)
            ha_high := math.max(High, math.max(ha_open, ha_close))
            ha_low := math.min(Low, math.min(ha_open, ha_close))
            polarity := ha_close >= ha_open
            candle_color := polarity ? settings.bullish_color : settings.bearish_color

            candle_data := CandleCTF.new(ha_open, ha_high, ha_low, ha_close, polarity, series_index, open_time, time_delta, candle_color)

            ha_candles.set(0, candle_data)
            ha_candles
        else
            candles

make_ctf_candles(series float source, series PrivateSettings settings)=>
    TickData tick = get_tick(source)

    varip CandleCTF candle_data = CandleCTF.new()
    varip CandleCTF[] candles = array.new<CandleCTF>(1)

    varip float cumulative_time_delta = 0
    varip int cumulative_series_idx = 0

    varip float Open = na
    varip float High = na
    varip float Low = na
    varip float Close = na
    varip float[] price = array.new<float>()
    varip bool polarity = false
    varip int series_index = 0
    varip int open_time = na
    varip int time_delta = na
    varip color candle_color = na

    varip int last_idx = 0

    if barstate.isrealtime
        if candles.size() > (settings.enable_average ? 166 : 240)
            candles.pop()

        bool open_state = switch settings.sample_type
            SampleType.Ticks => cumulative_series_idx == 0
            SampleType.Time => cumulative_time_delta == 0

        bool open_condition = switch settings.tied_open
            true => na(Open)
            false => open_state

        if open_condition
            Open := tick.price
            time_delta := timenow - nz(open_time, timenow)
            open_time := timenow

        cumulative_series_idx += 1
        if tick.series_index != last_idx
            cumulative_time_delta += tick.time_delta

        price.unshift(tick.price)
        High := price.max()
        Low := price.min()
        Close := price.first()
        polarity := Close >= Open
        candle_color := polarity ? settings.bullish_color : settings.bearish_color

        candle_data := CandleCTF.new(Open, High, Low, Close, polarity, series_index, open_time, time_delta, candle_color)
        candles.set(0, candle_data)

        bool clear_state = switch settings.sample_type
            SampleType.Ticks => cumulative_series_idx >= settings.number_of_ticks
            SampleType.Time => cumulative_time_delta >= settings.number_of_seconds

        if clear_state
            candles.insert(1, candle_data)
            price.clear()

            if settings.tied_open
                Open := Close
                time_delta := timenow - nz(open_time, timenow)
                open_time := timenow
                price.push(Open)

            series_index += 1
            cumulative_series_idx := 0
            cumulative_time_delta := 0

        last_idx := tick.series_index
    ctf_heikin_ashi(candles, settings)

// ctf candle generation }

// ctf ema generation {

ctf_ema(CandleCTF[] src, PrivateSettings settings)=>
    varip float[] ema_retern = array.new<float>(1, na)

    varip float ema = na
    varip float ema_previous = na
    varip float ema_update = na

    varip int current_idx = 0
    varip int previous_idx = 0
    varip bool flag = false

    var float alpha = 2.0 / (1.0 + settings.ema_period)
    var float i_alpha = 1 - alpha

    if barstate.isrealtime
        if src.size() >= 0
            previous_idx := current_idx
            current_idx := src.first().series_index

            flag := current_idx != previous_idx

            if flag
                ema_previous := ema
                ema := src.first().Close * alpha + nz(ema_previous, src.first().Close) * i_alpha
                ema_retern.insert(1, ema)

                if ema_retern.size() > src.size() + 1
                    ema_retern.pop()

                ema_retern.set(0, ema)
                ema_retern

            else
                ema_update := src.first().Close * alpha + nz(ema_previous, src.first().Close) * i_alpha
                ema_retern.set(0, ema_update)
                ema_retern
    ema_retern

// @function Calculates an Exponential Moving Average for a CandleCTF array
// @param ema_period Period for the EMA calculation
// @returns Array of float values representing the EMA of the candle data, ordered with most recent at index 0
export method ctf_ema(CandleCTF[] self, simple float ema_period)=>
    var PrivateSettings config = PrivateSettings.new(ema_period = ema_period, check_errors = false)
    ctf_ema(self, config)

// ctf ema generation }

// ctf drawing {

method draw_ctf_candles_time(series CandleDrawing[] self, series CandleCTF[] candles, series PrivateSettings settings)=>
    var string timeframe_string = settings.timeframe()
    var string timezone = settings.timezone()
    var int time_offset = timeframe.in_seconds(timeframe.period) * 1000
    self.dump()

    if barstate.isrealtime
        if candles.size() > 0
            for i = candles.size() - 1 to 0
                int j = i * 2

                int center_time = time - j * time_offset
                int left_time = center_time - time_offset
                int right_time = center_time + time_offset

                CandleCTF candle_data = candles.get(i)

                color candle_color = candle_data.candle_color
                float body_top = candle_data.polarity ? candle_data.Close : candle_data.Open
                float body_bottom = candle_data.polarity ? candle_data.Open : candle_data.Close

                string time_string = candle_data.make_time_string(timeframe_string, timezone)

                self.unshift(CandleDrawing.new(
                     box.new(
                           left = left_time
                         , top = candle_data.Open
                         , right = right_time
                         , bottom = candle_data.Close
                         , border_color = candle_color
                         , bgcolor = candle_color
                         , xloc = xloc.bar_time
                         )

                     , line.new(
                           x1 = center_time
                         , y1 = candle_data.High
                         , x2 = center_time
                         , y2 = body_top
                         , color = candle_color
                         , xloc = xloc.bar_time
                         )

                     , line.new(
                           x1 = center_time
                         , y1 = body_bottom
                         , x2 = center_time
                         , y2 = candle_data.Low
                         , color = candle_color
                         , xloc = xloc.bar_time
                         )

                     , label.new(
                           x = center_time
                         , y = math.avg(candle_data.Open, candle_data.Close)
                         , text = " \n "
                         , xloc = xloc.bar_time
                         , color = #00000000
                         , style = label.style_label_center
                         , textcolor = #00000000
                         , tooltip = time_string
                         )
                     )
                 )

method draw_ctf_candles_index(series CandleDrawing[] self, series CandleCTF[] candles, series PrivateSettings settings)=>
    var string timeframe_string = settings.timeframe()
    var string timezone = settings.timezone()

    self.dump()

    if barstate.isrealtime
        if candles.size() > 0
            for i = candles.size() - 1 to 0
                int j = i * 2

                int center_index = bar_index - j
                int left_index = center_index - 1
                int right_index = center_index + 1

                CandleCTF candle_data = candles.get(i)

                color candle_color = candle_data.candle_color
                float body_top = candle_data.polarity ? candle_data.Close : candle_data.Open
                float body_bottom = candle_data.polarity ? candle_data.Open : candle_data.Close

                string time_string = candle_data.make_time_string(timeframe_string, timezone)

                self.unshift(CandleDrawing.new(
                     box.new(
                           left = left_index
                         , top = candle_data.Open
                         , right = right_index
                         , bottom = candle_data.Close
                         , border_color = candle_color
                         , bgcolor = candle_color
                         , xloc = xloc.bar_index
                         )

                     , line.new(
                           x1 = center_index
                         , y1 = candle_data.High
                         , x2 = center_index
                         , y2 = body_top
                         , color = candle_color
                         , xloc = xloc.bar_index
                         )

                     , line.new(
                           x1 = center_index
                         , y1 = body_bottom
                         , x2 = center_index
                         , y2 = candle_data.Low
                         , color = candle_color
                         , xloc = xloc.bar_index
                         )

                     , label.new(
                           x = center_index
                         , y = math.avg(candle_data.Open, candle_data.Close)
                         , text = " \n "
                         , xloc = xloc.bar_index
                         , color = #00000000
                         , style = label.style_label_center
                         , textcolor = #00000000
                         , tooltip = time_string
                         )
                     )
                 )

method draw_ctf_line_time(series line[] self, series float[] filter, series PrivateSettings settings)=>
    self.dump()
    var int time_offset = timeframe.in_seconds(timeframe.period) * 1000

    if barstate.isrealtime
        if settings.enable_average and filter.size() > 1
            for i = filter.size() - 1 to 1
                int j = i * 2 - 1

                int center_time = time - j * time_offset
                int left_time = center_time - time_offset
                int right_time = center_time + time_offset

                self.unshift(line.new(
                       left_time
                     , filter.get(i)
                     , right_time
                     , filter.get(i - 1)
                     , color = settings.avg_color
                     , width = settings.line_size
                     , xloc = xloc.bar_time
                     )
                 )

method draw_ctf_line_index(series line[] self, series float[] filter, series PrivateSettings settings)=>
    self.dump()

    if barstate.isrealtime
        if settings.enable_average and filter.size() > 1
            for i = filter.size() - 1 to 1
                int j = i * 2

                int left_index = bar_index - j
                int right_index = left_index + 2

                self.unshift(line.new(
                       left_index
                     , filter.get(i)
                     , right_index
                     , filter.get(i - 1)
                     , color = settings.avg_color
                     , width = settings.line_size
                     , xloc = xloc.bar_index
                     )
                 )

// ctf drawing }

// ctf drawing public {

// @function Renders custom timeframe candles using bar time coordinates
// @param sample_type Optional - Method for sampling data (Time or Ticks), used for tooltips
// @param number_of_ticks Optional - Number of ticks per candle (used when sample_type is Ticks), used for tooltips
// @param number_of_seconds Optional - Time duration per candle in seconds (used when sample_type is Time), used for tooltips
// @param timezone Optional - Timezone offset from UTC (-12 to +12), used for tooltips
// @returns void - Renders candles on the chart using time-based x-coordinates
export method draw_ctf_candles_time(
   series CandleCTF[] self
 , simple SampleType sample_type = SampleType.Time
 , simple int number_of_ticks = 10
 , simple float number_of_seconds = 20
 , simple int timezone = -4
 )=>
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var PrivateSettings config = PrivateSettings.new(
           sample_type = sample_type
         , number_of_ticks = number_of_ticks
         , number_of_seconds = number_of_seconds
         , timezone = timezone
         )
    candle_plot.draw_ctf_candles_time(self, config)

// @function Renders custom timeframe candles using bar index coordinates
// @param sample_type Optional - Method for sampling data (Time or Ticks), used for tooltips
// @param number_of_ticks Optional - Number of ticks per candle (used when sample_type is Ticks), used for tooltips
// @param number_of_seconds Optional - Time duration per candle in seconds (used when sample_type is Time), used for tooltips
// @param timezone Optional - Timezone offset from UTC (-12 to +12), used for tooltips
// @returns void - Renders candles on the chart using index-based x-coordinates
export method draw_ctf_candles_index(
   series CandleCTF[] self
 , simple SampleType sample_type = SampleType.Time
 , simple int number_of_ticks = 10
 , simple float number_of_seconds = 20
 , simple int timezone = -4
 )=>
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var PrivateSettings config = PrivateSettings.new(
           sample_type = sample_type
         , number_of_ticks = number_of_ticks
         , number_of_seconds = number_of_seconds
         , timezone = timezone
         )
    candle_plot.draw_ctf_candles_index(self, config)

// @function Renders a line representing a price component from the candles using time coordinates
// @param source Optional - Type of price data to extract (defaults to Close)
// @param line_size Optional - Width of the line
// @param line_color Optional - Color of the line
// @returns void - Renders a connected line on the chart using time-based x-coordinates
export method draw_ctf_line_time(
   series CandleCTF[] self
 , simple Source source = Source.Close
 , simple int line_size = 2
 , simple color line_color = #2196f3
 )=>
    float[] line_data = self.candle_ctf_to_float(source)
    var PrivateSettings config = PrivateSettings.new(
           check_errors = false
         , enable_average = true
         , avg_color = line_color
         , line_size = line_size
         )
    var line[] line_drawing = array.new<line>()
    line_drawing.draw_ctf_line_time(line_data, config)

// @function Renders a line representing a price component from the candles using index coordinates
// @param source Optional - Type of price data to extract (defaults to Close)
// @param line_size Optional - Width of the line
// @param line_color Optional - Color of the line
// @returns void - Renders a connected line on the chart using index-based x-coordinates
export method draw_ctf_line_index(
   series CandleCTF[] self
 , simple Source source = Source.Close
 , simple int line_size = 2
 , simple color line_color = #2196f3
 )=>
    float[] line_data = self.candle_ctf_to_float(source)
    var PrivateSettings config = PrivateSettings.new(
           check_errors = false
         , enable_average = true
         , avg_color = line_color
         , line_size = line_size
         )
    var line[] line_drawing = array.new<line>()
    line_drawing.draw_ctf_line_index(line_data, config)

// @function Renders a line from a varip float array using time coordinates
// @param line_size Optional - Width of the line, defaults to 2
// @param line_color Optional - Color of the line
// @returns void - Renders a connected line on the chart using time-based x-coordinates
export method draw_ctf_line_time(
   series float[] self
 , simple int line_size = 2
 , simple color line_color = #2196f3
 )=>
    var PrivateSettings config = PrivateSettings.new(
           check_errors = false
         , enable_average = true
         , avg_color = line_color
         , line_size = line_size
         )
    var line[] line_drawing = array.new<line>()
    line_drawing.draw_ctf_line_time(self, config)

// @function Renders a line from a varip float array using index coordinates
// @param line_size Optional - Width of the line, defaults to 2
// @param line_color Optional - Color of the line
// @returns void - Renders a connected line on the chart using index-based x-coordinates
export method draw_ctf_line_index(
   series float[] self
 , simple int line_size = 2
 , simple color line_color = #2196f3
 )=>
    var PrivateSettings config = PrivateSettings.new(
           check_errors = false
         , enable_average = true
         , avg_color = line_color
         , line_size = line_size
         )
    var line[] line_drawing = array.new<line>()
    line_drawing.draw_ctf_line_index(self, config)

// ctf drawing public }

// Custom Time Candles Public {

// @function Plots tick-based candles with moving average
// @param source Input price source to sample
// @param candle_type Type of candle chart to display
// @param number_of_ticks Number of ticks per candle
// @param timezone Timezone offset from UTC (-12 to +12)
// @param tied_open Whether to tie open price to close of previous candle
// @param ema_period Period for the exponential moving average
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @param line_width Optional - Width of the moving average line, defaults to 2
// @param ema_color Optional - Color of the moving average line
// @param use_time_indexing Optional - When true the function will plot with xloc.time, when false it will plot using xloc.bar_index
// @returns void - Creates visual candle chart with EMA overlay
export plot_ctf_tick_candles(
   series float source
 , simple CandleType candle_type
 , simple int number_of_ticks
 , simple int timezone
 , simple bool tied_open
 , simple float ema_period
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 , simple int line_width = 2
 , series color ema_color = #2196f3
 , simple bool use_time_indexing = false
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , SampleType.Ticks
         , tied_open
         , number_of_ticks
         , na
         , timezone
         , bullish_color
         , bearish_color
         , true
         , ema_period
         , ema_color
         , line_width)

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var line[] filter_plot = array.new<line>()

    CandleCTF[] candles = make_ctf_candles(source, settings)
    float[] ema = ctf_ema(candles, settings)

    if use_time_indexing
        candle_plot.draw_ctf_candles_time(candles, settings)
        filter_plot.draw_ctf_line_time(ema, settings)
    else
        candle_plot.draw_ctf_candles_index(candles, settings)
        filter_plot.draw_ctf_line_index(ema, settings)

// @function Plots time-based candles with moving average
// @param source Input price source to sample
// @param candle_type Type of candle chart to display
// @param number_of_seconds Time duration per candle in seconds
// @param timezone Timezone offset from UTC (-12 to +12)
// @param tied_open Whether to tie open price to close of previous candle
// @param ema_period Period for the exponential moving average
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @param line_width Optional - Width of the moving average line, defaults to 2
// @param ema_color Optional - Color of the moving average line
// @param use_time_indexing Optional - When true the function will plot with xloc.time, when false it will plot using xloc.bar_index
// @returns void - Creates visual candle chart with EMA overlay
export plot_ctf_time_candles(
   series float source
 , simple CandleType candle_type
 , simple float number_of_seconds
 , simple int timezone
 , simple bool tied_open
 , simple float ema_period
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 , simple int line_width = 2
 , series color ema_color = #2196f3
 , simple bool use_time_indexing = false
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , SampleType.Time
         , tied_open
         , na
         , number_of_seconds
         , timezone
         , bullish_color
         , bearish_color
         , true
         , ema_period
         , ema_color
         , line_width)

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var line[] filter_plot = array.new<line>()

    CandleCTF[] candles = make_ctf_candles(source, settings)
    float[] ema = ctf_ema(candles, settings)

    if use_time_indexing
        candle_plot.draw_ctf_candles_time(candles, settings)
        filter_plot.draw_ctf_line_time(ema, settings)
    else
        candle_plot.draw_ctf_candles_index(candles, settings)
        filter_plot.draw_ctf_line_index(ema, settings)

// @function Plots tick-based candles without moving average
// @param source Input price source to sample
// @param candle_type Type of candle chart to display
// @param number_of_ticks Number of ticks per candle
// @param timezone Timezone offset from UTC (-12 to +12)
// @param tied_open Whether to tie open price to close of previous candle
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @param use_time_indexing Optional - When true the function will plot with xloc.time, when false it will plot using xloc.bar_index
// @returns void - Creates visual candle chart without moving average
export plot_ctf_tick_candles(
   series float source
 , simple CandleType candle_type
 , simple int number_of_ticks
 , simple int timezone
 , simple bool tied_open
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 , simple bool use_time_indexing = false
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , SampleType.Ticks
         , tied_open
         , number_of_ticks
         , na
         , timezone
         , bullish_color
         , bearish_color
         , false
         )

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    CandleCTF[] candles = make_ctf_candles(source, settings)

    if use_time_indexing
        candle_plot.draw_ctf_candles_time(candles, settings)
    else
        candle_plot.draw_ctf_candles_index(candles, settings)

// @function Plots time-based candles without moving average
// @param source Input price source to sample
// @param candle_type Type of candle chart to display
// @param number_of_seconds Time duration per candle in seconds
// @param timezone Timezone offset from UTC (-12 to +12)
// @param tied_open Whether to tie open price to close of previous candle
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @param use_time_indexing Optional - When true the function will plot with xloc.time, when false it will plot using xloc.bar_index
// @returns void - Creates visual candle chart without moving average
export plot_ctf_time_candles(
   series float source
 , simple CandleType candle_type
 , simple float number_of_seconds
 , simple int timezone
 , simple bool tied_open
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 , simple bool use_time_indexing = false
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , SampleType.Time
         , tied_open
         , na
         , number_of_seconds
         , timezone
         , bullish_color
         , bearish_color
         , false
         )

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    CandleCTF[] candles = make_ctf_candles(source, settings)

    if use_time_indexing
        candle_plot.draw_ctf_candles_time(candles, settings)
    else
        candle_plot.draw_ctf_candles_index(candles, settings)

// @function Unified function for plotting candles with comprehensive options
// @param source Input price source to sample
// @param candle_type Optional - Type of candle chart to display
// @param sample_type Optional - Method for sampling data (Time or Ticks)
// @param number_of_ticks Optional - Number of ticks per candle (used when sample_type is Ticks)
// @param number_of_seconds Optional - Time duration per candle in seconds (used when sample_type is Time)
// @param timezone Optional - Timezone offset from UTC (-12 to +12)
// @param tied_open Optional - Whether to tie open price to close of previous candle
// @param ema_period Optional - Period for the exponential moving average
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @param enable_ema Optional - Whether to display the EMA overlay
// @param line_width Optional - Width of the moving average line, defaults to 2
// @param ema_color Optional - Color of the moving average line
// @param use_time_indexing Optional - When true the function will plot with xloc.time, when false it will plot using xloc.bar_index
// @returns void - Creates visual candle chart with optional EMA overlay
export plot_ctf_candles(
   series float source
 , simple CandleType candle_type = CandleType.candlestick
 , simple SampleType sample_type = SampleType.Time
 , simple int number_of_ticks = 10
 , simple float number_of_seconds = 20
 , simple int timezone = -4
 , simple bool tied_open = true
 , simple float ema_period = 9
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 , series bool enable_ema = true
 , simple int line_width = 2
 , series color ema_color = #2196f3
 , simple bool use_time_indexing = false
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , sample_type
         , tied_open
         , number_of_ticks
         , number_of_seconds
         , timezone
         , bullish_color
         , bearish_color
         , enable_ema
         , ema_period
         , ema_color
         , line_width)

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var line[] filter_plot = array.new<line>()

    CandleCTF[] candles = make_ctf_candles(source, settings)
    float[] ema = ctf_ema(candles, settings)

    if use_time_indexing
        candle_plot.draw_ctf_candles_time(candles, settings)
        filter_plot.draw_ctf_line_time(ema, settings)
    else
        candle_plot.draw_ctf_candles_index(candles, settings)
        filter_plot.draw_ctf_line_index(ema, settings)

// @function Creates an array of custom timeframe candles without rendering them
// @param source Input price source to sample
// @param candle_type Type of candle chart to create (candlestick or Heikin-Ashi)
// @param sample_type Method for sampling data (Time or Ticks)
// @param number_of_ticks Optional - Number of ticks per candle (used when sample_type is Ticks)
// @param number_of_seconds Optional - Time duration per candle in seconds (used when sample_type is Time)
// @param tied_open Optional - Whether to tie open price to close of previous candle
// @param bullish_color Optional - Color for bullish candles
// @param bearish_color Optional - Color for bearish candles
// @returns Array of CandleCTF objects ordered with most recent at index 0
export ctf_candles_array(
   series float source
 , simple CandleType candle_type
 , simple SampleType sample_type
 , simple int number_of_ticks = 10
 , simple float number_of_seconds = 20
 , simple bool tied_open = true
 , series color bullish_color = #1da05f80
 , series color bearish_color = #d40f0f80
 )=>
    var PrivateSettings settings = PrivateSettings.new(
           candle_type
         , sample_type
         , tied_open
         , number_of_ticks
         , number_of_seconds
         , 0
         , bullish_color
         , bearish_color
         , false
         , na
         )

    settings.error()
    var CandleDrawing[] candle_plot = array.new<CandleDrawing>()
    var line[] filter_plot = array.new<line>()

    CandleCTF[] candles = make_ctf_candles(source, settings)
    candles

// Custom Time Candles Public }

// } Custom Time Candles

// LIBRARY }


// CHART TIME EXAMPLE {

// inputs {

// { candle settings

const string candle_group = "Candle Settings"
var Source plot_source = input.enum(Source.HLC3, "Plot Source", group = candle_group)
var CandleType candle_type = input.enum(CandleType.candlestick, "Chart Type", group = candle_group)
color bullish_color = input.color(#1da05f80, "Bullish", group = candle_group)
color bearish_color = input.color(#d40f0f80, "Bearish", group = candle_group)

// } candle settings

// inputs }

// calculations {

// { main

float rsi = ta.rsi(close, 14)
Candle candle = candle_series(rsi, candle_type, false, bullish_color, bearish_color)
float rsi_close = candle.source(plot_source, rsi)
float avg = sma(rsi_close, 14)

// } main

// calculations }

// plot {

plot(rsi_close, "Indicator", #2962FF)
plot(avg, "Average", #FF6D00)
plotcandle(candle.Open, candle.High, candle.Low, candle.Close, "Candles", candle.candle_color, candle.candle_color, bordercolor = candle.candle_color)

hline(50, "Middle Band", #787b8680)

h2 = hline(70, "Upper Band", #787B86)
h3 = hline(30, "Lower Band", #787B86)
fill(h2, h3, #2196f31a, "Background")

// plot }

// CHART TIME EXAMPLE }

// CTF EXAMPLE {

plot_ctf_candles(rsi + 100, CandleType.heikin_ashi, SampleType.Time, na, 3, -4, true, 9)
hline(150, "Middle Band", #787b8680)

ch2 = hline(170, "Upper Band", #787B86)
ch3 = hline(130, "Lower Band", #787B86)
fill(ch2, ch3, #2196f31a, "Background")

// CTF EXAMPLE }