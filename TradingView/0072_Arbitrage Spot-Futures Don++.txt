// © DonKabu

//@version=6
strategy("Arbitrage Spot-Futures Don++", overlay=false,
     initial_capital=100000, default_qty_type=strategy.percent_of_equity,
     default_qty_value=10, commission_type=strategy.commission.percent,
     commission_value=0.015)

// === 1. PARAMÈTRES CONFIGURABLES ===
symbolSpot = input.string("BINANCE:BTCUSDT", "Paire Spot",
     tooltip="Format: EXCHANGE:SYMBOLE (ex: BINANCE:BTCUSDT)")
symbolFuture = input.string("BINANCE:BTCUSDT.P", "Paire Futures",
     tooltip="Format: EXCHANGE:SYMBOLE.P")

minSpreadPct = input.float(0.05, "Spread minimum (%)", minval=0.03, maxval=0.2, step=0.01) // Spread minimal pour entrer
lengthLookback = input.int(5, "Période analyse", minval=3, maxval=10) // Période pour les calculs dynamiques
useVolFilter = input.bool(false, "Filtre ATR") // Activation du filtre ATR
maxHoldHours = input.int(6, "Durée max (heures)", minval=1) // Durée maximale d'une position
adaptiveThreshold = input.bool(true, "Seuil adaptatif") // Activation des seuils dynamiques

// === 2. FONCTIONS UTILITAIRES ===
pine_max(a, b) => a >= b ? a : b
pine_min(a, b) => a <= b ? a : b

// === 3. RÉCUPÉRATION ET VÉRIFICATION DES DONNÉES ===
[spot, spotVol] = request.security(symbolSpot, timeframe.period, [close, volume], lookahead=barmerge.lookahead_on)
[future, futVol] = request.security(symbolFuture, timeframe.period, [close, volume], lookahead=barmerge.lookahead_on)

validData = not na(spot) and not na(future) and spot > 0 and future > 0
if not validData
    runtime.error("Données manquantes/invalides. Vérifiez: " + symbolSpot + " / " + symbolFuture)

// Debug des données
if barstate.islast
    debugLabel = label.new(bar_index, high,
         "Spot: " + str.tostring(spot) +
         "\nFuture: " + str.tostring(future) +
         "\nVolume Spot: " + str.tostring(spotVol) +
         "\nVolume Fut: " + str.tostring(futVol),
         color=color.blue, style=label.style_label_down)

// === 4. CALCULS DES SEUILS ===
spread = validData ? (future - spot) / spot : na
atr = ta.atr(14) / spot * 100

// Seuils dynamiques
avgSpread = validData ? ta.sma(spread, lengthLookback) : na
stdDev = validData ? ta.stdev(spread, lengthLookback) : na
dynamicLong = avgSpread + stdDev * 1.5
dynamicShort = avgSpread - stdDev * 1.5

entryLong = adaptiveThreshold and not na(dynamicLong) ? pine_max(minSpreadPct / 100, dynamicLong) : minSpreadPct / 100
entryShort = adaptiveThreshold and not na(dynamicShort) ? pine_min(-minSpreadPct / 100, dynamicShort) : -minSpreadPct / 100
exitThreshold = 0.6 // 60% du spread d'entrée

// === 5. GESTION DE POSITION ===
positionSize() =>
    strategy.equity * 0.3 / spot // 30% du capital

// === 6. CONDITIONS D'ENTRÉE ===
timeOK = strategy.opentrades == 0 or (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) > maxHoldHours * 3600000
canEnterLong = validData and spread >= entryLong and timeOK
canEnterShort = validData and spread <= entryShort and timeOK

// Fonction pour entrer dans une position
enterTrade(direction, qty) =>
    if direction == "LONG"
        strategy.entry("LongSpot", strategy.long, qty=qty)
        strategy.entry("ShortFut", strategy.short, qty=qty)
    else
        strategy.entry("ShortSpot", strategy.short, qty=qty)
        strategy.entry("LongFut", strategy.long, qty=qty)
    alert(direction + " @ Spread=" + str.tostring(spread * 100, "#.##") + "%")

if canEnterLong
    enterTrade("LONG", positionSize())

if canEnterShort
    enterTrade("SHORT", positionSize())

// === 7. CONDITIONS DE SORTIE ===
if strategy.position_size != 0
    currentSpread = spread
    isLong = strategy.position_avg_price > 0

    shouldExit = isLong ? currentSpread < entryLong * exitThreshold : currentSpread > entryShort * exitThreshold
    timeExpired = (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) >= maxHoldHours * 3600000

    if shouldExit or timeExpired
        strategy.close_all()
        alert("EXIT @ Spread=" + str.tostring(spread * 100, "#.##") + "%")

// === 8. VISUALISATION ===
plot(spot, "Spot Price", color=color.blue, linewidth=2)
plot(future, "Future Price", color=color.yellow, linewidth=2)
plot(spread * 100, "Spread (%)", style=plot.style_area, color=spread > 0 ? color.green : color.red)

plot(entryLong * 100, "Seuil Long", color=color.green, style=plot.style_circles)
plot(entryShort * 100, "Seuil Short", color=color.red, style=plot.style_circles)
hline(0, "Ligne Zéro", color=color.gray)

// Lignes horizontales fixes
fixedEntryThreshold = minSpreadPct
fixedExitThreshold = fixedEntryThreshold * 0.6

hline(fixedEntryThreshold, "Seuil Long Fixe", color=color.green, linestyle=hline.style_dotted)
hline(-fixedEntryThreshold, "Seuil Short Fixe", color=color.red, linestyle=hline.style_dotted)
hline(fixedExitThreshold, "Sortie Long Fixe", color=color.green, linestyle=hline.style_dashed)
hline(-fixedExitThreshold, "Sortie Short Fixe", color=color.red, linestyle=hline.style_dashed)

// (c) KabuSoft2@gmail.com
// Cette stratégie d'arbitrage Spot-Futures est un outil puissant pour exploiter les écarts de prix entre les marchés.
// Bien qu'elle soit déjà fonctionnelle, elle peut encore être améliorée pour répondre à des scénarios de trading plus complexes.
// N'hésitez pas à tester, modifier et partager vos idées pour rendre cette stratégie encore plus performante !