//@version=6
strategy("Grease Trap V1.0", shorttitle="Grease Trap Fibonacci", overlay=true, initial_capital=100000, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// User inputs for the number of Fibonacci sequence elements and profit targets in percentage
fibSequenceLength1   = input.int(9,  title="Number of Fibonacci Sequence Elements for Indicator", minval=1)
fibSequenceLength2   = input.int(14, title="Number of Fibonacci Sequence Elements for Base Indicator", minval=1)
longProfitTargetPct  = input.float(2.0,  "Long Profit Target (%)",  step=0.1) / 100.0
shortProfitTargetPct = input.float(2.0,  "Short Profit Target (%)", step=0.1) / 100.0

// Function to calculate Fibonacci sequence dynamically
fibSequence(dataLength, sequenceLength) =>
    sequence = array.new_int()
    array.push(sequence, 1)
    array.push(sequence, 1)
    for i = 2 to dataLength by 1
        nextVal = array.get(sequence, i - 1) + array.get(sequence, i - 2)
        if array.size(sequence) >= sequenceLength
            break
        array.push(sequence, nextVal)
    sequence

// Function to calculate the final average dynamically
fibGroupedAverage(src, dataLength, sequenceLength) =>
    sequence    = fibSequence(dataLength, sequenceLength)
    totalSum    = 0.0
    totalCount  = 0
    index       = 0
    for i = 0 to array.size(sequence) - 1
        fibLen = array.get(sequence, i)
        sum    = 0.0
        count  = 0
        for j = 0 to fibLen - 1
            if index < dataLength
                sum    := sum + nz(src[index])
                index  := index + 1
                count  := count + 1
        if count > 0
            groupAverage = sum / count
            totalSum    := totalSum + groupAverage
            totalCount  := totalCount + 1
    finalAverage = totalSum / totalCount
    finalAverage

// Calculating final averages dynamically
dataLength         = math.max(200, bar_index + 1)
finalAverageValue1 = fibGroupedAverage(close, dataLength, fibSequenceLength1)
finalAverageValue2 = fibGroupedAverage(close, dataLength, fibSequenceLength2)

// Determine line colors based on comparison and current high
line1AboveHigh = finalAverageValue1 > high
line2AboveHigh = finalAverageValue2 > high
lineColor1     = line1AboveHigh and not line2AboveHigh ? color.yellow : line2AboveHigh ? color.red : (finalAverageValue1 > finalAverageValue2 ? color.green : color.red)
lineColor2     = line2AboveHigh ? color.red : color.white

plot(finalAverageValue1, title="Dynamic Fibonacci Grouped Average",     color=lineColor1, linewidth=2)
plot(finalAverageValue2, title="Dynamic Fibonacci Grouped Average Base", color=lineColor2, linewidth=2)

// Define signal conditions: buy when the Group Average crosses above the Base, and sell when it crosses below
buySignal  = ta.crossover(finalAverageValue1, finalAverageValue2)
sellSignal = ta.crossunder(finalAverageValue1, finalAverageValue2)

// Calculate the y-coordinate for the dot (using the average of the two lines)
dotY = (finalAverageValue1 + finalAverageValue2) / 2

// Plot dots at the crossover positions using plotshape with absolute positioning
plotshape(buySignal ? dotY : na, title="Green Dot", style=shape.circle, location=location.absolute, color=color.green, size=size.normal)
plotshape(sellSignal ? dotY : na, title="Red Dot", style=shape.circle, location=location.absolute, color=color.red, size=size.normal)

// Execute strategy orders:
// On a buy signal: if flat or short, close any short position and enter long.
if buySignal and strategy.position_size <= 0
    if strategy.position_size < 0
        strategy.close("Short", comment="Close Short on Buy Signal")
    strategy.entry("Long", strategy.long, comment="Enter Long")

// On a sell signal: if flat or long, close any long position and enter short.
if sellSignal and strategy.position_size >= 0
    if strategy.position_size > 0
        strategy.close("Long", comment="Close Long on Sell Signal")
    strategy.entry("Short", strategy.short, comment="Enter Short")

// Manage profit targets for open positions:
if strategy.position_size > 0
    // For long positions, exit when price reaches the profit target
    longTargetPrice = strategy.position_avg_price * (1 + longProfitTargetPct)
    strategy.exit("Long TP", from_entry="Long", limit=longTargetPrice, comment="Long Take Profit")

if strategy.position_size < 0
    // For short positions, exit when price reaches the profit target
    shortTargetPrice = strategy.position_avg_price * (1 - shortProfitTargetPct)
    strategy.exit("Short TP", from_entry="Short", limit=shortTargetPrice, comment="Short Take Profit")

// Alert conditions for notifications
alertcondition(buySignal,  title="Buy Alert",  message="Buy signal: Group Average crossed above the Base!")
alertcondition(sellSignal, title="Sell Alert", message="Sell signal: Group Average crossed below the Base!")