//@version=4
//@author=LucF

// Tape [LucF]
//  v9, 2021.07.23 12:14 — LucF

// Displays an ersatz of a trading console's "tape" section, a POC line and volume delta information, all derived from realtime information.
//   • The tape shows time, price and volume of each new update to the chart's feed.
//   • Volume delta is calculated using the volume and price movement of each realtime update.
//   • Alerts can be configured on volume delta bumps (consecutive increasing/decreasing values of volume delta) or breaches of a threshold, and on high-volume tape lines.

// This code was written using:
//  • The PineCoders Coding Conventions for Pine: http://www.pinecoders.com/coding_conventions/
//  • Code inspired by the PineCoders publication on `varip`: https://www.tradingview.com/script/ppQxBISk-Using-varip-variables-PineCoders/

// This indicator's page on TV: https://www.tradingview.com/script/8mVFTxPg-Tape-LucF/


study("Tape [LucF]", "Tape", true)


// ———————————————————— Constants {

var string ON  = "On"
var string OFF = "Off"

var string TOP = "Top"
var string BOT = "Bottom"

var string CL0 = "None"
var string CL1 = "Text"
var string CL2 = "Background"

var string TD1 = "Longs"
var string TD2 = "Shorts"
var string TD3 = "Longs and Shorts"

var color  C_TAPE_BULL       = color.new(color.green,  00)
var color  C_TAPE_BEAR       = color.new(color.red,    00)
var color  C_TAPE_NEUTRAL    = color.new(color.gray,   00)
var color  C_TAPE_DIV        = color.new(color.orange, 00)
var color  C_TAPE_BULL_BG    = color.new(color.green,  90)
var color  C_TAPE_BEAR_BG    = color.new(color.red,    90)
var color  C_TAPE_NEUTRAL_BG = color.new(color.gray,   90)
var color  C_TAPE_DIV_BG     = color.new(color.orange, 90)
// }



// ———————————————————— Inputs {

var string GP1 = "Tape"
int     i_tapeLinesMax    = input(25,                   "Quantity of tape lines displayed",                 group = GP1, minval = 0, maxval = 50, tooltip = "The maximum is 50.\nUse zero to hide the tape.")
bool    i_tapeTopToBottom = input(TOP,                  "New lines appear at",                              options = [TOP, BOT], group = GP1) == TOP
bool    i_tapeTime        = input(ON,                   "Show Time",                                        inline = "10", group = GP1, options = [ON, OFF]) == ON
float   i_timeOffset      = input(0,                    "Timezone",                                         inline = "10", group = GP1, minval = -12.0, maxval = 14.0, step = 1.0) * 1000 * 60 * 60
float   i_ignoreVol       = input(0.,                   "Hide updates when volume is less than",            group = GP1, minval = 0., tooltip = "Volume values for hidden updates always count in Volume Delta calculations.")
int     i_tapeVolumePrec  = input(8,                    "Precision of volume values",                       group = GP1, minval = 0, maxval = 16)
string  i_tapeTextSize    = input("small",              "Text Size",                                        group = GP1, options = ["tiny", "small", "normal", "large", "huge", "auto"])
string  i_tapeColor       = input(CL1,                  "Color the tape",                                   group = GP1, options = [CL0, CL1, CL2], tooltip = "When using color, text or tape lines appear in bull/bear colors on price movement. In the 'DELTAS` summary, price will appear in bull/bear color on movement, and delta volume on its polarity.")
color   i_c_tapeBull      = input(C_TAPE_BULL,          "Text: Bull",                                       inline = "11", group = GP1)
color   i_c_tapeBear      = input(C_TAPE_BEAR,          "Bear",                                             inline = "11", group = GP1)
color   i_c_tapeNeutral   = input(C_TAPE_NEUTRAL,       "Neutral",                                          inline = "11", group = GP1)
color   i_c_tapeDiv       = input(C_TAPE_DIV,           "Div",                                              inline = "11", group = GP1)
color   i_c_tapeBullBg    = input(C_TAPE_BULL_BG,       "Bg:  Bull",                                        inline = "12", group = GP1)
color   i_c_tapeBearBg    = input(C_TAPE_BEAR_BG,       "Bear",                                             inline = "12", group = GP1)
color   i_c_tapeNeutralBg = input(C_TAPE_NEUTRAL_BG,    "Neutral",                                          inline = "12", group = GP1)
color   i_c_tapeDivBg     = input(C_TAPE_DIV_BG,        "Div",                                              inline = "12", group = GP1)
string  i_tableYpos       = input("middle",             "Tape position",                                    inline = "13", group = GP1, options = ["top", "middle", "bottom"])
string  i_tableXpos       = input("right",              "",                                                 inline = "13", group = GP1, options = ["left", "center", "right"])

var string GP2 = "Markers"
bool    i_marker1         = input(OFF,                  "Marker 1 (⬆⬇) on volume delta bumps",              options = [ON, OFF], group = GP2, tooltip = "Will display a single up/down arrow below the bar. Volume delta bumps are two bars with consecutive and increasing/decreasing plus/minus delta volume values, when no divergence occurs on the second bar.\n► Alerts using these markers will only trigger at the bar's close.") == ON
bool    i_marker2         = input(OFF,                  "Marker 2 (⇑⇓) on volume delta exceeding...",       options = [ON, OFF], group = GP2, tooltip = "Will display a double up/down arrow below the bar. Markers will appear when volume delta for a bar exceeds the threshold.\n► Alerts using these markers will only trigger at the bar's close.") == ON
float   i_marker2Val      = input(1000000.,             "  Volume Delta Threshold",                         minval = 0., group = GP2)
bool    i_marker3         = input(OFF,                  "Marker 3 (⤊⤋) on tape lines with large volume...", options = [ON, OFF], group = GP2, tooltip = "Will display a triple up/down arrow below the bar. This will show a marker before the tape's volume value when the volume of a tape line exceeds the threshold.\n► Alerts using these markers will trigger the moment they appear.") == ON
float   i_marker3Val      = input(1000000.,             "  Tape Volume Threshold",                          minval = 0., group = GP2)

var string GP3 = "Configuration of alert events on markers"
string  i_markerDir       = input(TD3,                  "Direction",                                        options = [TD1, TD2, TD3], group = GP3, tooltip = "These settings allow you to filter the marker events you have selected in the section above. The filters you apply here will determine which markers trigger alerts.\n► You can safely disregard the warning that will appear when you create alerts.")
bool    i_markerAlt       = input(OFF,                  "Alternate Longs and Shorts",                       options = [ON, OFF], group = GP3, tooltip = "When 'Longs and Shorts' are selected, this only triggers an alert on the first marker in a given direction. This prevents triggering successive alerts in the same direction. Has no effect when only 'Longs' or only 'Shorts' are selected.") == ON and i_markerDir == TD3


var bool doLongs  = (i_markerDir == TD1 or i_markerDir == TD3)
var bool doShorts = (i_markerDir == TD2 or i_markerDir == TD3)
// }



// ———————————————————— Functions {

// ————— Function producing a string format usable with `tostring()` to restrict precision to ticks.
f_tickFormat() =>
    string _s = tostring(syminfo.mintick)
    _s := str.replace_all(_s, "25", "00")
    _s := str.replace_all(_s, "5",  "0")
    _s := str.replace_all(_s, "1",  "0")

// ————— Function creates a string by concatenating `_count` times the `_string`.
f_stringOf(_count, _string) =>
    string _return = array.join(array.new_string(_count, _string))

// ————— Function appends `_text` to `_msg` when `_cond` is true.
f_addTextIf(_cond, _msg, _text) =>
    string _return = _cond ? _msg + (_msg != "" ? ", " : "") + _text : _msg

// ————— Functions rounding OC to tick precision.
f_roundedToTickOC() =>
    float _op = round(open  / syminfo.mintick) * syminfo.mintick
    float _cl = round(close / syminfo.mintick) * syminfo.mintick
    [_op, _cl]

// ————— Function returning the delta volume polarity (+/-) for a historical bar or a realtime update.
//       When there is no movement since the last `close`, it uses the previous bar's polarity.
//       The function also works on historical bars and is particularly well-suited to smaller TFs with many bars with no movement.
//       WARNING: Note that one peculiarity of this logic is that a bar with `close > open` will always be considered positive, even if `close < close[1]`.
f_dvUpDn(_open, _close) =>
    // float _open : open price of current bar.
    // float _close: close price of current bar.
    varip bool _dvUp = false
    varip bool _dvDn = false
    varip float _prevClose = _open
    if barstate.isrealtime
        bool _flat = _close == _prevClose
        _dvUp := _flat ? _dvUp : _close > _prevClose
        _dvDn := _flat ? _dvDn : _close < _prevClose
    else
        bool _flat = _close == _open
        _dvUp := not _flat ? _close > _open : _close == _prevClose ? _dvUp : _close > _prevClose
        _dvDn := not _dvUp
    _prevClose := _close
    [_dvUp, _dvDn]
// }



// ———————————————————— Calculations {

// Get up/dn state of realtime update.
[op, cl] = f_roundedToTickOC()
[updUp, updDn]   = f_dvUpDn(op, cl)

// Tape is made of three columns. The `directions` array determines the line's color.
varip string[] column0    = array.new_string()
varip string[] column1    = array.new_string()
varip string[] column2    = array.new_string()
varip bool[]   directions = array.new_bool()

varip float lastPrice     = na
varip float lastVolume    = 0.
varip float deltaVolume   = 0.
varip int   linesInTape   = 0
float       newVolume     = 0.

// Tape information.
var string TICK_FORMAT = f_tickFormat()
var string TAPE_VOLUME_PRECISION = "0" + (i_tapeVolumePrec == 0 ? "" : ".") + f_stringOf(i_tapeVolumePrec, "0")
var string COLUMN0_HEADER  = "TIME"
var string COLUMN1_HEADER  = "PRICE"
var string COLUMN2_HEADER  = "VOLUME"

// Volume delta states and alert conditions.
bool dvDiv      = na
bool barDvUp    = na
bool barDvDn    = na
bool barDvDiv   = na
bool marker1Up  = na
bool marker1Dn  = na
bool marker2Up  = na
bool marker2Dn  = na
bool marker3Up  = na
bool marker3Dn  = na


if barstate.isrealtime
    // Table displaying the tape.
    table _tape = table.new(i_tableYpos + "_" + i_tableXpos, 3, i_tapeLinesMax + 3)

    // New realtime bar or first realtime update when script loads on the chart; reset data.
    if barstate.isnew or na(lastPrice)
        lastVolume    := 0.
        deltaVolume   := 0.

    // ————— Calculate Volume Delta.
    float _updDirection = updUp ? 1 : updDn ? -1 : 0
    newVolume   := nz(volume) - lastVolume
    deltaVolume := deltaVolume +  (newVolume * _updDirection)
    bool _noPriceChange = cl == lastPrice

    // Tape volume alert conditions.
    marker3Up := i_marker3 and newVolume > i_marker3Val and updUp
    marker3Dn := i_marker3 and newVolume > i_marker3Val and updDn

    // ————— Display tape.
    if i_tapeLinesMax > 0
        // Only print lines for updates where volume is above user-selected threshold.
        if newVolume >= i_ignoreVol
            string _column0NewLine = str.format("{0,time,HH:mm:ss}", timenow + i_timeOffset)
            string _column1NewLine = tostring(cl, TICK_FORMAT) + (_noPriceChange ? "" : updUp ? "＋" : updDn ? "－" : "")
            string _column2NewLine = (barstate.isnew ? "↻ " : "") + (marker3Up ? "▲" : marker3Dn ? "▼" : "") + tostring(newVolume, TAPE_VOLUME_PRECISION)
            if i_tapeTopToBottom
                // Add lines from top.
                array.unshift(column0, _column0NewLine)
                array.unshift(column1, _column1NewLine)
                array.unshift(column2, _column2NewLine)
                array.unshift(directions, updUp)
                linesInTape += 1
                if linesInTape > i_tapeLinesMax
                    array.pop(column0)
                    array.pop(column1)
                    array.pop(column2)
                    array.pop(directions)
                    linesInTape -= 1
            else
                // Add lines from bottom.
                array.push(column0, _column0NewLine)
                array.push(column1, _column1NewLine)
                array.push(column2, _column2NewLine)
                array.push(directions, updUp)
                linesInTape += 1
                if linesInTape > i_tapeLinesMax
                    array.shift(column0)
                    array.shift(column1)
                    array.shift(column2)
                    array.shift(directions)
                    linesInTape -= 1

        // Tape headers.
        if i_tapeTime
            table.cell(_tape, 0, 0, COLUMN0_HEADER, text_color = i_c_tapeNeutral, text_size = i_tapeTextSize)
        table.cell(_tape, 1, 0, COLUMN1_HEADER, text_color = i_c_tapeNeutral, text_size = i_tapeTextSize)
        table.cell(_tape, 2, 0, COLUMN2_HEADER, text_color = i_c_tapeNeutral, text_size = i_tapeTextSize)
        // Tape body.
        color _c_text = na
        color _c_bg   = na
        if array.size(column0) > 0
            for _i = 0 to linesInTape - 1
                // Get direction of line to set bgcolor.
                bool _dirUp = array.get(directions, _i)
                _c_bg   := i_tapeColor == CL2 ? _dirUp ? i_c_tapeBullBg : i_c_tapeBearBg : na
                _c_text := i_tapeColor == CL1 ? _dirUp ? i_c_tapeBull   : i_c_tapeBear   : i_c_tapeNeutral
                // Populate one line of the tape.
                if i_tapeTime
                    table.cell(_tape, 0, _i + 1, array.get(column0, _i), bgcolor = _c_bg, text_color = i_c_tapeNeutral, text_size = i_tapeTextSize)
                table.cell(_tape, 1, _i + 1, array.get(column1, _i), bgcolor = _c_bg, text_color = _c_text, text_size = i_tapeTextSize, text_halign = text.align_left)
                table.cell(_tape, 2, _i + 1, array.get(column2, _i), bgcolor = _c_bg, text_color = _c_text, text_size = i_tapeTextSize, text_halign = text.align_right)
        // Tape footer (deltas).
        float  _priceDirection = sign(cl - op)
        string _column0Footer  = str.format("{0,time,HH:mm:ss}", timeframe.isintraday ? timenow - time : 0)
        string _column1Footer  = tostring(abs(cl - op), TICK_FORMAT) + (na(lastPrice) ? "" : _priceDirection > 0 ? "＋" : _priceDirection < 0 ? "－" : "")
        string _column2Footer  = tostring(deltaVolume, TAPE_VOLUME_PRECISION)
        table.cell(_tape, 1, linesInTape + 1, " ", text_color = i_c_tapeNeutral, text_size = i_tapeTextSize, text_halign = text.align_left)
        if i_tapeTime
            _c_bg   := i_tapeColor == CL2 and _priceDirection != sign(deltaVolume) ? i_c_tapeDivBg : na
            _c_text := i_tapeColor == CL1 and _priceDirection != sign(deltaVolume) ? i_c_tapeDiv   : i_c_tapeNeutral
            table.cell(_tape, 0, linesInTape + 2, _column0Footer, bgcolor = _c_bg, text_color = _c_text, text_size = i_tapeTextSize)
        _c_bg   := i_tapeColor == CL2 ? _priceDirection > 0 ? i_c_tapeBullBg : _priceDirection < 0 ? i_c_tapeBearBg : i_c_tapeNeutralBg : na
        _c_text := i_tapeColor == CL1 ? _priceDirection > 0 ? i_c_tapeBull   : _priceDirection < 0 ? i_c_tapeBear   : i_c_tapeNeutral   : i_c_tapeNeutral
        table.cell(_tape, 1, linesInTape + 2, _column1Footer, bgcolor = _c_bg, text_color = _c_text, text_size = i_tapeTextSize, text_halign = text.align_left)
        _c_bg   := i_tapeColor == CL2 ? deltaVolume > 0 ? i_c_tapeBullBg : deltaVolume < 0 ? i_c_tapeBearBg : i_c_tapeNeutral : na
        _c_text := i_tapeColor == CL1 ? deltaVolume > 0 ? i_c_tapeBull   : deltaVolume < 0 ? i_c_tapeBear   : i_c_tapeNeutral : i_c_tapeNeutral
        table.cell(_tape, 2, linesInTape + 2, _column2Footer, bgcolor = _c_bg, text_color = _c_text, text_size = i_tapeTextSize, text_halign = text.align_right)


    // Volume delta bumps alert conditions.
    barDvUp   := deltaVolume > 0
    barDvDn   := deltaVolume < 0
    barDvDiv  := (barDvUp and cl < op) or (barDvDn and cl > op)
    marker1Up := i_marker1 and barDvUp and barDvUp[1] and deltaVolume > deltaVolume[1] and not barDvDiv
    marker1Dn := i_marker1 and barDvDn and barDvDn[1] and deltaVolume < deltaVolume[1] and not barDvDiv
    // Volume delta alert conditions.
    marker2Up := i_marker2 and deltaVolume >  i_marker2Val and not barDvDiv
    marker2Dn := i_marker2 and deltaVolume < -i_marker2Val and not barDvDiv

    // Save current price and volume for comparison on next update.
    lastPrice     := cl
    lastVolume    := nz(volume)

// Display Data Window values.
plotchar(barstate.isrealtime ? deltaVolume : na, "Volume Delta", "", location.top, barDvDiv ? i_c_tapeDiv : barDvUp ? i_c_tapeBull : i_c_tapeBear)
// }



// ———————————————————— Markers and alerts {

bool triggerM1Up = barstate.isconfirmed and marker1Up
bool triggerM1Dn = barstate.isconfirmed and marker1Dn
bool triggerM2Up = barstate.isconfirmed and marker2Up
bool triggerM2Dn = barstate.isconfirmed and marker2Dn
bool triggerM3Up = marker3Up
bool triggerM3Dn = marker3Dn
varip bool lastAlertDirectionUp = na
var string TEXT_MARKER1_UP = "M1 Bump Up"
var string TEXT_MARKER1_DN = "M1 Bump Down"
var string TEXT_MARKER2_UP = "M2 Volume delta Up"
var string TEXT_MARKER2_DN = "M2 Volume delta Down"
var string TEXT_MARKER3_UP = "M3 Tape Volume Up"
var string TEXT_MARKER3_DN = "M3 Tape Volume Down"
// Trigger alerts on user-selected conditions.
bool triggerLong  = (triggerM1Up or triggerM2Up or triggerM3Up) and (not i_markerAlt or na(lastAlertDirectionUp) or not lastAlertDirectionUp) and doLongs
bool triggerShort = (triggerM1Dn or triggerM2Dn or triggerM3Dn) and (not i_markerAlt or na(lastAlertDirectionUp) or     lastAlertDirectionUp) and doShorts
string alertMsg = ""
if triggerLong or triggerShort
    string deltaVolumeText = tostring(deltaVolume)
    string newVolumeText   = tostring(newVolume,   TAPE_VOLUME_PRECISION)
    alertMsg := f_addTextIf(triggerM1Up, alertMsg, TEXT_MARKER1_UP + ": " + deltaVolumeText)
    alertMsg := f_addTextIf(triggerM1Dn, alertMsg, TEXT_MARKER1_DN + ": " + deltaVolumeText)
    alertMsg := f_addTextIf(triggerM2Up, alertMsg, TEXT_MARKER2_UP + ": " + deltaVolumeText)
    alertMsg := f_addTextIf(triggerM2Dn, alertMsg, TEXT_MARKER2_DN + ": " + deltaVolumeText)
    alertMsg := f_addTextIf(triggerM3Up, alertMsg, TEXT_MARKER3_UP + ": " + newVolumeText)
    alertMsg := f_addTextIf(triggerM3Dn, alertMsg, TEXT_MARKER3_DN + ": " + newVolumeText)
    if triggerLong
        lastAlertDirectionUp := true
    else
        lastAlertDirectionUp := false

if alertMsg != ""
    alert(alertMsg, alert.freq_all)

// Plot alert markers.
plotchar(triggerLong  and triggerM1Up, TEXT_MARKER1_UP, "⬆", location.belowbar, color.lime,    size = size.tiny)
plotchar(triggerShort and triggerM1Dn, TEXT_MARKER1_DN, "⬇", location.belowbar, color.fuchsia, size = size.tiny)
plotchar(triggerLong  and triggerM2Up, TEXT_MARKER2_UP, "⇑", location.belowbar, color.lime,    size = size.tiny)
plotchar(triggerShort and triggerM2Dn, TEXT_MARKER2_DN, "⇓", location.belowbar, color.fuchsia, size = size.tiny)
plotchar(triggerLong  and triggerM3Up, TEXT_MARKER3_UP, "⤊", location.belowbar, color.lime,    size = size.tiny)
plotchar(triggerShort and triggerM3Dn, TEXT_MARKER3_DN, "⤋", location.belowbar, color.fuchsia, size = size.tiny)
// }