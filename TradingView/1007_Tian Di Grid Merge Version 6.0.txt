import PineCoders/Time/4
import TradingView/Strategy/3
//@version=5
strategy(shorttitle="Tian Di Grid Merge Version 6.0",
         title="Tian Di Grid Merge Version 6.0",
         overlay=true,
         initial_capital=10000,
         default_qty_type=strategy.cash,
         default_qty_value=100,
         commission_type=strategy.commission.percent,
         commission_value=0.04,
         pyramiding=400,
         close_entries_rule="ANY",
         currency='USD',
         slippage=5,
         max_bars_back=4000)


//======================================================================================================================================时间
i_text = input.text_area(defval = "Attention: Do not choose long or short together, and do not choose equal difference or equal ratio together;\n cannot trade: If normal trading is not possible, switch to a 1m cycle;\n Grid spacing: minimum 0.1%, below which no profit can be made;\n Position value: default is 100u, which is the amount already leveraged;\n fold investment multiple: The order amount for each order is the same, and there is no double investment;", title = "Strategic considerations")



start_year = input.int(title='Start', defval=2017, minval=2010, maxval=3000, group='Time setting for backtesting', inline='1')//
start_month = input.int(title='', defval=1, group='Time setting for backtesting', inline='1', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
start_date = input.int(title='', defval=1, group='Time setting for backtesting', inline='1', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
start_hour = input.int(title='', defval=1, group='Time setting for backtesting', inline='1', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])

end_year = input.int(title='End', defval=2025, minval=1800, maxval=3000, group='Time setting for backtesting', inline='2')
end_month = input.int(title='', defval=12, group='Time setting for backtesting', inline='2', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
end_date = input.int(title='', defval=31, group='Time setting for backtesting', inline='2', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])
end_hour = input.int(title='', defval=24, group='Time setting for backtesting', inline='2', options = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24])
in_date = time >= timestamp(syminfo.timezone, start_year, start_month, start_date, start_hour,0) and time < timestamp(syminfo.timezone, end_year, end_month, end_date, end_hour, 0)

//======================================================================================================================================Opening value
grid_base_order_1 = input.int(100, title='Opening value', inline="1", group="fund management")
qty_1 = grid_base_order_1 / close

long_chose = input.bool(true, title="Long", inline="1", group="Opening direction")
short_chose = input.bool(false, title="Short", inline="1", group="Opening direction")

// Selection of warehouse addition method
useArithmeticSpacing = input.bool(true, title="Equal difference warehouse addition", inline="1", group="Warehouse addition method")
useGeometricSpacing = input.bool(false, title="Equal ratio warehousing", inline="1", group="Warehouse addition method")

// Close the position when the profit exceeds the grid profit
closeOnProfit = input.bool(true, title="Close the position when the profit exceeds the grid profit", inline="1", group="Closing Position Settings")

//======================================================================================================================================Grid parameters
// == INPUT ==
i_upperBound = input.float(3900, title='Upper boundary', inline="1", group='Grid parameters')
i_lowerBound = input.float(900, title='lower boundary', inline="1", group='Grid parameters')
i_gridQty = input.int(350, title='Number of grids', inline="1", group='Grid parameters', minval=3, maxval=350, tooltip="Max350,Min3")
minGridSpacingPct = input.float(0.1, title='Minimum Grid Spacing Percentage', inline="2", group='Grid parameters', minval=0.01)
minBoundDifferencePct = input.float(0.1, title='Minimum upper and lower limit difference percentage', inline="2", group='Grid parameters', minval=0.01)

// Please select only one method of adding to the warehouse
if useArithmeticSpacing and useGeometricSpacing
    var errorMsg = "Please select only one method of adding to the warehouse。"
    label.new(x=bar_index, y=close, text=errorMsg, color=color.red, textcolor=color.white, size=size.normal)
    strategy.close_all()
    runtime.error(errorMsg)

//======================================================================================================================================
//If an order with the same ID already exists, open the warehouse (in simple terms: A must be held in order to open the order)
ID_true(name) =>
    repeat = false
    for i = 0 to strategy.opentrades - 1
        if strategy.opentrades.profit(i) != 0
            if name == strategy.opentrades.entry_id(i)
                repeat := true
                break
    repeat

// Build a price (grid line) array (arithmetic) from bottom to top using the lower limit, grid width, and number of grid lines
f_buildArithmeticGrid(_lb, _gw, _gq) =>
    gridArr = array.new_float(_gq)
    for i = 0 to _gq - 1
        array.set(gridArr, i, _lb + _gw * i)
    gridArr

// Build a price (grid line) array (proportionally) from bottom to top using the lower limit, grid width, and number of grid lines
f_buildGeometricGrid(_lb, _ub, _gq) =>
    gridArr = array.new_float(_gq)
    factor = math.pow(_ub / _lb, 1 / (_gq - 1))
    for i = 0 to _gq - 1
        array.set(gridArr, i, _lb * math.pow(factor, i))
    gridArr

//Return an array containing the nearest gridlines above and below the current price (excluding the current price). Drawing section
f_getNearGridLines(_gridArr, _price) =>
    arr = array.new_int(2)
    for i = 0 to array.size(_gridArr) - 1
        if array.get(_gridArr, i) > _price
            array.set(arr, 0, i)
            array.set(arr, 1, i - 1)
            break
    arr

// Calculate the actual minimum grid spacing and minimum upper and lower limit difference
boundDifference = i_upperBound - i_lowerBound
minGridSpacing = minGridSpacingPct / 100 * boundDifference
minBoundDifference = minBoundDifferencePct / 100 * boundDifference

// Check if the upper and lower limit difference is less than the minimum upper and lower limit difference
if boundDifference < minBoundDifference
    var errorMsg = "The difference between the upper and lower limits is too small. Please adjust the upper and lower limits。"
    label.new(x=bar_index, y=close, text=errorMsg, color=color.red, textcolor=color.white, size=size.normal)
    strategy.close_all()
    runtime.error(errorMsg)

// Dynamically adjust the number of grids
gridWidth = (i_upperBound - i_lowerBound) / (i_gridQty - 1)

// Use ternary expressions to ensure that the minimum grid spacing is not less than 0.1%
minGridSpacing := minGridSpacing < 0.1 / 100 * boundDifference ? 0.1 / 100 * boundDifference : minGridSpacing
if gridWidth < minGridSpacing
    i_gridQty := math.ceil((i_upperBound - i_lowerBound) / minGridSpacing) + 1
    gridWidth := (i_upperBound - i_lowerBound) / (i_gridQty - 1)

// Build a grid line array based on the selected warehousing method
var gridLineArr = useArithmeticSpacing ? f_buildArithmeticGrid(i_lowerBound, gridWidth, i_gridQty) : useGeometricSpacing ? f_buildGeometricGrid(i_lowerBound, i_upperBound, i_gridQty) : na
var orderArr = array.new_bool(i_gridQty, false)  // A Boolean array indicating whether there is an open order corresponding to each grid line

var closeLineArr = f_getNearGridLines(gridLineArr, close)  // Used for plotting - an array consisting of 2 indices corresponding to the grid lines near the price
var nearTopGridLine = array.get(closeLineArr, 0)
var nearBotGridLine = array.get(closeLineArr, 1)

// Record the entry time of the order
var float[] entryTimes = array.new_float(i_gridQty, na)

// == LOGIC ==
if in_date
    for i = 0 to i_gridQty - 1
        if long_chose and not short_chose
            if close < array.get(gridLineArr, i) and not array.get(orderArr, i) and i < array.size(gridLineArr) - 1
                buyId = i
                array.set(orderArr, buyId, true)
                array.set(entryTimes, buyId, na)
                if strategy.opentrades == 0
                    strategy.entry(id=str.tostring(0), direction=strategy.long, qty=qty_1, comment='#' + str.tostring(0))
                if strategy.opentrades > 0 and buyId > 0
                    strategy.entry(id=str.tostring(buyId), direction=strategy.long, qty=qty_1, comment='#' + str.tostring(buyId))
            if close > array.get(gridLineArr, i) and i != 0
                if array.get(orderArr, i - 1) and (na(array.get(entryTimes, i - 1)) or (time - array.get(entryTimes, i - 1)) > timeframe.multiplier * 60)
                    sellId = i - 1
                    array.set(orderArr, sellId, false)
                    strategy.close(id=str.tostring(sellId), comment='#' + str.tostring(sellId))
                    array.set(entryTimes, sellId, na)
        if not long_chose and short_chose
            if close < array.get(gridLineArr, i) and not array.get(orderArr, i) and i < array.size(gridLineArr) - 1
                buyId = i
                array.set(orderArr, buyId, true)
                array.set(entryTimes, buyId, time)
                // Attention: The position cannot be closed immediately here
            if close > array.get(gridLineArr, i) and i != 0
                if array.get(orderArr, i - 1) and (not na(array.get(entryTimes, i - 1)) and (time - array.get(entryTimes, i - 1)) > timeframe.multiplier * 60)
                    sellId = i - 1
                    array.set(orderArr, sellId, false)
                    strategy.entry(id=str.tostring(sellId), direction=strategy.short, qty=qty_1, comment='#' + str.tostring(sellId))
                    // Update the entry time to the current timestamp for the next inspection
                    array.set(entryTimes, sellId, time)

    // New closing logic: When any order reaches the profit taking condition, all orders entering the same position will be closed
    if strategy.opentrades > 0 and closeOnProfit == true
        for i = 0 to strategy.opentrades - 1
            entry_id = strategy.opentrades.entry_id(i)
            entry_price = strategy.opentrades.entry_price(i)
            entry_time = strategy.opentrades.entry_time(i)
            if (long_chose and close > entry_price + (i_upperBound - i_lowerBound) / i_gridQty) or (short_chose and close < entry_price - (i_upperBound - i_lowerBound) / i_gridQty)
                // Ensure that the holding time is at least one candlestick
                if na(entry_time) or (time - entry_time) > timeframe.multiplier * 60
                    // Traverse all orders, find orders that enter the same position as the current order and close them
                    for j = 0 to strategy.opentrades - 1
                        if strategy.opentrades.entry_id(j) == entry_id
                            strategy.close(id=strategy.opentrades.entry_id(j), comment='#' + str.tostring(strategy.opentrades.entry_id(j)))

    //This is the cancellation of order number 0. Without this place, order number 0 may still exist
    if strategy.opentrades >= 1 and ID_true('0')
        if long_chose and close > strategy.position_avg_price + (i_upperBound - i_lowerBound) / i_gridQty
            strategy.close(id=str.tostring('0'), comment='#' + str.tostring(0))
        if short_chose and close < strategy.position_avg_price - (i_upperBound - i_lowerBound) / i_gridQty
            strategy.close(id=str.tostring('0'), comment='#' + str.tostring(0))

// Update the vicinity of grid lines (for display)
closeLineArr := f_getNearGridLines(gridLineArr, close)
nearTopGridLine := array.get(closeLineArr, 0)
nearBotGridLine := array.get(closeLineArr, 1)


plot(in_date?array.get(gridLineArr, nearTopGridLine):na, color=color.rgb(255, 0, 255, 20), style=plot.style_stepline, linewidth=2)
plot(in_date?array.get(gridLineArr, nearBotGridLine):na, color=color.rgb(0, 0, 255, 20), style=plot.style_stepline, linewidth=2)