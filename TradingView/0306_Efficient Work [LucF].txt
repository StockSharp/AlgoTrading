//@version=4
//@author=LucF

// Efficient Work [LucF]
//  v1.1, 2020.12.04 16:47 — LucF

// Efficient Work measures the ratio of price movement from close to close (resulting work)
//   over the distance traveled to the high and low before settling down at the close (total work).

// This code was written using the following standards:
//  • PineCoders Coding Conventions for Pine: http://www.pinecoders.com/coding_conventions/
//  • A modified version of the PineCoders MTF Oscillator Framework: https://www.tradingview.com/script/Wvcqygsx-MTF-Oscillator-Framework-PineCoders/
//  • A modified version of the PineCoders MTF Selection Framework: https://www.tradingview.com/script/90mqACUV-MTF-Selection-Framework-PineCoders-FAQ/

// This indicator's page on TV: https://www.tradingview.com/script/yG0rpNzO-Efficient-Work-LucF/

study("Efficient Work [LucF]", "Efficient Work")



// ———————————————————— Constants
// {
// ————— Options for inputs.
BGC0 = "None", BGC1 = "Main Line Above/Below Centerline", BGC2 = "Main Line Above/Below Hi/Lo Channel", BGC3 = "Main Line Above/Below Divergence Levels", BGC4 = "Main Line Above/Below Medium TF", BGC5 = "Main Line Above/Below Highest TF"
BGC6 = "Chart TF Above/Below Medium TF", BGC7 = "Chart TF Above/Below Highest TF", BGC8 = "Medium TF Above/Below Centerline", BGC9 = "Highest TF Above/Below Centerline", BGC10 = "High volatility", BGC11 = "Low Volatility"
LIN0 = "None", LIN1 = "Aggregate", LIN2 = "Chart Timeframe", LIN3 = "Medium Timeframe", LIN4 = "Highest Timeframe"
MAT1 = "Simple (SMA)", MAT2 = "Exponential (EMA)", MAT3 = "Weighed (WMA)", MAT4 = "Volume-Weighed (VWMA)", MAT5 = "Arnaud-Legoux (ALMA)", MAT6 = "Linear Regression", MAT7 = "Hull (HMA)"
ON   = "On", OFF = "Off"
TF1  = "Auto-Steps", TF2 = "Multiples", TF3 = "Fixed"
VOL1 = "All", VOL2 = "High only", VOL3 = "Low only"

// ————— Signal's centerline.
CENTERLINE    = 0
// ————— Default colors for color inputs.
c_BULL_BRIGHT = #40FF00ff
c_BULL_MEDIUM = #40FF0080
c_BULL_DARK   = #40FF0040
c_BEAR_BRIGHT = #FF0080ff
c_BEAR_MEDIUM = #FF008080
c_BEAR_DARK   = #FF008040
c_LINE2       = color.orange
c_LINE3       = color.purple
c_NEUTRAL     = color.gray
c_CENTERLINE  = color.silver
c_BACKGR_BULL = #40FF0010
c_BACKGR_BEAR = #FF008010
c_MARKER_BULL = c_BULL_MEDIUM
c_MARKER_BEAR = c_BEAR_MEDIUM
// }



// ———————————————————— Inputs
// {
_10                 = input(true,           "═════════════ Plots ═══════════════")
i_line1             = input(LIN2,           "Main Line",                            options = [LIN0, LIN1, LIN2, LIN3, LIN4])
i_line1Width        = input(3,              "  Thickness",                          minval = 1, maxval = 10)
i_line2             = input(LIN0,           "Line 2",                               options = [LIN0, LIN1, LIN2, LIN3, LIN4])
i_line2Width        = input(2,              "  Thickness",                          minval = 1, maxval = 10)
i_line3             = input(LIN0,           "Line 3",                               options = [LIN0, LIN1, LIN2, LIN3, LIN4])
i_line3Width        = input(1,              "  Thickness",                          minval = 1, maxval = 10)
i_showDiv           = input(ON,             "Divergences",                          options = [OFF, ON]) == ON
i_showDivLevels     = input(ON,             "Divergence Levels",                    options = [OFF, ON]) == ON
i_showMarkersBull   = input(OFF,            "Bull Markers On Color Transitions",    options = [OFF, ON]) == ON
i_showMarkersBear   = input(OFF,            "Bear Markers On Color Transitions",    options = [OFF, ON]) == ON
i_showHiLoChannel   = input(OFF,            "Hi/Lo Channel",                        options = [OFF, ON]) == ON
i_channelLookback   = input(100,            "  Lookback",                           minval = 1)
i_bgColor           = input(BGC0,           "Background Color",                     options = [BGC0, BGC1, BGC2, BGC3, BGC4, BGC5, BGC6, BGC7, BGC8, BGC9, BGC10, BGC11])
i_tfShow            = input(ON,             "Show Resolution",                      options = [OFF, ON]) == ON
i_offsetTf          = input(3,              "  Label Horizontal Offset")

_20                 = input(true,           "═════ Main Line Coloring Conditions ═══════")
i_colorCond1        = input(OFF,            "Above/Below Centerline",               options = [OFF, ON]) == ON
i_colorCond2        = input(OFF,            "Above/Below Hi/Lo Channel",            options = [OFF, ON]) == ON
i_colorCond3        = input(OFF,            "Above/Below Divergence Levels",        options = [OFF, ON]) == ON
i_colorCond4        = input(OFF,            "Above/Below Medium TF",                options = [OFF, ON]) == ON
i_colorCond5        = input(OFF,            "Above/Below Highest TF",               options = [OFF, ON]) == ON
i_colorCond6        = input(OFF,            "Chart TF Above/Below Medium TF",       options = [OFF, ON]) == ON
i_colorCond7        = input(OFF,            "Chart TF Above/Below Highest TF",      options = [OFF, ON]) == ON
i_colorCond8        = input(OFF,            "Medium TF Above/Below Centerline",     options = [OFF, ON]) == ON
i_colorCond9        = input(OFF,            "Highest TF Above/Below Centerline",    options = [OFF, ON]) == ON
i_colorFilter1      = input(VOL1,           "Filter Conditions On Volatility",      options = [VOL1, VOL2, VOL3])

_30                 = input(true,           "════════════ Signal ═══════════════")
i_maType            = input(MAT5,           "MA Type",                              options = [MAT1, MAT2, MAT3, MAT4, MAT5, MAT6, MAT7])
i_maPeriod          = input(20,             "MA Period",                            minval = 1)

_40                 = input(true,           "══════════ Higher Timeframes ═════════")
i_tfType            = input(TF1,            "Selection Mode",                       options = [TF1, TF2, TF3])
i_mtfMult           = input(5,              "  Multiple For Medium Timeframe")
i_htfMult           = input(10,             "  Multiple For Higher Timeframe")
i_mtfFixedRes       = input("D",            "  Fixed For Medium Timeframe",         type = input.resolution)
i_htfFixedRes       = input("W",            "  Fixed For Higher Timeframe",         type = input.resolution)

_50                 = input(true,           "═══════════ Repainting ═════════════")
i_signalRepaint     = input(ON,             "Repainting of Chart's Timeframe",      options = [OFF, ON]) == ON
i_tfRepaint         = input(OFF,            "Repainting of Higher Timeframes",      options = [OFF, ON]) == ON

_60                 = input(true,           "═════════ Aggregate Weights ══════════")
i_ctfWeight         = input(1.0,            "Weight of Chart TF",                   minval = 0, step = 0.25)
i_mtfWeight         = input(1.0,            "Weight of Medium TF",                  minval = 0, step = 0.25)
i_htfWeight         = input(1.0,            "Weight of Highest TF",                 minval = 0, step = 0.25)

_70                 = input(true,           "══════════ High Volatility ════════════")
i_fastVolatility    = input(7,              "When Short-term ATR",                  minval = 1)
i_slowVolatility    = input(40,             "Is Higher Than Long-term ATR",         minval = 2)

_80                 = input(true,           "════════════ Colors ═══════════════")
i_c_bullBright      = input(c_BULL_BRIGHT,  "Main Line: Bull Bright")
i_c_bullMedium      = input(c_BULL_MEDIUM,  "Main Line: Bull Medium")
i_c_bullDark        = input(c_BULL_DARK,    "Main Line: Bull Dark")
i_c_bearBright      = input(c_BEAR_BRIGHT,  "Main Line: Bear Bright")
i_c_bearMedium      = input(c_BEAR_MEDIUM,  "Main Line: Bear Medium")
i_c_bearDark        = input(c_BEAR_DARK,    "Main Line: Bear Dark")
i_c_neutral         = input(c_NEUTRAL,      "Main Line: Neutral")
i_c_line2           = input(c_LINE2,        "Line 2")
i_c_line3           = input(c_LINE3,        "Line 3")
i_c_centerline      = input(c_CENTERLINE,   "Centerline")
i_c_backgroundBull  = input(c_BACKGR_BULL,  "Background: Bull")
i_c_backgroundBear  = input(c_BACKGR_BEAR,  "Background: Bear")
i_c_markerBull      = input(c_MARKER_BULL,  "Marker: Bull")
i_c_markerBear      = input(c_MARKER_BEAR,  "Marker: Bear")

i_centerline        = CENTERLINE
// }



// ———————————————————— Helper Functions.
// {

// ————— Function returning efficient work.
f_efficientWork() =>
    _workUp = high - min(open, nz(close[1], close))
    _workDn = max(open, nz(close[1])) - low
    _work   = _workUp + _workDn
    _ew     = _work == 0 ? 0. : (close - nz(close[1], open)) / _work

// ————— Function returning the signal's value.
f_signal() =>
    f_efficientWork()

// ————— Returns 1 when _c boolean is true, 0 if false.
f_01(_c) => _c ? 1 : 0

// ————— Converts current chart resolution into a float minutes value.
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (
      timeframe.isseconds ? 1. / 60             :
      timeframe.isminutes ? 1.                  :
      timeframe.isdaily   ? 60. * 24            :
      timeframe.isweekly  ? 60. * 24 * 7        :
      timeframe.ismonthly ? 60. * 24 * 30.4375  : na)

// ————— Returns resolution of _res string timeframe in minutes.
f_tfResInMinutes(_res) =>
    // _res: resolution of any TF (in `timeframe.period` string format).
    security(syminfo.tickerid, _res, f_resInMinutes())

// ————— Returns a multiple of current resolution as a string in `timeframe.period` format usable with `security()`.
f_multipleOfRes(_res, _mult) =>
    // _res :  current resolution in minutes, in the fractional format supplied by f_resInMinutes() companion function.
    // _mult: Multiple of current TF to be calculated.
    // ————— Convert current float TF in minutes to target string TF in `timeframe.period` string format.
    _targetResInMin = _res * max(_mult, 1)
    // ————— Find best string to express the resolution.
    _targetResInMin   <= 0.083 ? "5S"  :
      _targetResInMin <= 0.251 ? "15S" :
      _targetResInMin <= 0.501 ? "30S" :
      _targetResInMin <= 1440  ? tostring(round(_targetResInMin)) :
      _targetResInMin <= 43800 ? tostring(round(min(_targetResInMin / 1440, 365))) + "D" :
      tostring(round(min(_targetResInMin / 43800, 12))) + "M"

// ————— Given a _res timeframe in float minutes, returns the first higher step for the medium timeframe.
f_resNextStep1(_res) =>
    // _res: current TF in fractional minutes.
    _res   <= 1     ? "15"  :
      _res <= 5     ? "60"  :
      _res <= 30    ? "240" :
      _res <= 360   ? "1D"  :
      _res <= 1440  ? "1W"  :
      _res <= 10080 ? "1M"  : "12M"

// ————— Given a _res timeframe in float minutes, returns the second highest step for the highest timeframe.
f_resNextStep2(_res) =>
    _res   <= 1     ? "60"  :
      _res <= 30    ? "D"   :
      _res <= 1440  ? "1M"  : "12M"

// ————— Print a label at end of chart.
f_print(_txt, _y, _color, _offsetLabels) =>
    var label _lbl = na
    _t = int(time + (time - time[1]) * _offsetLabels)
    if barstate.islast and _txt != ""
        if na(_lbl)
            // Only create label once.
            _lbl := label.new(_t, _y, _txt, xloc.bar_time, yloc.price, #00000000, label.style_none, _color, size.large)
            // Fudge return type of `if` block so compiler doesn't complain (thx to midtownsk8rguy for the trick).
            int(na)
        else
            // Rather than delete and recreate the label on every realtime bar update, update the label's information; it's more efficient.
            label.set_xy(_lbl, _t, _y)
            label.set_text(_lbl, _txt)
            label.set_textcolor(_lbl, _color)
            int(na)

// ————— Function rounding _price to tick precision.
f_roundToTick(_price) => round(_price / syminfo.mintick) * syminfo.mintick

// ————— Function returning true when a bar is considered to be an up bar.
f_barUp() =>
    // Round prices to tick value because excahnge feeds sometimes include higher precision.
    _roundedO = f_roundToTick(open)
    _roundedC = f_roundToTick(close)
    // Account for the normal "close > open" condition, but also for zero movement bars when their close is higher than previous close.
    _result = _roundedC > _roundedO or (_roundedC == _roundedO and _roundedC > nz(_roundedC[1]))

// ————— Function returning true when a high volatility condition is detected.
f_highVolatility() =>
    // Dependencies : i_fastVolatility, i_slowVolatility
    atr(i_fastVolatility) > atr(i_slowVolatility)
// }



// ———————————————————— Calculations.
// {

// ————— Function returning the MA of the signal.
f_avgSignal(_src, _p, _maType) =>
    // _p           : Initial MA period.
    // _maType      : MA type.
    // Dependencies : MATx constants.
    _maType   == MAT1 ? sma(   _src, _p)          :
      _maType == MAT2 ? ema(   _src, _p)          :
      _maType == MAT3 ? wma(   _src, _p)          :
      _maType == MAT4 ? vwma(  _src, _p)          :
      _maType == MAT5 ? alma(  _src, _p, 0.85, 6) :
      _maType == MAT6 ? linreg(_src, _p, 0)       :
      _maType == MAT7 ? hma(   _src, _p)          : float(na)

// ————— Higher resolutions calcs.
chartResInMinutes = f_resInMinutes()
// Medium timeframe.
mtf = i_tfType == TF1 ? f_resNextStep1(chartResInMinutes) : i_tfType == TF2 ? f_multipleOfRes(chartResInMinutes, i_mtfMult) : i_tfType == TF3 ? i_mtfFixedRes : timeframe.period
// Highest timeframe.
htf = i_tfType == TF1 ? f_resNextStep2(chartResInMinutes) : i_tfType == TF2 ? f_multipleOfRes(chartResInMinutes, i_htfMult) : i_tfType == TF3 ? i_htfFixedRes : timeframe.period

// ————— Signal calculation at chart and higher resolutions.
signal  = f_signal()
sCtf    = f_avgSignal(signal, i_maPeriod, i_maType)[not i_signalRepaint and barstate.isrealtime ? 1 : 0]
sMtf    = i_tfRepaint ? security(syminfo.tickerid, mtf, signal) : security(syminfo.tickerid, mtf, signal[1], false, true)
sHtf    = i_tfRepaint ? security(syminfo.tickerid, htf, signal) : security(syminfo.tickerid, htf, signal[1], false, true)
// ————— Aggregate signal.
// Only use higher TFs when they return a value (thx to scarf for the remark leading to this fix).
mtfWeight = na(sMtf) ? 0 : i_mtfWeight
htfWeight = na(sHtf) ? 0 : i_htfWeight
sAgg = ((sCtf * i_ctfWeight) + (nz(sMtf) * mtfWeight) + (nz(sHtf) * htfWeight)) / (i_ctfWeight + mtfWeight + htfWeight)

// ————— Returns the signal corresponding to _userSelection.
f_line(_userSelection) =>
    // Dependency: LINx constants for line type.
    _userSelection   == LIN1 ? sAgg :
      _userSelection == LIN2 ? sCtf :
      _userSelection == LIN3 ? sMtf :
      _userSelection == LIN4 ? sHtf : na

// ————— Assign lines as per user selections.
line1 = f_line(i_line1)
line2 = f_line(i_line2)
line3 = f_line(i_line3)

// ————— Divergences, defined by the bar's direction being different than the signal's direction.
var float divLevel = na
div = f_barUp() != rising(line1, 1)
if div
    // On new divergences, save line1's current level.
    divLevel := line1

// ————— Hi/Lo channel.
channelHi = highest(line1, i_channelLookback)
channelLo = lowest( line1, i_channelLookback)

// ————— Function returning +1/0/-1 as per bull/neutral/bear state of _condNo if _useCond is true.
f_conditionState(_condNo, _useCond) =>
    // _condNo      : condition to be evaluated.
    // _useCond     : boolean determining if the condition must be evaluated.
    // Dependencies : CENTERLINE, channelHi, channelLo, line1, sCtf, sMtf, sHtf.
    if _useCond
        if _condNo == 1
            sign(line1 - i_centerline)
        else if _condNo == 2
            line1 > channelHi[1] ? 1 : line1 < channelLo[1] ? -1 : 0
        else if _condNo == 3
            sign(line1 - divLevel)
        else if _condNo == 4
            sign(line1 - sMtf)
        else if _condNo == 5
            sign(line1 - sHtf)
        else if _condNo == 6
            sign(sCtf - sMtf)
        else if _condNo == 7
            sign(sCtf - sHtf)
        else if _condNo == 8
            sign(sMtf - i_centerline)
        else if _condNo == 9
            sign(sHtf - i_centerline)
        else
            0
    else
        0

// ————— Determine main line's color from bull/bear/neutral states of user-selected coloring conditions.
// The Volatility selection in Inputs is applied as a filter, as opposed to a bull/neutral/bear color selection criterion.
filterOk         = (i_colorFilter1 == VOL1 or (i_colorFilter1 == VOL2 and f_highVolatility()) or (i_colorFilter1 == VOL3 and not f_highVolatility()))
// Count how many conditions user has turned on.
qtyOfConditions  = f_01(i_colorCond1) + f_01(i_colorCond2) + f_01(i_colorCond3) + f_01(i_colorCond4) + f_01(i_colorCond5) + f_01(i_colorCond6) + f_01(i_colorCond7) + f_01(i_colorCond8) + f_01(i_colorCond9)
// Add states of all coloring condition.
conditionsStates = f_conditionState(1, i_colorCond1) + f_conditionState(2, i_colorCond2) + f_conditionState(3, i_colorCond3) + f_conditionState(4, i_colorCond4) + f_conditionState(5, i_colorCond5) + f_conditionState(6, i_colorCond6) + f_conditionState(7, i_colorCond7) + f_conditionState(8, i_colorCond8) + f_conditionState(9, i_colorCond9)
// Bull/Bear state triggers when all selected conditions are in agreement.
stateBull        = qtyOfConditions > 0 and conditionsStates ==   qtyOfConditions
stateBear        = qtyOfConditions > 0 and conditionsStates == - qtyOfConditions
// Build color using compound coloring conditions and filter.
c_line1          = not filterOk ? i_c_neutral : stateBull ? i_c_bullBright : stateBear ? i_c_bearBright: i_c_neutral
// }



// ———————————————————— Plots
// {
// ————— Data Window diplay.
plotchar(sCtf,   "Chart TF",      "", location.top, sCtf   > i_centerline ? i_c_bullBright : i_c_bearBright)
plotchar(sMtf,   "Medium TF",     "", location.top, sMtf   > i_centerline ? i_c_bullBright : i_c_bearBright)
plotchar(sHtf,   "Highest TF",    "", location.top, sHtf   > i_centerline ? i_c_bullBright : i_c_bearBright)
plotchar(signal, "Instant value", "", location.top, signal > i_centerline ? i_c_bullBright : i_c_bearBright)
plotchar(na,     "════════════",  "", location.top, na)

// ————— Hi/Lo channel
plot(i_showHiLoChannel ? channelHi : na, "Channel High")
plot(i_showHiLoChannel ? channelLo : na, "Channel Low")

// ————— Signal lines.
p_line1 = plot(line1, "Main Line", c_line1,   i_line1Width)
plot(line2, "Line 2", i_c_line2, i_line2Width)
plot(line3, "Line 3", i_c_line3, i_line3Width)

// ————— Center line.
hline(i_centerline, "Center Line", i_c_centerline, hline.style_dotted)

// ————— Divergences.
c_divLine = change(divLevel) ? color(na) : line1 > divLevel ? i_c_bullMedium : line1 < divLevel ? i_c_bearMedium : i_c_neutral
c_divFill = change(divLevel) ? color(na) : line1 > divLevel ? i_c_bullDark   : line1 < divLevel ? i_c_bearDark   : i_c_neutral
p_div = plot(i_showDivLevels ? divLevel : na, "Divergence Level", c_divLine)
fill(p_line1, p_div, c_divFill, 50)
plotchar(i_showDiv and div ? i_centerline : na, "Divergence", "•", location.absolute, i_c_centerline, size = size.tiny)

// ————— Markers.
markerUp = i_showMarkersBull and c_line1 == i_c_bullBright and c_line1[1] != i_c_bullBright
markerDn = i_showMarkersBear and c_line1 == i_c_bearBright and c_line1[1] != i_c_bearBright
plotchar(markerUp, "Marker Up", "▲", location.bottom, i_c_markerBull, size = size.tiny)
plotchar(markerDn, "Marker Dn", "▼", location.top,    i_c_markerBear, size = size.tiny)

// ————— Backtesting & Trading Engine external signal line.
plot(markerUp ? 2 : markerDn ? -2 : na, "BTE Signal", display = display.none)

// —————————— Background.
// ————— Function returning a bull/bear background color from one of the coloring conditions.
f_c_bgColorFromCondition(_condNo) =>
    // _condNo: color condition to evaluate.
    // Dependencies: f_conditionState(), i_c_backgroundBull, i_c_backgroundBear.
    _state = f_conditionState(_condNo, true)
    _state == 1 ? i_c_backgroundBull : _state == -1 ? i_c_backgroundBear : color(na)
// ————— Function returning a bull/bear color from the user-selected background coloring mode.
f_c_background(_userSelection) =>
    // _userSelection : background coloring type.
    // Dependencies : BGCx constants, f_getBgColorFromCondition(), i_c_backgroundBull, i_c_backgroundBear.
    _userSelection   == BGC1  ? f_c_bgColorFromCondition(1) :
      _userSelection == BGC2  ? f_c_bgColorFromCondition(2) :
      _userSelection == BGC3  ? f_c_bgColorFromCondition(3) :
      _userSelection == BGC4  ? f_c_bgColorFromCondition(4) :
      _userSelection == BGC5  ? f_c_bgColorFromCondition(5) :
      _userSelection == BGC6  ? f_c_bgColorFromCondition(6) :
      _userSelection == BGC7  ? f_c_bgColorFromCondition(7) :
      _userSelection == BGC8  ? f_c_bgColorFromCondition(8) :
      _userSelection == BGC9  ? f_c_bgColorFromCondition(9) :
      _userSelection == BGC10 ?     f_highVolatility() ? i_c_backgroundBull : color(na) :
      _userSelection == BGC11 ? not f_highVolatility() ? i_c_backgroundBull : color(na) : color(na)

bgcolor(f_c_background(i_bgColor))

// ————— Show warning or higher timeframes, if needed.
labelText = ""
if chartResInMinutes >= f_tfResInMinutes(mtf) or chartResInMinutes >= f_tfResInMinutes(htf)
    // Chart resolution is higher than one of the fixed TFs.
    labelText := "Chart\nresolution\nmust be < " + mtf + " and " + htf
else
    // Display higher timeframe values.
    if i_tfShow
        labelText := mtf + "\n" + htf
f_print(labelText, 0, color.silver, i_offsetTf)

// ————— When a higher TF signal kicks in, show a label indicating this.
f_higherTfIsUsed(_userSelection) => _userSelection == LIN1 or _userSelection == LIN3 or _userSelection == LIN4
var higherTfIsUsed = f_higherTfIsUsed(i_line1) or f_higherTfIsUsed(i_line2) or f_higherTfIsUsed(i_line3)
if higherTfIsUsed
    if na(sMtf[1]) and not na(sMtf)
        label.new(bar_index, i_centerline, mtf + "►", textcolor = i_c_centerline, style = label.style_none)
    else if na(sHtf[1]) and not na(sHtf)
        label.new(bar_index, i_centerline, htf + "►", textcolor = i_c_centerline, style = label.style_none)

// ————— Alert.
alertcondition(markerUp or markerDn, "Efficient Work", "Efficient Work")
// }