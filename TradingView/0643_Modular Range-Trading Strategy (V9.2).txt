// ========================================================================
// ⚠️免责声明 / Disclaimer ⚠️
//
// 本脚本仅用于学习和研究目的，不构成任何投资建议。
// 作者不参与任何实盘操作、不提供资金管理服务、亦不保证策略的盈利能力。
// 严禁将本脚本用于任何形式的募资、私募、非法投资或金融违法活动。
// 使用本脚本即表示使用者愿意承担全部交易风险和法律责任，作者不承担任何损失或法律责任。
//
// This script is for educational and research purposes only.
// The author does NOT provide investment advice, trading signals, or financial services.
// The use of this strategy in any form of fundraising, private placement, or illegal financial activity is strictly prohibited.
// Use at your own risk. The author is NOT responsible for any loss or legal consequences caused by the use of this script.
// ========================================================================

// FROST_quant
// 脚本名称: 模块化震荡行情策略 (V9.2 - 最终版 - 仓位互斥 + 同逻辑加仓 + 反弹确认)
// 用途: 震荡行情多空双吃
// 版本: Pine Script v6

//@version=6
strategy("模块化震荡行情策略 (V9.2)",
         shorttitle="震荡Pro_V9.2",
         overlay=true,
         initial_capital=1000,
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=300,
         commission_type=strategy.commission.percent,
         commission_value=0.075,
        // 关键: 允许在同一逻辑内加仓
         pyramiding=10,
         slippage=2)

// =================================================================================
// 0. 回测时间范围选择
// =================================================================================
string group_backtest = "回测时间范围"
i_startTime = input.time(timestamp("2023-01-01T00:00:00"), "回测开始时间", group=group_backtest)
i_endTime = input.time(timestamp("2025-12-31T23:59:59"), "回测结束时间", group=group_backtest)
time_condition = time >= i_startTime and time <= i_endTime

// =================================================================================
// *** K线确认设置 ***
// =================================================================================
string group_signal = "信号控制"
wait_for_close = input.bool(true, "等待K线收盘后发信号", group=group_signal, tooltip="开启后只在K线收盘时发出信号，避免未收盘时的虚假信号")

// =================================================================================
// 1. 通用指标参数
// =================================================================================
string group_indicators = "通用指标参数"
bb_len = input.int(20, title="布林带周期", group=group_indicators)
bb_stddev = input.float(2.0, title="布林带标准差", group=group_indicators)
rsi_len = input.int(14, title="RSI 周期", group=group_indicators)
rsi_ma_len = input.int(14, title="RSI 均线周期", group=group_indicators)
macd_fast = input.int(12, title="MACD 快速周期", group=group_indicators)
macd_slow = input.int(26, title="MACD 慢速周期", group=group_indicators)
macd_signal = input.int(9, title="MACD 信号线周期", group=group_indicators)
atr_len = input.int(14, title="ATR 周期", group=group_indicators)
adx_len = input.int(14, title="ADX 周期", group=group_indicators)

// =================================================================================
// 2. 逻辑 1: 动能确认均值回归 (震荡)
// =================================================================================
string group_logic1 = "逻辑1: 动能确认均值回归 (震荡)"
use_logic1 = input.bool(true, title="启用本逻辑", group=group_logic1)
adx_threshold_logic1 = input.float(40.0, "ADX 震荡阈值 (<)", group=group_logic1)
atr_multiplier_logic1 = input.float(1.8, "ATR 止损乘数", group=group_logic1, step=0.1)
use_bb_exit_logic1 = input.bool(true, "启用布林带对轨止盈", group=group_logic1)
use_rsi_exit_logic1 = input.bool(true, "启用RSI均线反转出场", group=group_logic1)

// =================================================================================
// 3. 逻辑 2: 布林带极限反转 (震荡)
// =================================================================================
string group_logic2 = "逻辑2: 布林带极限反转 (震荡)"
use_logic2 = input.bool(true, title="启用本逻辑", group=group_logic2)
rsi_ob_logic2 = input.int(80, "RSI 超买阈值", group=group_logic2)
rsi_os_logic2 = input.int(30, "RSI 超卖阈值", group=group_logic2)
adx_threshold_logic2 = input.float(35, "ADX 震荡阈值 (<)", group=group_logic2)
atr_multiplier_logic2 = input.float(1.8, "ATR 止损乘数", group=group_logic2, step=0.1)
use_bb_exit_logic2 = input.bool(true, "启用布林带中轨止盈", group=group_logic2)
use_rsi_exit_logic2 = input.bool(true, "启用RSI均线反转出场", group=group_logic2)

// =================================================================================
// 5. 指标与事件预计算
// =================================================================================
// ---- 基础指标计算 ----
[bb_middle, bb_upper, bb_lower] = ta.bb(close, bb_len, bb_stddev)
rsi = ta.rsi(close, rsi_len)
rsi_ma = ta.sma(rsi, rsi_ma_len)
[macd_line, signal_line, _] = ta.macd(close, macd_fast, macd_slow, macd_signal)
atr = ta.atr(atr_len)
[di_plus, di_minus, adx_value] = ta.dmi(adx_len, adx_len)

// ---- 震荡市场状态 (逻辑1 & 2) ----
is_ranging_market_logic1 = adx_value < adx_threshold_logic1
is_ranging_market_logic2 = adx_value < adx_threshold_logic2

// ---- 通用价格与指标事件 ----
price_below_bb_middle = close < bb_middle
price_above_bb_middle = close > bb_middle
// *** 恢复逻辑二最初的“反弹确认”信号 ***
price_crosses_back_above_lower = ta.crossover(close, bb_lower)
price_crosses_back_below_upper = ta.crossunder(close, bb_upper)
macd_golden_cross = ta.crossover(macd_line, signal_line)
macd_death_cross = ta.crossunder(macd_line, signal_line)
rsi_above_ma = rsi > rsi_ma
rsi_below_ma = rsi < rsi_ma

// ---- 通用出场事件 ----
exit_long_bb_upper_target = ta.crossover(close, bb_upper)
exit_short_bb_lower_target = ta.crossunder(close, bb_lower)
exit_long_bb_middle_target = ta.crossover(close, bb_middle)
exit_short_bb_middle_target = ta.crossunder(close, bb_middle)
exit_long_rsi_reversal = ta.crossunder(rsi, rsi_ma)
exit_short_rsi_reversal = ta.crossover(rsi, rsi_ma)

// ---- 基础绘图 ----
p_upper = plot(bb_upper, title="上轨", color=color.new(color.teal, 50))
plot(bb_middle, title="中轨", color=color.new(color.gray, 70))
p_lower = plot(bb_lower, title="下轨", color=color.new(color.teal, 50))
fill(p_upper, p_lower, color=color.new(color.teal, 95), title="通道填充")


// =================================================================================
// *** 核心修改: 仓位状态管理 (实现互斥且允许同逻辑加仓) ***
// =================================================================================
// 在每根K线开始时，检查当前是否有来自任一逻辑的持仓
var bool is_logic1_trade_active = false
var bool is_logic2_trade_active = false

is_logic1_trade_active := false
is_logic2_trade_active := false

if strategy.opentrades > 0
    for i = 0 to strategy.opentrades - 1
        string trade_id = strategy.opentrades.entry_id(i)
        if str.contains(trade_id, "逻辑1")
            is_logic1_trade_active := true
        if str.contains(trade_id, "逻辑2")
            is_logic2_trade_active := true

// =================================================================================
// A. 动态ATR止损位可视化 (分离颜色)
// =================================================================================
var float sl_level_l1 = na
var float sl_level_l2 = na

if is_logic1_trade_active
    sl_level_l1 := strategy.position_size > 0 ? (close - atr * atr_multiplier_logic1) : (close + atr * atr_multiplier_logic1)
else
    sl_level_l1 := na

if is_logic2_trade_active
    sl_level_l2 := strategy.position_size > 0 ? (close - atr * atr_multiplier_logic2) : (close + atr * atr_multiplier_logic2)
else
    sl_level_l2 := na

if strategy.position_size == 0
    sl_level_l1 := na
    sl_level_l2 := na

plot(sl_level_l1[1], title="逻辑1 ATR止损线", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)
plot(sl_level_l2[1], title="逻辑2 ATR止损线", color=color.new(color.orange, 0), style=plot.style_linebr, linewidth=2)

// =================================================================================
// *** K线确认条件 ***
// =================================================================================
bar_confirmed = wait_for_close ? barstate.isconfirmed : true

// =================================================================================
// 6. 入场逻辑模块化定义 (增加互斥条件)
// =================================================================================
// 逻辑一开仓条件: 当前不得有逻辑二的仓位 (is_logic2_trade_active为false)
logic1_long_condition = use_logic1 and not is_logic2_trade_active and bar_confirmed and is_ranging_market_logic1 and macd_golden_cross and rsi_above_ma and price_below_bb_middle
logic1_short_condition = use_logic1 and not is_logic2_trade_active and bar_confirmed and is_ranging_market_logic1 and macd_death_cross and rsi_below_ma and price_above_bb_middle

// 逻辑二开仓条件: 当前不得有逻辑一的仓位 (is_logic1_trade_active为false)
logic2_long_condition = use_logic2 and not is_logic1_trade_active and bar_confirmed and is_ranging_market_logic2 and price_crosses_back_above_lower and rsi <= rsi_os_logic2
logic2_short_condition = use_logic2 and not is_logic1_trade_active and bar_confirmed and is_ranging_market_logic2 and price_crosses_back_below_upper and rsi >= rsi_ob_logic2

// =================================================================================
// 8. 策略执行 (各逻辑独立)
// =================================================================================
// ---- 逻辑 1: 执行 ----
if (use_logic1 and time_condition)
    if (logic1_long_condition)
        strategy.entry("逻辑1多单", strategy.long, comment="开仓: 逻辑1-多单")
    if (logic1_short_condition)
        strategy.entry("逻辑1空单", strategy.short, comment="开仓: 逻辑1-空单")

    strategy.exit("ATR止损-逻辑1多", from_entry="逻辑1多单", stop=close - (atr * atr_multiplier_logic1))
    strategy.exit("ATR止损-逻辑1空", from_entry="逻辑1空单", stop=close + (atr * atr_multiplier_logic1))

    if (use_bb_exit_logic1)
        if (exit_long_bb_upper_target)
            strategy.close("逻辑1多单", comment="止盈: 逻辑1-布林带上轨")
        if (exit_short_bb_lower_target)
            strategy.close("逻辑1空单", comment="止盈: 逻辑1-布林带下轨")

    if (use_rsi_exit_logic1)
        // 恢复原始的、支持加仓的盈利判断逻辑
        if (is_logic1_trade_active and strategy.position_size > 0 and exit_long_rsi_reversal and price_above_bb_middle)
            float total_profit_L1_long = 0.0
            for i = 0 to strategy.opentrades - 1
                if str.contains(strategy.opentrades.entry_id(i), "逻辑1多单")
                    total_profit_L1_long += strategy.opentrades.profit(i)
            if (total_profit_L1_long > 0)
                strategy.close("逻辑1多单", comment="出场: 逻辑1-总体盈利且RSI反转")

        if (is_logic1_trade_active and strategy.position_size < 0 and exit_short_rsi_reversal and price_below_bb_middle)
            float total_profit_L1_short = 0.0
            for i = 0 to strategy.opentrades - 1
                if str.contains(strategy.opentrades.entry_id(i), "逻辑1空单")
                    total_profit_L1_short += strategy.opentrades.profit(i)
            if (total_profit_L1_short > 0)
                strategy.close("逻辑1空单", comment="出场: 逻辑1-总体盈利且RSI反转")

// ---- 逻辑 2: 执行 ----
if (use_logic2 and time_condition)
    if (logic2_long_condition)
        strategy.entry("逻辑2多单", strategy.long, comment="开仓: 逻辑2-多单")
    if (logic2_short_condition)
        strategy.entry("逻辑2空单", strategy.short, comment="开仓: 逻辑2-空单")

    strategy.exit("ATR止损-逻辑2多", from_entry="逻辑2多单", stop=close - (atr * atr_multiplier_logic2))
    strategy.exit("ATR止损-逻辑2空", from_entry="逻辑2空单", stop=close + (atr * atr_multiplier_logic2))

    if (use_bb_exit_logic2)
        if (exit_long_bb_middle_target)
            strategy.close("逻辑2多单", comment="止盈: 逻辑2-布林带中轨")
        if (exit_short_bb_middle_target)
            strategy.close("逻辑2空单", comment="止盈: 逻辑2-布林带中轨")

    if (use_rsi_exit_logic2)
        // 恢复原始的、支持加仓的盈利判断逻辑
        if (is_logic2_trade_active and strategy.position_size > 0 and exit_long_rsi_reversal and price_above_bb_middle)
            float total_profit_L2_long = 0.0
            for i = 0 to strategy.opentrades - 1
                if str.contains(strategy.opentrades.entry_id(i), "逻辑2多单")
                    total_profit_L2_long += strategy.opentrades.profit(i)
            if (total_profit_L2_long > 0)
                strategy.close("逻辑2多单", comment="出场: 逻辑2-总体盈利且RSI反转")

        if (is_logic2_trade_active and strategy.position_size < 0 and exit_short_rsi_reversal and price_below_bb_middle)
            float total_profit_L2_short = 0.0
            for i = 0 to strategy.opentrades - 1
                if str.contains(strategy.opentrades.entry_id(i), "逻辑2空单")
                    total_profit_L2_short += strategy.opentrades.profit(i)
            if (total_profit_L2_short > 0)
                strategy.close("逻辑2空单", comment="出场: 逻辑2-总体盈利且RSI反转")