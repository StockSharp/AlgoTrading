//@version=5
strategy("Parent Session Sweeps + Alert", overlay=true, initial_capital=100000, default_qty_value=1000, default_qty_type=strategy.cash, commission_type=strategy.commission.percent, commission_value=0.1)

// Group for Killzone Settings
g_KZS = "Killzone Settings"

// Session definitions and colors
as_am = input.session(title="Asia", defval="2000-0300", inline="ASKZ", group=g_KZS)
askz_color = input.color(color.new(color.blue, 0), "", inline="ASKZ", group=g_KZS)
lo_am = input.session(title="London", defval="0300-0830", inline="LOKZ", group=g_KZS)
ldkz_color = input.color(color.new(color.yellow, 0), "", inline="LOKZ", group=g_KZS)
ny_am = input.session(title="New York", defval="0830-1600", inline="NYKZ", group=g_KZS)
nykz_color = input.color(color.new(color.green, 0), "", inline="NYKZ", group=g_KZS)

// Input for enabling/disabling Killzone Ranges
show_kz = input.bool(true, "Show Killzone Ranges", group=g_KZS)
max_kz = input.int(5, "Maximum Killzone Ranges", minval=1, maxval=50, group=g_KZS)

// Display style selection
display_style = input.string("Filled Boxes", "Display Style", options=["Filled Boxes", "Lines"], group=g_KZS)

// Line style selection (only visible when "Lines" is selected)
line_style = input.string("Solid", "Line Style", options=["Solid", "Dotted", "Dashed"], group=g_KZS, tooltip="Only applicable when Display Style is set to Lines")

// Transparency for filled boxes
box_transp = input.int(85, "Box Transparency", minval=0, maxval=100, group=g_KZS)

// Timezone selection
timezone_kz_rg = input.string("America/New_York", "Timezone", options=["Chart", "America/New_York"], group=g_KZS)

// Add user input for risk-reward ratio and candle close filter
min_rr = input.float(1, "Minimum Risk-Reward Ratio", minval=0.1, step=0.1, group="Strategy Settings")
use_candle_filter = input.bool(true, "Use Candle Close Filter", group="Strategy Settings")

// Function to get session times in selected timezone
f_get_session_times(session_string) =>
    if (timezone_kz_rg == "Chart")
        time(timeframe.period, session_string)
    else
        time(timeframe.period, session_string, "America/New_York")

// Function to get line style
f_get_line_style() =>
    switch line_style
        "Solid" => line.style_solid
        "Dotted" => line.style_dotted
        "Dashed" => line.style_dashed

// New variables for parent session log
var float[] session_highs = array.new_float()
var float[] session_lows = array.new_float()
var float[] session_indices = array.new_float()
var bool confirmed_parent_session = false
var bool parent_session_swept = false
var float parent_session_high = na
var float parent_session_low = na
var int last_session_end = 0
var float interim_high = na
var float interim_low = na
var string setup_type = na
var float setup_entry = na
var float setup_stop = na
var float setup_target = na
var float sweep_high = na
var float sweep_low = na
var int inside_session_count = 0

// Variables to store most recent ended session values and their bar indices
var float current_ended_high = na
var float current_ended_low = na
var float current_ended_end = na

// Function to check if a session is within another session
f_is_within_session(inner_high, inner_low, outer_high, outer_low) =>
    inner_high <= outer_high and inner_low >= outer_low

// Function to process each session
f_process_session(session, color) =>
    session_time = f_get_session_times(session)
    var float session_high = na
    var float session_low = na
    var float session_start_index = na
    var line start_line = na
    var line end_line = na
    var box session_box = na

    var bool session_ended = false
    var float session_end_index = na

    if show_kz
        if (not session_time[1] and session_time)
            session_high := high
            session_low := low
            session_start_index := bar_index
            session_ended := false
            session_end_index := na

            if display_style == "Lines"
                start_line := line.new(bar_index, session_high, bar_index, session_low, color=color, width=2, style=f_get_line_style())
            else
                session_box := box.new(bar_index, session_high, bar_index, session_low, bgcolor=color.new(color, box_transp), border_color=color.new(color, 100))

        if session_time
            session_high := math.max(nz(session_high), high)
            session_low := math.min(nz(session_low), low)
            if display_style == "Lines"
                if not na(start_line)
                    line.set_y1(start_line, session_high)
                    line.set_y2(start_line, session_low)
            else if not na(session_box)
                box.set_right(session_box, bar_index)
                box.set_top(session_box, session_high)
                box.set_bottom(session_box, session_low)

        if (session_time[1] and not session_time)
            session_ended := true
            session_end_index := bar_index[1]
            if display_style == "Lines"
                end_line := line.new(bar_index[1], session_high, bar_index[1], session_low, color=color, width=2, style=f_get_line_style())

    [session_ended, session_high, session_low, session_start_index, session_end_index]


// Call the function for each session and store the results
[as_ended, as_high, as_low, as_start, as_end] = f_process_session(as_am, askz_color)
[lo_ended, lo_high, lo_low, lo_start, lo_end] = f_process_session(lo_am, ldkz_color)
[ny_ended, ny_high, ny_low, ny_start, ny_end] = f_process_session(ny_am, nykz_color)

// Function to safely get the last element of an array
f_get_last(arr) =>
    size = array.size(arr)
    size > 0 ? array.get(arr, size - 1) : na

// Determine the most recent ended session based on actual bar indices
if as_ended or lo_ended or ny_ended
    float latest_end = math.max(nz(as_end, 0), nz(lo_end, 0), nz(ny_end, 0))

    if latest_end == ny_end
        current_ended_high := ny_high
        current_ended_low := ny_low
        current_ended_end := ny_end
    else if latest_end == as_end
        current_ended_high := as_high
        current_ended_low := as_low
        current_ended_end := as_end
    else if latest_end == lo_end
        current_ended_high := lo_high
        current_ended_low := lo_low
        current_ended_end := lo_end


    // Only update arrays if this is a new session end
    float last_session_end = f_get_last(session_indices)
    if na(last_session_end) or current_ended_end > last_session_end
        array.push(session_highs, current_ended_high)
        array.push(session_lows, current_ended_low)
        array.push(session_indices, current_ended_end)

        // Update interim high and low
        interim_high := array.max(session_highs)
        interim_low := array.min(session_lows)

// New variables to track sweep and reclaim
var bool waiting_for_reclaim = false
var int sweep_bar_index = na

// New variables to track the extreme values after sweep
var float post_sweep_extreme = na

// New variables for tracking setups and success rates
var float[] bullish_setups = array.new_float()
var float[] bearish_setups = array.new_float()
var int bullish_successes = 0
var int bearish_successes = 0
var int total_bullish_setups = 0
var int total_bearish_setups = 0

// Debugging variables
var int total_sweeps = 0
var int total_reclaims = 0
var int total_setups = 0

// New variables for parent session lines
var line parent_high_line = na
var line parent_low_line = na

// Update the parent session swept logic
if confirmed_parent_session and not parent_session_swept
    if high > parent_session_high
        parent_session_swept := true
        sweep_high := high
        sweep_low := low
        setup_type := "Bearish"
        waiting_for_reclaim := true
        sweep_bar_index := bar_index
        post_sweep_extreme := high
        total_sweeps += 1
    else if low < parent_session_low
        parent_session_swept := true
        sweep_high := high
        sweep_low := low
        setup_type := "Bullish"
        waiting_for_reclaim := true
        sweep_bar_index := bar_index
        post_sweep_extreme := low
        total_sweeps += 1

    if na(parent_high_line)
        parent_high_line := line.new(bar_index, parent_session_high, bar_index, parent_session_high, color=color.red, width=1, style=line.style_solid)
    else
        line.set_x2(parent_high_line, bar_index)

    if na(parent_low_line)
        parent_low_line := line.new(bar_index, parent_session_low, bar_index, parent_session_low, color=color.green, width=1, style=line.style_solid)
    else
        line.set_x2(parent_low_line, bar_index)

// Update the extreme value while waiting for reclaim
if waiting_for_reclaim
    if setup_type == "Bearish"
        post_sweep_extreme := math.max(post_sweep_extreme, high)
    else if setup_type == "Bullish"
        post_sweep_extreme := math.min(post_sweep_extreme, low)

// Function to calculate risk-reward ratio
f_calc_rr(entry, stop, target) =>
    risk = math.abs(entry - stop)
    reward = math.abs(target - entry)
    reward / risk

// Function to check if a candle meets the filter criteria
f_candle_filter(is_bullish) =>
    if is_bullish
        close > open and (high - close) < (close - low)
    else
        close < open and (high - close) > (close - low)

// Check for reclaim and setup confirmation
if waiting_for_reclaim
    if (setup_type == "Bearish" and close <= parent_session_high) or (setup_type == "Bullish" and close >= parent_session_low)
        candle_filter_passed = use_candle_filter ? f_candle_filter(setup_type == "Bullish") : true

        if candle_filter_passed
            waiting_for_reclaim := false
            total_reclaims += 1
            setup_entry := close
            setup_stop := setup_type == "Bearish" ? post_sweep_extreme : post_sweep_extreme
            setup_target := setup_type == "Bearish" ? parent_session_low : parent_session_high

            rr_ratio = f_calc_rr(setup_entry, setup_stop, setup_target)

            if rr_ratio >= min_rr
                total_setups += 1

                // Create alert message
                alert_message = syminfo.ticker + " " + setup_type + " Setup\nEntry: " + str.tostring(setup_entry, "#.#####") + "\nStop: " + str.tostring(setup_stop, "#.#####") + "\nTarget: " + str.tostring(setup_target, "#.#####")
                alert(alert_message, alert.freq_once_per_bar_close)

                if setup_type == "Bullish"
                    array.push(bullish_setups, bar_index)
                    total_bullish_setups += 1
                    strategy.entry("Bullish", strategy.long, when = strategy.position_size == 0)
                    strategy.exit("Bullish Exit", "Bullish", stop=setup_stop, limit=setup_target)
                else
                    array.push(bearish_setups, bar_index)
                    total_bearish_setups += 1
                    strategy.entry("Bearish", strategy.short, when = strategy.position_size == 0)
                    strategy.exit("Bearish Exit", "Bearish", stop=setup_stop, limit=setup_target)

// Check for setup outcomes
if array.size(bullish_setups) > 0
    for i = array.size(bullish_setups) - 1 to 0
        setup_bar = array.get(bullish_setups, i)
        if bar_index > setup_bar
            if high >= setup_target
                bullish_successes += 1
                array.remove(bullish_setups, i)
            else if low <= setup_stop
                array.remove(bullish_setups, i)

if array.size(bearish_setups) > 0
    for i = array.size(bearish_setups) - 1 to 0
        setup_bar = array.get(bearish_setups, i)
        if bar_index > setup_bar
            if low <= setup_target
                bearish_successes += 1
                array.remove(bearish_setups, i)
            else if high >= setup_stop
                array.remove(bearish_setups, i)

// Calculate success rates
bullish_rate = total_bullish_setups > 0 ? (bullish_successes / total_bullish_setups) * 100 : 0
bearish_rate = total_bearish_setups > 0 ? (bearish_successes / total_bearish_setups) * 100 : 0

// Display dashboard with debugging info
var table dashboard = table.new(position.top_right, 2, 8, border_width=1)
table.cell(dashboard, 0, 0, "Bullish Success Rate", bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 1, 0, str.tostring(bullish_rate, "#.##") + "%", bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 0, 1, "Bearish Success Rate", bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 1, 1, str.tostring(bearish_rate, "#.##") + "%", bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 0, 2, "Total Sweeps", bgcolor=color.new(color.blue, 90), text_color=color.black)
table.cell(dashboard, 1, 2, str.tostring(total_sweeps), bgcolor=color.new(color.blue, 90), text_color=color.black)
table.cell(dashboard, 0, 3, "Total Bullish Setups", bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 1, 3, str.tostring(total_bullish_setups), bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 0, 4, "Total Bearish Setups", bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 1, 4, str.tostring(total_bearish_setups), bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 0, 5, "Bullish Successes", bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 1, 5, str.tostring(bullish_successes), bgcolor=color.new(color.green, 90), text_color=color.black)
table.cell(dashboard, 0, 6, "Bearish Successes", bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 1, 6, str.tostring(bearish_successes), bgcolor=color.new(color.red, 90), text_color=color.black)
table.cell(dashboard, 0, 7, "Total Setups", bgcolor=color.new(color.purple, 90), text_color=color.black)
table.cell(dashboard, 1, 7, str.tostring(total_bullish_setups + total_bearish_setups), bgcolor=color.new(color.purple, 90), text_color=color.black)

// Update the need_reset conditions
need_reset = inside_session_count > 4 or
             (not na(parent_session_high) and (interim_high > parent_session_high or interim_low < parent_session_low)) or
             (parent_session_swept and
              array.size(session_indices) > 0 and
              math.max(nz(as_start, 0), nz(lo_start, 0), nz(ny_start, 0)) > sweep_bar_index and
              bar_index > math.max(nz(as_start, 0), nz(lo_start, 0), nz(ny_start, 0)))

// Perform reset when needed
if need_reset
    array.clear(session_highs)
    array.clear(session_lows)
    array.clear(session_indices)
    confirmed_parent_session := false
    parent_session_swept := false
    waiting_for_reclaim := false
    parent_session_high := na
    parent_session_low := na
    setup_type := na
    setup_entry := na
    setup_stop := na
    setup_target := na
    sweep_high := na
    sweep_low := na
    inside_session_count := 0
    sweep_bar_index := na
    interim_high := na
    interim_low := na
    post_sweep_extreme := na
    line.delete(parent_high_line)
    line.delete(parent_low_line)
    parent_high_line := na
    parent_low_line := na

// After processing each session, check if we need to update parent session
if as_ended or lo_ended or ny_ended
    if not confirmed_parent_session and array.size(session_highs) >= 2
        latest_high = array.get(session_highs, array.size(session_highs) - 1)
        latest_low = array.get(session_lows, array.size(session_lows) - 1)
        prev_high = array.get(session_highs, array.size(session_highs) - 2)
        prev_low = array.get(session_lows, array.size(session_lows) - 2)

        if latest_high < prev_high and latest_low > prev_low
            confirmed_parent_session := true
            parent_session_high := prev_high
            parent_session_low := prev_low
        else
            // Remove the oldest session if not confirmed
            array.shift(session_highs)
            array.shift(session_lows)
            array.shift(session_indices)

    // Ensure we store only the last few sessions
    while array.size(session_highs) > max_kz
        array.shift(session_highs)
        array.shift(session_lows)
        array.shift(session_indices)