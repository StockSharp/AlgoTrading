//@version=5

strategy("Gann + Laplace Smoothed Hybrid Volume Spread Analysis","Gann LSHVSA Strategy [Algo Alert]", default_qty_type = "percent_of_equity",  default_qty_value=15)
import Celje_2300/aprox/1
import TradingView/ta/5

gannvzo = input.bool(true,"Gann vzo",inline = "showF4GannML")
gannentry = input.bool(false,"Gann entry",inline = "showF4GannML")
short = input.bool(false, "ir true: short ; else close")

close_all = input.bool(true,"Enable Close all", tooltip=" Position is always 1 or -1 if false, and 1, 0 or -1 if true. 0 Is falling above 0 or rising bellow 0")


DefaultGannMLSetting = "[Color][ChoCh Gann][ChoCh SGann]"
showF1GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")
showSF1GannML = true // input.bool(true,"F1", group = DefaultGannMLSetting,inline = "showF1GannML")
colorF1GannML = input.color(color.aqua, '', group = DefaultGannMLSetting,inline = "showF1GannML")
showChoChF1GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")
showChoChSF1GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")

showF2GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF2GannML")
showSF2GannML = true // input.bool(true,"F2", group = DefaultGannMLSetting,inline = "showF2GannML")
colorF2GannML = input.color(color.yellow, '', group = DefaultGannMLSetting,inline = "showF2GannML")
showChoChF2GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF2GannML")
showChoChSF2GannML = input.bool(false,"", group = DefaultGannMLSetting,inline = "showF2GannML")

showF3GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF3GannML")
showSF3GannML = true //
colorF3GannML = input.color(color.purple, '', group = DefaultGannMLSetting,inline = "showF3GannML")
showChoChF3GannML = input.bool(false,"", group = DefaultGannMLSetting,inline = "showF3GannML")
showChoChSF3GannML = false // input.bool(false,"", group = DefaultGannMLSetting,inline = "showF3GannML")


//  Credit to meomeo105 for writing the gann swing part

f_CalculateF0(_pointX,_pointY,arrayX0,arrayY0)=>
    array.unshift(arrayX0,_pointX)
    array.unshift(arrayY0,_pointY)
    [1]

f_CalculateFn1(_pointX,_pointY,arrayXn,arrayYn,arrayXFn1,arrayYFn1)=>
    //_resultdraw 2:Tiếp tục 1:Đảo chiều
    int _resultdraw = 0
    //OSB pha dinh/day
    if((array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and array.get(arrayYn,0) < array.get(arrayYFn1,1)) or (array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and array.get(arrayYn,0) > array.get(arrayYFn1,1)))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    //Dao chieu sang giam
    else if(array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and (array.get(arrayYn,0) < array.get(arrayYn,1) and array.get(arrayYn,0) < array.get(arrayYn,2) and array.get(arrayYn,1) < array.get(arrayYn,3)) and array.get(arrayYn,2) < array.get(arrayYn,3))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    //Dao chieu sang tang
    else if(array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and (array.get(arrayYn,0) > array.get(arrayYn,1) and array.get(arrayYn,0) > array.get(arrayYn,2) and array.get(arrayYn,1) > array.get(arrayYn,3)) and array.get(arrayYn,2) > array.get(arrayYn,3))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    else if(array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and _pointY >= array.get(arrayYFn1,0) and (_pointY >= array.get(arrayYFn1,0) or (array.get(arrayYn,0) > array.get(arrayYn,2) and array.get(arrayYn,2) > array.get(arrayYn,1)) or (array.get(arrayYn,0) > array.get(arrayYn,1) and array.get(arrayYn,1) > array.get(arrayYn,2) and array.get(arrayYn,2) > array.get(arrayYn,3))))
        array.set(arrayXFn1, 0, _pointX)
        array.set(arrayYFn1, 0, _pointY)
        _resultdraw := 2
    else if(array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and _pointY <= array.get(arrayYFn1,0) and (_pointY <= array.get(arrayYFn1,0) or (array.get(arrayYn,0) < array.get(arrayYn,2) and array.get(arrayYn,2) < array.get(arrayYn,1)) or (array.get(arrayYn,0) < array.get(arrayYn,1) and array.get(arrayYn,1) < array.get(arrayYn,2) and array.get(arrayYn,2) < array.get(arrayYn,3))))
        array.set(arrayXFn1, 0, _pointX)
        array.set(arrayYFn1, 0, _pointY)
        _resultdraw := 2
    [_resultdraw]

f_CalculateSFn1(_pointX,_pointY,_arrayMark,_mIdxMark,arraySXFn1,arraySYFn1)=>
    int _resultdraw = 0
    if(array.get(_arrayMark,_mIdxMark) == 0)
        if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY >= array.get(arraySYFn1,0)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY <= array.get(arraySYFn1,0)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            _resultdraw := 2
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            _resultdraw := 1
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,0) and _pointY > array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,0) and _pointY < array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            array.set(_arrayMark,_mIdxMark,_pointY)
            _resultdraw := 1
    else if(array.get(_arrayMark,_mIdxMark) > 0)
        if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            array.set(_arrayMark,_mIdxMark,0)
            _resultdraw := 1
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,2)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,2)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            array.set(_arrayMark,_mIdxMark,0)
            _resultdraw := 2
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY <= array.get(arraySYFn1,2) and _pointY >= array.get(arraySYFn1,0)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY >= array.get(arraySYFn1,2) and _pointY <= array.get(arraySYFn1,0)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            array.set(_arrayMark,_mIdxMark,_pointY)
            _resultdraw := 2

    [_resultdraw]

f_CalculateRemoveDuplicateLine(arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1)=>
    if(array.size(arrayLineX0) > 1 and array.size(arrayLineSX0) >1)
        if(array.get(arrayLineSY1,1) ==  array.get(arrayLineY1,1) and   array.get(arrayLineSY0,1) ==  array.get(arrayLineY0,1)   and array.get(arrayLineSX1,1) == array.get(arrayLineX1,1) and array.get(arrayLineSX0,1) ==array.get(arrayLineX0,1)     )
        //if(line.get_y1(array.get(arraySLine,1)) == line.get_y1(array.get(arrayLine,1)) and line.get_y2(array.get(arraySLine,1)) == line.get_y2(array.get(arrayLine,1))and line.get_x1(array.get(arraySLine,1)) == line.get_x1(array.get(arrayLine,1)) and line.get_x2(array.get(arraySLine,1)) == line.get_x2(array.get(arrayLine,1)))
            //line.delete(array.get(arrayLine,1))
            array.remove(arrayLineX0,1)
            array.remove(arrayLineY0,1)
            array.remove(arrayLineX1,1)
            array.remove(arrayLineY1,1)


f_CalculateChoCh(arraySXFn1,arraySYFn1) =>
    int _X = 0
    float _Y = 0
    // ChoCh Trường hợp chữ N ngược, chữ N
    if((array.get(arraySYFn1,3) > array.get(arraySYFn1,2) and array.get(arraySYFn1,3) < array.get(arraySYFn1,1) and array.get(arraySYFn1,0) < array.get(arraySYFn1,2)) or (array.get(arraySYFn1,3) < array.get(arraySYFn1,2) and array.get(arraySYFn1,3) > array.get(arraySYFn1,1) and array.get(arraySYFn1,0) > array.get(arraySYFn1,2)))
        _X := array.get(arraySXFn1,2)
        _Y := array.get(arraySYFn1,2)
    [_X,_Y]

f_CalculateDrawF(_drawF,_showSF,arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayX,arrayY,showChoCh,arrayMChoCh,idxChoCh,_color) =>
    if(_drawF > 0)
        if(_drawF == 1)
            array.unshift(arrayLineX0,array.get(arrayX,1))
            array.unshift(arrayLineY0,array.get(arrayY,1))
            array.unshift(arrayLineX1,array.get(arrayX,0))
            array.unshift(arrayLineY1,array.get(arrayY,0))

        else if(_drawF == 2 and array.size(arrayLineX0) >0)
            array.set(arrayLineX0,0,array.get(arrayX,0))
            array.set(arrayLineY0,0,array.get(arrayY,0))

        [XChoCh,YChoCh] = f_CalculateChoCh(arrayX,arrayY)
        if(showChoCh and YChoCh >0 and array.get(arrayMChoCh,idxChoCh) != YChoCh)
            array.set(arrayMChoCh,idxChoCh,YChoCh)
            //line.new(XChoCh,YChoCh,time,YChoCh, color = _color,xloc = xloc.bar_time,width = 1,style = line.style_dotted)

f_CalculateDrawSF(_drawSF,arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1,arraySX,arraySY,showChoCh,arrayMChoCh,idxChoCh,_color) =>
    if(_drawSF > 0)
        if(_drawSF == 1)
            array.unshift(arrayLineSX0,array.get(arraySX,1))
            array.unshift(arrayLineSY0,array.get(arraySY,1))
            array.unshift(arrayLineSX1,array.get(arraySX,0))
            array.unshift(arrayLineSY1,array.get(arraySY,0))
        else if(_drawSF == 2 and array.size(arrayLineSX0) >0)
            array.set(arrayLineSX0,0,array.get(arraySX,0))
            array.set(arrayLineSY0,0,array.get(arraySY,0))
        f_CalculateRemoveDuplicateLine(arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1)
        [XChoChS,YChoChS] = f_CalculateChoCh(arraySX,arraySY)
        if(showChoCh and YChoChS >0 and array.get(arrayMChoCh,idxChoCh) != YChoChS)
            array.set(arrayMChoCh,idxChoCh,YChoChS)
            //line.new(XChoChS,YChoChS,time,YChoChS, color = _color,xloc = xloc.bar_time,width = 1,style = line.style_dashed)

var arrayMarkGannML = array.new_float(3,0)
var arrayMarkChoChGannML = array.new_float(6,0)
var arrayXF0GannML = array.new_int(5,time)
var arrayYF0GannML = array.new_float(5,close)
var arrayXF1GannML = array.new_int(5,time)
var arrayYF1GannML = array.new_float(5,close)
var arrayLineXF1_0GannML = array.new_int()
var arrayLineYF1_0GannML = array.new_float()
var arrayLineXF1_1GannML = array.new_int()
var arrayLineYF1_1GannML = array.new_float()
var arrayLineF1GannML = array.new_line()
var arraySXF1GannML = array.new_int(5,time)
var arraySYF1GannML = array.new_float(5,close)
var arrayLineSXF1_0GannML = array.new_int()
var arrayLineSYF1_0GannML = array.new_float()
var arrayLineSXF1_1GannML = array.new_int()
var arrayLineSYF1_1GannML = array.new_float()
var arraySLineF1GannML = array.new_line()
var arrayXF2GannML = array.new_int(5,time)
var arrayYF2GannML = array.new_float(5,close)
var arrayLineXF2_0GannML = array.new_int()
var arrayLineYF2_0GannML = array.new_float()
var arrayLineXF2_1GannML = array.new_int()
var arrayLineYF2_1GannML = array.new_float()
var arrayLineF2GannML = array.new_line()
var arraySXF2GannML = array.new_int(5,time)
var arraySYF2GannML = array.new_float(5,close)
var arrayLineSXF2_0GannML = array.new_int()
var arrayLineSYF2_0GannML = array.new_float()
var arrayLineSXF2_1GannML = array.new_int()
var arrayLineSYF2_1GannML = array.new_float()

var arraySLineF2GannML = array.new_line()
var arrayXF3GannML = array.new_int(5,time)
var arrayYF3GannML = array.new_float(5,close)
var arrayLineXF3_0GannML = array.new_int()
var arrayLineYF3_0GannML = array.new_float()
var arrayLineXF3_1GannML = array.new_int()
var arrayLineYF3_1GannML = array.new_float()
var arrayLineF3GannML = array.new_line()
var arraySXF3GannML = array.new_int(5,time)
var arraySYF3GannML = array.new_float(5,close)
var arrayLineSXF3_0GannML = array.new_int()
var arrayLineSYF3_0GannML = array.new_float()
var arrayLineSXF3_1GannML = array.new_int()
var arrayLineSYF3_1GannML = array.new_float()
var arraySLineF3GannML = array.new_line()

f_CalculateAndDrawFn1(_pointX,_pointY) =>
    //F0 : Song cua nen
    array.unshift(arrayXF0GannML,_pointX)
    array.unshift(arrayYF0GannML,_pointY)
    //F1,F2,...: Song cua song theo Gann
    if(showF1GannML or showF2GannML or showF3GannML or showSF1GannML or showSF2GannML or showSF3GannML)
        [drawF1] = f_CalculateFn1(_pointX,_pointY,arrayXF0GannML,arrayYF0GannML,arrayXF1GannML,arrayYF1GannML)
        f_CalculateDrawF(showF1GannML?drawF1:0,showSF1GannML,arrayLineXF1_0GannML,arrayLineYF1_0GannML,arrayLineXF1_1GannML,arrayLineYF1_1GannML ,arrayXF1GannML,arrayYF1GannML,showChoChF1GannML,arrayMarkChoChGannML,0,colorF1GannML)
        if(drawF1 > 0 and (showF2GannML or showF3GannML or showSF1GannML or showSF2GannML or showSF3GannML))
            [drawSF1] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,0,arraySXF1GannML,arraySYF1GannML)
            f_CalculateDrawSF(showSF1GannML?drawSF1:0,arrayLineXF1_0GannML,arrayLineYF1_0GannML,arrayLineXF1_1GannML,arrayLineYF1_1GannML ,arrayLineSXF1_0GannML,arrayLineSYF1_0GannML,arrayLineSXF1_1GannML,arrayLineSYF1_1GannML ,arraySXF1GannML,arraySYF1GannML,showChoChSF1GannML,arrayMarkChoChGannML,1,colorF1GannML)
            if(drawSF1 > 0 and (showF2GannML or showF3GannML or showSF2GannML or showSF3GannML))
                [drawF2] = f_CalculateFn1(_pointX,_pointY,arraySXF1GannML,arraySYF1GannML,arrayXF2GannML,arrayYF2GannML)
                f_CalculateDrawF(showF2GannML?drawF2:0,showSF2GannML,arrayLineXF2_0GannML,arrayLineYF2_0GannML,arrayLineXF2_1GannML,arrayLineYF2_1GannML ,arrayXF2GannML,arrayYF2GannML,showChoChF2GannML,arrayMarkChoChGannML,2,colorF2GannML)
                if(drawF2 > 0 and (showF3GannML or showSF2GannML or showSF3GannML))
                    [drawSF2] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,1,arraySXF2GannML,arraySYF2GannML)
                    f_CalculateDrawSF(showSF2GannML?drawSF2:0,arrayLineXF2_0GannML,arrayLineYF2_0GannML,arrayLineXF2_1GannML,arrayLineYF2_1GannML ,arrayLineSXF2_0GannML,arrayLineSYF2_0GannML,arrayLineSXF2_1GannML,arrayLineSYF2_1GannML ,arraySXF2GannML,arraySYF2GannML,showChoChSF2GannML,arrayMarkChoChGannML,3,colorF2GannML)
                    if(drawSF2 > 0 and (showF3GannML or showSF3GannML))
                        [drawF3] = f_CalculateFn1(_pointX,_pointY,arraySXF2GannML,arraySYF2GannML,arrayXF3GannML,arrayYF3GannML)
                        f_CalculateDrawF(showF3GannML?drawF3:0,showSF3GannML,arrayLineXF3_0GannML,arrayLineYF3_0GannML,arrayLineXF3_1GannML,arrayLineYF3_1GannML,arrayXF3GannML,arrayYF3GannML,showChoChF3GannML,arrayMarkChoChGannML,4,colorF3GannML)
                        if(drawF3 > 0 and (showSF3GannML))
                            [drawSF3] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,2,arraySXF3GannML,arraySYF3GannML)
                            f_CalculateDrawSF(showSF3GannML?drawSF3:0,arrayLineXF3_0GannML,arrayLineYF3_0GannML,arrayLineXF3_1GannML,arrayLineYF3_1GannML,arrayLineSXF3_0GannML,arrayLineSYF3_0GannML,arrayLineSXF3_1GannML,arrayLineSYF3_1GannML,arraySXF3GannML,arraySYF3GannML,showChoChSF3GannML,arrayMarkChoChGannML,5,colorF3GannML)

f_CalculateAndDraw(_pointX,_pointY1,_pointY2) =>
    if((array.get(arrayYF0GannML,0) > _pointY1 and array.get(arrayYF0GannML,0) > _pointY2) or (array.get(arrayYF0GannML,0) < _pointY1 and array.get(arrayYF0GannML,0) < _pointY2))
        f_CalculateAndDrawFn1(time,array.get(arrayYF0GannML,1))
    f_CalculateAndDrawFn1(time,_pointY1)
    f_CalculateAndDrawFn1(time,_pointY2)

highPrev = high
lowPrev = low
if(true)
    if(high > highPrev[1] and low > lowPrev[1])
        f_CalculateAndDraw(time,low,high)
    else if(high < highPrev[1] and low < lowPrev[1])
        f_CalculateAndDraw(time,high,low)
    else if((high >= highPrev[1] and low < lowPrev[1]) or (high > highPrev[1] and low <= lowPrev[1]))
        if(close > open)
            f_CalculateAndDraw(time,low,high)
        else
            f_CalculateAndDraw(time,high,low)
    else if(high[0] <= highPrev[1] and low[0] >= lowPrev[1])
        highPrev := highPrev[1]
        lowPrev := lowPrev[1]
//plot(array.get(arrayMarkChoChGannML,1), color = colorF1GannML)
//plot(array.get(arrayMarkChoChGannML,1)[1], color =colorF1GannML )

//plot(array.get(arrayMarkChoChGannML,2), color = colorF2GannML)
//plot(array.get(arrayMarkChoChGannML,2)[1], color = colorF2GannML)
//plot(array.get(arrayMarkChoChGannML,3), color = colorF3GannML)
//plot(array.get(arrayMarkChoChGannML,3)[1], color =colorF3GannML)
//plot(array.get(arrayMarkChoChGannML,4))
//plot(array.get(arrayMarkChoChGannML,4)[1])



var aaa = true
var bbb = true
var eee = true
var fff = true
var a2 = true
var b2 = true
var a3 = true
var b3 = true


if array.get(arrayMarkChoChGannML,4) < array.get(arrayMarkChoChGannML,4)[1]
    aaa := true
    bbb := false
if array.get(arrayMarkChoChGannML,4) > array.get(arrayMarkChoChGannML,4)[1]
    aaa := false
    bbb := true

if array.get(arrayMarkChoChGannML,1) < array.get(arrayMarkChoChGannML,1)[1]
    eee := true
    fff := false
if array.get(arrayMarkChoChGannML,1) > array.get(arrayMarkChoChGannML,1)[1]
    eee := false
    fff := true

if array.get(arrayMarkChoChGannML,3) < array.get(arrayMarkChoChGannML,3)[1]
    a3 := true
    b3 := false
if array.get(arrayMarkChoChGannML,3) > array.get(arrayMarkChoChGannML,3)[1]
    a3 := false
    b3 := true

if array.get(arrayMarkChoChGannML,2) < array.get(arrayMarkChoChGannML,2)[1]
    a2 := true
    b2 := false
if array.get(arrayMarkChoChGannML,2) > array.get(arrayMarkChoChGannML,2)[1]
    a2 := false
    b2 := true

ccc = array.get(arrayMarkChoChGannML,0) != array.get(arrayMarkChoChGannML,0)[1] and array.get(arrayMarkChoChGannML,0) < high and ( array.get(arrayMarkChoChGannML,0) > close[1] ) and  ( fff or (bbb or b2 or b3)) ? true : false
ddd = array.get(arrayMarkChoChGannML,0) != array.get(arrayMarkChoChGannML,0)[1] and array.get(arrayMarkChoChGannML,0) > low and ( array.get(arrayMarkChoChGannML,0) < close[1] ) and (  eee or (aaa or a2 or a3)) ? true : false

var position_gann = 1
toggle = true //, "Stay in trade for longer.")

if ((ddd[0]   )and short   )
    //strategy.entry("short",strategy.short)
    //strategy.entry("short",strategy.short)
    position_gann := -1
if ((ccc or (((bbb and b2 and b3)) and toggle) ) and not (((ddd[0] and not short) or not (ccc or (((bbb and b2 and b3) and fff) and toggle))))  )
    //strategy.entry("long",strategy.long)
    position_gann := 1





if (((ddd[0] and not short) or not (ccc and not short or (((bbb and b2 and b3) and fff) and toggle))))
    //strategy.entry("short",strategy.short)
    //strategy.close_all()
    position_gann := 0





plot(position_gann , "gann_position" , display=display.status_line)

aproximation = input.bool(title = 'Double Fourier', tooltip="Improved Fourier Transform of Open&Close" ,defval = true, group = "Source")
smoothed_volume = input.bool(title = 'Smoothed Volume', tooltip="Vomume is dynamically EMA smoothed over last X days." ,defval = true, group = "Source")

maxEmaLength=input.int(12,title = 'Smoothed Volume Length', tooltip="Smooth Volume over last X days." , group = "Source")
v= smoothed_volume ? volume/aprox.smooth(aprox.FFT(volume),src = volume[1], maxEmaLength = maxEmaLength) : volume/ volume[1]

lenth=input.int(10,title = 'Volume*Source Smoothing', tooltip="Ema of Source*Volume of last X days." , group = "Calculations")
malenth=input.int(20,title = 'Smoothed Volume Length', tooltip="Ema of Close*Volume - Open*Volume of last X days." , group = "Calculations")

var lenth1 = lenth -  position_gann

if position_gann != position_gann[1]
    lenth1 /= 2

lenth1 := math.min(lenth1 + math.abs(position_gann),lenth)

src = aproximation ? (aprox.DTF32(close)) : close
mac = ta.ema2(src,gannvzo ? lenth1 : lenth +  position_gann) //mac = aprox.smooth(volume,src = src,minEmaLength = lenth, maxEmaLength2 = 12) //maxEmaLength2 = input(12)
vmac=mac*v


src_0 =  aproximation ? (aprox.DTF32(open)) : open
mao = ta.ema2(src_0, gannvzo ? lenth1 : lenth+  position_gann) //mao = aprox.smooth(volume,src = src_0,minEmaLength = lenth, maxEmaLength2 = 12)//maxEmaLength2 = input(12)
vmao=mao*v


vd=vmac-vmao
plot(vd, color = vd<0?color.red:color.green, style = plot.style_columns)


vdma= ta.ema(vd,malenth)
plot(vdma, color=color.rgb(0, 0, 0, 52), linewidth=2, style = plot.style_area)
plot(vdma, color=vdma>0?color.rgb(23, 235, 4, 81):color.rgb(133, 4, 4, 75), linewidth=2, style = plot.style_area)
hline(0)


longCondition= vdma > 0  and vd > 0
shortCondition = vdma < 0  and vd <0

var pos = 0
var long = 0

if longCondition
    pos := 1
    long := 1
    strategy.entry("long",strategy.long)

if shortCondition
    pos := -1
    long := -1
    strategy.entry("short",strategy.short)


if not longCondition and not shortCondition and close_all and (position_gann == 0 or not gannentry)
    pos := 0
    strategy.close_all()

plotchar(longCondition and long[1]==-1 ? -math.max(vd[1],vd[2],vd[3],vd[4],vd[5],vd[6],vd[7],vd[8],vd[9],vd[10],vd[11],vd[12],vd[13],vd[14],vd[15],vd[16],vd[17],vd[18],vd[19],mac/100) : na, char = "▲", color = color.rgb(0, 255, 187,40), location = location.absolute, size = size.tiny, display=display.pane)
plotchar(shortCondition  and long[1]==1 ? -math.min(vd[1],vd[2],vd[3],vd[4],vd[5],vd[6],vd[7],vd[8],vd[9],vd[10],vd[11],vd[12],vd[13],vd[14],vd[15],vd[16],vd[17],vd[18],vd[19],-mac/100)  : na, char = "▼", color = color.rgb(255, 17, 0, 40), location = location.absolute, size = size.tiny, display=display.pane)

plot(close, title="ClosePrice", display=display.status_line)
plot(open, title="OpenPrice", display=display.status_line)
plot(pos, color = longCondition ? color.rgb(9, 232, 173, 50) : shortCondition ? color.rgb(255, 17, 0, 50) : color.rgb(100, 100, 100), title="position", display=display.status_line)