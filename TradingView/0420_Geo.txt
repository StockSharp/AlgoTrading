//@version=6
// @description This library provides a comprehensive set of geometric functions and types, including point and line manipulation, vector operations, angle calculations, and polygon analysis. It offers tools for creating, transforming, and analyzing geometric shapes and their relationships.
library("geo")

// #############################################################################
// ## Types Definitions
// #############################################################################

// @type A Point, can be used for vector, floating calcs, etc. Use the cp method for plots
// @field x (float)              -The x-coordinate
// @field y (float)              -The y-coordinate
// @field a (float)              -An Angle storage spot
// @field v (float)              -A Value
// @field cp (chart.point)       -The chart point for plotting
export type Point
    float       x  = 0.0
    float       y  = 0.0
    float       a  = 0.0
    float       v  = 0.0

// @type Line
// @field point (Point) - The starting point of the line
// @field slope (float) - The slope of the line
// @field line_color (color) - The color of the line
export type Line
    Point point
    float slope
    color line_color = #cccccc

// @type Polygon
// @field points (array<Point>) - The array of points that make up the polygon
// @field line_olor (color)     - The color of the polygon
// @field fill_olor (color)     - The optional fill color of the polygon
export type Polygon
    array<Point> points
    color line_color = #cccccc
    color fill_color = #cccccc

// @type Circle
// @field center (Point) - The center point of the circle
// @field radius (float) - The radius of the circle
// @field line_color (color) - The color of the circle
// @field fill_color (color) - The optional fill color of the circle
export type Circle
    Point center
    float radius     = 50
    color line_color = #cccccc
    color fill_color = #cccccc

// @enum Sort - Choose Sorting Method
// @field X         - sorted by x coord
// @field Y         - sorted by y coord
// @field UP        - sorted by Bottom left to top right
// @field DOWN      - sorted by Top right to bottom Left
// @field DISTANCE  - sorted by distance from an Input Point
export enum Sort
    X         = "x"
    Y         = "y"
    UP        = "up"
    DOWN      = "down"
    DISTANCE  = "distance"

// @function Square root function
// @param   value (float)        -The number to take the square root of
// @returns (float)              -The square root of the input value
export method sqrt(float value) =>
    math.sqrt(value)

// @function Square function
// @param x (float)              -The number to square
// @returns (float)              -The square of the input value
export method sqr(float x) =>
    x * x

// @function Cosine function
// @param v (series float)       -The value to find the cosine of
// @returns (series float)       -The cosine of the input value
export method cos(series float v) =>
    math.cos(v)

// @function Sine function
// @param v (series float)       -The value to find the sine of
// @returns (series float)       -The sine of the input value
export method sin(series float v) =>
    math.sin(v)

// @function Tangent function
// @param v (series float)       -The value to find the tangent of
// @returns (series float)       -The tangent of the input value
export method tan(series float v) =>
    math.tan(v)

// @function Arc cosine function
// @param v (series float)       -The value to find the arc cosine of
// @returns (series float)       -The arc cosine of the input value
export method acos(series float v) =>
    math.acos(v)

// @function Arc sine function
// @param v (series float)       -The value to find the arc sine of
// @returns (series float)       -The arc sine of the input value
export method asin(series float v) =>
    math.asin(v)

// @function Arc tangent function
// @param v (series float)       -The value to find the arc tangent of
// @returns (series float)       -The arc tangent of the input value
export method atan(series float v) =>
    math.atan(v)

// @function atan2 function
// @param   dy (float)           -The y-coordinate
// @param   dx (float)           -The x-coordinate
// @returns (float)              -The angle in radians
export method atan2(float dy, float dx) =>
    a = 0.0
    if math.abs(dx) > math.abs(dy)
        a := math.atan(dy / dx)
    else
        a := math.atan(dx / dy)
        if a < 0
            a := -math.pi / 2 - a
        else
            a := math.pi / 2 - a

    if dx < 0 and dy < 0
        a -= math.pi
    else if dx < 0
        a += math.pi
    a

// @function Absolute distance between any two float values
// @param _value1 First value
// @param _value2 Second value
// @returns Absolute Positive Distance
export method gap(float _value1, float __value2) =>
    math.abs(_value1 - __value2)

// @function Check if the ratio is within the tolerance of the golden ratio
// @param a (float)              -The first number
// @param b (float)              -The second number
// @param tolerance (float)      -The tolerance percennt as 1 = 1 percent
// @returns (bool)               -True if the ratio is within the tolerance, false otherwise
export method phi_tol(float a, float b, float tolerance) =>
    lo_phi = math.phi * (1 - tolerance / 100)
    hi_phi = math.phi * (1 + tolerance / 100)
    r      = b / a
    (r > lo_phi and r < hi_phi)

// @function frad Fractional
// @param   x (float)            -The number to convert to fractional
// @returns (float)              -The number converted to fractional
export method frac(float x) =>
    x % (math.pi * 2)

// @function limiting int to hold the value within the chart range
// @param   x (float)            -The number to limit
// @returns (int)                -The number limited to the chart range
export method safeindex(float x, int limit = 4999) =>
    first = last_bar_index - limit
    math.round(math.max(1, first, math.min(last_bar_index + 490, x)))

// @function limiting int check if within the chartplottable range
// @param   x (float)            -The number to limit
// @returns (int)                -The number limited to the chart range
export method safecheck(float x, int limit = 4999) =>
    first = last_bar_index - limit
    (x > math.max(1, first)) and (x < last_bar_index + 498)

// @function interpolate between two values
// @param   a (float)            -The first value
// @param   b (float)            -The second value
// @param   t (float)            -The interpolation factor (0 to 1)
// @returns (float)              -The interpolated value
export method interpolate(float a, float b, float t) =>
    a * t + (1 - t) * b

// @function interpolate x/y/a/v between two points
// @param   a (Point)            -The first Point
// @param   b (Point)            -The second Point
// @param   t (float)            -The interpolation factor (0 to 1)
// @returns (float)              -The interpolated Point
export method interpolate(Point a, Point b, float t) =>
    x  = a.x * t + (1 - t) * b.x
    y  = a.y * t + (1 - t) * b.y
    _a = a.a * t + (1 - t) * b.a
    _v = a.v * t + (1 - t) * b.v
    Point.new(x, y, _a, _v)

// @function Greatest common divisor of two ints
// @param a (int)                -The first int
// @param b (int)                -The second int)
// @returns (int)                -The greatest commdivisor
export method gcd(int _numerator, int _denominator) =>
    _greatestCommon = _numerator
    _den            = _denominator
    _swap           = _den
    while _den            != 0
        _greatestCommon %= _den
        _swap           := _den
        _den            := _greatestCommon
        _greatestCommon := _swap
    _greatestCommon

// @function Least common multiple of two ints
// @param a (int)                -The first int
// @param b (int)                -The second int
// @returns (int)                -The least common multiple
export method lcm(int a, int b) =>
    math.abs(a * b) / gcd(a, b)

// @function Set the x value of the point, and pass point for chaining
// @param self (Point)           -The point to modify
// @param value (float)          -The new x-coordinate
export method set_x(Point self, float value) =>
    self.x := value
    self

// @function Set the y value of the point, and pass point for chaining
// @param self (Point)           -The point to modify
// @param value (float)          -The new y-coordinate
export method set_y(Point self, float value) =>
    self.y := value
    self

// @function Get the x value of the point
// @param self (Point)           -The point to get the x-coordinate from
// @returns (float)              -The x-coordinate
export method get_x(Point self) =>
    self.x

// @function Get the y value of the point
// @param self (Point)           -The point to get the y-coordinate from
// @returns (float)              -The y-coordinate
export method get_y(Point self) =>
    self.y

// @function Lowest element of the point
// @param self (Point)           -The point
// @returns (float)              -The lowest value between x and y
export method vmin(Point self) =>
    math.min(self.x, self.y)

// @function Highest element of the point
// @param self (Point)           -The point
// @returns (float)              -The highest value between x and y
export method vmax(Point self) =>
    math.max(self.x, self.y)

// @function Addition
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (Point)              -the add of the two points
export method add(Point p1, Point p2) =>
    Point.new(p1.x + p2.x, p1.y + p2.y)

// @function Subtraction
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (Point)              -the sub of the two points
export method sub(Point p1, Point p2) =>
    Point.new(p1.x - p2.x, p1.y - p2.y)

// @function Multiplication by scalar
// @param p (Point)              -The point
// @param scalar (float)         -The scalar to multiply by
// @returns (Point)              -the multiplied point of the point and the scalar
export method mul(Point p, float scalar) =>
    Point.new(p.x * scalar, p.y * scalar)

// @function Division by scalar
// @param p (Point)              -The point
// @param scalar (float)         -The scalar to divide by
// @returns (Point)              -the divided point of the point and the scalar
export method div(Point p, float scalar) =>
    Point.new(p.x / scalar, p.y / scalar)

// @function Rotate a point around the origin by an angle (in degrees)
// @param p (Point)              -The point to rotate
// @param angle (float)          -The angle to rotate by in degrees
// @returns (Point)              -the rotated point
export method rotate(Point p, float angle) =>
    rad  = math.toradians(angle)
    xNew = p.x * math.cos(rad) - p.y * math.sin(rad)
    yNew = p.x * math.sin(rad) + p.y * math.cos(rad)
    Point.new(xNew, yNew)

// @function Length of the vector from (x = 0, y = 0) to the point
// @param p (Point)              -The point
// @returns (float)              -the length of the point
export method length(Point p) =>
    math.sqrt(p.x * p.x + p.y * p.y)

// @function Length squared of the vector
// @param p (Point)              -The point
// @returns (float)              -The squared length of the point
export method length_squared(Point p) =>
    p.x * p.x + p.y * p.y

// @function Normalize the point to a unit vector
// @param p (Point)              -The point to normalize
// @returns (Point)              -the normalized point
export method normalize(Point p) =>
    len_sq = p.length_squared()
    if len_sq > 0
        len = math.sqrt(len_sq)
        p.div(len)
    else
        p

// @function Dot product
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (float)              -the dot of the two points
export method dot(Point p1, Point p2) =>
    p1.x * p2.x + p1.y * p2.y

// @function Cross product result (in 2D, this is a scalar)
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (float)              -the cross of the two points
export method cross(Point p1, Point p2) =>
    p1.x * p2.y - p1.y * p2.x

// @function Distance between two points
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (float)              -the distance of the two points
export method distance(Point p1, Point p2) =>
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    math.sqrt(dx * dx + dy * dy)

// @function Angle between two points in degrees
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (float)              -the angle of the first point and the second point
export method angle(Point p1, Point p2) =>
    math.todegrees(atan2(p1.cross(p2), p1.dot(p2)))

// @function Angle between two points in degrees from a pivot point
// @param p (Point)              -The point to calculate the angle from
// @param pivot (Point)          -The pivot point
// @param other (Point)          -The other point
// @returns (float)              -the angle between the two points
export method angle_between(Point p, Point pivot, Point other) =>
    p.sub(pivot).angle(other.sub(pivot))

// @function Translate a point from one origin to another
// @param p (Point)              -The point to translate
// @param from_origin (Point)    -The origin to translate from
// @param to_origin (Point)      -The origin to translate to
// @returns (Point)              -the translated point
export method translate(Point p, Point from_origin, Point to_origin) =>
    p.add(to_origin.sub(from_origin))

// @function Midpoint of two points
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (Point)              -The midpoint of the two points
export method midpoint(Point p1, Point p2) =>
    Point.new((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)

// @function Rotate a point around a pivot point by an angle (in degrees)
// @param p (Point)              -The point to rotate
// @param angle (float)          -The angle to rotate by in degrees
// @param pivot (Point)          -The pivot point to rotate around
// @returns (Point)              -the rotated point
export method rotate_around(Point p, float angle, Point pivot) =>
    pivot.add(p.sub(pivot).rotate(angle))

// @function Multiply vector _a with _b
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (Point)              -The result of the multiplication
export method multiply(Point _a, Point _b) =>
    Point.new(_a.x * _b.x, _a.y * _b.y)

// @function Divide vector _a by _b
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (Point)              -The result of the division
export method divide(Point _a, Point _b) =>
    Point.new(_a.x / _b.x, _a.y / _b.y)

// @function Negative of vector _a
// @param _a (Point)             -The point to negate
// @returns (Point)              -The negated point
export method negate(Point _a) =>
    Point.new(0, 0).sub(_a)

// @function Perpendicular Vector of _a
// @param _a (Point)             -The point
// @returns (Point)              -The perpendicular point
export method perp(Point _a) =>
    Point.new(_a.y, -_a.x)

// @function Compute the floor of argument vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The floor of the point
export method vfloor(Point _a) =>
    Point.new(math.floor(_a.x), math.floor(_a.y))

// @function Compute the fractional part of the elements from vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The fractional part of the point
export method fractional(Point _a) =>
    Point.new(frac(_a.x), frac(_a.y))

// @function Compute the sine of argument vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The sine of the point
export method vsin(Point _a) =>
    Point.new(math.sin(_a.x), math.sin(_a.y))

// @function Compute the absolute of argument vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The absolute of the point
export method vabs(Point _a) =>
    Point.new(math.abs(_a.x), math.abs(_a.y))

// @function Compute the mod of argument vector _a
// @param _a (Point)             -The point
// @param _b (float)             -The mod
// @returns (Point)              -The mod of the point
export method vmod(Point _a, float _b) =>
    Point.new(_a.x % _b, _a.y % _b)

// @function Compute the sign of argument vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The sign of the point
export method vsign(Point _a) =>
    Point.new(math.sign(_a.x), math.sign(_a.y))

// @function Compute the round of argument vector _a
// @param _a (Point)             -The point
// @returns (Point)              -The round of the point
export method vround(Point _a) =>
    Point.new(math.round(_a.x), math.round(_a.y))

// @function normalizes the y value of a point to an input height
// @param p (Point)              -The point to normalize
// @param height (float)         -The height to normalize to
// @returns (Point)              -the normalized point
export method normalize_y(Point p, float height) =>
    new_point    = p.normalize()
    new_point.y := -p.y * (1 - 1 / ((height / 2 - math.abs(p.y)) / (height / 2)))
    new_point.x := p.x
    new_point

// @function Calculate the centroid of multiple points
// @param points (array<Point>)  -The array of points
// @returns (Point)              -The centroid point
export method centroid(array<Point> points) =>
    sum_x = 0.0
    sum_y = 0.0
    for p in points
        sum_x += p.x
        sum_y += p.y
    Point.new(sum_x / points.size(), sum_y / points.size())

// @function Random Point in a given height and width
// @param _height (float)        -The height of the area to generate the point in
// @param _width (float)         -The width of the area to generate the point in
// @param _origin (Point)        -The origin of the area to generate the point in (default: na, will create a Point(0, 0))
// @param _centered (bool)       -Center the origin point in the area, otherwise, positive h/w (default: false)
// @returns (Point)              -The random point in the given area
export method random_point(float _height, float _width, Point _origin = na, bool _centered = false) =>
    origin = na(_origin) ? Point.new(0.0, 0.0) : _origin // Handle na origin
    base_x = origin.x - (_centered ? _width / 2 : 0)
    base_y = origin.y - (_centered ? _height / 2 : 0)
    Point.new(math.random(base_x, base_x + _width), math.random(base_y, base_y + _height))


// @function Random Point Array in a given height and width
// @param _height (float)        -The height of the area to generate the array
// @param _width (float)         -The width of the area to generate the array
// @param _origin (Point)        -The origin of the area to generate the array (default: na, will create a Point(0, 0))
// @param _centered (bool)       -Center the origin point in the area, otherwise, positive h/w (default: false)
// @param _count (int)           -The number of points to generate (default: 50)
// @returns (array<Point>)       -The random point array in the given area
export method random_point_array(Point _origin, float _height = na, float _width = 100, bool _centered = false, int _count = 50) =>
    height      = nz(_height, 100)
    origin_safe = na(_origin) ? Point.new(0.0, 0.0) : _origin
    width_safe  = _width
    height_safe = height

    _points = array.new<Point>()
    base_x = origin_safe.x - (_centered ? width_safe  / 2 : 0)
    base_y = origin_safe.y - (_centered ? height_safe / 2 : 0)

    for _i = 0 to _count - 1
        _points.push(Point.new(math.random(base_x, base_x + width_safe), math.random(base_y, base_y + height_safe)))
    _points


// @function sort - Sorts an array of Point UDTs based on the specified sort mode.
// @param points (array<Point>) The array of Point UDTs to be sorted.
// @param sort_mode (Sort) The sorting mode (default: Sort.X).
//     - Sort.X: Sorts points based on their x-coordinates.
//     - Sort.Y: Sorts points based on their y-coordinates.
//     - Sort.UP: Sorts points diagonally from bottom-left to top-right.
//     - Sort.DOWN: Sorts points diagonally from top-left to bottom-right.
//     - Sort.DISTANCE: Sorts points based on their distance from the origin_point.
// @param origin_point (Point) Optional origin point for distance sorting. If missing, defaults to the center of the points array.
// @returns (array<Point>) A new array containing the sorted Point UDTs.
export method sort_points(array<Point> points, Sort sort_mode, bool reverse = false, Point origin_point = na) =>
    sorted = switch sort_mode
        Sort.X =>
            // Sort by X coordinate
            sort_values = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values.set(i, points.get(i).x)
            sorted_indices = sort_values.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points
        Sort.Y =>
            // Sort by Y coordinate
            sort_values = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values.set(i, points.get(i).y)
            sorted_indices = sort_values.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points
        Sort.UP =>
            // Sort diagonally from bottom-left to top-right (increasing x+y)
            sort_values_combined = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values_combined.set(i, points.get(i).x + points.get(i).y) // Sum of x and y for diagonal sort
            sorted_indices = sort_values_combined.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points
        Sort.DOWN =>
            // Sort diagonally from top-left to bottom-right (increasing x-y)
            sort_values_combined = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values_combined.set(i, points.get(i).x - points.get(i).y) // Difference of x and y for diagonal sort
            sorted_indices = sort_values_combined.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points
        Sort.DISTANCE =>
            // Sort by distance from origin_point
            origin_point_safe = na(origin_point) ? centroid(points) : origin_point // Use centroid if origin not provided
            sort_values_distance = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values_distance.set(i, points.get(i).distance(origin_point_safe))
            sorted_indices = sort_values_distance.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points

        => // Default case: Sort.X (if sort_mode is not recognized or missing)
            sort_values = array.new<float>(points.size())
            for i = 0 to points.size() - 1
                sort_values.set(i, points.get(i).x)
            sorted_indices = sort_values.sort_indices()
            sorted_points  = array.new<Point>(points.size())
            for i = 0 to sorted_indices.size() - 1
                sorted_points.set(i, points.get(sorted_indices.get(i)))
            sorted_points
    if reverse
        sorted.reverse()
    sorted

// @function Sorts an array of points by x or y coordinate
// @param points (array<Point>)  -The array of points to sort
// @param by_x (bool)            -Whether to sort by: true for x, false for y
// @returns (array<Point>)       -The sorted array of points
export method sort_points(array<Point> points, bool by_x = true) =>
    sort_values = array.new<float>(points.size())
    for i = 0 to points.size() - 1
        sort_values.set(i, by_x ? points.get(i).x : points.get(i).y)
    sorted_indices = sort_values.sort_indices()
    sorted_points  = array.new<Point>(points.size())
    for i = 0 to sorted_indices.size() - 1
        sorted_points.set(i, points.get(sorted_indices.get(i)))
    sorted_points

// @function Compares two points for equality
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (bool)               -True if the points are equal, false otherwise
export method equals(Point _a, Point _b) =>
    _a.x == _b.x and _a.y == _b.y

// @function Maximum of two points from origin, using dot product
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (Point)              -The maximum point
export method max(Point origin, Point _a, Point _b) =>
    p1 = origin.dot(_a)
    p2 = origin.dot(_b)
    p1 > p2 ? _a : _b

// @function Minimum of two points from origin, using dot product
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (Point)              -The minimum point
export method min(Point origin, Point _a, Point _b) =>
    p1 = origin.dot(_a)
    p2 = origin.dot(_b)
    p1 < p2 ? _a : _b

// @function Average x of point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The average x-coordinate
export method avg_x(array<Point> points) =>
    sum = 0.0
    for p in points
        sum += p.x
    points.size() > 0 ? sum / points.size() : 0.0 // Avoid division by zero

// @function Average y of point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The average y-coordinate
export method avg_y(array<Point> points) =>
    sum = 0.0
    for p in points
        sum += p.y
    points.size() > 0 ? sum / points.size() : 0.0 // Avoid division by zero

// @function Range of x values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The range of x-coordinates
export method range_x(array<Point> points) =>
    if points.size() == 0
        0.0
    else
        vals = array.new<float>()
        for p in points
            vals.push(p.x)
        vals.range()

// @function Range of y values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The range of y-coordinates
export method range_y(array<Point> points) =>
    if points.size() == 0
        0.0
    else
        vals = array.new<float>()
        for p in points
            vals.push(p.y)
        vals.range()

// @function max of x values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The max of x-coordinates
export method max_x(array<Point> points) =>
    min_val = points.size() > 0 ? points.get(0).x : na
    if points.size() > 1
        for i = 1 to points.size() - 1
            min_val := math.min(min_val, points.get(i).x)
    min_val

// @function min of x values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The min of x-coordinates
export method min_x(array<Point> points) =>
    max_val = points.size() > 0 ? points.get(0).x : na
    if points.size() > 1
        for i = 1 to points.size() - 1
            max_val := math.max(max_val, points.get(i).x)
    max_val

// @function min of y values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The min of y-coordinates
export method min_y(array<Point> points) =>
    min_val = points.size() > 0 ? points.get(0).y : na
    if points.size() > 1
        for i = 1 to points.size() - 1
            min_val := math.min(min_val, points.get(i).y)
    min_val

// @function max of y values in point array
// @param points (array<Point>)  -The array of points
// @returns (float)              -The max of y-coordinates
export method max_y(array<Point> points) =>
    max_val = points.size() > 0 ? points.get(0).y : na
    if points.size() > 1
        for i = 1 to points.size() - 1
            max_val := math.max(max_val, points.get(i).y)
    max_val

// @function Scale a point by a scalar
// @param _a (Point)             -The point to scale
// @param _scalar (float)        -The scalar value
// @returns (Point)              -The scaled point
export method scale(Point _a, float _scalar) =>
    Point.new(_a.x * _scalar, _a.y * _scalar)

// @function Rescale a point to a new magnitude
// @param _a (Point)             -The point to rescale
// @param _length (float)        -The new magnitude
// @returns (Point)              -The rescaled point
export method rescale(Point _a, float _length) =>
    len = _a.length()
    _scalar = len == 0.0 ? 0.0 : _length / len
    _a.scale(_scalar)

// @function Rotate a point by an angle in radians
// @param _a (Point)             -The point to rotate
// @param _radians (float)       -The angle in radians
// @returns (Point)              -The rotated point
export method rotate_rad(Point _a, float _radians) =>
    _cos = math.cos(_radians)
    _sin = math.sin(_radians)
    Point.new(_a.x * _cos - _a.y * _sin, _a.x * _sin + _a.y * _cos)

// @function Rotate a point by an angle in degrees
// @param _a (Point)             -The point to rotate
// @param _degree (float)        -The angle in degrees
// @returns (Point)              -The rotated point
export method rotate_degree(Point _a, float _degree) =>
    _a.rotate_rad(math.toradians(_degree))

// @function Ceil a point to a certain number of digits
// @param _a (Point)             -The point to ceil
// @param _digits (int)          -The number of digits to ceil to
// @returns (Point)              -The ceiled point
export method vceil(Point _a, int _digits) =>
    _places = math.pow(10, _digits)
    Point.new(math.ceil(_a.x * _places) / _places, math.ceil(_a.y * _places) / _places)

// @function Raise both point elements to a power
// @param _a (Point)             -The point
// @param _exponent (float)      -The exponent
// @returns (Point)              -The point with elements raised to the power
export method vpow(Point _a, float _exponent) =>
    Point.new(math.pow(_a.x, _exponent), math.pow(_a.y, _exponent))

// @function Distance from point _a to line between _b and _c
// @param _a (Point)             -The point
// @param _b (Point)             -The start point of the line
// @param _c (Point)             -The end point of the line
// @returns (float)              -The perpendicular distance
export method perpendicular_distance(Point _a, Point _b, Point _c) =>
    _d = _c.sub(_b)
    len_d = _d.length()
    len_d == 0.0 ? _a.distance(_b) : math.abs(_a.cross(_d) + _c.cross(_b)) / len_d // Handle zero length segment

// @function Project a point onto another
// @param _a (Point)             -The point to project
// @param _axis (Point)          -The point to project onto
// @returns (Point)              -The projected point
export method project(Point _a, Point _axis) =>
    len_sq = _axis.length_squared()
    _t = len_sq == 0.0 ? 0.0 : _a.dot(_axis) / len_sq // Avoid division by zero
    _axis.mul(_t)

// @function Project a point onto a point of unit length
// @param _a (Point)             -The point to project
// @param _axis (Point)          -The unit length point to project onto
// @returns (Point)              -The projected point
export method projectN(Point _a, Point _axis) =>
    _t = _a.dot(_axis)
    _axis.mul(_t)

// @function Reflect a point on another
// @param _a (Point)             -The point to reflect
// @param _axis (Point)          -The point to reflect on
// @returns (Point)              -The reflected point
export method reflect(Point _a, Point _axis) =>
    _a.project(_axis).mul(2.0).sub(_a)

// @function Reflect a point to an arbitrary axis
// @param _a (Point)             -The point to reflect
// @param _axis (Point)          -The axis to reflect to
// @returns (Point)              -The reflected point
export method reflectN(Point _a, Point _axis) =>
    _a.projectN(_axis).mul(2.0).sub(_a)

// @function Angle in radians of a point
// @param _a (Point)             -The point
// @returns (float)              -The angle in radians
export method angle_rad(Point _a) =>
    -atan2(-_a.y, _a.x)

// @function Unsigned degree angle between 0 and +180 by given two points
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (float)              -The unsigned angle in degrees
export method angle_unsigned(Point _a, Point _b) =>
    dot_prod = _a.normalize().dot(_b.normalize())
    math.todegrees(math.acos(math.max(-1.0, math.min(1.0, dot_prod)))) // Clamp dot product for safety

// @function Signed degree angle between -180 and +180 by given two points
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (float)              -The signed angle in degrees
export method angle_signed(Point _a, Point _b) =>
    _na = _a.normalize()
    _nb = _b.normalize()
    dot_prod = _na.dot(_nb)
    angle_val = math.todegrees(math.acos(math.max(-1.0, math.min(1.0, dot_prod)))) // Clamp dot product
    angle_val * (_na.cross(_nb) >= 0 ? 1.0 : -1.0)

// @function Degree angle between 0 and 360 by given two points
// @param _a (Point)             -The first point
// @param _b (Point)             -The second point
// @returns (float)              -The angle in degrees (0-360)
export method angle_360(Point _a, Point _b) =>
    _na     = _a.normalize()
    _nb     = _b.normalize()
    dot_prod = _na.dot(_nb)
    _degree = math.todegrees(math.acos(math.max(-1.0, math.min(1.0, dot_prod)))) // Clamp dot product
    _na.cross(_nb) >= 0.0 ? _degree : 360.0 - _degree

// @function Restricts a point between a min and max value
// @param _a (Point)             -The point to restrict
// @param _vmin (Point)          -The minimum point
// @param _vmax (Point)          -The maximum point
// @returns (Point)              -The restricted point
export method clamp(Point _a, Point _vmin, Point _vmax) =>
    _x = math.max(math.min(_a.x, _vmax.x), _vmin.x)
    _y = math.max(math.min(_a.y, _vmax.y), _vmin.y)
    Point.new(_x, _y)

// @function Linearly interpolates between points a and b by _rate_of_move
// @param _a (Point)             -The starting point
// @param _b (Point)             -The ending point
// @param _rate_of_move (float)  -The rate of movement (0-1)
// @returns (Point)              -The interpolated point
export method lerp(Point _a, Point _b, float _rate_of_move) =>
    _t = math.max(0.0, math.min(1.0, _rate_of_move)) // Clamp t between 0 and 1
    _a.add(_b.sub(_a).scale(_t))

// @function Slope of a line between two points
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @returns (float)              -The slope of the line, returns na for vertical lines
export method slope(Point p1, Point p2) =>
    dx = p1.x - p2.x
    dx == 0.0 ? na : (p1.y - p2.y) / dx // Handle vertical line

// @function Get y-coordinate of a point on the line given its x-coordinate
// @param self (Line)            -The line
// @param x (float)              -The x-coordinate
// @returns (float)              -The y-coordinate (na if line is vertical and x doesn't match)
export method gety(Line self, float x) =>
    if na(self.slope) // Vertical line
        x == self.point.x ? self.point.y : na // Return point's y only if x matches
    else
        self.slope * (x - self.point.x) + self.point.y

// @function Get x-coordinate of a point on the line given its y-coordinate
// @param self (Line)            -The line
// @param y (float)              -The y-coordinate
// @returns (float)              -The x-coordinate (na if line is horizontal and y doesn't match)
export method getx(Line self, float y) =>
    if na(self.slope) // Vertical line
        self.point.x // Always return the line's x
    else if self.slope == 0.0 // Horizontal line
        y == self.point.y ? self.point.x : na // Return point's x only if y matches
    else
        (y - self.point.y) / self.slope + self.point.x

// @function Intersection point of two lines
// @param self (Line)            -The first line
// @param other (Line)           -The second line
// @returns (Point)              -The intersection point (na if parallel or coincident)
export method intersection(Line self, Line other) =>
    if na(self.slope) and na(other.slope) // Both vertical
        na // Parallel or coincident
    else if na(self.slope) // Self is vertical
        x = self.point.x
        y = other.gety(x)
        na(y) ? na : Point.new(x, y)
    else if na(other.slope) // Other is vertical
        x = other.point.x
        y = self.gety(x)
        na(y) ? na : Point.new(x, y)
    else if self.slope == other.slope // Parallel (non-vertical)
        na
    else // General case
        x = (other.point.y - self.point.y + self.slope * self.point.x - other.slope * other.point.x) / (self.slope - other.slope)
        y = self.gety(x) // Can use either line's gety
        Point.new(x, y)

// @function Calculate a point on the arc defined by three points
// @param self (Point)           -The starting point of the arc
// @param b (Point)              -The middle point of the arc
// @param p3 (Point)             -The end point of the arc
// @returns (Point)              -A point on the arc
export method calculate_arc_point(Point self, Point p2, Point p3) =>
    angle  = p2.angle_between(self, p3) / 2
    vector = p2.sub(self).rotate(-angle)
    self.add(vector)

// @function Approximate the center of a spiral using three points
// @param point1 (Point)         -The first point
// @param point2 (Point)         -The second point
// @param point3 (Point)         -The third point
// @returns (Point)              -The approximate center point (na if points are collinear)
export method approximate_center(Point point1, Point point2, Point point3) =>
    // Calculate midpoints
    midpoint12 = point1.midpoint(point2)
    midpoint23 = point2.midpoint(point3)

    // Calculate slopes of segments
    slope12 = point1.slope(point2)
    slope23 = point2.slope(point3)

    // Handle vertical segments
    perp_slope12 = na(slope12) ? 0.0 : slope12 == 0.0 ? na : -1 / slope12
    perp_slope23 = na(slope23) ? 0.0 : slope23 == 0.0 ? na : -1 / slope23

    // Create lines representing perpendicular bisectors
    line1 = na(perp_slope12) ? Line.new(midpoint12, na) : Line.new(midpoint12, perp_slope12) // Handle horizontal segment
    line2 = na(perp_slope23) ? Line.new(midpoint23, na) : Line.new(midpoint23, perp_slope23) // Handle horizontal segment

    // Find intersection
    center_point = line1.intersection(line2)
    center_point

// @function Get coordinate from center by radius and angle
// @param center (Point)         -The center point
// @param radius (float)         -The radius of the circle
// @param angle (float)          -The angle in degrees
// @returns (Point)              -The coordinate on the circle
export method createEdge(Point center, float radius, float angle) =>
    x = center.x + radius * math.cos(math.toradians(angle))
    y = center.y + radius * math.sin(math.toradians(angle))
    Point.new(x, y)

// @function Get growth factor of spiral point
// @param p1 (Point)             -The first point
// @param p2 (Point)             -The second point
// @param p3 (Point)             -The third point
// @returns (float)              -The growth factor (na if distance is zero)
export method getGrowthFactor(Point p1, Point p2, Point p3) =>
    d1 = p1.distance(p2)
    d2 = p2.distance(p3)
    d1 == 0.0 ? na : d2 / d1

// @function Convert Point to chart.point using chart.point.from_index(safeindex(point.x), point.y)
// @param point (Point)          -The point to convert
// @returns (chart.point)        -The chart.point representation of the input point
export method to_chart_point(Point point, int max_dist = 4999) =>
    chart.point.from_index(safeindex(point.x, max_dist), point.y)

// @function Draw a line from p1 to p2
// @param p1 (Point)             -First point
// @param p2 (Point)             -Second point
// @param color (color)          -Color of the line
// @param width (int)            -Width of the line
// @param style (string)         -Style of the line
// @returns (line)               -Line object (na if indices are unsafe)
export method plotline(Point p1, Point p2, color col = color.white, int width = 1, string style = line.style_solid) =>
    ix1 = safeindex(p1.x)
    ix2 = safeindex(p2.x)
    line.new(ix1, p1.y, ix2, p2.y, xloc = xloc.bar_index, color = col, width = width, style = style)

// @function Draw an array of points as chart points on the chart
// @param points (array<Point>)  -The points to draw
// @returns (array<chart.point>) -The array of chart points (only includes valid points)
export method to_chart_points(array<Point> points, bool ignore_unbounded = true) =>
    polypoints = array.new<chart.point>()
    first      = last_bar_index - 4999
    last       = last_bar_index + 490
    zero = math.max(1,first)
    for p in points
        if ignore_unbounded and p.x > last or p.x < zero
            continue
        xi = math.round(math.max(1, first, math.min(last_bar_index + 490, p.x)))
        cp = chart.point.from_index(xi,p.y)
        polypoints.push( cp )
    polypoints

// @function Draw lines between points in an array
// @param points (array<Point>)  -The array of points
// @param col (color)            -The color of the lines
// @param width (int)            -Width of the lines
// @param style (string)         -Style of the lines
// @param closed (bool)          -Connect the last point to the first
export method drawlines(array<Point> points, color col, int width = 1, string style = line.style_solid, bool closed = false) =>
    chart_points = points.to_chart_points()
    if chart_points.size() >= 2
        for i = 0 to chart_points.size() - 2
            p1 = chart_points.get(i)
            p2 = chart_points.get(i + 1)
            line.new(p1,p2, xloc = xloc.bar_index, color = col, width = width, style = style)
        if closed and chart_points.size() > 2
            p_last = chart_points.last()
            p_first = chart_points.first()
            line.new(p_first,p_last, xloc = xloc.bar_index, color = col, width = width, style = style)

// @function Calculate the area of a polygon defined by an array of points (Shoelace formula)
// @param points (array<Point>)  -The array of points representing the polygon vertices
// @returns (float)              -The area of the polygon (positive for CCW, negative for CW)
export method polygon_area(array<Point> points) =>
    area  = 0.0
    n     = points.size()
    if n < 3
        0.0 // Not a polygon
    else
        for i = 0 to n - 1
            j     = (i + 1) % n // Next vertex index
            area += points.get(i).x * points.get(j).y
            area -= points.get(j).x * points.get(i).y
        area / 2.0

// @function Calculate the perimeter of a polygon
// @param points (array<Point>)  -Array of points defining the polygon
// @returns (float)              -Perimeter of the polygon
export method polygon_perimeter(array<Point> points) =>
    perimeter   = 0.0
    num_points  = points.size()
    if num_points < 2
        0.0
    else
        for i = 0 to num_points - 1
            perimeter  += points.get(i).distance(points.get((i + 1) % num_points)) // Use modulo for closed loop
        perimeter

// @function Check if a point is inside a polygon using the Ray Casting algorithm
// @param point (Point)          -The point to check
// @param polygon (array<Point>) -Array of points defining the polygon vertices in order (CW or CCW)
// @returns (bool)               -True if the point is inside the polygon, false otherwise
export method is_point_in_polygon(Point point, array<Point> _polygon) =>
    n = _polygon.size()
    if n < 3
        false // Not a polygon
    inside = false
    p1 = _polygon.last() // Start with the last vertex to connect to the first
    for i = 0 to n - 1
        p2 = _polygon.get(i)

        // Check if the ray intersects the edge (p1, p2)
        if (p1.y == p2.y) // Ignore horizontal edges (or handle specifically if needed)
            p1 := p2
            continue

        if math.min(p1.y, p2.y) < point.y and math.max(p1.y, p2.y) >= point.y
            // Calculate the x-intersection of the ray with the edge line
            x_intersection = (point.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y) + p1.x

            // If the intersection point is to the right of the test point, flip the inside flag
            if x_intersection > point.x
                inside := not inside
        p1 := p2 // Move to the next edge
    inside

// @function Calculates the convex hull perimeter of a set of points (Monotone Chain Algorithm)
// @param points (array<Point>)  -The array of points
// @returns (array<Point>)       -The array of points forming the convex hull perimeter (CCW order), empty if less than 3 points
export method perimeter(array<Point> points) =>
    n = points.size()
    if n < 3
        array.new<Point>() // Not enough points for a hull

    // Sort points primarily by x, secondarily by y
    sorted_points = sort_points(points, Sort.X)

    upper_hull = array.new<Point>()
    lower_hull = array.new<Point>()

    // Build lower hull
    for point in sorted_points
        while lower_hull.size() >= 2 and lower_hull.get(-1).sub(lower_hull.get(-2)).cross(point.sub(lower_hull.get(-1))) <= 0 // Check for non-left turn
            lower_hull.pop()
        lower_hull.push(point)

    // Build upper hull (iterate in reverse)
    for i = n - 1 to 0 by -1
        point = sorted_points.get(i)
        while upper_hull.size() >= 2 and upper_hull.get(-1).sub(upper_hull.get(-2)).cross(point.sub(upper_hull.get(-1))) <= 0 // Check for non-left turn
            upper_hull.pop()
        upper_hull.push(point)

    // Combine hulls (remove duplicate start/end points)
    hull = array.new<Point>()
    for i = 0 to lower_hull.size() - 2 // Exclude last point of lower hull
        hull.push(lower_hull.get(i))
    for i = 0 to upper_hull.size() - 2 // Exclude last point of upper hull
        hull.push(upper_hull.get(i))
    hull

// @function Point Create Convenience
// @field x (float)              -The x-coordinate
// @field y (float)              -The y-coordinate
// @field a (float)              -An Angle storage spot
// @field v (float)              -A Value
// @returns (Point)              -new point
export method Point(float x, float y, float a = 0, float v =  0) =>
    Point.new(x, y, a, v)

// @function Debug Label for a Point
// @param x (Point)              - Point to label
// @param display_text (string)  - Optional text to add
// @param col (color)            - Label background color
// @param txt_col (color)        - Label text color
// @returns (label)              - The created label object (na if index unsafe)
export method debug_label(Point x, string display_text = "", color col = color.gray, color txt_col = color.white, string style = label.style_label_center, int size = 10) =>
    cp = x.to_chart_point()
    label.new(cp, str.format("{2}\nx:{0,number,#.##}\ny:{1,number,#.##}", x.x, x.y, display_text),
                 xloc = xloc.bar_index, textalign = text.align_center, text_font_family = font.family_monospace,
                 style = style, color = col, textcolor = txt_col, size = size)

// @function regular_polygon: Generates points for a regular polygon.
// @param center (Point)         - Center of the polygon.
// @param radius (float)         - Radius of the polygon (distance from center to vertices).
// @param sides (int)            - Number of sides of the polygon (min 3).
// @param start_angle (float)    - Angle offset for the first vertex in degrees (default 0).
// @returns (array<Point>)       - Array of Point objects for the polygon vertices.
export method regular_polygon(Point center, float radius, int sides, float start_angle = 0.0) =>
    polygon_points = array.new<Point>()
    safe_sides = math.max(3, sides) // Ensure at least 3 sides
    angle_step = 360.0 / safe_sides
    for i = 0 to safe_sides - 1
        angle = start_angle + i * angle_step
        polygon_points.push(center.createEdge(radius, angle))
    polygon_points

// @function point_in_circle: Checks if a point is inside a circle.
// @param circle (Circle)        - A circle object
// @param point (Point)          - The point to check.
// @returns (bool)               - True if the point is inside or on the circle, false otherwise.
export method point_in_circle(Circle circle, Point point) =>
    point.distance(circle.center) <= circle.radius

// @function  Creates an array of points for a rescaled circle / tilted oval based on two reference along the edge.
// @param point1 (Point)         - The first reference point  (e.g., a high pivot).
// @param point2 (Point)         - The second reference point (e.g., a low  pivot).
// @param steps  (int)           - Number of points to generate for the circle (default: 100).
// @returns (array<Point>)       - An array of Point objects representing the scaled circle.
export method scaled_circle(Point point1, Point point2, int steps = 100) =>
    circle_points = array.new<Point>()
    center        = point1.midpoint(point2)
    radius_x      = point1.distance(center)
    radius_y      = point2.distance(center) * math.abs(point1.y-point2.y)/radius_x
    for i = 0 to steps - 1
        angle_rad = i * 2 * math.pi / steps
        cos       = math.cos(angle_rad)
        tilt      = interpolate(center.y - point2.y ,center.y - point1.y,0.5*(cos+1))
        x         = center.x + radius_x * cos
        y         = center.y + radius_y * math.sin(angle_rad) + tilt
        circle_points.push(Point.new(x, y))
    circle_points