//@version=5
strategy('Breakouts With Timefilter Strategy [LuciTech]',
 shorttitle = 'Breakouts Strategy [LuciTech]',
 overlay = true,
 max_bars_back=500,
 max_lines_count=500,
 initial_capital=10000,
 default_qty_type=strategy.percent_of_equity,
 default_qty_value=100)

// Credit
// @veryfid for ATR SL - https://www.tradingview.com/script/LgjsidVh-ATR-Stop-Loss-Finder/
// @TradesLuci1 for Breakouts (Entry Logic) - https://www.tradingview.com/script/QOIBSlbB-Breakouts-with-timefilter-LuciTech/

// ToolTips
sltip = 'Defines the stop-loss length based on candles. 0 means 1 candle, 1 means 2 candles, and so on.'
betip = 'Enter the R multiple at which the stop loss moves to breakeven. 0 means breakeven is disabled.'
rrtip = 'The risk-reward ratio determines the relationship between potential reward and risk. For example, 3 means risking 1 unit to gain 3 units.'
risk_percent_tip = 'The percentage of your equity that you are willing to risk per trade.'
sl_type_tip = 'Choose the stop-loss calculation type: ATR-based, Candle-based, or points-based.'
ATRlength_tip = 'The number of periods used to calculate the Average True Range (ATR).'
smoothing_tip = 'Choose the smoothing method for ATR: RMA, SMA, EMA, or WMA.'
ATRlines_tip = 'Enable or disable plotting of ATR-based stop-loss lines.'
fillcolour_tip = 'Select the background color to visually indicate the active time filter range on the chart.'
pointstip = 'Set a fixed points value for the stop loss (in points, adjusted for symbol tick size).'

// Input settings
length = input.int(title='Length', defval=5, group='Inputs')
bullcolor = input(title="Colours Bull/Bear", defval=color.rgb(0, 255, 0), inline='colour1', group='Inputs')
bearcolor = input(title="", defval=color.rgb(255, 0, 0), inline='colour1', group='Inputs')
showLastOnly = input.bool(title="Show Last Breakout", defval=false, group='Inputs')

// Risk Management Inputs
risk_percent = input.float(1, title="Risk %", minval=0.1, maxval=100, step=0.1, group = 'Risk Management', tooltip=risk_percent_tip) / 100
Risk_reward = input.float(defval=3, title='Risk:Reward', step=0.1, tooltip=rrtip)
sl_type = input.string("ATR", title="Stop Loss Type", options=["ATR", "Candle", "points"], tooltip=sl_type_tip)
SL_length = input(0, title='Candle Length', tooltip=sltip)
points_sl = input.float(50, title="Fixed Points", minval=1, step=1, tooltip=pointstip)
ATRlength = input.int(title='ATR length', defval=14, minval=1, tooltip=ATRlength_tip)
smoothing = input.string(title='ATR Smoothing/ATR Lines', defval='SMA', options=['RMA', 'SMA', 'EMA', 'WMA'], tooltip=smoothing_tip)
atrmult = input.float(0.5, step=0.1, title='ATR multiplier')
ATRlines = input(false, 'Show ATR Lines', tooltip=ATRlines_tip)

// Position Colour Inputs
entrypricecolour = input.color(color.rgb(244, 244, 244, 75), title = 'Entry/SL/TP', group = 'Position colours', inline = 'peb')
stoplosscolour = input.color(color.rgb(255, 0, 0, 75), title = '', group = 'Position colours', inline = 'peb')
takeprofitcolour = input.color(color.rgb(0, 255, 0, 75), title = '', group = 'Position colours', inline = 'peb')

// Time filter inputs
enable_time_filter = input.bool(true, title="Enable Time Filter", group="Time Filter")
start_hour = input.int(defval=14, title='Start Hour (24h)', minval=0, maxval=23, group = 'Time Filter')
start_minute = input.int(defval=30, title='Start Minute', minval=0, maxval=59, group = 'Time Filter')
end_hour = input.int(defval=15, title='End Hour (24h)', minval=0, maxval=23, group = 'Time Filter')
end_minute = input.int(defval=0, title='End Minute', minval=0, maxval=59, group = 'Time Filter')
showFill = input.bool(defval=true, title="Fill Background", inline = 'colour1', group = 'Time Filter')
fillColor = input.color(color.rgb(192, 192, 192, 90), title='', inline = 'colour1', tooltip=fillcolour_tip, group = 'Time Filter')

// MA Filter Inputs
useMAFilter = input.bool(false, title="MA Filter", group="MA Filter")
ma_type = input.string("HMA", title="Type", options=["SMA", "EMA", "WMA", "VWMA", "HMA"], group="MA Filter")
ma_length = input.int(99, title="Length", group="MA Filter")
ma_src = input(close, title="Source", group="MA Filter")
ma_color = input.color(color.rgb(192, 192, 192), title="Colour", group="MA Filter")

// ATR SL
ma_function(source, ATRlength) =>
    if smoothing == 'RMA'
        ta.rma(source, ATRlength)
    else
        if smoothing == 'SMA'
            ta.sma(source, ATRlength)
        else
            if smoothing == 'EMA'
                ta.ema(source, ATRlength)
            else
                ta.wma(source, ATRlength)

a = ma_function(ta.tr(true), ATRlength) * atrmult
x = ma_function(ta.tr(true), ATRlength) * atrmult + high
x2 = low - ma_function(ta.tr(true), ATRlength) * atrmult
p1 = plot(ATRlines ? x : na, title='ATR Short Stop Loss', color=stoplosscolour, trackprice=ATRlines)
p2 = plot(ATRlines ? x2 : na, title='ATR Long Stop Loss', color=takeprofitcolour, trackprice=ATRlines)

// Time filter function
is_within_time_window() =>
    t = time_close(timeframe.period, "Europe/London")

    // Extract hours and minutes from the time
    hour = hour(t, "Europe/London")
    minute = minute(t, "Europe/London")

    // Calculate total minutes for easier comparison
    current_minutes = hour * 60 + minute
    start_minutes = start_hour * 60 + start_minute
    end_minutes = end_hour * 60 + end_minute

    current_minutes >= start_minutes and current_minutes <= end_minutes

inTimeRange = enable_time_filter ? is_within_time_window() : true
var color bgColor = na
bgColor := showFill and inTimeRange and enable_time_filter ? fillColor : na
bgcolor(bgColor)


// Entry Logic
// Calculate the selected MA type
calculate_ma() =>
    if ma_type == "SMA"
        ta.sma(ma_src, ma_length)
    else if ma_type == "EMA"
        ta.ema(ma_src, ma_length)
    else if ma_type == "WMA"
        ta.wma(ma_src, ma_length)
    else if ma_type == "VWMA"
        ta.vwma(ma_src, ma_length)
    else if ma_type == "HMA"
        ta.hma(ma_src, ma_length)
    else
        ta.sma(ma_src, ma_length)
ma_value = calculate_ma()

// Only plot if MA filter is enabled
plot(useMAFilter ? ma_value : na, 'MA', ma_color, 2)

// Store pivot points and their locations
ph = ta.pivothigh(length, length)
pl = ta.pivotlow(length, length)
var float[] pivotHighPrices = array.new_float()
var int[] pivotHighBars = array.new_int()
var float[] pivotLowPrices = array.new_float()
var int[] pivotLowBars = array.new_int()

// Variables for signals and their timestamps
var int lastHighSignalBar = na
var int lastLowSignalBar = na
var line lastHighLine = na
var line lastLowLine = na

// Function to maintain only last 3 elements in arrays
maintainLastThree(float[] priceArray, int[] barArray) =>
    while array.size(priceArray) > 3
        array.shift(priceArray)
        array.shift(barArray)

// Add new pivot points to arrays
if not na(ph)
    array.push(pivotHighPrices, ph)
    array.push(pivotHighBars, bar_index[length])
    maintainLastThree(pivotHighPrices, pivotHighBars)

if not na(pl)
    array.push(pivotLowPrices, pl)
    array.push(pivotLowBars, bar_index[length])
    maintainLastThree(pivotLowPrices, pivotLowBars)

// Define signal conditions
bool highSignal = false
bool lowSignal = false

// Process pivot highs
if array.size(pivotHighPrices) > 0
    for i = array.size(pivotHighPrices) - 1 to 0
        pivotPrice = array.get(pivotHighPrices, i)
        pivotBar = array.get(pivotHighBars, i)

        // If price closes above pivot high
        if close > pivotPrice
            highSignal := true
            lastHighSignalBar := bar_index

            // Only draw line if signal conditions are met
            if (not enable_time_filter or inTimeRange)
                // Remove old high line if showLastOnly is true and a previous line exists
                if showLastOnly and not na(lastHighLine)
                    line.delete(lastHighLine)
                // Draw the new line
                newLine = line.new(pivotBar, pivotPrice, bar_index, pivotPrice,
                     color=bullcolor, width=1, xloc=xloc.bar_index)
                if showLastOnly
                    lastHighLine := newLine

            // Remove the pivot from tracking
            array.remove(pivotHighPrices, i)
            array.remove(pivotHighBars, i)

// Process pivot lows
if array.size(pivotLowPrices) > 0
    for i = array.size(pivotLowPrices) - 1 to 0
        pivotPrice = array.get(pivotLowPrices, i)
        pivotBar = array.get(pivotLowBars, i)

        // If price closes below pivot low
        if close < pivotPrice
            lowSignal := true
            lastLowSignalBar := bar_index

            // Only draw line if signal conditions are met
            if (not enable_time_filter or inTimeRange)
                // Remove old low line if showLastOnly is true and a previous line exists
                if showLastOnly and not na(lastLowLine)
                    line.delete(lastLowLine)
                // Draw the new line
                newLine = line.new(pivotBar, pivotPrice, bar_index, pivotPrice,
                     color=bearcolor, width=1, xloc=xloc.bar_index)
                if showLastOnly
                    lastLowLine := newLine

            // Remove the pivot from tracking
            array.remove(pivotLowPrices, i)
            array.remove(pivotLowBars, i)

bool finalbullsignal = showLastOnly ? (highSignal and bar_index == lastHighSignalBar) : highSignal
bool finalbearsignal = showLastOnly ? (lowSignal and bar_index == lastLowSignalBar) : lowSignal

// Apply MA filter to the signals
bool ma_filtered_bull = finalbullsignal and (not useMAFilter or close > ma_value)
bool ma_filtered_bear = finalbearsignal and (not useMAFilter or close < ma_value)

// Plot shapes and background
plotshape(ma_filtered_bull and (not enable_time_filter or inTimeRange), style=shape.triangleup, location=location.belowbar, color=bullcolor, size=size.tiny)
plotshape(ma_filtered_bear and (not enable_time_filter or inTimeRange), style=shape.triangledown, location=location.abovebar, color=bearcolor, size=size.tiny)

alertcondition(ma_filtered_bull, 'Bullish Breakout')
alertcondition(ma_filtered_bear, 'Bearish Breakout')

// Strategy
var float stop_level = na
var float target_level = na
var float entry_price = na
var float initial_stop = na
var bool moved_to_breakeven = false

calculate_position_size(stop_distance) =>
    if stop_distance > 0
        risk_amount = strategy.equity * risk_percent
        position_size = risk_amount / stop_distance
        math.floor(position_size / syminfo.mintick) * syminfo.mintick
    else
        na

// Calculate points-based stop loss
points_value = points_sl * syminfo.mintick

if inTimeRange and strategy.position_size == 0
    // Reset breakeven flag when entering new trades
    moved_to_breakeven := false

    // Strategy: Long entry logic
    if ma_filtered_bull
        stop_level := sl_type == "ATR" ? x2 : (sl_type == "Candle" ? low[SL_length] : close - points_value)
        initial_stop := stop_level
        stop_distance = close - stop_level
        target_level := close + (Risk_reward * stop_distance)
        position_size = calculate_position_size(stop_distance)
        sl_price = sl_type == "ATR" ? x2 : (sl_type == "Candle" ? low[SL_length] : close - points_value)
        tp_price = close + (Risk_reward * (close - sl_price))

        if not na(position_size) and position_size > 0
            strategy.entry("Long", strategy.long, qty=position_size)
            strategy.exit("Exit Long", "Long", stop=stop_level, limit=target_level)
            entry_price := close

    // Strategy: Short entry logic
    if ma_filtered_bear
        stop_level := sl_type == "ATR" ? x : (sl_type == "Candle" ? high[SL_length] : close + points_value)
        initial_stop := stop_level
        stop_distance = stop_level - close
        target_level := close - (Risk_reward * stop_distance)
        position_size = calculate_position_size(stop_distance)
        sl_price = sl_type == "ATR" ? x : (sl_type == "Candle" ? high[SL_length] : close + points_value)
        tp_price = close - (Risk_reward * (sl_price - close))

        if not na(position_size) and position_size > 0
            strategy.entry("Short", strategy.short, qty=position_size)
            strategy.exit("Exit Short", "Short", stop=stop_level, limit=target_level)
            entry_price := close

// Plotting Entry, SL, and TP lines
plot(strategy.position_size != 0 ? entry_price : na, title="Entry Price", color=entrypricecolour, style=plot.style_linebr)
plot(strategy.position_size != 0 ? stop_level : na, title="Stop Loss", color=stoplosscolour, style=plot.style_linebr)
plot(strategy.position_size != 0 ? target_level : na, title="Take Profit", color=takeprofitcolour, style=plot.style_linebr)
// Fill between Entry and SL
plot_entry = plot(strategy.position_size != 0 ? entry_price : na, "Entry for SL Fill", display=display.none)
plot_sl = plot(strategy.position_size != 0 ? stop_level : na, "SL for Fill", display=display.none)
fill(plot_entry, plot_sl, color = strategy.position_size != 0 ? (entry_price > stop_level ? stoplosscolour : stoplosscolour) : na)
// Fill between Entry and TP
plot_entry_tp = plot(strategy.position_size != 0 ? entry_price : na, "Entry for TP Fill", display=display.none)
plot_tp = plot(strategy.position_size != 0 ? target_level : na, "TP for Fill", display=display.none)
fill(plot_entry_tp, plot_tp, color = strategy.position_size != 0 ? (entry_price > target_level ? takeprofitcolour : takeprofitcolour) : na)