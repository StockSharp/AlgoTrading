// © Amjad_S
//@version=5

//█▀ █▀▀ █▀ █▀ █ █▀█ █▄░█   █▄▄ █▀█ █▀▀ ▄▀█ █▄▀ █▀█ █░█ ▀█▀   █▀ █▀▀ ▄▀█ █░░ █▀█ █▀▀ █▀█
//▄█ ██▄ ▄█ ▄█ █ █▄█ █░▀█   █▄█ █▀▄ ██▄ █▀█ █░█ █▄█ █▄█ ░█░   ▄█ █▄▄ █▀█ █▄▄ █▀▀ ██▄ █▀▄

//+------------------------------------------------------------------+
//                                                     STRATEGY CALL |
//+------------------------------------------------------------------+{
strategy(title = "Session Breakout Scalper Trading Bot",
     shorttitle = "Session Breakout Scalper",
     overlay = true,
     initial_capital = 1000,
     default_qty_type = strategy.percent_of_equity,
     default_qty_value = 100,
     commission_type = strategy.commission.percent,
     commission_value = 0.00,
     slippage = 0,
     pyramiding = 0,
     calc_on_every_tick = false,
     calc_on_order_fills = false,
     margin_long = 0,
     margin_short = 0)
    //  max_lines_count = 1,
    //  max_boxes_count = 1)

//+------------------------------------------------------------------+
//                                                     PINE CONNECTER|
//+------------------------------------------------------------------+{
// PineConnector Settings
var g_pc        = "PineConnector Settings", string id = "Your 13 digit PineConnecter License ID"
float initial_cap = input.float(1000, title = "Acount Initial Balance", group = g_pc, tooltip = "make sure to set this to your acount's initial balance"
     + " Note that the strategy uses variable / trailing risk per trade (a fixed x% from current acount equity rather than a fixed value such as x% * initial acount balance)")
float equity_rsk_cent = input.float(0.01, title = "Acount risk per trade %", step = 0.01, group = g_pc, tooltip = "This controlls how much of your acount_balance is risked per trade")
pc_ticker       = input.string("EIGHTCAP:BTCUSD", title = "Symbol Trading", group = g_pc, tooltip = "This is the financial asset you want to trade, the stratgey will send the trade alert from this symbol to the third party software."
     + "Make sure your symbol exchange on Trading View is the same as the exchange used in your third party trading exacution software (e.g. MT4/5). This helps avoid transaction costs and ensure your stratgy is entering tradings at the desried price."
     + "(This is becuase spot rates vary per exchange.")
pc_id           = input.string(title="License ID", defval=id, group=g_pc, tooltip="This is your PineConnector license ID")
pc_prefix       = input.string(title="MetaTrader Prefix", defval="", group=g_pc, tooltip="This is your broker's MetaTrader symbol prefix")
pc_suffix       = input.string(title="MetaTrader Suffix", defval="", group=g_pc, tooltip="This is your broker's MetaTrader symbol suffix")

// Generate PineConnector custom function
// PC SYNTAX = (LicenseID,Command,Symbol,Others,..,)
// MY PC SYNTAX = LicenseID,Command,Symbol,sl,tp,risk
string ticker_traded = pc_ticker
// note string subsetting is exclsuive interval
var symbol = pc_prefix + str.substring(ticker_traded, str.pos(ticker_traded, ":") + 1) + pc_suffix
pc_entry_alert(direction, pendingtype, pendingprice, sl, tp) =>
    pc_id + "," + direction + pendingtype + "," + symbol + ",price=" + str.tostring(pendingprice) +",sl=" + str.tostring(sl) + ",tp=" + str.tostring(tp) + ",risk=" + str.tostring(equity_rsk_cent * 100) // risk is variable

//+------------------------------------------------------------------+
//                                                     BACKTEST TIME |
//+------------------------------------------------------------------+{
//          Date and Time           //
var string g_backtest_time = "Backtest Time Range"
start_date = input.time(timestamp("2007-01-01T00:00:00"), group = g_backtest_time) // Unix time is a system for representing a point in time.
end_date = input.time(timestamp("9999-01-01T00:00:00"), group = g_backtest_time)

period() =>
    time >= start_date and time <= end_date ? true : false

//+------------------------------------------------------------------+
//                                      STRATEGY BACKTEST REQUIREMNTS|
//+------------------------------------------------------------------+{
// strategy.risk.max_cons_loss_days(20)
// strategy.risk.max_drawdown(15, strategy.percent_of_equity)
// strategy.risk.max_intraday_filled_orders(2)
// strategy.risk.max_intraday_loss(10, strategy.percent_of_equity)

//+------------------------------------------------------------------+
//                                                        USER INPUTS|
//+------------------------------------------------------------------+{
//______________________BALANCE & ORDER TYPE______________________________
var string g_cap =      "STRAT EQUITY & RISK"
bool iLOT =             input.bool(false, title = "Use Lot order fromat instaed of UNITS", group = "STRAT EQUITY & RISK")
//__________________SL & TP______________________
SL_B1 =     input.float(10.0, title = "pips SL (BUY 1)", step = 1, group = "STRAT TP & SL")
TP_B1 =     input.float(60.0, title = "pips TP (BUY 1)", step = 1, group = "STRAT TP & SL")
SL_S1 =     input.float(10.0, title = "pips SL (SELL 1)", step = 1, group = "STRAT TP & SL")
TP_S1 =     input.float(60.0, title = "pips TP (SELL 1)", step = 1, group = "STRAT TP & SL")
//__________________SL & TP______________________
var string g_atr_stop = "ATR STOP"
atr_stop = input.bool(true, title = "ATR stop", group = g_atr_stop)
lkb_atr = input.int(30, title = "ATR lookback", group = g_atr_stop)
atr_mult = input.float(4, title = "ATR factor", step = 0.1, group = g_atr_stop)
atr = ta.atr(lkb_atr)
//____________________PERCENT DAY GAIN________________________
var string g_cent_gain = "PERCENT DAY GAIN GOAL"
cent_gain1 = input.float(0.9, title = "day percent gain goal %1", step = 0.01, group = g_cent_gain, minval = 0.01, inline = "1", tooltip = "This is the lower bound % that the strategy will aim to gain")
cent_gain2 = input.float(1.5, title = "day percent gain goal %2", step = 0.01, group = g_cent_gain, minval = 0.05, inline = "1", tooltip = "This is the higher bound % that the strategy will aim to gain")
//____________________TRADE STRAT LABLES________________________
var string g_lbl = "Trade Labels"
show_lbl = input.bool(true, title = "Strategy label plots", group = g_lbl)
B_lbl1 =   input.color(color.new(color.lime, 50), title = "BUY 1 LABEL", group = g_lbl)
S_lbl1 =   input.color(color.new(color.red, 50), title = "SELL 1 LABEL", group = g_lbl)
//_______________________ REGIME FILTERS _______________________
var string g_regime_filters = "STRATEGY REGIME FILTERS"
// LARRY WILLIAMS LARGE TRADE INDEX
bool lwti_regime = input.bool(false, title = "Larry Willimas Large Trade Index Regime filter", group = g_regime_filters)
lkb_lwti = input.int(8, title = "Period lookback", group = g_regime_filters)
type = input.string("EMA", title = "Average Type", options = ["EMA", "WMA", "SMA"], group = g_regime_filters)
// ADEAN OSCIALLATOR
var string g_regime_AO = "STRAT REGIMES OSCILLATOR"
bool AO_regime = input.bool(true, title = "Andean OScillator Straetgy Regime", group = g_regime_filters)
length_a     = input.int(50, title = "length of alpha", group = g_regime_filters)
sig_length = input.int(9, title = 'Signal Length', group = g_regime_filters)
//____________________TIMES & TIMES TOGGLE________________________
var string g_time = "Trade Median Times"
box_bg_cl = input.color(color.new(color.gray, 70), title = "Box backround", group = g_time)
ctm_session1 = input.session(defval = "0100-0101", title = "User defined Sesssion 1", inline = "1", group = g_time)
ctm_session_1_switch = input.bool(defval = false, title = "Time 1 toggle", inline = "1", group = g_time)
ctm_session2 = input.session(defval = "0300-0301", title = "User defined Sesssion 2", inline = "2", group = g_time)
ctm_session_2_switch = input.bool(defval = false, title = "Time 2 toggle", inline = "2", group = g_time)
ctm_session3 = input.session(defval = "0500-0501", title = "User defined Sesssion 3", inline = "3", group = g_time)
ctm_session_3_switch = input.bool(defval = false, title = "Time 3 toggle", inline = "3", group = g_time)
ctm_session4 = input.session(defval = "0700-0701", title = "User defined Sesssion 4", inline = "4", group = g_time)
ctm_session_4_switch = input.bool(defval = false, title = "Time 4 toggle", inline = "4", group = g_time)
ctm_session5 = input.session(defval = "0900-0901", title = "User defined Sesssion 5", inline = "5", group = g_time)
ctm_session_5_switch = input.bool(defval = false, title = "Time 5 toggle", inline = "5", group = g_time)
ctm_session6 = input.session(defval = "1100-1101", title = "User defined Sesssion 6", inline = "6", group = g_time)
ctm_session_6_switch = input.bool(defval = false, title = "Time 6 toggle", inline = "6", group = g_time)
ctm_session7 = input.session(defval = "1300-1301", title = "User defined Sesssion 7", inline = "7", group = g_time)
ctm_session_7_switch = input.bool(defval = true, title = "Time 7 toggle", inline = "7", group = g_time)
ctm_session8 = input.session(defval = "1500-1501", title = "User defined Sesssion 8", inline = "8", group = g_time)
ctm_session_8_switch = input.bool(defval = false, title = "Time 8 toggle", inline = "8", group = g_time)
ctm_session9 = input.session(defval = "1700-1701", title = "User defined Sesssion 9", inline = "9", group = g_time)
ctm_session_9_switch = input.bool(defval = true, title = "Time 9 toggle", inline = "9", group = g_time)
ctm_session10 = input.session(defval = "1900-1901", title = "User defined Sesssion 10", inline = "10", group = g_time)
ctm_session_10_switch = input.bool(defval = false, title = "Time 10 toggle", inline = "10", group = g_time)
ctm_session11 = input.session(defval = "2100-2101", title = "User defined Sesssion 11", inline = "11", group = g_time)
ctm_session_11_switch = input.bool(defval = false, title = "Time 11 toggle", inline = "11", group = g_time)
ctm_session12 = input.session(defval = "2300-2301", title = "User defined Sesssion 12", inline = "12", group = g_time)
ctm_session_12_switch = input.bool(defval = true, title = "Time 12 toggle", inline = "12", group = g_time)
//____________________LOOKBACK BARS________________________
var string g_bars_lkb = "Lookback of bars"
int lkb1 = input.int(5, title = "lkb1 time1", inline = "1",  group = g_bars_lkb)
int lkb2 = input.int(5, title = "lkb2 time2", inline = "1",  group = g_bars_lkb)
int lkb3 = input.int(5, title = "lkb3 time3", inline = "1",  group = g_bars_lkb)
int lkb4 = input.int(5, title = "lkb4 time4", inline = "2",  group = g_bars_lkb)
int lkb5 = input.int(5, title = "lkb5 time5", inline = "2",  group = g_bars_lkb)
int lkb6 = input.int(5, title = "lkb6 time6", inline = "2",  group = g_bars_lkb)
int lkb7 = input.int(5, title = "lkb7 time7", inline = "3",  group = g_bars_lkb)
int lkb8 = input.int(5, title = "lkb8 time8", inline = "3",  group = g_bars_lkb)
int lkb9 = input.int(5, title = "lkb9 time9", inline = "3",  group = g_bars_lkb)
int lkb10 = input.int(5, title = "lkb10 time10", inline = "4",  group = g_bars_lkb)
int lkb11 = input.int(5, title = "lkb11 time11", inline = "4",  group = g_bars_lkb)
int lkb12 = input.int(5, title = "lkb12 time12", inline = "4",  group = g_bars_lkb)
//____________________DASH BORAD________________________
var string g_table = "Strategy Dashboard Display"
string tableYposInput = input.string("top", "Panel position", inline = "11", options = ["top", "middle", "bottom"], group = g_table)
string tableXposInput = input.string("right", "", inline = "11", options = ["left", "center", "right"], group = g_table)
bg_clr = input.color(color.new(#ffffff, 60), "Table Backround Color", group = g_table)
text_clr = input.color(color.rgb(255, 255, 255), "Table Text Color", group = g_table)

//+------------------------------------------------------------------+
//                                                    REGIME FILTERS |
//+------------------------------------------------------------------+{
// MA switch
ma_swicth(type, source_, lkb_) =>
    avg = float(na)
    if type == "EMA"
        avg := ta.ema(source_, lkb_)
    else if type == "SMA"
        avg := ta.sma(source_, lkb_)
    else if type == "WMA"
        avg := ta.wma(source_, lkb_)
    avg

// LARRY WILLIAMS LARGE TRADE INDEX - LWTI
lwti(lkb_) =>
    // varuable types after casting
    ma = float(na), atr_ = float(na), out = float(na), lwti_siganl_pos = bool(na), lwti_signal_neg = bool(na)
    // will return the average type of the difference od the close` and the close n bars ago
    ma := ma_swicth(type, close - nz(close[lkb_]), lkb_)
    // average of the true range
    atr_ := ta.atr(lkb_)
    // quotient of the lagged trailing differnece and the atr
    out := ((ma / atr_) * 50) + 50
    // lwti signal
    posative_sentiment_level = 50
    lwti_siganl_pos := out > posative_sentiment_level
    lwti_signal_neg := out < -posative_sentiment_level
    [out, lwti_siganl_pos, lwti_signal_neg]

// ANDEAN OSCILLATOR - AO
// code by "Alpaca.markets"
var alpha_AO = 2/(length_a+1)
var up1 = 0.,var up2 = 0.
var dn1 = 0.,var dn2 = 0.
C = close
O = open

up1 := nz(math.max(C,O,up1[1] - (up1[1]-C)*alpha_AO),C)
up2 := nz(math.max(C*C,O*O,up2[1] - (up2[1]-C*C)*alpha_AO),C*C)

dn1 := nz(math.min(C,O,dn1[1] + (C-dn1[1])*alpha_AO),C)
dn2 := nz(math.min(C*C,O*O,dn2[1] + (C*C-dn2[1])*alpha_AO),C*C)

//Components
bull = math.sqrt(dn2-dn1*dn1)
bear = math.sqrt(up2-up1*up1)
signal = ta.ema(math.max(bull,bear),sig_length)

//+------------------------------------------------------------------+
//                                              REGIME FILTER STATES |
//+------------------------------------------------------------------+{
// ANDEAN OSCILLATOR CONDITION STATE
bool AO_trending_regime_bull = bull > bear
bool AO_trending_regime_bear = bear > bull

// LARRY WILLIAMS TRADE INDEX STATE
[out, lwti_siganl_pos, lwti_signal_neg] = lwti(lkb_lwti)

//+------------------------------------------------------------------+
//                                                    FUNCTION CALLS |
//+------------------------------------------------------------------+{
// custom breakout box function, this will calculate the highs and lows given a intiger lookback period, The highs and lows are the buy and sell orders respectivly
rndm_scalp_box(time_session_, session_on_, lkb_) =>
    // UNIX time
    var bool UNIX = na
    // times 2 to include past and future lkb, and + 1 to include intermediate bar
    var range_lkb = (lkb_ * 2)
    float hh = ta.highest(high, range_lkb)
    float ll = ta.lowest(low, range_lkb)
    var float hi_max = na
    var float lo_max = na
    var line hi_Line = na
    var line lo_Line = na
    var box hi_Lo_Box = na
    // check if session is valid
    bool valid_session = session_on_ == true
    // detect changes in timeframe, time is equal to session and time toggle is on
    bool newTF = (time == time(timeframe.period, time_session_)) and valid_session
    // was the session valid and true lkb bars ago, true from current bar to session time
    bool lkf = valid_session and newTF[lkb_] == true
    bool new_range = valid_session and lkf == true
    if new_range
        UNIX := true
    else
        UNIX := false
    if lkf
        hi_max := hh
        lo_max := ll
        if close < hi_max and close > lo_max
            hi_Line := line.new(bar_index - range_lkb, hi_max, bar_index, hi_max, color = color.green, width = 2)
            lo_Line := line.new(bar_index - range_lkb, lo_max, bar_index, lo_max, color = color.red, width = 2)
            hi_Lo_Box := box.new(bar_index - range_lkb, hi_max, bar_index, lo_max, border_color = na, bgcolor = box_bg_cl)
            int(na)
    [hi_max, lo_max, hi_Line, lo_Line, hi_Lo_Box, newTF, lkf, new_range, UNIX]

// daily session
day() =>
    change = ta.change(time("D")) == 0
    var bool new_day = na
    if change == true
        new_day := true
    else if change == false
        new_day := false
    [change, new_day]

//+------------------------------------------------------------------+
//                                             CUSTOM FUNCTION CALLS |
//+------------------------------------------------------------------+{
// PLOT random scalper
[hi_max1, lo_max1, hiLine1, loLine1, hiLoBox1, newTF1, lkf1, new_range1, UNIX1] = rndm_scalp_box(ctm_session1, ctm_session_1_switch, lkb1)
[hi_max2, lo_max2, hiLine2, loLine2, hiLoBox2, newTF2, lkf2, new_range2, UNIX2] = rndm_scalp_box(ctm_session2, ctm_session_2_switch, lkb2)
[hi_max3, lo_max3, hiLine3, loLine3, hiLoBox3, newTF3, lkf3, new_range3, UNIX3] = rndm_scalp_box(ctm_session3, ctm_session_3_switch, lkb3)
[hi_max4, lo_max4, hiLine4, loLine4, hiLoBox4, newTF4, lkf4, new_range4, UNIX4] = rndm_scalp_box(ctm_session4, ctm_session_4_switch, lkb4)
[hi_max5, lo_max5, hiLine5, loLine5, hiLoBox5, newTF5, lkf5, new_range5, UNIX5] = rndm_scalp_box(ctm_session5, ctm_session_5_switch, lkb5)
[hi_max6, lo_max6, hiLine6, loLine6, hiLoBox6, newTF6, lkf6, new_range6, UNIX6] = rndm_scalp_box(ctm_session6, ctm_session_6_switch, lkb6)
[hi_max7, lo_max7, hiLine7, loLine7, hiLoBox7, newTF7, lkf7, new_range7, UNIX7] = rndm_scalp_box(ctm_session7, ctm_session_7_switch, lkb7)
[hi_max8, lo_max8, hiLine8, loLine8, hiLoBox8, newTF8, lkf8, new_range8, UNIX8] = rndm_scalp_box(ctm_session8, ctm_session_8_switch, lkb8)
[hi_max9, lo_max9, hiLine9, loLine9, hiLoBox9, newTF9, lkf9, new_range9, UNIX9] = rndm_scalp_box(ctm_session9, ctm_session_9_switch, lkb9)
[hi_max10, lo_max10, hiLine10, loLine10, hiLoBox10, newTF10, new_range10, lkf10, UNIX10] = rndm_scalp_box(ctm_session10, ctm_session_10_switch, lkb10)
[hi_max11, lo_max11, hiLine11, loLine11, hiLoBox11, newTF11, new_range11, lkf11, UNIX11] = rndm_scalp_box(ctm_session11, ctm_session_11_switch, lkb11)
[hi_max12, lo_max12, hiLine12, loLine12, hiLoBox12, newTF12, new_range12, lkf12, UNIX12] = rndm_scalp_box(ctm_session12, ctm_session_12_switch, lkb12)

// PLOT times
clr = color.new(#6b6b6b, 0)
bgcolor(time == time(timeframe.period, ctm_session1) and ctm_session_1_switch == true or
     time == time(timeframe.period, ctm_session2) and ctm_session_2_switch == true or
     time == time(timeframe.period, ctm_session3) and ctm_session_3_switch == true or
     time == time(timeframe.period, ctm_session4) and ctm_session_4_switch == true or
     time == time(timeframe.period, ctm_session5) and ctm_session_5_switch == true or
     time == time(timeframe.period, ctm_session6) and ctm_session_6_switch == true or
     time == time(timeframe.period, ctm_session7) and ctm_session_7_switch == true or
     time == time(timeframe.period, ctm_session8) and ctm_session_8_switch == true or
     time == time(timeframe.period, ctm_session9) and ctm_session_9_switch == true or
     time == time(timeframe.period, ctm_session10) and ctm_session_10_switch == true or
     time == time(timeframe.period, ctm_session11) and ctm_session_11_switch == true or
     time == time(timeframe.period, ctm_session12) and ctm_session_12_switch == true ? clr :
     na)

//+------------------------------------------------------------------+
//                                          STRATEGY POSITION SIZING |
//+------------------------------------------------------------------+{
// currency conversion, code by @ZenAndTheArtOfTrading
AcountequalQcurrency = strategy.account_currency == syminfo.currency
AcountequalBcurrency = strategy.account_currency == syminfo.basecurrency
AcountnotQB = not AcountequalBcurrency and not AcountequalQcurrency
// construct the custom pair and call if fx pair is true
conversionPair = AcountequalQcurrency ? syminfo.tickerid : strategy.account_currency + syminfo.currency
conversionRate = AcountnotQB or AcountequalBcurrency ? request.security(conversionPair, "D", close, ignore_invalid_symbol = true) : 1.0

// pip converison
Pip() =>
    if syminfo.type == "forex"
    // to convert to points (pips to points), note pip = 0.0001
        syminfo.mintick * 10
    else if syminfo.type != "forex"
        syminfo.mintick * 1000

// trade order size
GetPosTrade(float balance, bool fixed = true, float cent_risked, float stoppoints, conversion) =>
    var float risk_amount = na
    var float riskperpoint = na
    var float positionsize = na
    var float net = na
    if fixed == true
        risk_amount := (balance * cent_risked) * conversion
    else if fixed != true
        net := strategy.grossprofit - strategy.grossloss
        risk_amount := ((balance + net) * cent_risked) * conversion
    // doller for point move
    riskperpoint := stoppoints * syminfo.pointvalue
    positionsize := risk_amount *  (1 / riskperpoint)
    math.round(positionsize, 2)

// units to lots calculation
UnitsToLot(float units) =>
    math.round((units / 100000), 2)

//+------------------------------------------------------------------+
//                                                           SL & TP |
//+------------------------------------------------------------------+{
// function is used to calculate stop loss and take profit for both long and short trades
getSLandTPprice(ent, pips, bool b = true) =>
    var float SLorTP = na
    if b == true
        SLorTP := ent - (pips * Pip())
    if b == false
        SLorTP := ent + (pips * Pip())
    SLorTP

//+------------------------------------------------------------------+
//                              STRATEGY ORDERS VARIABLE DECLERATION |
//+------------------------------------------------------------------+{
var float buy_ent     = na
var float SL_val_buy  = na
var float buy_SL_diff = na
var float TP_val_buy  = na
var float sell_ent    = na
var float SL_val_sell = na
var float sell_SL_diff = na
var float TP_val_sell = na
// ORDER SIZE
var float position_size = na
// ENTRY PLOTS
var float buy_ent_plot = na
var float sell_ent_plot = na

//-------------------------------------------------------------------+
//                                   SHORT AND LONG TRADE VALIDATION |
//+------------------------------------------------------------------+{
new_range = bool(na)
bs = float(na)
ls = float(na)

// the breakout box prices, these are used for buy and sell trade entry
if UNIX1 == true
    new_range := true, bs := hi_max1, ls := lo_max1
else if UNIX2 == true
    new_range := true, bs := hi_max2, ls := lo_max2
else if UNIX3 == true
    new_range := true, bs := hi_max3, ls := lo_max3
else if UNIX4 == true
    new_range := true, bs := hi_max4, ls := lo_max4
else if UNIX5 == true
    new_range := true, bs := hi_max5, ls := lo_max5
else if UNIX6 == true
    new_range := true, bs := hi_max6, ls := lo_max6
else if UNIX7 == true
    new_range := true, bs := hi_max7, ls := lo_max7
else if UNIX8 == true
    new_range := true, bs := hi_max8, ls := lo_max8
else if UNIX9 == true
    new_range := true, bs := hi_max9, ls := lo_max9
else if UNIX10 == true
    new_range := true, bs := hi_max10, ls := lo_max10
else if UNIX11 == true
    new_range := true, bs := hi_max11, ls := lo_max11
else if UNIX12 == true
    new_range := true, bs := hi_max12, ls := lo_max12

// declare variable, new range will be insentiated new values depending on if UNIX is true
bool order_condition = new_range

//+------------------------------------------------------------------+
//                                        SHORT AND LONG TRADE ENTRY |
//+------------------------------------------------------------------+{
// strategy entry code
if period()
    if order_condition
        if syminfo.type == "forex" or syminfo.type != "forex"
            // BUY ORDER
            buy_ent := bs
            SL_val_buy := atr_stop ? buy_ent - (atr * atr_mult) : atr_stop == false ? getSLandTPprice(buy_ent, SL_B1, b = true) : na
            buy_SL_diff := math.abs(buy_ent - SL_val_buy)
            TP_val_buy := getSLandTPprice(buy_ent, TP_B1, b = false)
            position_size := GetPosTrade(balance = initial_cap,
                                         fixed = false,
                                         cent_risked = equity_rsk_cent,
                                         stoppoints = buy_SL_diff,
                                         conversion = conversionRate)
            strategy.entry(id = "BUY 1", direction = strategy.long, qty = iLOT ? UnitsToLot(position_size) :
                 position_size, stop = buy_ent)
            // *** PC ALERT FOR B1 STOP ***
            alertStringB1_stop = pc_entry_alert("buy", "stop", buy_ent, SL_val_buy, TP_val_buy)
            alert(alertStringB1_stop, alert.freq_once_per_bar_close)
            // SELL ORDER
            sell_ent := ls
            SL_val_sell := atr_stop ? sell_ent + (atr * atr_mult) : atr_stop == false ? getSLandTPprice(sell_ent, SL_S1, b = false) : na
            sell_SL_diff := math.abs(sell_ent - SL_val_sell)
            TP_val_sell := getSLandTPprice(sell_ent, TP_S1, b = true)
            position_size := GetPosTrade(balance = initial_cap,
                                         fixed = false,
                                         cent_risked = equity_rsk_cent,
                                         stoppoints = sell_SL_diff,
                                         conversion = conversionRate)
            strategy.entry(id = "SELL 1", direction = strategy.short, qty = iLOT ? UnitsToLot(position_size) :
                 position_size, stop = sell_ent)
            // *** PC ALERT FOR S1 STOP ***
            alertStringS1_stop = pc_entry_alert("sell", "stop", sell_ent, SL_val_sell, TP_val_sell)
            alert(alertStringS1_stop, alert.freq_once_per_bar_close)
    else if new_range == false
        buy_ent     := na
        SL_val_buy  := na
        buy_SL_diff := na
        TP_val_buy  := na
        sell_ent     := na
        SL_val_sell  := na
        sell_SL_diff := na
        TP_val_sell  := na

//+------------------------------------------------------------------+
//                                                  CHECK ORDER TYPE |
//+------------------------------------------------------------------+{
bool new_entry_b_1 = strategy.opentrades.entry_id(strategy.opentrades - 1) == "BUY 1"
bool new_entry_s_1 = strategy.opentrades.entry_id(strategy.opentrades - 1) == "SELL 1"

//+------------------------------------------------------------------+
//                                            ALERT CANCEL VARIABLES |
//+------------------------------------------------------------------+{
var string alert_cancel_all = na
var string alert_cancel_buys = na
var string alert_cancel_sells = na

//+------------------------------------------------------------------+
//                    REGIME FILTER CLOSE - INTIGRATED IN AUTOMATION |
//+------------------------------------------------------------------+{
// cancels current order if regime is not true

// for buy side
bool buy_regime_state = (lwti_regime == true and AO_regime == true) ? lwti_siganl_pos == true and AO_trending_regime_bull == true :
     (lwti_regime == false and AO_regime == true) ? AO_trending_regime_bull == true :
     (lwti_regime == true and AO_regime == false) ? lwti_siganl_pos == true :
     (lwti_regime == false and AO_regime == false) ? true : na

// for sell side
bool sell_regime_state = (lwti_regime == true and AO_regime == true) ? lwti_signal_neg == true and AO_trending_regime_bear == true :
     (lwti_regime == false and AO_regime == true) ? AO_trending_regime_bear == true :
     (lwti_regime == true and AO_regime == false) ? lwti_signal_neg == true :
     (lwti_regime == false and AO_regime == false) ? true : na

// for buy and sell trades (first check if curerntly in trade and direction of trade)
if strategy.position_size > 0 and new_entry_b_1
    // when buy states true, strategy close returs false
    if buy_regime_state[1] == false
        strategy.close(id = "BUY 1", immediately = true, comment = "BUY REGIME STATES NO LONGER TRUE")
        //*** PC ALERT CANCEL B1 & B2 ***
        alert_cancel_buys :=  pc_id + ",closelong," + symbol
        alert(alert_cancel_buys, alert.freq_once_per_bar_close)
else if strategy.position_size < 0 and new_entry_s_1
    // when sell states true, strategy close returns false
    if sell_regime_state[1] == false
        strategy.close(id = "SELL 1", immediately = true, comment = "SELL REGIME STATES NO LONGER TRUE")
        //*** PC ALERT CANCEL B1 & B2 ***
        alert_cancel_buys :=  pc_id + ",closeshort," + symbol
        alert(alert_cancel_buys, alert.freq_once_per_bar_close)

//+------------------------------------------------------------------+
//                                                 ORDER BIAS CANCEL |
//+------------------------------------------------------------------+{
// check for current breakout direction
bool in_order = strategy.opentrades[1] == 0 and strategy.position_size != 0

if in_order
    // if in buy order cancel sell stop
    if new_entry_b_1
        strategy.cancel(id = "SELL 1")
        //*** PC ALERT CANCEL B1 & B2 ***
        alert_cancel_sells :=  pc_id + ",cancelshort," + symbol
        alert(alert_cancel_sells, alert.freq_once_per_bar_close)
    // if in sell order cancel buy stop
    else if new_entry_s_1
        strategy.cancel(id = "BUY 1")
        //*** PC ALERT CANCEL B1 & B2 ***
        alert_cancel_buys :=  pc_id + ",cancellong," + symbol
        alert(alert_cancel_buys, alert.freq_once_per_bar_close)

//+------------------------------------------------------------------+
//                                               ORDER SESSION CLOSE |
//+------------------------------------------------------------------+{
// Cancels any open orders when a new session is detected
if strategy.position_size != 0
    if time == time(timeframe.period , ctm_session1) and ctm_session_1_switch == true or
         time == time(timeframe.period , ctm_session2) and ctm_session_2_switch == true or
         time == time(timeframe.period , ctm_session3) and ctm_session_3_switch == true or
         time == time(timeframe.period , ctm_session4) and ctm_session_4_switch == true or
         time == time(timeframe.period , ctm_session5) and ctm_session_5_switch == true or
         time == time(timeframe.period , ctm_session6) and ctm_session_6_switch == true or
         time == time(timeframe.period , ctm_session7) and ctm_session_7_switch == true or
         time == time(timeframe.period , ctm_session8) and ctm_session_8_switch == true or
         time == time(timeframe.period , ctm_session9) and ctm_session_9_switch == true or
         time == time(timeframe.period , ctm_session10) and ctm_session_10_switch == true or
         time == time(timeframe.period , ctm_session11) and ctm_session_11_switch == true or
         time == time(timeframe.period , ctm_session12) and ctm_session_12_switch == true
        strategy.close_all(immediately = true)
        //*** PC ALERT EXIT B1 & S1 ***
        alert_cancel_all := pc_id + ",closeall," + symbol
        alert(alert_cancel_all, alert.freq_once_per_bar_close)

//+------------------------------------------------------------------+
//                                                  DAY SESSION GAIN |
//+------------------------------------------------------------------+{
// todays starting acount balance
acount_balance = strategy.initial_capital + (strategy.netprofit + strategy.openprofit)
var float day_start_equity = na

// new day function
[change, new_day] = day()

// function that calculates todays equaity growth in $, if within range
if new_day
    day_start_equity := strategy.initial_capital + strategy.netprofit
else if new_day == false and strategy.position_size != 0
    if ((acount_balance - day_start_equity) / day_start_equity) > (cent_gain1 / 100) and ((acount_balance - day_start_equity) / day_start_equity)  <= (cent_gain2 / 100)
        strategy.close_all(immediately = true)
        // if acount holds order over new day and makes given gain percecntage, and new session time is not true, cancel orders, as we have alreadt made todyas gain
        strategy.cancel("BUY 1")
        strategy.cancel("SELL 1")
        //*** PC ALERT EXIT B1 & S1 ***
        alert_cancel_all := pc_id + ",closeall," + symbol
        alert(alert_cancel_all, alert.freq_once_per_bar_close)
        //*** PC ALERT CANCEL B1 & S1 ***
        alert_cancel_buys :=  pc_id + ",cancellong," + symbol
        alert(alert_cancel_buys, alert.freq_once_per_bar_close)
        //*** PC ALERT CANCEL B1 & S1 ***
        alert_cancel_sells :=  pc_id + ",cancelshort," + symbol
        alert(alert_cancel_sells, alert.freq_once_per_bar_close)

//+------------------------------------------------------------------+
//                                         SHORT AND LONG TRADE EXIT |
//+------------------------------------------------------------------+{
// TP and SL and risk are specafied in strategy alert, Therefore their is no need to enter alerts for trade exits specificly. This code is for trade exits on tradingview, this is required fopr the backtester to run
// for buy
if strategy.position_size > 0
    if strategy.position_entry_name == "BUY 1"
        strategy.exit(id = "BUY 1 - BUY EXIT#1", from_entry = "BUY 1", limit = TP_val_buy, stop = SL_val_buy,
             qty = math.abs(strategy.position_size))
// for sell
else if strategy.position_size < 0
    if strategy.position_entry_name == "SELL 1"
        strategy.exit(id = "SELL 1 - SELL EXIT#1", from_entry = "SELL 1", limit = TP_val_sell, stop = SL_val_sell,
             qty = math.abs(strategy.position_size))

//+------------------------------------------------------------------+
//                                                       TRADE PLOTS |
//+------------------------------------------------------------------+{
// anti repainting of signals
valid_trd_signal_b = new_entry_b_1 and new_entry_b_1[1] == false
valid_trd_signal_s = new_entry_s_1 and new_entry_s_1[1] == false

// signal plots
plotshape(valid_trd_signal_b, style = shape.triangleup, color = #10c900, location = location.belowbar, title = "long setup", size = size.normal)
plotshape(valid_trd_signal_s, style = shape.triangledown, color = #ff0000, location = location.abovebar, title = "short setup", size = size.normal)

if strategy.position_size > 0
    buy_ent_plot := buy_ent
else if strategy.position_size < 0
    sell_ent_plot := sell_ent
else
    buy_ent_plot := na
    sell_ent_plot := na

// for buy 1
ent_buy = plot(strategy.position_size <= 0 ? na : buy_ent_plot, color = color.gray, style=plot.style_linebr, title="ENT BUY 1")
sl_buy1 = plot(strategy.position_size > 0 and new_entry_b_1 ? SL_val_buy : na,  color=color.red,   style=plot.style_linebr, title="SL BUY 1")
tp_buy1 = plot(strategy.position_size > 0 and new_entry_b_1 ? TP_val_buy : na, color=color.green, style=plot.style_linebr, title="TP BUY 1")
// for sell 1
ent_sell = plot(strategy.position_size >= 0 ? na : sell_ent_plot, color = color.gray, style=plot.style_linebr, title="ENT SELL 1")
sl_sell1 = plot(strategy.position_size < 0 and new_entry_s_1 ? SL_val_sell : na,  color=color.red,   style=plot.style_linebr, title="SL SELL 1")
tp_sell1 = plot(strategy.position_size < 0 and new_entry_s_1 ? TP_val_sell : na, color=color.green, style=plot.style_linebr, title="TP SELL 1")

// fill shapes
// for b1
fill(tp_buy1, ent_buy,  color = color.new(#14ff00, 80))
fill(ent_buy, sl_buy1, color = color.new(#ff1b1c, 80))
// for s1
fill(ent_sell, tp_sell1,  color = color.new(#14ff00, 80))
fill(sl_sell1, ent_sell, color = color.new(#ff1b1c, 80))

//+------------------------------------------------------------------+
//                                                 TRADE ENTRY STATS |
//+------------------------------------------------------------------+{
// total strategy trades to check for new entry, closed trades + entry trades
ttl_trd = strategy.closedtrades + strategy.opentrades
new_trd = ttl_trd > ttl_trd[1] and strategy.opentrades > 0 and strategy.opentrades <= 1 // bounded fro 0 to 1

// label plot if new order
if new_trd and show_lbl == true
    // get Order ID and entry price
    label_txt = strategy.opentrades.entry_id(0) + "\n@" +
         str.tostring(strategy.opentrades.entry_price(0)) + "\n- " +
    // get TP, SL
         "Balance risked: $" + str.tostring(math.round(((strategy.initial_capital + strategy.netprofit) * equity_rsk_cent) * conversionRate, 3)) + "\n- " +
    // get order position size (units and lots)
         "Strategy position size (LOTS):" + str.tostring(math.abs(strategy.position_size))
    if str.contains(strategy.opentrades.entry_id(0), "BUY 1")
        label.new(bar_index, low, color = B_lbl1, textcolor = color.new(color.white, 0), text = label_txt, text_font_family = font.family_monospace, style = label.style_label_up)
    else if str.contains(strategy.opentrades.entry_id(0), "SELL 1")
        label.new(bar_index, high, color = S_lbl1, textcolor = color.new(color.white, 0), text = label_txt, text_font_family = font.family_monospace, style = label.style_label_down)

// DEBUG
lb = label.new(bar_index + 10,
     close,
     text = "New day ?" + "\n" + str.tostring(new_day) +
     "\n" + "\n" + "day $ balance" + "\n" + str.tostring(day_start_equity) +
     "\n" + "\n" + "real time $ Equity" + "\n" + str.tostring(acount_balance) +
     "\n" + "\n" + "SYMBOL Trading" + "\n" + str.tostring(pc_ticker),
     text_font_family = font.family_monospace,
     color = color.white,
     style = label.style_label_left)
label.delete(lb[1])

//+------------------------------------------------------------------+
//                                                             TABLE |
//<<------------------------------------------------------------------+{
// create table
table panel = table.new(tableYposInput + "_" + tableXposInput, 2, 4)

// table variables
ror_live = math.round(((acount_balance - strategy.initial_capital) / strategy.initial_capital)*100, 2)
ror_day_live = math.round(((acount_balance - day_start_equity) / day_start_equity)*100, 2)

// custom table function
TableFill(table_id, column, row, expression, text_font_color, background_color, text_font = font.family_monospace) =>
    table.cell(table_id, column, row, text = expression, text_color = text_font_color, bgcolor = background_color, text_font_family =  text_font)

// fill table
TableFill(panel, 0, 0, "BUY", text_clr, bg_clr)
TableFill(panel, 1, 0, strategy.position_size > 0 or new_entry_b_1 ? "LIVE" : "Na", strategy.position_size > 0 or new_entry_b_1 ? color.rgb(0, 255, 8) : color.rgb(255, 0, 0), background_color = bg_clr)
TableFill(panel, 0, 1, "SELL", text_clr, bg_clr)
TableFill(panel, 1, 1, strategy.position_size < 0 or new_entry_s_1 ? "LIVE" : "Na", strategy.position_size < 0 or new_entry_s_1 ? color.rgb(0, 255, 8) : color.rgb(255, 0, 0), bg_clr)
TableFill(panel, 0, 1, "SELL", text_clr, bg_clr)
TableFill(panel, 0, 2, "Strategy ROR", text_clr, bg_clr)
TableFill(panel, 1, 2, str.tostring(ror_live) + "%", text_clr, ror_live > 0 ? color.rgb(0, 255, 8, 60) : color.rgb(194, 0, 0, 61))
TableFill(panel, 0, 3, "Daily Strategy ROR", text_clr, bg_clr)
TableFill(panel, 1, 3, str.tostring(ror_day_live) + "%", text_clr, ror_day_live > 0 ? color.rgb(0, 255, 8, 60) : color.rgb(194, 0, 0, 61))

//>>------------------------------------------------------------------}