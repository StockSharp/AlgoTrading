// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © DonovanWall

//██████╗ ██╗    ██╗
//██╔══██╗██║    ██║
//██║  ██║██║ █╗ ██║
//██║  ██║██║███╗██║
//██████╔╝╚███╔███╔╝
//╚═════╝  ╚══╝╚══╝

//@version=4
study("Monte Carlo Range Forecast [DW]", shorttitle="MC Range Forecast [DW]", overlay=false)

//This is an experimental study designed to forecast the range of price movement from a specified starting point using a Monte Carlo simulation.

//Monte Carlo experiments are a broad class of computational algorithms that utilize random sampling to derive real world numerical results.
//These types of algorithms have a number of applications in numerous fields of study including physics, engineering, behavioral sciences, climate forecasting, computer graphics, gaming AI, mathematics, and finance.
//Although the applications vary, there is a typical process behind the majority of Monte Carlo methods:
// -> First, a distribution of possible inputs is defined.
// -> Next, values are generated randomly from the distribution.
// -> The values are then fed through some form of deterministic algorithm.
// -> And lastly, the results are aggregated over some number of iterations.

//In this study, the Monte Carlo process used generates a distribution of aggregate pseudorandom linear price returns summed over a user defined period, then plots standard deviations of the outcomes from the mean outcome generate forecast regions.
//The pseudorandom process used in this script relies on a modified Wichmann-Hill pseudorandom number generator (PRNG) algorithm.
//Wichmann-Hill is a hybrid generator that uses three linear congruential generators (LCGs) with different prime moduli.
//Each LCG within the generator produces an independent, uniformly distributed number between 0 and 1.
//The three generated values are then summed and modulo 1 is taken to deliver the final uniformly distributed output.
//Because of its long cycle length, Wichmann-Hill is a fantastic generator to use on TV since it's extremely unlikely that you'll ever see a cycle repeat.
//The resulting pseudorandom output from this generator has a minimum repetition cycle length of 6,953,607,871,644.
//Fun fact: Wichmann-Hill is a widely used PRNG in various software applications. For example, Excel 2003 and later uses this algorithm in its RAND function, and it was the default generator in Python up to v2.2.

//The generation algorithm in this script takes the Wichmann-Hill algorithm, and uses a multi-stage transformation process to generate the results.
//First, a parent seed is selected. This can either be a fixed value, or a dynamic value.
//The dynamic parent value is produced by taking advantage of Pine's timenow variable behavior. It produces a variable parent seed by using a frozen ratio of timenow/time.
//Because timenow always refelcts the current real time when frozen and the time variable reflects the chart's beginning time when frozen, the ratio of these values produces a new number every time the cache updates.

//After a parent seed is selected, its value is then fed through a uniformly distributed seed array generator, which generates multiple arrays of pseudorandom "children" seeds.
//The seeds produced in this step are then fed through the main generators to produce arrays of pseudorandom simulated outcomes, and a pseudorandom series to compare with the real series.

//The main generators within this script are designed to (at least somewhat) model the stochastic nature of financial time series data.
//The first step in this process is to transform the uniform outputs of the Wichmann-Hill into outputs that are normally distributed.
//In this script, the transformation is done using an estimate of the normal distribution quantile function.
//Quantile functions, otherwise known as percent-point or inverse cumulative distribution functions, specify the value of a random variable such that the probability of the variable being within the value's boundary equals the input probability.
//The quantile equation for a normal probability distribution is μ + σ(√2)erf^-1(2(p - 0.5)) where μ is the mean of the distribution, σ is the standard deviation, erf^-1 is the inverse Gauss error function, and p is the probability.
//Because erf^-1() does not have a simple, closed form interpretation, it must be approximated.
//To keep things lightweight in this approximation, I used a truncated Maclaurin Series expansion for this function with precomputed coefficients and rolled out operations to avoid nested looping.
//This method provides a decent approximation of the error function without completely breaking floating point limits or sucking up runtime memory.
//Note that there are plenty of more robust techniques to approximate this function, but their memory needs very. I chose this method specifically because of runtime favorability.
//To generate a pseudorandom approximately normally distributed variable, the uniformly distributed variable from the Wichmann-Hill algorithm is used as the input probability for the quantile estimator.

//Now from here, we get a pretty decent output that could be used itself in the simulation process. Many Monte Carlo simulations and random price generators utilize a normal variable.
//However, if you compare the outputs of this normal variable with the actual returns of the real time series, you'll find that the variability in shocks (random changes) doesn't quite behave like it does in real data.
//This is because most real financial time series data is more complex. Its distribution may be approximately normal at times, but the variability of its distribution changes over time due to various underlying factors.
//In light of this, I believe that returns behave more like a convoluted product distribution rather than just a raw normal.
//So the next step to get our procedurally generated returns to more closely emulate the behavior of real returns is to introduce more complexity into our model.
//Through experimentation, I've found that a return series more closely emulating real returns can be generated in a three step process:
// -> First, generate multiple independent, normally distributed variables simultaneously.
// -> Next, apply pseudorandom weighting to each variable ranging from -1 to 1, or some limits within those bounds. This modulates each series to provide more variability in the shocks by producing product distributions.
// -> Lastly, add the results together to generate the final pseudorandom output with a convoluted distribution. This adds variable amounts of constructive and destructive interference to produce a more "natural" looking output.
//In this script, I use three independent normally distributed variables multiplied by uniform product distributed variables.
//The first variable is generated by multiplying a normal variable by one uniformly distributed variable. This produces a bit more tailedness (kurtosis) than a normal distribution, but nothing too extreme.
//The second variable is generated by multiplying a normal variable by two uniformly distributed variables. This produces moderately greater tails in the distribution.
//The third variable is generated by multiplying a normal variable by three uniformly distributed variables. This produces a distribution with heavier tails.
//For additional control of the output distributions, the uniform product distributions are given optional limits.
//These limits control the boundaries for the absolute value of the uniform product variables, which affects the tails. In other words, they limit the weighting applied to the normally distributed variables in this transformation.
//All three sets are then multiplied by user defined amplitude factors to adjust presence, then added together to produce our final pseudorandom return series with a convoluted product distribution.

//Once we have the final, more "natural" looking pseudorandom series, the values are recursively summed over the forecast period to generate a simulated result.
//This process of generation, weighting, addition, and summation is repeated over the user defined number of simulations with different seeds generated from the parent to produce our array of initial simulated outcomes.
//After the initiol simulation array is generated, the max, min, mean and standard deviation of this array are calculated, and the values are stored in holding arrays on each iteration to be called upon later.
//Reference difference series and price values are also stored in holding arrays to be used in our comparison plots.

//In this script, I use a linear model with simple returns rather than compounding log returns to generate the output.
//The reason for this is that in generating outputs this way, we're able to run our simulations recursively from the beginning of the chart, then apply scaling and anchoring post-process.
//This allows a greater conservation of runtime memory than the alternative, making it more suitable for doing longer forecasts with heavier amounts of simulations in TV's runtime environment.

//From our starting time, the previous bar's price, volatility, and optional drift (expected return) are factored into our holding arrays to generate the final forecast parameters.
//After these parameters are computed, the range forecast is produced.
//The basis value for the ranges is the mean outcome of the simulations that were run.
//Then, quarter standard deviations of the simulated outcomes are added to and subtracted from the basis up to 3σ to generate the forecast ranges.
//All of these values are plotted and colorized based on their theoretical probability density. The most likely areas are the warmest colors, and least likely areas are the coolest colors.
//An information panel is also displayed at the starting time which shows the starting time and price, forecast type, parent seed value, simulations run, forecast bars, total drift, mean, standard deviation, max outcome, min outcome, and bars remaining.
//The interesting thing about simulated outcomes is that although the probability distribution of each simulation is not normal, the distribution of different outcomes converges to a normal one with enough steps.
//In light of this, the probability density of oucomes is highest near the initial value + total drift, and decreases the further away from this point you go.
//This makes logical sense since the central path is the easiest one to travel.

//Given the ever changing state of markets, I find this tool to be best suited for shorter term forecasts.
//However, if the movements of price are expected to remain relatively stable, longer term forecasts may be equally as valid.

//There are many possible ways for users to apply this tool to their analysis setups. For example, the forecast ranges may be used as a guide to help users set risk targets.
//Or, the generated levels could be used in conjunction with other indicators for meaningful confluence signals.
//More advanced users could even extrapolate the functions used within this script for various purposes, such as generating pseudorandom data to test systems on, perform integration and approximations, etc.
//These are just a few examples of potential uses of this script. How you choose to use it to benefit your trading, analysis, and coding is entirely up to you.
//If nothing else, I think this is a pretty neat script simply for the novelty of it.

//----------
//How To Use:

//When you first add the script to your chart, you will be prompted to confirm the starting date and time, number of bars to forecast, number of simulations to run, and whether to include drift assumption.
//You will also be prompted to confirm the forecast type. There are two types to choose from:
// -> End Result - This uses the values from the end of the simulation throughout the forecast interval.
// -> Developing - This uses the values that develop from bar to bar, providing a real-time outlook.
//You can always update these settings after confirmation as well.
//Once these inputs are confirmed, the script will boot up and automatically generate the forecast in a separate pane.
//Note that if there is no bar of data at the time you wish to start the forecast, the script will automatically detect use the next available bar after the specified start time.

//From here, you can now control the rest of the settings.

//The "Seeding Settings" section controls the initial seed value used to generate the children that produce the simulations.
//In this section, you can control whether the seed is a fixed value, or a dynamic one.
//Since selecting the dynamic parent option will change the seed value every time you change the settings or refresh your chart, there is a "Regenerate" input built into the script.
//This input is a dummy input that isn't connected to any of the calculations. The purpose of this input is to force an update of the dynamic parent without affecting the generator or forecast settings.
//Note that because we're running a limited number of simulations, different parent seeds will typically yield slightly different forecast ranges.
//When using a small number of simulations, you will likely see a higher amount of variance between differently seeded results because smaller numbers of sampled simulations yield a heavier bias.
//The more simulations you run, the smaller this variance will become since the outcomes become more convergent toward the same distribution, so the differences between differently seeded forecasts will become more marginal.
//When using a dynamic parent, pay attention to the dispersion of ranges.
//When you find a set of ranges that is dispersed how you like with your configuration, set your fixed parent value to the parent seed that shows in the info panel.
//This will allow you to replicate that dispersion behavior again in the future.
//An important thing to note when settings alerts on the plotted levels, or using them as components for signals in other scripts, is to decide on a fixed value for your parent seed to avoid minor repainting due to seed changes.
//When the parent seed is fixed, no repainting occurs.

//The "Amplitude Settings" section controls the amplitude coefficients for the three differently tailed generators.
//These amplitude factors will change the difference series output for each simulation by conrolling how aggressively each series moves.
//When "Adjust Amplitude Coefficients" is disabled, all three coefficients are set to 1.
//Note that if you expect volatility to significantly diverge from its historical values over the forecast interval, try experimenting with these factors to match your anticipation.

//The "Weighting Settings" section controls the weighting boundaries for the three generators.
//These weighting limits affect how tailed the distributions in each generator are, which in turn affects the final series outputs.
//The maximum absolute value range for the weights is [0, 1]. When "Limit Generator Weights" is disabled, this is the range that is automatically used.

//The last set of inputs is the "Display Settings", where you can control the visual outputs.
//From here, you can select to display either "Forecast" or "Difference Comparison" via the "Output Display Type" dropdown tab.
//"Forecast" is the type displayed by default. This plots the end result or developing forecast ranges.
//There is an option with this display type to show the developing extremes of the simulations. This option is enabled by default.
//There's also an option with this display type to show one of the simulated price series from the set alongside actual prices.
//This allows you to visually compare simulated prices alongside the real prices.
//"Difference Comparison" allows you to visually compare a synthetic difference series from the set alongside the actual difference series.
//This display method is primarily useful for visually tuning the amplitude and weighting settings of the generators.
//There are also info panel settings on the bottom, which allow you to control size, colors, and date format for the panel.

//It's all pretty simple to use once you get the hang of it. So play around with the settings and see what kinds of forecasts you can generate!

//----------
//ADDITIONAL NOTES & DISCLAIMERS

//Although I've done a number of things within this script to keep runtime demands as low as possible, the fact remains that this script is fairly computationally heavy.
//Because of this, you may get random timeouts when using this script.
//This could be due to either random drops in available runtime on the server, using too many simulations, or running the simulations over too many bars.
//If it's just a random drop in runtime on the server, hide and unhide the script, re-add it to the chart, or simply refresh the page.
//If the timeout persists after trying this, then you'll need to adjust your settings to a less demanding configuration.

//Please note that no specific claims are being made in regards to this script's predictive accuracy.
//It must be understood that this model is based on randomized price generation with assumed constant drift and dispersion from historical data before the starting point.
//Models like these not consider the real world factors that may influence price movement (economic changes, seasonality, macro-trends, instrument hype, etc.), nor the changes in sample distribution that may occur.
//In light of this, it's perfectly possible for price data to exceed even the most extreme simulated outcomes.

//The future is uncertain, and becomes increasingly uncertain with each passing point in time.
//Predictive models of any type can vary significantly in performance at any point in time, and nobody can guarantee any specific type of future performance.
//When using forecasts in making decisions, DO NOT treat them as any form of guarantee that values will fall within the predicted range.
//When basing your trading decisions on any trading methodology or utility, predictive or not, you do so at your own risk.
//No guarantee is being issued regarding the accuracy of this forecast model.
//Forecasting is very far from an exact science, and the results from any forecast are designed to be interpreted as potential outcomes rather than anything concrete.

//With that being said, when applied prudently and treated as "general case scenarios", forecast models like these may very well be potentially beneficial tools to have in the arsenal.

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Updates:

// - Updated the inverse error function approximation. The previous truncated Maclaurin Series based approximation was a bit too crude for my liking.
// It's now based on inverting a close approximation of the error function. This method has much less estimation error, and significantly more tail preservation.
// Fortunately, this approximation method doesn't make a significantly larger dent in runtime consumption, so you should still be able to enjoy the forecast configurations you had in the previous version.

// - Added a price tracking field to the bottom of the info panel.
// When there are bars remaining in the forecast, the panel will say, "Current Price = xxx," where xxx is the real time current price value.
// When the forecast interval is completed, the panel will say, "Final Price = xxx," where xxx is the final price on the last bar of the forecast interval.

//Please note that once you load your chart with this updated version, it will replace the previous version and override your previous settings if you have it on the chart already.
//So, be sure to either re-add the script to your chart, or reconfigure your forecast settings.

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Functions
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Parent Seed Function
Parent_Seed(m)=>
    var time_ratio = 10000000*timenow/time
    var fraction   = time_ratio - floor(time_ratio)
    var Parent     = round(fraction*m)
    Parent

//Seed Array Generator Function (Uniformly Distributed)
Rand_Seeds(s, n)=>
    var indx      = 0
    var seeds     = array.new_float(n)
    var seed_temp = 0.0
    var a1        = s
    var a2        = s
    var a3        = s
    if indx==0
        for i = 0 to (n - 1)
            a1        := (171*a1 % 30269)
            a2        := (172*a2 % 30307)
            a3        := (170*a3 % 30323)
            seed_temp := ((a1/30269) + (a2/30307) + (a3/30323)) % 1
            array.set(seeds, i, max(round(seed_temp*10000), 1))
        indx := indx + 1
    var s_copy     = array.copy(seeds)
    var slice_size = int(n/3)
    seeds1     = array.slice(s_copy, 0, slice_size)
    seeds2     = array.slice(s_copy, slice_size, 2*slice_size)
    seeds3     = array.slice(s_copy, 2*slice_size, 3*slice_size)
    [seeds1, seeds2, seeds3]

//Simulation Value Function
Sim_Vals(s1_vals, s2_vals, s3_vals, s4_vals, s5_vals, s6_vals, nbars,
         amp1, amp2, amp3, min_w1, min_w2, min_w3, max_w1, max_w2, max_w3, indx_d, indx_p)=>
    var sr2         = sqrt(2)
    var pi          = acos(-1)
    var A           = 8*(pi - 3)/(3*pi*(4 - pi))
    var B           = 2/(A*pi)
    var nsims       = array.size(s1_vals)
    var max_vals    = array.new_float(nbars)
    var min_vals    = array.new_float(nbars)
    a1_vals         = array.copy(s1_vals)
    a2_vals         = array.copy(s2_vals)
    a3_vals         = array.copy(s3_vals)
    a4_vals         = array.copy(s4_vals)
    a5_vals         = array.copy(s5_vals)
    a6_vals         = array.copy(s6_vals)
    b1_vals         = array.copy(s3_vals)
    b2_vals         = array.copy(s1_vals)
    b3_vals         = array.copy(s2_vals)
    b4_vals         = array.copy(s6_vals)
    b5_vals         = array.copy(s4_vals)
    b6_vals         = array.copy(s5_vals)
    b7_vals         = array.copy(s2_vals)
    b8_vals         = array.copy(s3_vals)
    b9_vals         = array.copy(s1_vals)
    c1_vals         = array.copy(s2_vals)
    c2_vals         = array.copy(s1_vals)
    c3_vals         = array.copy(s3_vals)
    c4_vals         = array.copy(s5_vals)
    c5_vals         = array.copy(s4_vals)
    c6_vals         = array.copy(s6_vals)
    c7_vals         = array.copy(s1_vals)
    c8_vals         = array.copy(s3_vals)
    c9_vals         = array.copy(s5_vals)
    c10_vals        = array.copy(s2_vals)
    c11_vals        = array.copy(s4_vals)
    c12_vals        = array.copy(s6_vals)
    var rand_temp1a = 0.0
    var rand_temp2a = 0.0
    var rand_temp3a = 0.0
    var rand_temp4a = 0.0
    var rand_temp5a = 0.0
    var rand_temp6a = 0.0
    var rand_temp7a = 0.0
    var rand_temp8a = 0.0
    var rand_temp9a = 0.0
    var rand_temp1  = 0.0
    var rand_temp2  = 0.0
    var rand_temp3  = 0.0
    var rand_temp4  = 0.0
    var rand_temp5  = 0.0
    var rand_temp6  = 0.0
    var rand_temp7  = 0.0
    var rand_temp8  = 0.0
    var rand_temp9  = 0.0
    var rand_wt1a   = 0.0
    var rand_wt2a   = 0.0
    var rand_wt3a   = 0.0
    var rand_wt1    = 0.0
    var rand_wt2    = 0.0
    var rand_wt3    = 0.0
    var fin_rand1   = 0.0
    var fin_rand2   = 0.0
    var fin_rand3   = 0.0
    var erf_inv1a   = 0.0
    var erf_inv1b   = 0.0
    var erf_inv1    = 0.0
    var erf_inv2a   = 0.0
    var erf_inv2b   = 0.0
    var erf_inv2    = 0.0
    var erf_inv3a   = 0.0
    var erf_inv3b   = 0.0
    var erf_inv3    = 0.0
    var rand_difs   = array.new_float(nsims)
    var rand_sims   = array.new_float(nsims, 0.0)
    var s_sum       = 0.0
    var s2_sum      = 0.0
    var s_temp      = 0.0
    var s_means     = array.new_float(nbars)
    var s_sdevs     = array.new_float(nbars)
    var s_difs      = array.new_float(nbars)
    var s_prices    = array.new_float(nbars)
    var indx        = 0
    if indx < nbars
        s_sum  := 0.0
        s2_sum := 0.0
        for i = 0 to (nsims - 1)
            erf_inv1a := 0.0
            erf_inv1b := 0.0
            erf_inv1  := 0.0
            erf_inv2a := 0.0
            erf_inv2b := 0.0
            erf_inv2  := 0.0
            erf_inv3a := 0.0
            erf_inv3b := 0.0
            erf_inv3  := 0.0
            array.set(a1_vals, i, 171*array.get(a1_vals, i) % 30269)
            array.set(a2_vals, i, 172*array.get(a2_vals, i) % 30307)
            array.set(a3_vals, i, 170*array.get(a3_vals, i) % 30323)
            rand_temp1a := ((array.get(a1_vals, i)/30269) + (array.get(a2_vals, i)/30307) + (array.get(a3_vals, i)/30323)) % 1
            rand_temp1  := 2*(rand_temp1a - 0.5)
            erf_inv1a   := 0.5*log(1 - rand_temp1*rand_temp1)
            erf_inv1b   := B + erf_inv1a
            erf_inv1    := sqrt(sqrt(erf_inv1b*erf_inv1b - erf_inv1a*2/A) - erf_inv1b)
            array.set(a4_vals, i, 171*array.get(a4_vals, i) % 30269)
            array.set(a5_vals, i, 172*array.get(a5_vals, i) % 30307)
            array.set(a6_vals, i, 170*array.get(a6_vals, i) % 30323)
            rand_temp2a := ((array.get(a4_vals, i)/30269) + (array.get(a5_vals, i)/30307) + (array.get(a6_vals, i)/30323)) % 1
            rand_temp2  := 2*(rand_temp2a - 0.5)
            array.set(b1_vals, i, 171*array.get(b1_vals, i) % 30269)
            array.set(b2_vals, i, 172*array.get(b2_vals, i) % 30307)
            array.set(b3_vals, i, 170*array.get(b3_vals, i) % 30323)
            rand_temp3a := ((array.get(b1_vals, i)/30269) + (array.get(b2_vals, i)/30307) + (array.get(b3_vals, i)/30323)) % 1
            rand_temp3  := 2*(rand_temp3a - 0.5)
            erf_inv2a   := 0.5*log(1 - rand_temp3*rand_temp3)
            erf_inv2b   := B + erf_inv2a
            erf_inv2    := sqrt(sqrt(erf_inv2b*erf_inv2b - erf_inv2a*2/A) - erf_inv2b)
            array.set(b4_vals, i, 171*array.get(b4_vals, i) % 30269)
            array.set(b5_vals, i, 172*array.get(b5_vals, i) % 30307)
            array.set(b6_vals, i, 170*array.get(b6_vals, i) % 30323)
            rand_temp4a := ((array.get(b4_vals, i)/30269) + (array.get(b5_vals, i)/30307) + (array.get(b6_vals, i)/30323)) % 1
            rand_temp4  := 2*(rand_temp4a - 0.5)
            array.set(b7_vals, i, 171*array.get(b7_vals, i) % 30269)
            array.set(b8_vals, i, 172*array.get(b8_vals, i) % 30307)
            array.set(b9_vals, i, 170*array.get(b9_vals, i) % 30323)
            rand_temp5a := ((array.get(b7_vals, i)/30269) + (array.get(b8_vals, i)/30307) + (array.get(b9_vals, i)/30323)) % 1
            rand_temp5  := 2*(rand_temp5a - 0.5)
            array.set(c1_vals, i, 171*array.get(c1_vals, i) % 30269)
            array.set(c2_vals, i, 172*array.get(c2_vals, i) % 30307)
            array.set(c3_vals, i, 170*array.get(c3_vals, i) % 30323)
            rand_temp6a := ((array.get(c1_vals, i)/30269) + (array.get(c2_vals, i)/30307) + (array.get(c3_vals, i)/30323)) % 1
            rand_temp6  := 2*(rand_temp6a - 0.5)
            erf_inv3a   := 0.5*log(1 - rand_temp6*rand_temp6)
            erf_inv3b   := B + erf_inv3a
            erf_inv3    := sqrt(sqrt(erf_inv3b*erf_inv3b - erf_inv3a*2/A) - erf_inv3b)
            array.set(c4_vals, i, 171*array.get(c4_vals, i) % 30269)
            array.set(c5_vals, i, 172*array.get(c5_vals, i) % 30307)
            array.set(c6_vals, i, 170*array.get(c6_vals, i) % 30323)
            rand_temp7a := ((array.get(c4_vals, i)/30269) + (array.get(c5_vals, i)/30307) + (array.get(c6_vals, i)/30323)) % 1
            rand_temp7  := 2*(rand_temp7a - 0.5)
            array.set(c7_vals, i, 171*array.get(c7_vals, i) % 30269)
            array.set(c8_vals, i, 172*array.get(c8_vals, i) % 30307)
            array.set(c9_vals, i, 170*array.get(c9_vals, i) % 30323)
            rand_temp8a := ((array.get(c7_vals, i)/30269) + (array.get(c8_vals, i)/30307) + (array.get(c9_vals, i)/30323)) % 1
            rand_temp8  := 2*(rand_temp8a - 0.5)
            array.set(c10_vals, i, 171*array.get(c10_vals, i) % 30269)
            array.set(c11_vals, i, 172*array.get(c11_vals, i) % 30307)
            array.set(c12_vals, i, 170*array.get(c12_vals, i) % 30323)
            rand_temp9a := ((array.get(c10_vals, i)/30269) + (array.get(c11_vals, i)/30307) + (array.get(c12_vals, i)/30323)) % 1
            rand_temp9  := 2*(rand_temp9a - 0.5)
            rand_wt1a   := rand_temp2
            rand_wt1    := min(max(abs(rand_wt1a), min_w1), max_w1)*(rand_wt1a)/abs(rand_wt1a)
            fin_rand1   := sr2*erf_inv1*rand_wt1*amp1
            rand_wt2a   := rand_temp4*rand_temp5
            rand_wt2    := min(max(abs(rand_wt2a), min_w2), max_w2)*(rand_wt2a)/abs(rand_wt2a)
            fin_rand2   := sr2*erf_inv2*rand_wt2*amp2
            rand_wt3a   := rand_temp7*rand_temp8*rand_temp9
            rand_wt3    := min(max(abs(rand_wt3a), min_w3), max_w3)*(rand_wt3a)/abs(rand_wt3a)
            fin_rand3   := sr2*erf_inv3*rand_wt3*amp3
            array.set(rand_difs, i, fin_rand1 + fin_rand2 + fin_rand3)
            array.set(rand_sims, i, array.get(rand_sims, i) + array.get(rand_difs, i))
            s_temp := array.get(rand_sims, i)
            s_sum  := s_sum + s_temp
            s2_sum := s2_sum + s_temp*s_temp
        array.set(s_means, indx, s_sum/nsims)
        array.set(s_sdevs, indx, sqrt((s2_sum/nsims) - (s_sum*s_sum)/(nsims*nsims)))
        array.set(max_vals, indx, array.max(rand_sims))
        array.set(min_vals, indx, array.min(rand_sims))
        array.set(s_difs, indx, array.get(rand_difs, indx_d))
        array.set(s_prices, indx, array.get(rand_sims, indx_p))
        indx := indx + 1
    [max_vals, min_vals, s_means, s_sdevs, s_difs, s_prices]

//Loop Free SMA Function
SMA(x, n)=>
    var x_vals    = array.new_float(n + 1)
    var sum       = 0.0
    var float SMA = na
    array.unshift(x_vals, x)
    array.pop(x_vals)
    sum := nz(sum) + array.get(x_vals, 0)
    if not na(array.get(x_vals, n))
        sum := nz(sum) - array.get(x_vals, n)
        SMA := sum/n
    SMA

//Loop Free Standard Deviation Function
Stdev(x, n)=>
    sqrt(SMA(x*x, n) - pow(SMA(x, n), 2))

//Cumulative Max Function
cmax(x)=>
    var cmax = 0.0
    if not na(x)
        if x > cmax
            cmax := x
    cmax

//Info Panel Drawing Function
draw_info_panel(show_, stime, price_, txt_, size_, color_bg, color_txt, lr)=>
    var panel_size   = size_=="Auto" ? size.auto : size_=="Tiny" ? size.tiny : size_=="Small" ? size.small : size_=="Normal" ? size.normal : size_=="Large" ? size.large : size.huge
    var style_       = lr=="Right" ? label.style_label_right : label.style_label_left
    var label panel_ = label.new(x=na, y=na, text=na, xloc=xloc.bar_time, color=color_bg, style=style_, textcolor=color_txt, size=panel_size, textalign=text.align_left)
    if show_
        label.set_xy(panel_, stime, price_)
        label.set_text(panel_, txt_)

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Inputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Forecast Inputs
var start_time  = input(defval=timestamp("01 Jan 2021 00:00"), type=input.time, title="Start Time", confirm=true, group="═════ Forecast Settings ═════", inline="fst")
var fbars       = input(defval=100, minval=2, title="Bars", confirm=true, group="═════ Forecast Settings ═════", inline="fsb")
var simulations = input(defval=1000, minval=2, title="Simulations", confirm=true, group="═════ Forecast Settings ═════", inline="fsb")*3
var use_drift   = input(defval=false, title="Include Drift Assumption", confirm=true, group="═════ Forecast Settings ═════", inline="fda")
var ftype       = input(defval="End Result", options=["End Result", "Developing"], title="Type", confirm=true, group="═════ Forecast Settings ═════", inline="ft")

//Seeding Inputs
var parent_type = input(defval="Fixed", options=["Fixed", "Dynamic"], title="Parent Seed Type", group="═════ Seeding Settings ═════", inline="pst")
var f_parent    = input(defval=123456.0, minval=0, title="Seed Value", group="Fixed Parent", inline="psfv")
var regen       = input(defval=0, title="Regenerate", group="Dynamic Parent", inline="psrg")

//Amplitude Inputs
var amp_cust = input(defval=true, title="Adjust Amplitude Coefficients", group="═════ Amplitude Settings ═════")
var coef_l   = input(defval=1.0, minval=0, title="Value", group="Variable 1", inline="v1c")
var coef_m   = input(defval=2.0, minval=0, title="Value", group="Variable 2", inline="v2c")
var coef_h   = input(defval=3.0, minval=0, title="Value", group="Variable 3", inline="v3c")

//Weighting Inputs
var lim_weight = input(defval=true, title="Limit Generator Weights", group="═════ Weighting Settings ═════")
var ls_min_wt  = input(defval=0.5, minval=0, maxval=1, title="Min", group="Variable 1 ", inline="v1w")
var ls_max_wt  = input(defval=1.0, minval=0, maxval=1, title="Max", group="Variable 1 ", inline="v1w")
var ms_min_wt  = input(defval=0.25, minval=0, maxval=1, title="Min", group="Variable 2 ", inline="v2w")
var ms_max_wt  = input(defval=1.0, minval=0, maxval=1, title="Max", group="Variable 2 ", inline="v2w")
var hs_min_wt  = input(defval=0.0, minval=0, maxval=1, title="Min", group="Variable 3 ", inline="v3w")
var hs_max_wt  = input(defval=1.0, minval=0, maxval=1, title="Max", group="Variable 3 ", inline="v3w")

//Display Settings
var disp_type       = input(defval="Forecast", options=["Forecast", "Difference Comparison"], title="Output Disaply Type", group="═════ Display Settings ═════", inline="odt")
var show_dev_ex     = input(defval=true, title="Show Developing Extremes", group="Forecast Display", inline="fsex")
var show_sim        = input(defval=false, title=" ", group="Forecast Display", inline="fsn")
var sim_nump        = input(defval=1, minval=1, title="Show Simulation #", group="Forecast Display", inline="fsn") - 1
var sim_numd        = input(defval=1, minval=1, title="Show Simulation #", group="Difference Comparison Display", inline="dsn") - 1
var show_info_label = input(defval=true, title=" ", group="Info Panel", inline="iplbl")
var lbl_size        = input(defval="Large", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], title="Show Panel", group="Info Panel", inline="iplbl")
var lbl_color       = input(defval=color.new(#350219, 30), title="Background", group="Info Panel", inline="ipcol")
var lbl_tcolor      = input(defval=color.new(#ffffff, 30), title="Text", group="Info Panel", inline="ipcol")
var date_format     = input(defval="MM/DD/YYYY", options=["MM/DD/YYYY", "YYYY/MM/DD", "DD/MM/YYYY"], title="Date Format", group="Info Panel", inline="ipdf")

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Definitions
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Constant Value Initialization
var end_index      = fbars - 1
var amp_l          = amp_cust ? coef_l : 1
var amp_m          = amp_cust ? coef_m : 1
var amp_h          = amp_cust ? coef_h : 1
var ls_min         = lim_weight ? ls_min_wt : 0
var ls_max         = lim_weight ? ls_max_wt : 1
var ms_min         = lim_weight ? ms_min_wt : 0
var ms_max         = lim_weight ? ms_max_wt : 1
var hs_min         = lim_weight ? hs_min_wt : 0
var hs_max         = lim_weight ? hs_max_wt : 1
var sim_num_p      = int(min(sim_nump, (simulations/3) - 1))
var sim_num_d      = int(min(sim_numd, (simulations/3) - 1))

//Simulation Data Initialization
src                = close
var start_price    = 0.0
var st_dev         = 0.0
var drift          = 0.0
var mc_mean        = 0.0
var mc_median      = 0.0
var mc_max         = 0.0
var mc_min         = 0.0
var mc_sdev        = 0.0
var float f_basis  = na
var hb             = array.new_float(12)
var lb             = array.new_float(12)
var float dev_h    = na
var float dev_l    = na
var float dev_m    = na
var dev_sd         = 0.0
var drift_dev      = 0.0
var bars           = 0
var fcond          = 0
var erf_inv_1      = 0.0
var erf_inv_2      = 0.0
var erf_inv_3      = 0.0
var rand_wt_lsa    = 0.0
var rand_wt_ls     = 0.0
var rand_final1    = 0.0
var rand_wt_msa    = 0.0
var rand_wt_ms     = 0.0
var rand_final2    = 0.0
var rand_wt_hsa    = 0.0
var rand_wt_hs     = 0.0
var rand_final3    = 0.0
var rand_series    = 0.0
var rand_price     = 0.0

//Info Panel Data Initialization
var start_year     = 0
var start_month    = 0
var start_day      = 0
var start_hour     = 0
var start_min      = 0
var start_sec      = 0
var days           = 0
var days_prev      = 0
var date_text1     = ""
var date_text2     = ""
var date_text3     = ""
var date_text      = ""
var time_text      = ""
var dt_text        = ""
var type_text      = "\nForecast Type = " + ftype + "\n═══════════════════\n"
var parent_text    = ""
var sim_text       = "Simulations Run = " + tostring(simulations/3)
var fbar_text      = "\nBars Forecast = " + tostring(fbars)
var drift_text     = ""
var mean_text      = ""
var sd_text        = ""
var max_text       = ""
var min_text       = ""
var info_text1     = ""
var info_text2     = "\n═══════════════════\nForecast Bars Remaining = "
var info_text3     = ""
var info_text      = ""

//Color Data Initialization
var fill1          = #ffa900
var fill2          = #ff9002
var fill3          = #ff731a
var fill4          = #ff4e2f
var fill5          = #ff0044
var fill6          = #ff005a
var fill7          = #ff0073
var fill8          = #ff008e
var fill9          = #f100ab
var fill10         = #ce00c9
var fill11         = #9800e6
var fill12         = #1e00ff
var b_color        = #ff8b00
var act_col        = #ffffff
var act_col2       = #00ffff
var act_col3       = #14e110
var inact_col      = #8b8b8b
var bg_col         = #000000

//Parent Seed
parent1 = Parent_Seed(1000000)
parent  = parent_type=="Dynamic" ? parent1 : f_parent

//Child Seed Generation
[children1, children2, children3] = Rand_Seeds(parent, simulations)
[children4, children5, children6] = Rand_Seeds(parent + 1, simulations)

//Main Data Array Generation
[hvals, lvals, mvals, svals, dvals, pvals] = Sim_Vals(children1, children2, children3, children4, children5, children6, fbars,
                                                      amp_l, amp_m, amp_h, ls_min, ms_min, hs_min, ls_max, ms_max, hs_max, sim_num_d, sim_num_p)

//Drift and Volatility Parameters
real_series = (src - src[1])
st_dev1     = Stdev(real_series, fbars)
drift1      = SMA(real_series, fbars)*fbars

//Forecast & Comparison Data Generation
if time >= start_time
    if time[1] < start_time
        st_dev := st_dev1[1]
        if use_drift
            drift := drift1[1]
        start_price := src[1]
        start_year  := year
        start_month := month
        start_day   := dayofmonth
        start_hour  := hour
        start_min   := minute
        start_sec   := second
        date_text1  := tostring(start_year) + "/" + (start_month < 10 ? "0" : "") + tostring(start_month) + "/" + (start_day < 10 ? "0" : "") + tostring(start_day)
        date_text2  := (start_month < 10 ? "0" : "") + tostring(start_month) + "/" + (start_day < 10 ? "0" : "") + tostring(start_day) + "/" + tostring(start_year)
        date_text3  := (start_day < 10 ? "0" : "") + tostring(start_day) + "/" + (start_month < 10 ? "0" : "") + tostring(start_month) + "/" + tostring(start_year)
        date_text   := date_format=="YYYY/MM/DD" ? date_text1 : date_format=="MM/DD/YYYY" ? date_text2 : date_text3
        time_text   := (start_hour < 10 ? "0" : "") + tostring(start_hour) + ":" + (start_min < 10 ? "0" : "") + tostring(start_min) + ":" + (start_sec < 10 ? "0" : "") + tostring(start_sec)
        dt_text     := "Simulating From " + date_text + ", " + time_text + " (Exchange Time)" + "\nStarting Price = " + tostring(start_price) + type_text
        parent_text := "Parent Seed = " + tostring(parent) + "\n═══════════════════\n"
        if ftype=="End Result"
            mc_max  := start_price + array.get(hvals, end_index)*st_dev + drift
            mc_min  := start_price + array.get(lvals, end_index)*st_dev + drift
            mc_mean := start_price + array.get(mvals, end_index)*st_dev + drift
            mc_sdev := array.get(svals, end_index)*st_dev
            f_basis := mc_mean
            array.set(hb, 0, f_basis + mc_sdev*0.25)
            array.set(hb, 1, f_basis + mc_sdev*0.5)
            array.set(hb, 2, f_basis + mc_sdev*0.75)
            array.set(hb, 3, f_basis + mc_sdev*1)
            array.set(hb, 4, f_basis + mc_sdev*1.25)
            array.set(hb, 5, f_basis + mc_sdev*1.5)
            array.set(hb, 6, f_basis + mc_sdev*1.75)
            array.set(hb, 7, f_basis + mc_sdev*2)
            array.set(hb, 8, f_basis + mc_sdev*2.25)
            array.set(hb, 9, f_basis + mc_sdev*2.5)
            array.set(hb, 10, f_basis + mc_sdev*2.75)
            array.set(hb, 11, f_basis + mc_sdev*3)
            array.set(lb, 0, f_basis - mc_sdev*0.25)
            array.set(lb, 1, f_basis - mc_sdev*0.5)
            array.set(lb, 2, f_basis - mc_sdev*0.75)
            array.set(lb, 3, f_basis - mc_sdev*1)
            array.set(lb, 4, f_basis - mc_sdev*1.25)
            array.set(lb, 5, f_basis - mc_sdev*1.5)
            array.set(lb, 6, f_basis - mc_sdev*1.75)
            array.set(lb, 7, f_basis - mc_sdev*2)
            array.set(lb, 8, f_basis - mc_sdev*2.25)
            array.set(lb, 9, f_basis - mc_sdev*2.5)
            array.set(lb, 10, f_basis - mc_sdev*2.75)
            array.set(lb, 11, f_basis - mc_sdev*3)
            drift_text  := "\nTotal Drift = " + tostring(drift) + "\n═══════════════════\n"
            mean_text   := "Mean Outcome = " + tostring(mc_mean)
            sd_text     := "\nStandard Deviation = " + tostring(mc_sdev)
            max_text    := "\nMaximum Outcome = " + tostring(mc_max)
            min_text    := "\nMinimum Outcome = " + tostring(mc_min)
            info_text1  := dt_text + parent_text +
                           sim_text + fbar_text + drift_text +
                           mean_text + sd_text + max_text + min_text
    if bars==fbars
        fcond := 0
    if bars < fbars
        rand_series := array.get(dvals, bars)*st_dev + drift/fbars
        drift_dev   := drift*bars/fbars
        rand_price  := start_price + array.get(pvals, bars)*st_dev + drift_dev
        dev_h       := start_price + array.get(hvals, bars)*st_dev + drift_dev
        dev_l       := start_price + array.get(lvals, bars)*st_dev + drift_dev
        dev_m       := start_price + array.get(mvals, bars)*st_dev + drift_dev
        dev_sd      := array.get(svals, bars)*st_dev
        if ftype=="Developing"
            f_basis := dev_m
            array.set(hb, 0, f_basis + dev_sd*0.25)
            array.set(hb, 1, f_basis + dev_sd*0.5)
            array.set(hb, 2, f_basis + dev_sd*0.75)
            array.set(hb, 3, f_basis + dev_sd*1)
            array.set(hb, 4, f_basis + dev_sd*1.25)
            array.set(hb, 5, f_basis + dev_sd*1.5)
            array.set(hb, 6, f_basis + dev_sd*1.75)
            array.set(hb, 7, f_basis + dev_sd*2)
            array.set(hb, 8, f_basis + dev_sd*2.25)
            array.set(hb, 9, f_basis + dev_sd*2.5)
            array.set(hb, 10, f_basis + dev_sd*2.75)
            array.set(hb, 11, f_basis + dev_sd*3)
            array.set(lb, 0, f_basis - dev_sd*0.25)
            array.set(lb, 1, f_basis - dev_sd*0.5)
            array.set(lb, 2, f_basis - dev_sd*0.75)
            array.set(lb, 3, f_basis - dev_sd*1)
            array.set(lb, 4, f_basis - dev_sd*1.25)
            array.set(lb, 5, f_basis - dev_sd*1.5)
            array.set(lb, 6, f_basis - dev_sd*1.75)
            array.set(lb, 7, f_basis - dev_sd*2)
            array.set(lb, 8, f_basis - dev_sd*2.25)
            array.set(lb, 9, f_basis - dev_sd*2.5)
            array.set(lb, 10, f_basis - dev_sd*2.75)
            array.set(lb, 11, f_basis - dev_sd*3)
            drift_text  := "\nTotal Drift = " + tostring(drift_dev) + "\n═══════════════════\n"
            mean_text   := "Mean Outcome = " + tostring(dev_m)
            sd_text     := "\nStandard Deviation = " + tostring(dev_sd)
            max_text    := "\nMaximum Outcome = " + tostring(dev_h)
            min_text    := "\nMinimum Outcome = " + tostring(dev_l)
            info_text1  := dt_text + parent_text +
                           sim_text + fbar_text + drift_text +
                           mean_text + sd_text + max_text + min_text
        fcond      := 1
        bars       := bars + 1
        info_text3 := info_text2 + tostring(fbars + 1 - bars) + "\n═══════════════════\nCurrent Price = " + tostring(src)
        info_text  := info_text1 + info_text3
    if fcond==0
        info_text3 := info_text2 + "0" + "\n═══════════════════\nFinal Price = " + tostring(src[1])
        info_text  := info_text1 + info_text3
real_max = cmax(time < start_time ? 0 : abs(real_series))
rand_max = cmax(time < start_time ? 0 : abs(rand_series))
if fcond==0
    rand_series := 0
    rand_max    := 0
    real_max    := 0

//-----------------------------------------------------------------------------------------------------------------------------------------------------------------
//Outputs
//-----------------------------------------------------------------------------------------------------------------------------------------------------------------

//Background Color
bgcolor(bg_col, transp=0)

//Comparison Displays
plot(disp_type=="Difference Comparison" ? real_series : na, title="Real Changes")
plot(disp_type=="Difference Comparison" ? rand_series : na, color=#ffffff, title="Random Changes")
plot(disp_type=="Difference Comparison" ? real_max : na, color=#00ff8b, title="Real Maximum Change Upper Band")
plot(disp_type=="Difference Comparison" ? -real_max : na, color=#00ff8b, title="Real Maximum Change Lower Band")
plot(disp_type=="Difference Comparison" ? rand_max : na, color=#ffff00, title="Random Maximum Change Upper Band")
plot(disp_type=="Difference Comparison" ? -rand_max : na, color=#ffff00, title="Random Minimum Change Lower Band")

//Price Plots
plot((disp_type=="Forecast") and (fcond==0) ? src : na, color=inact_col, style=plot.style_linebr, title="Price Outside Forecast Bars")
plot((disp_type=="Forecast") and fcond ? src : na, color=act_col, style=plot.style_linebr, linewidth=3, transp=0, title="Price Within Forecast Bars")

//Forecast Range Plots
mid_plot  = plot((disp_type=="Forecast") and fcond ? f_basis : na, color=b_color, linewidth=3, title="Expected Value Level")
hb1_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 0) : na, color=fill1, linewidth=1, title="0.25 Sigma Upper Level")
hb2_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 1) : na, color=fill2, linewidth=1, title="0.5 Sigma Upper Level")
hb3_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 2) : na, color=fill3, linewidth=1, title="0.75 Sigma Upper Level")
hb4_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 3) : na, color=fill4, linewidth=3, title="1 Sigma Upper Level")
hb5_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 4) : na, color=fill5, linewidth=1, title="1.25 Sigma Upper Level")
hb6_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 5) : na, color=fill6, linewidth=1, title="1.5 Sigma Upper Level")
hb7_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 6) : na, color=fill7, linewidth=1, title="1.75 Sigma Upper Level")
hb8_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 7) : na, color=fill8, linewidth=3, title="2 Sigma Upper Level")
hb9_plot  = plot((disp_type=="Forecast") and fcond ? array.get(hb, 8) : na, color=fill9, linewidth=1, title="2.25 Sigma Upper Level")
hb10_plot = plot((disp_type=="Forecast") and fcond ? array.get(hb, 9) : na, color=fill10, linewidth=1, title="2.5 Sigma Upper Level")
hb11_plot = plot((disp_type=="Forecast") and fcond ? array.get(hb, 10) : na, color=fill11, linewidth=1, title="2.75 Sigma Upper Level")
hb12_plot = plot((disp_type=="Forecast") and fcond ? array.get(hb, 11) : na, color=fill12, linewidth=3, title="3 Sigma Upper Level")
lb1_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 0) : na, color=fill1, linewidth=1, title="0.25 Sigma Lower Level")
lb2_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 1) : na, color=fill2, linewidth=1, title="0.5 Sigma Lower Level")
lb3_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 2) : na, color=fill3, linewidth=1, title="0.75 Sigma Lower Level")
lb4_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 3) : na, color=fill4, linewidth=3, title="1 Sigma Lower Level")
lb5_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 4) : na, color=fill5, linewidth=1, title="1.25 Sigma Lower Level")
lb6_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 5) : na, color=fill6, linewidth=1, title="1.5 Sigma Lower Level")
lb7_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 6) : na, color=fill7, linewidth=1, title="1.75 Sigma Lower Level")
lb8_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 7) : na, color=fill8, linewidth=3, title="2 Sigma Lower Level")
lb9_plot  = plot((disp_type=="Forecast") and fcond ? array.get(lb, 8) : na, color=fill9, linewidth=1, title="2.25 Sigma Lower Level")
lb10_plot = plot((disp_type=="Forecast") and fcond ? array.get(lb, 9) : na, color=fill10, linewidth=1, title="2.5 Sigma Lower Level")
lb11_plot = plot((disp_type=="Forecast") and fcond ? array.get(lb, 10) : na, color=fill11, linewidth=1, title="2.75 Sigma Lower Level")
lb12_plot = plot((disp_type=="Forecast") and fcond ? array.get(lb, 11) : na, color=fill12, linewidth=3, title="3 Sigma Lower Level")

//Forecast Range Fills
fill(mid_plot, hb1_plot, color=fill1, transp=60, title="0.25 Sigma Upper Fill")
fill(hb1_plot, hb2_plot, color=fill2, transp=60, title="0.25 - 0.5 Sigma Upper Fill")
fill(hb2_plot, hb3_plot, color=fill3, transp=60, title="0.5 - 0.75 Sigma Upper Fill")
fill(hb3_plot, hb4_plot, color=fill4, transp=60, title="0.75 - 1 Sigma Upper Fill")
fill(hb4_plot, hb5_plot, color=fill5, transp=60, title="1 - 1.25 Sigma Upper Fill")
fill(hb5_plot, hb6_plot, color=fill6, transp=60, title="1.25 - 1.5 Sigma Upper Fill")
fill(hb6_plot, hb7_plot, color=fill7, transp=60, title="1.5 - 1.75 Sigma Upper Fill")
fill(hb7_plot, hb8_plot, color=fill8, transp=60, title="1.75 - 2 Sigma Upper Fill")
fill(hb8_plot, hb9_plot, color=fill9, transp=60, title="2 - 2.25 Sigma Upper Fill")
fill(hb9_plot, hb10_plot, color=fill10, transp=60, title="2.25 - 2.5 Sigma Upper Fill")
fill(hb10_plot, hb11_plot, color=fill11, transp=60, title="2.5 - 2.75 Sigma Upper Fill")
fill(hb11_plot, hb12_plot, color=fill12, transp=60, title="2.75 - 3 Sigma Upper Fill")
fill(mid_plot, lb1_plot, color=fill1, transp=60, title="0.25 Sigma Lower Fill")
fill(lb1_plot, lb2_plot, color=fill2, transp=60, title="0.25 - 0.5 Sigma Lower Fill")
fill(lb2_plot, lb3_plot, color=fill3, transp=60, title="0.5 - 0.75 Sigma Lower Fill")
fill(lb3_plot, lb4_plot, color=fill4, transp=60, title="0.75 - 1 Sigma Lower Fill")
fill(lb4_plot, lb5_plot, color=fill5, transp=60, title="1 - 1.25 Sigma Lower Fill")
fill(lb5_plot, lb6_plot, color=fill6, transp=60, title="1.25 - 1.5 Sigma Lower Fill")
fill(lb6_plot, lb7_plot, color=fill7, transp=60, title="1.5 - 1.75 Sigma Lower Fill")
fill(lb7_plot, lb8_plot, color=fill8, transp=60, title="1.75 - 2 Sigma Lower Fill")
fill(lb8_plot, lb9_plot, color=fill9, transp=60, title="2 - 2.25 Sigma Lower Fill")
fill(lb9_plot, lb10_plot, color=fill10, transp=60, title="2.25 - 2.5 Sigma Lower Fill")
fill(lb10_plot, lb11_plot, color=fill11, transp=60, title="2.5 - 2.75 Sigma Lower Fill")
fill(lb11_plot, lb12_plot, color=fill12, transp=60, title="2.75 - 3 Sigma Lower Fill")

//Developing Value Reference Plots
plot((disp_type=="Forecast") and fcond and show_dev_ex ? dev_h : na, color=act_col2, style=plot.style_linebr, linewidth=3, title="Developing High Outcome")
plot((disp_type=="Forecast") and fcond and show_dev_ex ? dev_l : na, color=act_col2, style=plot.style_linebr, linewidth=3, title="Developing Low Outcome")
plot((disp_type=="Forecast") and fcond and show_sim ? rand_price : na, color=act_col3, style=plot.style_linebr, linewidth=2, title="Developing Random Simulation")

//Info Panel Display
draw_info_panel(show_info_label and max(fcond, fcond[1]), start_time, disp_type=="Forecast" ? start_price : 0, info_text, lbl_size, lbl_color, lbl_tcolor, "Right")