//@version=6
// Strategy: Box Range with RSI Divergence (Dynamic Adjustment - OKX Signal Format)
// Â© aws2333
//I'm chinese
strategy("Kaito  Box with RSI Div(Dynamic Adjustment + MA + Long)", overlay=true,default_qty_type=strategy.percent_of_equity, default_qty_value=10)


rsiOverbought = 80
rsiOversold = 13
boxLength = input.int(3, title="Box Length", minval=1)
rsiLength = input.int(2, title="RSI Length", minval=1)
divergenceLookback = input.int(2, title="Divergence Lookback Period", minval=1)
leftLookback = input.int(2, title="Left Lookback", minval=1)
rightLookback = input.int(2, title="Right Lookback", minval=1)
var float avgPrice = na
//var float position_size = 0

signalToken = input.string("**********", "Signal Token")
enterOrderType = input.string("limit", "Order Type", options=["market", "limit"])
enterOrderPriceOffset = input.float(0.05, "Order Price Offset", minval=0, maxval=100, step=0.01)
enterInvestmentType = input.string("percentage_investment", "Investment Type", options=["margin", "contract", "percentage_balance", "percentage_investment"])
exitOrderType = input.string("limit", "Order Type", options=["market", "limit"])
exitOrderPriceOffset = input.float(0.05, "Order Price Offset", minval=0, maxval=100, step=0.01)
exitInvestmentType = input.string("percentage_position", "Investment Type", options=["percentage_position"])
maxLag = input.float(30, "maxLag")

minEnterPercent = 1.3
minExitPercent = 0.09


highestHigh = ta.highest(high, boxLength)
lowestLow = ta.lowest(low, boxLength)


plot(highestHigh, title="Upper Box", color=color.new(color.green, 0), linewidth=1, style=plot.style_line)
plot(lowestLow, title="Lower Box", color=color.new(color.red, 0), linewidth=1, style=plot.style_line)


rsi = ta.rsi(low, rsiLength)


isLowestLeft = low < ta.lowest(low[1], leftLookback)
isLowestRight = low <= ta.lowest(low, rightLookback)
isLowestClose = isLowestLeft and isLowestRight

isHighestLeft = low > ta.highest(low[1], leftLookback)
isHighestRight = low >= ta.highest(low, rightLookback)
isHighestClose = isHighestLeft and isHighestRight

lowestClose = ta.lowest(low, divergenceLookback)
lowestRsi = ta.lowest(rsi, divergenceLookback)
highestClose = ta.highest(low, divergenceLookback)
highestRsi = ta.highest(rsi, divergenceLookback)


lowestClosePrev = ta.lowest(low[1], leftLookback)
lowestRsiPrev = ta.lowest(rsi[1], leftLookback)
highestClosePrev = ta.highest(low[1], leftLookback)
highestRsiPrev = ta.highest(rsi[1], leftLookback)



bullishDivergence = isLowestClose and (low < lowestClosePrev) and (rsi > lowestRsiPrev) and (rsi < rsiOversold)
bearishDivergence = isHighestClose and (low > highestClosePrev) and (rsi < highestRsiPrev) and (rsi > rsiOverbought)


ma(source, length, type) =>
    type == "SMA" ? ta.sma(source, length) :type == "EMA" ? ta.ema(source, length) :type == "SMMA (RMA)" ? ta.rma(source, length) :type == "WMA" ? ta.wma(source, length) :type == "VWMA" ? ta.vwma(source, length) :na


custom_timeframe = input.timeframe("3", "Custom time period (leave blank for current period)")


ma_type = input.string("SMA", "Moving average type", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"])


ma20_period = input.int(20, "MA20 ", minval=1)
ma50_period = input.int(50, "MA50 ", minval=1)
ma100_period = input.int(100, "MA100 ", minval=1)
ma200_period = input.int(200, "MA200 ", minval=1)


source_close = request.security(syminfo.tickerid, custom_timeframe, close)


ma20 = ma(source_close, ma20_period, ma_type)
ma50 = ma(source_close, ma50_period, ma_type)
ma100 = ma(source_close, ma100_period, ma_type)
ma200 = ma(source_close, ma200_period, ma_type)


up_signal_1 = ma20 > ma200
up_signal_2 = ma50 > ma200
up_signal_3 = ma100 > ma200
up_signal_4 = (high > ma20 and high > ma50 and high > ma100 and high > ma200)
up_trend = (up_signal_1 and up_signal_2 and up_signal_3 and (source_close > ma200)) or up_signal_4


down_signal_1 = ma20 < ma200
down_signal_2 = ma50 < ma200
down_signal_3 = ma100 < ma200
down_signal_4 = (low < ma20 and low < ma50 and low < ma100 and low < ma200)
down_trend = (down_signal_1 and down_signal_2 and down_signal_3 and (source_close < ma200)) or down_signal_4




plot(ma20, color=color.yellow, title="MA20")
plot(ma50, color=color.orange, title="MA50")
plot(ma100, color=color.red, title="MA100")
plot(ma200, color=color.maroon, title="MA200")


var float longAddPercent = na
var float shortAddPercent = na
roundToFourDecimals(value) => math.round(value * 10000) / 10000

if not na(avgPrice)
    if close < avgPrice
        longAddPercent := roundToFourDecimals(math.max(math.min(math.pow((avgPrice - close)* 1000/5,1.1)  , 100), minEnterPercent))
    if close > avgPrice
        longAddPercent := 1

    if close == avgPrice
        longAddPercent := 1


if not na(avgPrice)
    if close < avgPrice
        shortAddPercent := 0.01

    if close > avgPrice
        shortAddPercent := roundToFourDecimals(math.max(math.min(math.pow((close - avgPrice)*1000,1.1), 100), minExitPercent))
    if close == avgPrice
        longAddPercent := 1


longSignal = (close <= lowestLow) and bullishDivergence
shortSignal = (close >= highestHigh) and bearishDivergence
plotLongSignal = down_trend and longSignal and close < avgPrice
plotShortSignal = up_trend and shortSignal and close > avgPrice

if plotLongSignal
    label.new(bar_index, avgPrice, "average price: " + str.tostring(avgPrice, "#.####"), style=label.style_label_up, color=color.green, textcolor=color.white )
if plotShortSignal
    label.new(bar_index, avgPrice,"average price: " + str.tostring(avgPrice, "#.####"), style=label.style_label_down, color=color.red, textcolor=color.white)




if plotLongSignal
    label.new(
         bar_index,
         close,
         "LONG :" + str.tostring(longAddPercent, "#.####") + "%, Close: " + str.tostring(close, "#.####"),
         style=label.style_label_up,
         color=color.new(color.green, 80),
         textcolor=color.white
         )

if plotShortSignal
    label.new(
             bar_index,
             close,
             "EXIT LONG :" + str.tostring(shortAddPercent, "#.####") + "%, Close: " + str.tostring(close, "#.####"),
             style=label.style_label_down,
             color=color.new(color.red, 80),
             textcolor=color.white
             )


if longSignal

    avgPrice := na(avgPrice) ? close : (avgPrice + close) / 2


getAlertMsg(action, instrument, signalToken, orderType,maxLag, orderPriceOffset, investmentType, amount) =>
    str = '{'
    str := str + '"action": "' + action + '", '
    str := str + '"instrument": "' + instrument + '", '
    str := str + '"signalToken": "' + signalToken + '", '
    str := str + '"timestamp": "' + str.format_time(timenow, "yyyy-MM-dd\'T\'HH:mm:ssZ", "UTC+0") + '", '
    str := str + '"orderType": "' + orderType + '", '
    str := str + '"maxLag": "' + str.tostring(maxLag) + '", '
    str := str + '"orderPriceOffset": ' + str.tostring(orderPriceOffset) + ', '
    str := str + '"investmentType": "' + investmentType + '", '
    str := str + '"amount": ' + str.tostring(amount)
    str := str + '}'
    str





if down_trend and longSignal

    strategy.entry("Long",strategy.long,qty=longAddPercent )
    alert(getAlertMsg("ENTER_LONG", syminfo.ticker, signalToken, enterOrderType,maxLag,enterOrderPriceOffset, enterInvestmentType, longAddPercent), freq=alert.freq_once_per_bar)
var float close_size = na

if up_trend and shortSignal

    if strategy.position_size > 0
        close_size := strategy.position_size * (shortAddPercent/100)
        strategy.order("Partial Close Long", strategy.short, close_size)

        alert(getAlertMsg("EXIT_LONG", syminfo.ticker, signalToken, exitOrderType,maxLag, exitOrderPriceOffset, exitInvestmentType, shortAddPercent), freq=alert.freq_once_per_bar)