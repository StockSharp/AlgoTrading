// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© rumpypumpydumpy

//@version=4
study("Equivolume Overlay - Volume Bars", overlay = true, max_lines_count = 165, max_boxes_count = 165, scale = scale.left)

num_boxes =         input(165, title = "Number of equivolume boxes", maxval = 165, tooltip = "Maximum 165")
lb =                input(60, title = "Volume lookback", tooltip = "Number of bars to sum")
full_width =        input(500, title = "Full width in number of bars", tooltip = "Width where current bar's volume = sum of volume lookback\nHigher values result in less rounding with the trade off of using more chart space")
scaling_val =       input(10, title = "Scaling value for volume bars", tooltip = "Higher values = smaller volume bars")
ma_type =           input("SMA", options = ["SMA", "EMA", "WMA"], title = "Volume MA type")
ma_len =            input(21, title = "Volume MA length")
ma_col =            input(color.orange, title = "MA color")
ma_width =          input(1, title = "MA line width")
up_col =            input(color.rgb(255, 255, 255, 33), title = "Bull candle color")
dn_col =            input(color.rgb(33, 150, 243, 33), title = "Bear candle color")

// -----------------------------------------------------------------------------
// Equivolume Calculation
// -----------------------------------------------------------------------------
float   sum_volume =    sum(volume, lb)
float   ratio =         volume / sum_volume[1]
int     width =         max(round(ratio * full_width), 1) // Determines width of equivolume box in bars
// -----------------------------------------------------------------------------




// -----------------------------------------------------------------------------
// MA Calculation
// -----------------------------------------------------------------------------
volume_ma = ma_type == "SMA" ? sma(volume, ma_len) : ma_type == "EMA" ? ema(volume, ma_len) : wma(volume, ma_len)
// -----------------------------------------------------------------------------


// -----------------------------------------------------------------------------
// Current live bar
// -----------------------------------------------------------------------------
var line    current_ma =    line.new(x1 = na, y1 = na, x2 = na, y2 = na, color = ma_col, width = ma_width)
var box     current_volume_box = box.new(left = na, top = na, right = na, bottom = na, border_color = color.rgb(0, 0, 0, 100))

line.set_xy1(current_ma, x = bar_index - 1, y = volume_ma[1])
line.set_xy2(current_ma, x = bar_index + width, y = volume_ma)

box.set_lefttop(current_volume_box, left = bar_index, top = volume)
box.set_rightbottom(current_volume_box, right = bar_index + width, bottom = 0)
box.set_bgcolor(current_volume_box, color = close >= open ? up_col : dn_col)

// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Historical bars
// -----------------------------------------------------------------------------

var float[] historical_ma_vals = array.new_float(num_boxes)
var float[] historical_volume_vals = array.new_float(num_boxes)
var bool[]  historical_direction = array.new_bool(num_boxes)
var int[]   historical_widths = array.new_int(num_boxes)


var line[]  historical_ma_lines = array.new_line(na)
var box[]   historical_volume_boxes = array.new_box(na)

if barstate.isfirst
    for i = 0 to num_boxes - 1
        array.unshift(historical_ma_lines, line.new(x1 = na, y1 = na, x2 = na, y2 = na, width = ma_width, color = ma_col))
        array.unshift(historical_volume_boxes, box.new(left = na, top = na, right = na, bottom = na, border_color = color.rgb(0, 0, 0, 100)))

if barstate.isconfirmed
    array.unshift(historical_ma_vals, volume_ma),       array.pop(historical_ma_vals)
    array.unshift(historical_volume_vals, volume),      array.pop(historical_volume_vals)
    array.unshift(historical_direction, close >= open), array.pop(historical_direction)
    array.unshift(historical_widths, width),            array.pop(historical_widths)

    int offset = 0

    for i = 0 to num_boxes - 2
        if offset < bar_index
            box_width = array.get(historical_widths, i) + 1
            right_index = bar_index - offset
            left_index = bar_index - offset - box_width
            ma_left_val = array.get(historical_ma_vals, i + 1)
            ma_right_val = array.get(historical_ma_vals, i)

            ma_line = array.get(historical_ma_lines, i)
            offset := offset + box_width
            line.set_xy1(ma_line, x = left_index, y = ma_left_val)
            line.set_xy2(ma_line, x = right_index, y = ma_right_val)
        else
            break

    offset := 0

    for i = 0 to num_boxes - 1
        if offset < bar_index
            volume_box =    array.get(historical_volume_boxes, i)
            box_width =     array.get(historical_widths, i)

            left_index =    bar_index - offset - box_width
            right_index =   bar_index - offset

            volume_val = array.get(historical_volume_vals, i)
            col = array.get(historical_direction, i) ? up_col : dn_col

            offset := offset + box_width + 1

            box.set_lefttop(volume_box, left = left_index, top = volume_val)
            box.set_rightbottom(volume_box, right = right_index, bottom = 0)
            box.set_bgcolor(volume_box, color = col)
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Setup scaling line
// -----------------------------------------------------------------------------
highest_volume = highest(volume, num_boxes)
var line scaling_line = line.new(x1 = na, y1 = na, x2 = na, y2 = na, color = color.rgb(0, 0, 0, 100), extend = extend.both)
line.set_xy1(scaling_line, x = max(bar_index - (array.sum(historical_widths) + num_boxes), 0), y = highest_volume * scaling_val)
line.set_xy2(scaling_line, x = bar_index, y = highest_volume * scaling_val)