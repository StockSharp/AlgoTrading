//@version=5
strategy("Anomalous Holonomy Field Theory", shorttitle="🌌 AHFT", overlay=true, initial_capital=100000, default_qty_type=strategy.fixed, default_qty_value=1, commission_type=strategy.commission.cash_per_contract, commission_value=0.62, slippage=1, calc_on_every_tick=false, process_orders_on_close=false, max_bars_back=1000)

//==============================================================================
// 📚 COMPREHENSIVE USER GUIDE & MATHEMATICAL THEORY
//==============================================================================//
// 🌌 ANOMALOUS HOLONOMY FIELD THEORY - THE ULTIMATE TRADING SYSTEM
//
// Welcome to the most advanced mathematical trading algorithm ever created,
// combining cutting-edge theories from theoretical physics, differential geometry,
// algebraic topology, and quantum field theory.
//
// ⚡ WHAT MAKES THIS REVOLUTIONARY:
//
// Traditional indicators use simple calculations like moving averages or RSI.
// This system analyzes markets through the lens of:
//
// 1. HOLONOMY GROUPS (Differential Geometry):
//    - Measures how price "parallel transports" around closed loops
//    - Detects hidden curvature in the market manifold
//    - Identifies topological obstructions to arbitrage
//
// 2. ANOMALY DETECTION (Quantum Field Theory):
//    - Models price as a quantum field with anomalous symmetries
//    - Detects spontaneous symmetry breaking (trend changes)
//    - Identifies vacuum fluctuations (volatility clusters)
//
// 3. GAUGE THEORY (Theoretical Physics):
//    - Markets as gauge fields with local symmetries
//    - Price action as covariant derivatives
//    - Momentum as gauge connection components
//
// 4. TOPOLOGICAL DATA ANALYSIS:
//    - Persistent homology of price formations
//    - Betti numbers for market structure
//    - Morse theory for critical points
//
// 🎯 DASHBOARD METRICS DEEP DIVE:
//
// 📊 HOLONOMY FIELD STRENGTH (-100 to +100):
// Mathematical Formula: H = ∮_C A·dx where A is the market connection
// • Measures the Wilson loop integral around price paths
// • >70: Strong positive curvature (bullish vortex forming)
// • <-70: Strong negative curvature (bearish collapse)
// • Near 0: Flat connection (range-bound, no directional bias)
// • Based on parallel transport in fiber bundles
//
// 🌀 ANOMALY LEVEL (0-100%):
// Mathematical Formula: A = |⟨0|φ(x)|0⟩ - ⟨0|φ(x)|0⟩_classical|
// • Quantum vacuum expectation deviation
// • >70%: Major anomaly (phase transition imminent)
// • 30-70%: Moderate anomaly (heightened volatility)
// • <30%: Normal quantum fluctuations
// • Detects non-perturbative effects in price action
//
// ⚡ QUANTUM STATE (-1, 0, +1):
// Mathematical Formula: |ψ⟩ = α|↑⟩ + β|↓⟩, measure in σ_z basis
// • +1: Collapsed to bullish eigenstate |↑⟩
// • 0: Superposition state (uncertain)
// • -1: Collapsed to bearish eigenstate |↓⟩
// • Based on quantum measurement theory
//
// 🔮 SIGNAL QUALITY RATINGS:
// • LEGENDARY: All quantum fields aligned, anomaly confirmed
// • EXCEPTIONAL: Strong holonomy, high anomaly correlation
// • STRONG: Good field strength, moderate anomaly
// • MODERATE: Decent signals, some uncertainty
// • WEAK: Minimal edge, high quantum noise
//
// 🧮 THE MATHEMATICS IN DETAIL:
//
// HOLONOMY CALCULATION:
// The holonomy group element g ∈ G is computed as:
// g = P exp(∮_C A_μ dx^μ)
// Where P denotes path ordering and A_μ is the gauge connection.
// In discrete form: g_n = ∏ᵢ exp(iA_i·Δx_i)
//
// ANOMALY DETECTION:
// Uses the Adler-Bell-Jackiw anomaly equation:
// ∂_μ j^μ = (e²/16π²)F_μν F̃^μν
// Where F̃^μν is the dual field strength tensor.
//
// QUANTUM FIELD OPERATOR:
// Price modeled as quantum field φ(x,t) with action:
// S[φ] = ∫d⁴x [½(∂_μφ)² - V(φ)]
// Vacuum fluctuations: ⟨0|φ²|0⟩ = ∫ d³k/(2π)³ · 1/(2ω_k)
//
// GAUGE TRANSFORMATION:
// Market invariance under: A'_μ = A_μ + ∂_μΛ
// Ensures gauge-invariant observables for robust signals.
//
// 💡 TRADING PHILOSOPHY:
//
// Markets are not random walks but complex quantum systems with:
// • Hidden symmetries (profit opportunities)
// • Topological constraints (support/resistance)
// • Anomalous behaviors (breakouts/crashes)
// • Holonomic memory (price has geometric phase)
//
// By detecting these deep mathematical structures, we can predict
// phase transitions and capture profits from quantum fluctuations.
//
// 🎯 HOW TO USE THIS SYSTEM:
//
// 1. SIGNAL IDENTIFICATION:
//    - Wait for Holonomy Field Strength to exceed thresholds
//    - Confirm with Anomaly Level >30%
//    - Check Quantum State alignment
//    - Verify visual portal activation
//
// 2. ENTRY EXECUTION:
//    - Use Quantum Portals for precise entry
//    - Size positions based on field strength
//    - Set stops at holonomic support/resistance
//
// 3. EXIT MANAGEMENT:
//    - Monitor anomaly decay
//    - Watch for quantum state flips
//    - Use trailing stops in strong trends
//
// 4. RISK CONTROL:
//    - Never trade against strong holonomy
//    - Reduce size in low anomaly environments
//    - Respect quantum uncertainty limits
//
// ⚠️ ADVANCED RISK WARNING:
// While mathematically sophisticated, markets can exhibit:
// • Quantum decoherence (signal degradation)
// • Non-local correlations (contagion effects)
// • Measurement collapse (observation changes outcome)
// Always use proper position sizing and risk management.
//
// ==============================================================================
// 🎯 SIGNAL CONFIGURATION
// ==============================================================================
group_signals = "🎯 Signal Configuration"
SIGNAL_SENSITIVITY = input.float(2.5, "⚙️ Signal Sensitivity", minval=0.5, maxval=12.0, step=0.1, group=group_signals,
  tooltip="🎯 WHAT IT IS: Controls the responsiveness of signal generation to market conditions\n\n" +
  "⚡ HOW IT WORKS: Adjusts the threshold for triggering buy/sell signals based on holonomy field strength\n\n" +
  "📈 HIGHER VALUES (6.0-12.0): Fewer signals, higher quality, less noise\n" +
  "📉 LOWER VALUES (0.5-3.0): More signals, more sensitive, higher noise\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping (1-5min): 1.5-3.0 (fast signals)\n" +
  "• Day Trading (15min-1H): 2.5-5.0 (balanced)\n" +
  "• Swing Trading (4H-1D): 5.0-8.0 (high quality)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: 3.0-5.0 (stable signals)\n" +
  "• Crypto: 1.5-3.5 (volatile markets)\n" +
  "• Forex: 4.0-6.0 (smooth trends)\n" +
  "• Indices: 3.5-5.5 (trending markets)\n\n" +
  "💡 PRO TIP: Start with 2.5 and adjust based on backtesting for your market and timeframe")
SCORE_AMPLIFIER = input.float(50.0, "🔊 Score Amplifier", minval=10.0, maxval=200.0, step=5.0, group=group_signals,
  tooltip="🎯 WHAT IT IS: Scales the raw holonomy field strength to produce meaningful signal values\n\n" +
  "⚡ HOW IT WORKS: Multiplies the calculated signal score to align with the -10 to +10 range\n\n" +
  "📈 HIGHER VALUES (100-200): Amplify signals for clearer differentiation, useful in low-volatility markets\n" +
  "📉 LOWER VALUES (10-50): Reduce amplification for more conservative signals, better in high-volatility markets\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 30-70 (faster signals)\n" +
  "• Day Trading: 50-100 (balanced amplification)\n" +
  "• Swing Trading: 80-150 (stronger signals)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 30-70 (volatile, needs sensitivity)\n" +
  "• Stocks: 50-100 (balanced)\n" +
  "• Forex: 80-120 (smooth trends)\n" +
  "• Indices: 70-110 (trending markets)\n\n" +
  "💡 PRO TIP: Adjust to ensure signals align with your risk tolerance and market conditions")
SIGNAL_CONFIRMATION = input.bool(true, "✅ Require Signal Confirmation", group=group_signals,
  tooltip="🎯 WHAT IT IS: Enforces additional technical filters for signal validation\n\n" +
  "⚡ HOW IT WORKS: Requires signals to align with EMA and RSI conditions to reduce false positives\n\n" +
  "📈 ENABLED: Higher quality signals, fewer trades, ideal for conservative strategies\n" +
  "📉 DISABLED: More signals, potentially noisier, suitable for aggressive strategies\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Disable for faster entries\n" +
  "• Day Trading: Enable for balanced reliability\n" +
  "• Swing Trading: Enable for high-confidence trades\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: Enable (stable markets benefit from confirmation)\n" +
  "• Crypto: Disable or Enable (depends on volatility tolerance)\n" +
  "• Forex: Enable (smooth trends)\n" +
  "• Indices: Enable (trending markets)\n\n" +
  "💡 PRO TIP: Enable for higher win rates, disable for higher trade frequency")
MIN_SIGNAL_SEPARATION = input.int(5, "⏳ Minimum Bars Between Signals", minval=1, maxval=20, group=group_signals,
  tooltip="🎯 WHAT IT IS: Minimum number of bars required between consecutive signals\n\n" +
  "⚡ HOW IT WORKS: Prevents over-trading by enforcing a cooldown period between signals\n\n" +
  "📈 HIGHER VALUES (10-20): Fewer signals, reduces whipsaws in choppy markets\n" +
  "📉 LOWER VALUES (1-5): More frequent signals, captures rapid market moves\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping (1-5min): 1-3 bars (fast-paced trading)\n" +
  "• Day Trading (15min-1H): 3-7 bars (balanced)\n" +
  "• Swing Trading (4H-1D): 7-15 bars (longer-term focus)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 1-5 (high volatility)\n" +
  "• Stocks: 5-10 (stable markets)\n" +
  "• Forex: 7-12 (trend-focused)\n" +
  "• Indices: 5-10 (trending markets)\n\n" +
  "💡 PRO TIP: Use higher values in low-volatility markets to avoid false signals")
// ==============================================================================
// 👑 ELITE EXECUTION SETTINGS
// ==============================================================================
group_execution = "👑 Elite Execution"
EXECUTION_MODE = input.string("Adaptive", "⚙️ Execution Mode", options=["Conservative", "Adaptive", "Aggressive"], group=group_execution,
  tooltip="🎯 WHAT IT IS: Determines the aggressiveness of trade execution and risk parameters\n\n" +
  "⚡ HOW IT WORKS: Adjusts signal thresholds, position sizing, and exit strategies\n\n" +
  "📈 CONSERVATIVE: Fewer trades, stricter criteria, lower risk, ideal for stable markets\n" +
  "📊 ADAPTIVE: Balances frequency and quality, adjusts to market conditions\n" +
  "📉 AGGRESSIVE: More trades, looser criteria, higher risk, suited for volatile markets\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Aggressive (capture quick moves)\n" +
  "• Day Trading: Adaptive (balance speed and reliability)\n" +
  "• Swing Trading: Conservative (focus on high-probability setups)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: Conservative or Adaptive (stable markets)\n" +
  "• Crypto: Aggressive (high volatility)\n" +
  "• Forex: Adaptive or Conservative (smooth trends)\n" +
  "• Indices: Adaptive (trending markets)\n\n" +
  "💡 PRO TIP: Use Adaptive for most scenarios, switch to Aggressive in high-volatility breakouts")
DYNAMIC_SIZING = input.bool(true, "📏 Dynamic Position Sizing", group=group_execution,
  tooltip="🎯 WHAT IT IS: Adjusts position size based on signal strength and market conditions\n\n" +
  "⚡ HOW IT WORKS: Scales position size using holonomy score, volatility, and performance metrics\n\n" +
  "📈 ENABLED: Optimizes risk-reward by increasing size for stronger signals\n" +
  "📉 DISABLED: Uses fixed position size based on base risk, more predictable\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Enable (rapid market changes)\n" +
  "• Day Trading: Enable (dynamic markets)\n" +
  "• Swing Trading: Enable or Disable (depends on risk preference)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: Enable (volatile, benefits from dynamic sizing)\n" +
  "• Stocks: Enable (adapts to signal strength)\n" +
  "• Forex: Enable or Disable (stable trends may not need it)\n" +
  "• Indices: Enable (trending markets)\n\n" +
  "💡 PRO TIP: Enable for better risk management, disable for consistent position sizes")
SMART_ENTRIES = input.bool(true, "🚪 Smart Entry Timing", group=group_execution,
  tooltip="🎯 WHAT IT IS: Enforces timing rules to optimize trade entry points\n\n" +
  "⚡ HOW IT WORKS: Uses minimum signal separation and market regime filters to time entries\n\n" +
  "📈 ENABLED: Reduces premature entries, improves win rate in trending markets\n" +
  "📉 DISABLED: Allows faster entries, may increase false positives\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Disable (need speed)\n" +
  "• Day Trading: Enable (balanced timing)\n" +
  "• Swing Trading: Enable (high-probability entries)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: Enable (stable markets)\n" +
  "• Crypto: Disable or Enable (depends on strategy)\n" +
  "• Forex: Enable (smooth trends)\n" +
  "• Indices: Enable (trending markets)\n\n" +
  "💡 PRO TIP: Enable to avoid over-trading in choppy markets")
ADVANCED_EXITS = input.bool(true, "🚶 Advanced Exit Management", group=group_execution,
  tooltip="🎯 WHAT IT IS: Uses trailing stops and dynamic take-profit levels for trade exits\n\n" +
  "⚡ HOW IT WORKS: Implements trailing stops based on ATR and signal strength for optimized exits\n\n" +
  "📈 ENABLED: Maximizes profits in trending markets, reduces losses in reversals\n" +
  "📉 DISABLED: Uses fixed stop-loss and take-profit, simpler but less adaptive\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Disable (quick exits needed)\n" +
  "• Day Trading: Enable (capture trends)\n" +
  "• Swing Trading: Enable (maximize profits)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: Enable (volatile markets)\n" +
  "• Stocks: Enable (trend capture)\n" +
  "• Forex: Enable (smooth trends)\n" +
  "• Indices: Enable (trending markets)\n\n" +
  "💡 PRO TIP: Enable for trending markets, disable for range-bound conditions")
// ==============================================================================
// 🔬 ADVANCED CONFIGURATION
// ==============================================================================
group_advanced = "🔬 Advanced Configuration"
anomaly_threshold = input.float(30.0, "⚠️ Anomaly Threshold", minval=0, maxval=100, step=0.1, group=group_advanced,
  tooltip="🎯 WHAT IT IS: Minimum anomaly level required to highlight significant market events\n\n" +
  "⚡ HOW IT WORKS: Filters anomaly grid levels based on price and volume deviations\n\n" +
  "📈 HIGHER VALUES (50-100): Fewer anomalies, focuses on extreme events\n" +
  "📉 LOWER VALUES (0-30): More anomalies, captures smaller deviations\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 10-20 (capture small anomalies)\n" +
  "• Day Trading: 20-40 (balanced)\n" +
  "• Swing Trading: 40-60 (major events)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 10-30 (volatile markets)\n" +
  "• Stocks: 20-40 (stable markets)\n" +
  "• Forex: 30-50 (smooth trends)\n" +
  "• Indices: 20-40 (trending markets)\n\n" +
  "💡 PRO TIP: Adjust based on market volatility to filter noise")
portal_threshold = input.float(0.7, "🌌 Portal Threshold", minval=0, maxval=1, step=0.1, group=group_advanced,
  tooltip="🎯 WHAT IT IS: Minimum signal strength for displaying quantum portals\n\n" +
  "⚡ HOW IT WORKS: Filters portal visualizations to show only high-confidence signals\n\n" +
  "📈 HIGHER VALUES (0.8-1.0): Fewer portals, higher quality signals\n" +
  "📉 LOWER VALUES (0.0-0.5): More portals, includes weaker signals\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 0.3-0.5 (frequent signals)\n" +
  "• Day Trading: 0.5-0.7 (balanced)\n" +
  "• Swing Trading: 0.7-0.9 (high-confidence)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 0.3-0.5 (volatile markets)\n" +
  "• Stocks: 0.5-0.7 (stable markets)\n" +
  "• Forex: 0.6-0.8 (smooth trends)\n" +
  "• Indices: 0.5-0.7 (trending markets)\n\n" +
  "💡 PRO TIP: Use higher thresholds for cleaner charts and stronger signals")
// ==============================================================================
// 🧠 ADAPTIVE INTELLIGENCE
// ==============================================================================
group_adaptive = "🧠 Adaptive Intelligence"
ENABLE_LEARNING = input.bool(true, "🧠 Enable Adaptive Learning", group=group_adaptive,
  tooltip="🎯 WHAT IT IS: Activates dynamic adjustment of risk based on trade performance\n\n" +
  "⚡ HOW IT WORKS: Analyzes recent trade outcomes to adjust position sizing and risk\n\n" +
  "📈 ENABLED: Adapts to market conditions, improves performance over time\n" +
  "📉 DISABLED: Uses static risk parameters, more predictable but less adaptive\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Disable (rapid trades, less time to adapt)\n" +
  "• Day Trading: Enable (adapts to intraday shifts)\n" +
  "• Swing Trading: Enable (longer-term optimization)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: Enable (volatile, benefits from adaptation)\n" +
  "• Stocks: Enable (adapts to market regimes)\n" +
  "• Forex: Enable or Disable (stable trends may not need it)\n" +
  "• Indices: Enable (trending markets)\n\n" +
  "💡 PRO TIP: Enable for long-term performance optimization, disable for short-term consistency")
LEARNING_SPEED = input.float(0.15, "⚡ Learning Speed", minval=0.05, maxval=0.3, step=0.05, group=group_adaptive,
  tooltip="🎯 WHAT IT IS: Controls how quickly the system adjusts risk based on performance\n\n" +
  "⚡ HOW IT WORKS: Determines the rate of change for the adaptive risk multiplier\n\n" +
  "📈 HIGHER VALUES (0.2-0.3): Faster adaptation, more responsive to recent performance\n" +
  "📉 LOWER VALUES (0.05-0.1): Slower adaptation, more stable risk adjustments\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 0.2-0.3 (quick adjustments)\n" +
  "• Day Trading: 0.15-0.25 (balanced)\n" +
  "• Swing Trading: 0.05-0.15 (stable adjustments)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 0.2-0.3 (volatile markets)\n" +
  "• Stocks: 0.1-0.2 (stable markets)\n" +
  "• Forex: 0.1-0.15 (smooth trends)\n" +
  "• Indices: 0.15-0.25 (trending markets)\n\n" +
  "💡 PRO TIP: Use higher values in volatile markets, lower values for consistent performance")
PERFORMANCE_TRACKING = input.int(50, "📈 Performance Window", minval=20, maxval=100, group=group_adaptive,
  tooltip="🎯 WHAT IT IS: Number of recent trades used for adaptive learning analysis\n\n" +
  "⚡ HOW IT WORKS: Tracks trade performance over the specified window to adjust risk\n\n" +
  "📈 LONGER WINDOW (60-100): More stable adjustments, considers long-term performance\n" +
  "📉 SHORTER WINDOW (20-40): More responsive, focuses on recent performance\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 20-30 (recent performance focus)\n" +
  "• Day Trading: 30-50 (balanced)\n" +
  "• Swing Trading: 50-80 (long-term trends)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 20-40 (volatile, recent focus)\n" +
  "• Stocks: 40-60 (stable markets)\n" +
  "• Forex: 50-80 (smooth trends)\n" +
  "• Indices: 40-60 (trending markets)\n\n" +
  "💡 PRO TIP: Use shorter windows in fast-moving markets, longer windows for stable trends")
// ==============================================================================
// 🛡️ RISK MANAGEMENT
// ==============================================================================
group_risk = "🛡️ Risk Management"
ACCOUNT_SIZE = input.float(100000, "💰 Account Size", minval=1000, group=group_risk,
  tooltip="🎯 WHAT IT IS: Total account balance used for position sizing calculations\n\n" +
  "⚡ HOW IT WORKS: Determines the base capital for risk percentage calculations\n\n" +
  "📈 HIGHER VALUES: Allows larger position sizes, suitable for well-funded accounts\n" +
  "📉 LOWER VALUES: Reduces position sizes, ideal for smaller accounts\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Any (scales with risk)\n" +
  "• Day Trading: Any (scales with risk)\n" +
  "• Swing Trading: Any (scales with risk)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• All Sectors: Set to your actual account size\n\n" +
  "💡 PRO TIP: Update regularly to reflect actual account balance for accurate sizing")
BASE_RISK = input.float(0.008, "🎲 Base Risk Per Trade %", minval=0.003, maxval=0.02, step=0.001, group=group_risk,
  tooltip="🎯 WHAT IT IS: Percentage of account risked per trade\n\n" +
  "⚡ HOW IT WORKS: Defines the base risk level for position sizing calculations\n\n" +
  "📈 HIGHER VALUES (0.015-0.02): Larger positions, higher potential reward and risk\n" +
  "📉 LOWER VALUES (0.003-0.01): Smaller positions, lower risk, more conservative\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 0.003-0.007 (many trades, low risk per trade)\n" +
  "• Day Trading: 0.007-0.012 (balanced)\n" +
  "• Swing Trading: 0.01-0.015 (fewer, higher-quality trades)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 0.003-0.008 (high volatility)\n" +
  "• Stocks: 0.007-0.012 (stable markets)\n" +
  "• Forex: 0.008-0.015 (smooth trends)\n" +
  "• Indices: 0.007-0.012 (trending markets)\n\n" +
  "💡 PRO TIP: Start with 0.008 and adjust based on risk tolerance and win rate")
MAX_DAILY_TRADES = input.int(12, "🚫 Max Daily Trades", minval=5, maxval=25, group=group_risk,
  tooltip="🎯 WHAT IT IS: Maximum number of trades allowed per day\n\n" +
  "⚡ HOW IT WORKS: Limits trading activity to manage exposure and over-trading\n\n" +
  "📈 HIGHER VALUES (15-25): Allows more trades, suitable for scalping or volatile markets\n" +
  "📉 LOWER VALUES (5-10): Restricts trading, ideal for conservative or swing trading\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: 15-25 (high-frequency trading)\n" +
  "• Day Trading: 10-15 (balanced)\n" +
  "• Swing Trading: 5-10 (fewer trades)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: 15-25 (volatile markets)\n" +
  "• Stocks: 8-15 (stable markets)\n" +
  "• Forex: 5-10 (smooth trends)\n" +
  "• Indices: 8-15 (trending markets)\n\n" +
  "💡 PRO TIP: Use lower values to avoid over-trading in choppy markets")
// ==============================================================================
// ⏰ SESSION
// ==============================================================================
group_session = "⏰ Session"
session_start = input.int(5, "🕒 Session Start Hour (24h)", minval=0, maxval=23, group=group_session,
  tooltip="🎯 WHAT IT IS: Start hour for allowed trading session\n\n" +
  "⚡ HOW IT WORKS: Restricts trading to specific hours to align with market activity\n\n" +
  "📈 HIGHER VALUES: Later start, suitable for specific market sessions (e.g., US afternoon)\n" +
  "📉 LOWER VALUES: Earlier start, captures early market moves\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Align with high-volume hours (e.g., 8-11 for US open)\n" +
  "• Day Trading: Align with market open/close (e.g., 9-16 for US)\n" +
  "• Swing Trading: Broader session (e.g., 5-20)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: 9-16 (US market hours)\n" +
  "• Crypto: 0-23 (24/7 markets)\n" +
  "• Forex: 0-23 or align with major sessions (e.g., London 3-12)\n" +
  "• Indices: 9-16 (US market hours)\n\n" +
  "💡 PRO TIP: Set to match your target market’s active hours for best results")
session_end = input.int(16, "🕔 Session End Hour (24h)", minval=0, maxval=23, group=group_session,
  tooltip="🎯 WHAT IT IS: End hour for allowed trading session\n\n" +
  "⚡ HOW IT WORKS: Stops trading after the specified hour to avoid low-liquidity periods\n\n" +
  "📈 HIGHER VALUES: Extends trading into later hours, captures full market sessions\n" +
  "📉 LOWER VALUES: Ends trading earlier, avoids volatile closes\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: End at high-volume close (e.g., 15-16 for US)\n" +
  "• Day Trading: End at market close (e.g., 16 for US)\n" +
  "• Swing Trading: Broader session (e.g., 20)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: 16 (US market close)\n" +
  "• Crypto: 23 (24/7 markets)\n" +
  "• Forex: Align with session close (e.g., 12 for London)\n" +
  "• Indices: 16 (US market close)\n\n" +
  "💡 PRO TIP: Avoid trading during low-liquidity hours to reduce slippage")
allow_weekend = input.bool(false, "🌙 Allow Weekend Trading?", group=group_session,
  tooltip="🎯 WHAT IT IS: Permits trading on weekends for 24/7 markets like crypto\n\n" +
  "⚡ HOW IT WORKS: Enables or disables trading on Saturday and Sunday\n\n" +
  "📈 ENABLED: Allows trading in 24/7 markets, maximizes opportunities\n" +
  "📉 DISABLED: Restricts trading to weekdays, avoids low-liquidity periods\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Enable for crypto, disable for others\n" +
  "• Day Trading: Enable for crypto, disable for others\n" +
  "• Swing Trading: Disable (focus on weekday trends)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Crypto: Enable (24/7 markets)\n" +
  "• Stocks: Disable (closed weekends)\n" +
  "• Forex: Disable (low liquidity weekends)\n" +
  "• Indices: Disable (closed weekends)\n\n" +
  "💡 PRO TIP: Enable only for crypto markets with sufficient weekend liquidity")
session_timezone = input.string("America/Chicago", "🌍 Session Timezone", options=["America/New_York", "America/Chicago", "America/Los_Angeles", "Europe/London", "Europe/Frankfurt", "Europe/Moscow", "Asia/Tokyo", "Asia/Hong_Kong", "Asia/Shanghai", "Asia/Singapore", "Australia/Sydney", "UTC"], group=group_session,
  tooltip="🎯 WHAT IT IS: Timezone for defining trading session hours\n\n" +
  "⚡ HOW IT WORKS: Aligns session start/end times with the selected timezone\n\n" +
  "📈 CHOOSING TIMEZONE: Select the timezone of your target market for accurate session timing\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Match primary market (e.g., America/New_York for US stocks)\n" +
  "• Day Trading: Match primary market\n" +
  "• Swing Trading: Match primary market or UTC for flexibility\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• Stocks: America/New_York (US) or relevant exchange\n" +
  "• Crypto: UTC (global 24/7 markets)\n" +
  "• Forex: Europe/London or UTC (major sessions)\n" +
  "• Indices: America/New_York or relevant exchange\n\n" +
  "💡 PRO TIP: Use UTC for crypto or global markets, local timezone for stocks/indices")
// ==============================================================================
// 🎨 VISUAL CONFIGURATION
// ==============================================================================
group_visual = "🎨 Visual Configuration"
visual_theme = input.string("Quantum Nebula", "🎨 Visual Theme", options=["Quantum Nebula", "Ethereal Prism", "Dark Matter", "Cosmic Aurora", "Void Resonance", "Temporal Flux", "Astral Projection"], group=group_visual,
  tooltip="🎯 WHAT IT IS: Defines the color scheme and aesthetic of the dashboard\n\n" +
  "⚡ HOW IT WORKS: Sets the visual style for all indicators and dashboard elements\n\n" +
  "🌈 THEME PERSONALITIES:\n" +
  "• 🌌 QUANTUM NEBULA: Deep purples, cosmic accents, mathematical elegance\n" +
  "• 🔮 ETHEREAL PRISM: Iridescent rainbow, vibrant and crypto-friendly\n" +
  "• ⚫ DARK MATTER: Monochromatic with energy bursts, minimalist\n" +
  "• 🌅 COSMIC AURORA: Northern lights-inspired, vibrant greens\n" +
  "• 🕳️ VOID RESONANCE: Deep space with neon, high contrast\n" +
  "• ⏰ TEMPORAL FLUX: Time-distortion colors, dynamic reds\n" +
  "• 👁️ ASTRAL PROJECTION: Ethereal amber, out-of-body aesthetic\n\n" +
  "🎯 MARKET MATCHING:\n" +
  "• Stocks: Quantum Nebula, Dark Matter\n" +
  "• Crypto: Ethereal Prism, Void Resonance\n" +
  "• Forex: Cosmic Aurora, Temporal Flux\n" +
  "• Indices: Quantum Nebula, Astral Projection\n\n" +
  "💡 PRO TIP: Choose a theme that matches your trading style and screen setup for visual comfort")
show_holonomy_field = input.bool(true, "🌀 Show Holonomy Field", group=group_visual,
  tooltip="🎯 WHAT IT IS: Multi-layer visualization of market resonance zones\n\n" +
  "⚡ HOW IT WORKS: Displays dynamic price bands based on holonomy calculations\n\n" +
  "📈 BENEFITS: Highlights key price zones for potential reversals or continuations\n" +
  "📉 DRAWBACKS: May clutter charts on lower timeframes\n\n" +
  "🕒 RECOMMENDED FOR:\n" +
  "• Swing Trading: Always ON\n" +
  "• Day Trading: ON for major trends\n" +
  "• Scalping: OFF (avoid clutter)\n\n" +
  "💡 USAGE: Watch for price interactions with field zones for trade signals")
show_quantum_portals = input.bool(true, "🌌 Show Quantum Portals", group=group_visual,
  tooltip="🎯 WHAT IT IS: Visualizes entry signals with recursive depth patterns\n\n" +
  "⚡ FEATURES:\n" +
  "• Triangle markers for entries\n" +
  "• Colored portals showing directional flow\n" +
  "• Recursive depth for momentum strength\n\n" +
  "🎯 VISUAL BENEFITS:\n" +
  "• Clear entry signal identification\n" +
  "• Momentum direction visualization\n" +
  "• Signal strength indication\n\n" +
  "💡 OPTIMIZATION: Turn OFF for cleaner charts, ON for maximum signal clarity")
show_anomaly_grid = input.bool(true, "📐 Show Anomaly Detection Grid", group=group_visual,
  tooltip="🎯 WHAT IT IS: Dynamic support/resistance levels with anomaly scores\n\n" +
  "⚡ HOW IT WORKS: Plots fractal highs/lows with calculated anomaly strength\n\n" +
  "📈 BENEFITS: Precise entry/exit timing, anomaly-based trade validation\n" +
  "📉 DRAWBACKS: Can overwhelm lower timeframes with multiple lines\n\n" +
  "🕒 RECOMMENDED FOR:\n" +
  "• Swing Trading: Always ON\n" +
  "• Day Trading: ON for key levels\n" +
  "• Scalping: OFF (too cluttered)\n\n" +
  "💡 USAGE: Combine with holonomy field for high-probability setups")
show_field_resonance = input.bool(true, "〰️ Show Field Resonance Bands", group=group_visual,
  tooltip="🎯 WHAT IT IS: Visualizes harmonic price zones based on market strength\n\n" +
  "⚡ HOW IT WORKS: Plots bands around key price levels to indicate resonance strength\n\n" +
  "📈 BENEFITS: Identifies high-probability support/resistance zones\n" +
  "📉 DRAWBACKS: May add visual complexity on volatile charts\n\n" +
  "🕒 RECOMMENDED FOR:\n" +
  "• Swing Trading: Always ON\n" +
  "• Day Trading: ON for trend confirmation\n" +
  "• Scalping: OFF (avoid clutter)\n\n" +
  "💡 USAGE: Trade bounces or breaks from resonance bands with signal confirmation")
show_phase_flow = input.bool(true, "🌊 Show Phase Space Flow", group=group_visual,
  tooltip="🎯 WHAT IT IS: Background heatmap showing market topology and momentum\n\n" +
  "⚡ HOW IT WORKS: Uses price and volume dynamics to create intensity-based background\n\n" +
  "🎨 INTENSITY LEVELS:\n" +
  "• Dark: Low activity, range-bound markets\n" +
  "• Medium: Moderate momentum, building trends\n" +
  "• Bright: High activity, strong trends\n\n" +
  "🎯 TRADING INSIGHT: Bright backgrounds indicate high-probability setups\n" +
  "💡 PRO TIP: Trade aggressively when phase flow is bright, conservatively when dark")
field_intensity = input.int(75, "🌫️ Field Transparency", minval=70, maxval=95, group=group_visual,
  tooltip="🎯 WHAT IT IS: Controls transparency of holonomy field and resonance bands\n\n" +
  "⚡ SETTINGS:\n" +
  "• 70-75: Bold visuals, strong impact\n" +
  "• 80-85: Balanced visibility\n" +
  "• 90-95: Subtle, minimal interference\n\n" +
  "🎯 CHART PREFERENCES:\n" +
  "• Busy Charts: 90-95\n" +
  "• Balanced Charts: 80-85\n" +
  "• Detailed Visuals: 70-75\n\n" +
  "💡 OPTIMIZATION: Adjust based on chart background and personal preference")
portal_depth = input.int(5, "🔄 Portal Recursion Depth", minval=3, maxval=8, group=group_visual,
  tooltip="🎯 WHAT IT IS: Number of recursive layers in quantum portal visualization\n\n" +
  "⚡ HOW IT WORKS: Creates nested patterns to indicate signal strength and momentum\n\n" +
  "📈 HIGHER DEPTH (6-8): More complex patterns, deeper momentum insight\n" +
  "📉 LOWER DEPTH (3-4): Simpler patterns, less visual complexity\n\n" +
  "🎯 PERFORMANCE OPTIMIZATION:\n" +
  "• Fast Charts: 3-4 (lower CPU usage)\n" +
  "• Detailed Analysis: 5-6 (balanced)\n" +
  "• Maximum Insight: 6-8 (complex patterns)\n\n" +
  "💡 BALANCE: Higher depth provides more insight but increases visual clutter")
// ==============================================================================
// 📊 DASHBOARD CONFIGURATION
// ==============================================================================
group_dashboard = "📊 Dashboard Configuration"
show_dashboard = input.bool(true, "📋 Show Enhanced Dashboard", group=group_dashboard,
  tooltip="🎯 WHAT IT IS: Displays a comprehensive panel with key trading metrics\n\n" +
  "⚡ HOW IT WORKS: Shows holonomy score, anomaly level, quantum state, and trade signals\n\n" +
  "📊 DASHBOARD INCLUDES:\n" +
  "• Holonomy Score (momentum strength)\n" +
  "• Anomaly Level (market events)\n" +
  "• Quantum State (market bias)\n" +
  "• Long/Short Signals\n" +
  "• Trend Direction\n\n" +
  "🎯 BENEFITS:\n" +
  "• Quick decision-making\n" +
  "• Real-time market insights\n" +
  "• Performance tracking\n\n" +
  "💡 RECOMMENDED: Keep ON for systematic trading, disable for minimal charts")
dashboard_size = input.string("Normal", "📏 Dashboard Size", options=["Small", "Normal", "Large"], group=group_dashboard,
  tooltip="🎯 WHAT IT IS: Controls the size and detail level of the dashboard\n\n" +
  "⚡ HOW IT WORKS: Adjusts the amount of information displayed\n\n" +
  "📱 SMALL: Minimal metrics, ideal for mobile or small screens\n" +
  "💻 NORMAL: Balanced detail, suitable for most desktops\n" +
  "🖥️ LARGE: Maximum detail, best for multi-monitor setups\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Small (quick reference)\n" +
  "• Day Trading: Normal (balanced info)\n" +
  "• Swing Trading: Large (detailed analysis)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• All Sectors: Normal (versatile)\n\n" +
  "💡 PRO TIP: Use Normal for most setups, Large for deep analysis")
dashboard_position_input = input.string("Top Right", "📍 Dashboard Position", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group=group_dashboard,
  tooltip="🎯 WHAT IT IS: Sets the dashboard’s position on the chart\n\n" +
  "⚡ HOW IT WORKS: Places the dashboard in a non-intrusive location\n\n" +
  "📍 TOP RIGHT: Standard placement, avoids price action\n" +
  "📍 TOP LEFT: Good for wide charts or left-handed users\n" +
  "📍 BOTTOM RIGHT: Focuses on recent price action, ideal for scalping\n" +
  "📍 BOTTOM LEFT: Maximizes price visibility, good for swing trading\n\n" +
  "🕒 TIMEFRAME OPTIMIZATION:\n" +
  "• Scalping: Bottom Right (recent price focus)\n" +
  "• Day Trading: Top Right (standard)\n" +
  "• Swing Trading: Bottom Left (price visibility)\n\n" +
  "🏦 SECTOR RECOMMENDATIONS:\n" +
  "• All Sectors: Top Right (versatile)\n\n" +
  "💡 PRO TIP: Choose a position that doesn’t obscure key chart areas")
// ==============================================================================
// 🎓 ADAPTIVE LEARNING DASHBOARD CONFIGURATION
// ==============================================================================
group_learning = "🎓 Adaptive Learning Dashboard"
show_learning_dashboard = input.bool(true, "🎓 Show Adaptive Learning Dashboard", group=group_learning)
learning_update_interval = input.int(5, "⏱️ Learning Update Interval (Minutes)", minval=1, maxval=60, group=group_learning)
learning_min_trades = input.int(20, "📊 Min Trades for Learning", minval=5, maxval=100, group=group_learning)
learning_sensitivity = input.float(1.0, "🎛️ Learning Sensitivity", minval=0.1, maxval=3.0, step=0.1, group=group_learning)
force_update_on_trade_close = input.bool(true, "🔄 Update on Trade Close", group=group_learning)
force_update_on_drawdown = input.bool(true, "📉 Update on Significant Drawdown", group=group_learning)
// Simple toggle to reset performance data only
reset_performance_data = input.bool(false, "🔄 Reset Performance Data", group=group_learning,
  tooltip="🎯 RESET PERFORMANCE DATA:\n\n" +
  "✅ Resets: Win rate, P&L, consecutive losses, trade count\n" +
  "❌ Keeps: All learned parameter values\n\n" +
  "💡 USE WHEN: You want to track performance from a specific point\n" +
  "while keeping the learned optimizations")
// ==============================================================================
// COLOR SCHEME DEFINITIONS
// ==============================================================================
// Quantum Nebula - Deep space purples with cosmic accents
color qn_primary = #8B5CF6      // Vibrant purple
color qn_secondary = #A78BFA    // Light purple
color qn_accent = #C084FC       // Bright purple
color qn_positive = #10B981     // Emerald
color qn_negative = #EF4444     // Red
color qn_anomaly_strong = #FBBF24  // Amber
color qn_anomaly_weak = #F59E0B    // Orange
color qn_field_glow = #E0E7FF      // Light indigo
color qn_phase_intense = #4C1D95   // Deep purple
color qn_phase_normal = #7C3AED    // Purple
// Ethereal Prism - Iridescent rainbow cascade
color ep_primary = #06B6D4      // Cyan
color ep_secondary = #0891B2    // Dark cyan
color ep_accent = #0EA5E9       // Sky blue
color ep_positive = #84CC16     // Lime
color ep_negative = #F43F5E     // Rose
color ep_anomaly_strong = #A855F7  // Purple
color ep_anomaly_weak = #E879F9    // Fuchsia
color ep_field_glow = #CFFAFE      // Cyan tint
color ep_phase_intense = #0C4A6E   // Deep blue
color ep_phase_normal = #0284C7    // Blue
// Dark Matter - Monochromatic with energy bursts
color dm_primary = #64748B      // Slate
color dm_secondary = #94A3B8    // Light slate
color dm_accent = #CBD5E1       // Lightest slate
color dm_positive = #22D3EE     // Cyan burst
color dm_negative = #F97316     // Orange burst
color dm_anomaly_strong = #FACC15  // Yellow energy
color dm_anomaly_weak = #FDE047    // Light yellow
color dm_field_glow = #F1F5F9      // Near white
color dm_phase_intense = #1E293B   // Dark slate
color dm_phase_normal = #475569    // Medium slate
// Cosmic Aurora - Northern lights inspiration
color ca_primary = #059669      // Emerald
color ca_secondary = #10B981    // Light emerald
color ca_accent = #34D399       // Bright green
color ca_positive = #06B6D4     // Cyan
color ca_negative = #EC4899     // Pink
color ca_anomaly_strong = #8B5CF6  // Purple aurora
color ca_anomaly_weak = #A78BFA    // Light purple
color ca_field_glow = #D1FAE5      // Mint tint
color ca_phase_intense = #064E3B   // Deep green
color ca_phase_normal = #047857    // Green
// Void Resonance - Deep space with neon accents
color vr_primary = #1F2937      // Gray-900
color vr_secondary = #374151    // Gray-700
color vr_accent = #4B5563       // Gray-600
color vr_positive = #00F5FF     // Neon cyan
color vr_negative = #FF006E     // Neon pink
color vr_anomaly_strong = #FFFF00  // Neon yellow
color vr_anomaly_weak = #9333EA    // Neon purple
color vr_field_glow = #111827      // Near black
color vr_phase_intense = #000000   // Black
color vr_phase_normal = #1F2937    // Dark gray
// Temporal Flux - Time distortion colors
color tf_primary = #DC2626      // Red
color tf_secondary = #F87171    // Light red
color tf_accent = #FCA5A5       // Pink red
color tf_positive = #059669     // Green
color tf_negative = #7C3AED     // Purple
color tf_anomaly_strong = #0891B2  // Cyan
color tf_anomaly_weak = #06B6D4    // Light cyan
color tf_field_glow = #FEE2E2      // Red tint
color tf_phase_intense = #7F1D1D   // Dark red
color tf_phase_normal = #B91C1C    // Medium red
// Astral Projection - Ethereal out-of-body experience
color ap_primary = #F59E0B      // Amber
color ap_secondary = #FCD34D    // Light amber
color ap_accent = #FDE68A       // Pale amber
color ap_positive = #8B5CF6     // Purple
color ap_negative = #0EA5E9     // Blue
color ap_anomaly_strong = #EC4899  // Pink
color ap_anomaly_weak = #F9A8D4    // Light pink
color ap_field_glow = #FEF3C7      // Amber tint
color ap_phase_intense = #78350F   // Dark amber
color ap_phase_normal = #D97706    // Orange
// ==============================================================================
// DYNAMIC COLOR SELECTION
// ==============================================================================
holonomy_primary = visual_theme == "Quantum Nebula" ? qn_primary :
                   visual_theme == "Ethereal Prism" ? ep_primary :
                   visual_theme == "Dark Matter" ? dm_primary :
                   visual_theme == "Cosmic Aurora" ? ca_primary :
                   visual_theme == "Void Resonance" ? vr_primary :
                   visual_theme == "Temporal Flux" ? tf_primary : ap_primary
holonomy_secondary = visual_theme == "Quantum Nebula" ? qn_secondary :
                     visual_theme == "Ethereal Prism" ? ep_secondary :
                     visual_theme == "Dark Matter" ? dm_secondary :
                     visual_theme == "Cosmic Aurora" ? ca_secondary :
                     visual_theme == "Void Resonance" ? vr_secondary :
                     visual_theme == "Temporal Flux" ? tf_secondary : ap_secondary
holonomy_accent = visual_theme == "Quantum Nebula" ? qn_accent :
                  visual_theme == "Ethereal Prism" ? ep_accent :
                  visual_theme == "Dark Matter" ? dm_accent :
                  visual_theme == "Cosmic Aurora" ? ca_accent :
                  visual_theme == "Void Resonance" ? vr_accent :
                  visual_theme == "Temporal Flux" ? tf_accent : ap_accent
quantum_positive = visual_theme == "Quantum Nebula" ? qn_positive :
                   visual_theme == "Ethereal Prism" ? ep_positive :
                   visual_theme == "Dark Matter" ? dm_positive :
                   visual_theme == "Cosmic Aurora" ? ca_positive :
                   visual_theme == "Void Resonance" ? vr_positive :
                   visual_theme == "Temporal Flux" ? tf_positive : ap_positive
quantum_negative = visual_theme == "Quantum Nebula" ? qn_negative :
                   visual_theme == "Ethereal Prism" ? ep_negative :
                   visual_theme == "Dark Matter" ? dm_negative :
                   visual_theme == "Cosmic Aurora" ? ca_negative :
                   visual_theme == "Void Resonance" ? vr_negative :
                   visual_theme == "Temporal Flux" ? tf_negative : ap_negative
anomaly_strong = visual_theme == "Quantum Nebula" ? qn_anomaly_strong :
                 visual_theme == "Ethereal Prism" ? ep_anomaly_strong :
                 visual_theme == "Dark Matter" ? dm_anomaly_strong :
                 visual_theme == "Cosmic Aurora" ? ca_anomaly_strong :
                 visual_theme == "Void Resonance" ? vr_anomaly_strong :
                 visual_theme == "Temporal Flux" ? tf_anomaly_strong : ap_anomaly_strong
anomaly_weak = visual_theme == "Quantum Nebula" ? qn_anomaly_weak :
               visual_theme == "Ethereal Prism" ? ep_anomaly_weak :
               visual_theme == "Dark Matter" ? dm_anomaly_weak :
               visual_theme == "Cosmic Aurora" ? ca_anomaly_weak :
               visual_theme == "Void Resonance" ? vr_anomaly_weak :
               visual_theme == "Temporal Flux" ? tf_anomaly_weak : ap_anomaly_weak
field_glow = visual_theme == "Quantum Nebula" ? qn_field_glow :
             visual_theme == "Ethereal Prism" ? ep_field_glow :
             visual_theme == "Dark Matter" ? dm_field_glow :
             visual_theme == "Cosmic Aurora" ? ca_field_glow :
             visual_theme == "Void Resonance" ? vr_field_glow :
             visual_theme == "Temporal Flux" ? tf_field_glow : ap_field_glow
phase_intense = visual_theme == "Quantum Nebula" ? qn_phase_intense : visual_theme == "Ethereal Prism" ? ep_phase_intense : visual_theme == "Dark Matter" ? dm_phase_intense : visual_theme == "Cosmic Aurora" ? ca_phase_intense : visual_theme == "Void Resonance" ? vr_phase_intense : visual_theme == "Temporal Flux" ? tf_phase_intense : ap_phase_intense
phase_normal = visual_theme == "Quantum Nebula" ? qn_phase_normal :
               visual_theme == "Ethereal Prism" ? ep_phase_normal :
               visual_theme == "Dark Matter" ? dm_phase_normal :
               visual_theme == "Cosmic Aurora" ? ca_phase_normal :
               visual_theme == "Void Resonance" ? vr_phase_normal :
               visual_theme == "Temporal Flux" ? tf_phase_normal : ap_phase_normal
// ========================================
// HELPER FUNCTION FOR DASHBOARD POSITION
// ========================================
f_getTablePosition(position_string) =>
    switch position_string
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Right" => position.bottom_right
        => position.top_right  // Default to top_right if invalid
// ========================================
// TIME AND SESSION LOGIC
// ========================================
bar_hour = hour(time, session_timezone)
bar_dow = dayofweek(time, session_timezone)
in_session = (session_start < session_end ? (bar_hour >= session_start and bar_hour < session_end) : (bar_hour >= session_start or bar_hour < session_end))
not_weekend = allow_weekend or (bar_dow != dayofweek.saturday and bar_dow != dayofweek.sunday)
trade_allowed = in_session and not_weekend
// ========================================
// CORE INDICATORS
// ========================================
rsi_confirmed = ta.rsi(close, 14)
ema20_confirmed = ta.ema(close, 20)
ema50_confirmed = ta.ema(close, 50)
[macd_line_confirmed, signal_line_confirmed, histogram_confirmed] = ta.macd(close, 12, 26, 9)
atr_confirmed = ta.atr(14)
vol_avg_confirmed = ta.sma(volume, 20)
htf_trend = request.security(syminfo.tickerid, "60", ta.ema(close, 20), lookahead=barmerge.lookahead_off)
// Calculate Fibonacci levels for additional resonance
price_range = ta.highest(high, 55) - ta.lowest(low, 55)
range_low = ta.lowest(low, 55)
// ========================================
// HOLONOMY FIELD CALCULATION
// ========================================
calculateRobustSignal() =>
    roc = (close - close[10]) / close[10] * 100
    vwap_distance = (close - ta.vwap(hlc3)) / close * 100
    signal = 0.0
    if close > htf_trend and close > ema20_confirmed
        signal += 1.0 * (close > ema50_confirmed ? 1.5 : 1.0)
        if roc > 0
            signal += roc / 10
        if volume > vol_avg_confirmed * 1.2
            signal += 0.5
    else if close < htf_trend and close < ema20_confirmed
        signal -= 1.0 * (close < ema50_confirmed ? 1.5 : 1.0)
        if roc < 0
            signal += roc / 10
        if volume > vol_avg_confirmed * 1.2
            signal -= 0.5
    vwap_contrib = math.max(-2, math.min(2, vwap_distance))
    signal += vwap_contrib
    if rsi_confirmed < 30 and signal > 0
        signal += 1.5
    else if rsi_confirmed < 40 and signal > 0
        signal += 0.5
    else if rsi_confirmed > 70 and signal < 0
        signal -= 1.5
    else if rsi_confirmed > 60 and signal < 0
        signal -= 0.5
    if macd_line_confirmed > signal_line_confirmed and signal > 0
        signal += 0.5
    else if macd_line_confirmed < signal_line_confirmed and signal < 0
        signal -= 0.5
    signal * SCORE_AMPLIFIER / 10
// ========================================
// MARKET REGIME FILTER
// ========================================
volatility_regime = atr_confirmed / close * 100
volatility_percentile_30 = ta.percentile_nearest_rank(volatility_regime, 100, 30)
volatility_percentile_70 = ta.percentile_nearest_rank(volatility_regime, 100, 70)
low_vol = volatility_regime < volatility_percentile_30
high_vol = volatility_regime > volatility_percentile_70
mode_multiplier = EXECUTION_MODE == "Conservative" ? 1.3 : EXECUTION_MODE == "Aggressive" ? 0.7 : 1.0
signal_threshold = low_vol ? SIGNAL_SENSITIVITY * 0.7 * mode_multiplier : high_vol ? SIGNAL_SENSITIVITY * 1.3 * mode_multiplier : SIGNAL_SENSITIVITY * mode_multiplier
// ========================================
// SIGNAL CALCULATION
// ========================================
float signal_strength_confirmed = calculateRobustSignal()
// ========================================
// ADAPTIVE LEARNING SYSTEM - WORKAROUND RESET
// ========================================
var array<float> trade_performance = array.new_float(PERFORMANCE_TRACKING)
var float adaptive_risk_multiplier = 1.0
var float win_rate = 0.5
var float avg_win = 0.0
var float avg_loss = 0.0
var bool market_regime_bullish = true
var float learned_signal_sensitivity = SIGNAL_SENSITIVITY
var float learned_score_amplifier = SCORE_AMPLIFIER
var int learned_min_signal_separation = MIN_SIGNAL_SEPARATION
var string learned_execution_mode = EXECUTION_MODE
var float learned_base_risk = BASE_RISK
var int learned_max_daily_trades = MAX_DAILY_TRADES
var float learned_learning_speed = LEARNING_SPEED
var int learned_performance_tracking = PERFORMANCE_TRACKING
var float learned_anomaly_threshold = anomaly_threshold
var float learned_portal_threshold = portal_threshold
var int learned_session_start = session_start
var int learned_session_end = session_end
var int last_learning_update = 0
var int learning_update_count = 0
var bool learning_data_initialized = false
var array<float> hourly_pnl = array.new_float(24, 0.0)
var array<int> hourly_trade_count = array.new_int(24, 0)
var float total_learning_pnl = 0.0
var int consecutive_losses = 0
var int max_consecutive_losses = 0
var int learning_start_trades = 0
var float learning_start_equity = 0.0
var int current_session_id = 0
var int daily_trades = 0
// ========================================
// SECTION 3: LEARNING LOGIC
// ========================================
current_time = time
if reset_performance_data or barstate.isfirst or not learning_data_initialized
    last_learning_update := time
    learning_update_count := 0
    total_learning_pnl := 0.0
    consecutive_losses := 0
    max_consecutive_losses := 0
    learning_start_trades := strategy.closedtrades
    learning_start_equity := strategy.equity
    adaptive_risk_multiplier := 1.0
    win_rate := 0.5
    avg_win := 0.0
    avg_loss := 0.0
    array.clear(trade_performance)
    array.clear(hourly_pnl)
    array.clear(hourly_trade_count)
    for i = 0 to 23
        array.push(hourly_pnl, 0.0)
        array.push(hourly_trade_count, 0)
    learning_data_initialized := true
    if barstate.isfirst
        learned_signal_sensitivity := SIGNAL_SENSITIVITY
        learned_score_amplifier := SCORE_AMPLIFIER
        learned_min_signal_separation := MIN_SIGNAL_SEPARATION
        learned_execution_mode := EXECUTION_MODE
        learned_base_risk := BASE_RISK
        learned_max_daily_trades := MAX_DAILY_TRADES
        learned_learning_speed := LEARNING_SPEED
        learned_performance_tracking := PERFORMANCE_TRACKING
        learned_anomaly_threshold := anomaly_threshold
        learned_portal_threshold := portal_threshold
        learned_session_start := session_start
        learned_session_end := session_end
if not reset_performance_data and ENABLE_LEARNING
    if strategy.closedtrades > strategy.closedtrades[1] and barstate.isconfirmed
        last_trade_return = strategy.closedtrades.profit(strategy.closedtrades - 1) / ACCOUNT_SIZE
        array.unshift(trade_performance, last_trade_return)
        if array.size(trade_performance) > PERFORMANCE_TRACKING
            array.pop(trade_performance)
        if array.size(trade_performance) >= 20
            wins = 0
            total_win = 0.0
            total_loss = 0.0
            win_count = 0
            loss_count = 0
            for i = 0 to array.size(trade_performance) - 1
                perf = array.get(trade_performance, i)
                if perf > 0
                    wins += 1
                    total_win += perf
                    win_count += 1
                else
                    total_loss += math.abs(perf)
                    loss_count += 1
            win_rate := array.size(trade_performance) > 0 ? wins / array.size(trade_performance) : 0.5
            avg_win := win_count > 0 ? total_win / win_count : 0.0
            avg_loss := loss_count > 0 ? total_loss / loss_count : 0.0
            if barstate.isconfirmed
                if total_loss > 0 and (total_win / total_loss) < 1.5
                    adaptive_risk_multiplier := math.max(0.5, adaptive_risk_multiplier - LEARNING_SPEED * 0.2)
                else if total_loss > 0 and (total_win / total_loss) > 2.5
                    adaptive_risk_multiplier := math.min(1.5, adaptive_risk_multiplier + LEARNING_SPEED * 0.1)
recent_closes = ta.sma(close, 20)
market_regime_bullish := close > recent_closes and recent_closes > ta.sma(close, 50)
if not reset_performance_data
    if strategy.closedtrades > strategy.closedtrades[1]
        daily_trades += 1
        if ENABLE_LEARNING and strategy.closedtrades > learning_start_trades
            trade_hour = hour(time, session_timezone)
            trade_pnl = strategy.closedtrades.profit(strategy.closedtrades - 1)
            current_hourly_pnl = array.get(hourly_pnl, trade_hour)
            current_hourly_count = array.get(hourly_trade_count, trade_hour)
            array.set(hourly_pnl, trade_hour, current_hourly_pnl + trade_pnl)
            array.set(hourly_trade_count, trade_hour, current_hourly_count + 1)
            total_learning_pnl += trade_pnl
            if trade_pnl < 0
                consecutive_losses += 1
                max_consecutive_losses := math.max(max_consecutive_losses, consecutive_losses)
            else
                consecutive_losses := 0
if dayofweek != dayofweek[1]
    daily_trades := 0
if not reset_performance_data and ENABLE_LEARNING
    update_interval_ms = learning_update_interval * 60 * 1000
    should_update_learning = (current_time - last_learning_update) >= update_interval_ms or (force_update_on_trade_close and strategy.closedtrades > strategy.closedtrades[1]) or (force_update_on_drawdown and adaptive_risk_multiplier < 0.7)
    if should_update_learning and array.size(trade_performance) >= learning_min_trades and barstate.isconfirmed
        trades_analyzed = math.min(array.size(trade_performance), 50)
        winning_trades = 0
        losing_trades = 0
        false_signals = 0
        total_wins = 0.0
        total_losses = 0.0
        for i = 0 to trades_analyzed - 1
            trade_result = array.get(trade_performance, i)
            if trade_result > 0
                winning_trades += 1
                total_wins += trade_result
            else
                losing_trades += 1
                total_losses += math.abs(trade_result)
                if math.abs(trade_result) < BASE_RISK * ACCOUNT_SIZE * 0.5
                    false_signals += 1
        current_win_rate = winning_trades / trades_analyzed
        false_signal_rate = losing_trades > 0 ? false_signals / losing_trades : 0
        sensitivity_multiplier = current_win_rate > 0.55 ? (0.98 - learning_sensitivity * 0.02) : (1.02 + learning_sensitivity * 0.02)
        learned_signal_sensitivity := SIGNAL_SENSITIVITY * sensitivity_multiplier
        learned_signal_sensitivity := math.max(0.5, math.min(12.0, learned_signal_sensitivity))
        amplifier_multiplier = current_win_rate > 0.55 ? (1.01 + learning_sensitivity * 0.01) : (0.99 - learning_sensitivity * 0.01)
        learned_score_amplifier := SCORE_AMPLIFIER * amplifier_multiplier
        learned_score_amplifier := math.max(10.0, math.min(200.0, learned_score_amplifier))
        if false_signal_rate > 0.3
            learned_min_signal_separation := math.min(MIN_SIGNAL_SEPARATION + 1, 20)
        else
            learned_min_signal_separation := math.max(MIN_SIGNAL_SEPARATION - 1, 1)
        if current_win_rate < 0.50
            learned_execution_mode := "Conservative"
        else if current_win_rate > 0.60
            learned_execution_mode := "Aggressive"
        else
            learned_execution_mode := "Adaptive"
        risk_multiplier = current_win_rate > 0.55 ? (1.01 + learning_sensitivity * 0.005) : (0.99 - learning_sensitivity * 0.005)
        learned_base_risk := BASE_RISK * risk_multiplier
        learned_base_risk := math.max(0.003, math.min(0.02, learned_base_risk))
        if current_win_rate > 0.60
            learned_max_daily_trades := math.min(MAX_DAILY_TRADES + 1, 25)
        else if current_win_rate < 0.45
            learned_max_daily_trades := math.max(MAX_DAILY_TRADES - 1, 5)
        else
            learned_max_daily_trades := MAX_DAILY_TRADES
        last_learning_update := current_time
        learning_update_count += 1
// ========================================
// EXECUTION ENGINE
// ========================================
var float daily_pnl = 0.0
var int last_signal_bar = 0
if dayofweek != dayofweek[1]
    daily_pnl := 0.0
    daily_trades := 0
if strategy.closedtrades > strategy.closedtrades[1]
    daily_pnl += strategy.closedtrades.profit(strategy.closedtrades - 1)
    daily_trades += 1
signal_quality_rating = ""
abs_signal = math.abs(signal_strength_confirmed)
if abs_signal >= signal_threshold * 1.5
    signal_quality_rating := "ELITE"
else if abs_signal >= signal_threshold * 1.2
    signal_quality_rating := "STRONG"
else if abs_signal >= signal_threshold
    signal_quality_rating := "GOOD"
else
    signal_quality_rating := "WEAK"
min_bars_between = EXECUTION_MODE == "Aggressive" ? MIN_SIGNAL_SEPARATION / 2 : EXECUTION_MODE == "Conservative" ? MIN_SIGNAL_SEPARATION * 2 : MIN_SIGNAL_SEPARATION
bars_since_signal = bar_index - last_signal_bar
entry_timing_good = SMART_ENTRIES ? bars_since_signal >= min_bars_between : true
max_trades_adjusted = EXECUTION_MODE == "Aggressive" ? MAX_DAILY_TRADES * 1.5 : EXECUTION_MODE == "Conservative" ? MAX_DAILY_TRADES * 0.7 : MAX_DAILY_TRADES
risk_ok = daily_trades < max_trades_adjusted
// ========================================
// POSITION SIZING
// ========================================
calculateElitePositionSize() =>
    base_risk_amount = ACCOUNT_SIZE * (BASE_RISK / 100) * adaptive_risk_multiplier
    raw_signal_mult = DYNAMIC_SIZING ? 0.5 + (math.abs(signal_strength_confirmed) / signal_threshold) * 1.5 : 1.0
    signal_mult = math.max(0.5, math.min(3.0, raw_signal_mult))
    regime_mult = market_regime_bullish and signal_strength_confirmed > 0 ? 1.2 : not market_regime_bullish and signal_strength_confirmed < 0 ? 1.2 : 0.8
    perf_mult = win_rate > 0.65 ? 1.5 : win_rate > 0.55 ? 1.2 : win_rate < 0.45 ? 0.5 : 1.0
    mode_mult = EXECUTION_MODE == "Aggressive" ? 1.8 : EXECUTION_MODE == "Conservative" ? 0.6 : 1.0
    vol_mult = atr_confirmed / ta.sma(atr_confirmed, 50)
    vol_adj = vol_mult > 1.2 ? 0.8 : vol_mult < 0.8 ? 1.3 : 1.0
    final_risk = base_risk_amount * signal_mult * regime_mult * perf_mult * mode_mult * vol_adj
    if syminfo.type == "futures"
        tick_value = syminfo.mintick * syminfo.pointvalue
        stop_ticks = (atr_confirmed * 1.5) / syminfo.mintick
        position_size = final_risk / (stop_ticks * tick_value)
        contracts = math.round(position_size)
        math.max(1, math.min(10, contracts))
    else if syminfo.type == "crypto"
        stop_percent = (atr_confirmed * 1.5) / close * 100
        position_val = final_risk / (stop_percent / 100)
        shares = position_val / close
        math.round(shares * 100) / 100
    else
        stop_percent = (atr_confirmed * 1.5) / close * 100
        position_val = final_risk / (stop_percent / 100)
        shares = position_val / close
        math.max(1, math.round(shares))
// ========================================
// STOP LOSS CALCULATION
// ========================================
calculateSmartStop(is_long) =>
    recent_range = ta.highest(high, 10) - ta.lowest(low, 10)
    pivot_point = (high[1] + low[1] + close[1]) / 3
    stop_mode_mult = EXECUTION_MODE == "Aggressive" ? 0.8 : EXECUTION_MODE == "Conservative" ? 1.5 : 1.0
    if is_long
        support = math.min(ta.lowest(low, 5), pivot_point - recent_range * 0.382)
        math.max(close - atr_confirmed * 1.5 * stop_mode_mult, support)
    else
        resistance = math.max(ta.highest(high, 5), pivot_point + recent_range * 0.382)
        math.min(close + atr_confirmed * 2 * stop_mode_mult, resistance)
current_position_size = calculateElitePositionSize()
long_stop_loss = calculateSmartStop(true)
short_stop_loss = calculateSmartStop(false)
// ========================================
// TRADE EXECUTION
// ========================================
strong_long = signal_strength_confirmed >= signal_threshold * 1.2 and strategy.position_size == 0
strong_short = signal_strength_confirmed <= -signal_threshold * 1.2 and strategy.position_size == 0
if EXECUTION_MODE == "Conservative" and SIGNAL_CONFIRMATION
    strong_long := strong_long and close > ema20_confirmed and rsi_confirmed > 30 and rsi_confirmed < 70
    strong_short := strong_short and close < ema20_confirmed and rsi_confirmed > 30 and rsi_confirmed < 70
can_trade = entry_timing_good and risk_ok and barstate.isconfirmed and trade_allowed
if strong_long and can_trade
    size = current_position_size
    stop_loss = long_stop_loss
    target_multiplier = EXECUTION_MODE == "Aggressive" ? 4.0 : EXECUTION_MODE == "Conservative" ? 2.0 : 3.0
    take_profit = close + ((close - stop_loss) * target_multiplier)
    strategy.entry("Long", strategy.long, qty=size)
    if ADVANCED_EXITS
        trail_activation = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 1.5 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 3.0 : atr_confirmed * 2.0
        trail_offset = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 0.3 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 0.8 : atr_confirmed * 0.5
        strategy.exit("LongExit", "Long", stop=stop_loss, limit=take_profit, trail_points=trail_activation, trail_offset=trail_offset)
    else
        strategy.exit("LongExit", "Long", stop=stop_loss, limit=take_profit)
    last_signal_bar := bar_index
if strong_short and can_trade
    size = current_position_size
    stop_loss = short_stop_loss
    target_multiplier = EXECUTION_MODE == "Aggressive" ? 4.0 : EXECUTION_MODE == "Conservative" ? 2.0 : 3.0
    take_profit = close - ((stop_loss - close) * target_multiplier)
    strategy.entry("Short", strategy.short, qty=size)
    if ADVANCED_EXITS
        trail_activation = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 1.5 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 3.0 : atr_confirmed * 2.0
        trail_offset = EXECUTION_MODE == "Aggressive" ? atr_confirmed * 0.3 : EXECUTION_MODE == "Conservative" ? atr_confirmed * 0.8 : atr_confirmed * 0.5
        strategy.exit("ShortExit", "Short", stop=stop_loss, limit=take_profit, trail_points=trail_activation, trail_offset=trail_offset)
    else
        strategy.exit("ShortExit", "Short", stop=stop_loss, limit=take_profit)
    last_signal_bar := bar_index
max_bars_in_trade = EXECUTION_MODE == "Aggressive" ? 50 : EXECUTION_MODE == "Conservative" ? 200 : 100
if strategy.position_size != 0
    bars_in_trade = bar_index - strategy.opentrades.entry_bar_index(0)
    if bars_in_trade > max_bars_in_trade
        strategy.close_all("Time Exit")
// ============================================
// HOLONOMY FIELD CALCULATIONS (GLOBAL SCOPE)
// ============================================
// Calculate dynamic field levels based on holonomy strength
field_base = ta.sma(close, 21)
field_strength = math.abs(signal_strength_confirmed) / signal_threshold
field_expansion = atr_confirmed * (0.5 + field_strength * 1.5)
// Create multiple field layers
field_upper_1 = field_base + field_expansion * 0.618
field_upper_2 = field_base + field_expansion * 1.0
field_upper_3 = field_base + field_expansion * 1.618
field_lower_1 = field_base - field_expansion * 0.618
field_lower_2 = field_base - field_expansion * 1.0
field_lower_3 = field_base - field_expansion * 1.618
// Pivot calculations (global scope)
pivot_high = ta.pivothigh(high, 5, 5)
pivot_low = ta.pivotlow(low, 5, 5)
// Fibonacci resonance calculations (global scope)
fib_236 = range_low + price_range * 0.236
fib_382 = range_low + price_range * 0.382
fib_500 = range_low + price_range * 0.500
fib_618 = range_low + price_range * 0.618
fib_786 = range_low + price_range * 0.786
// ============================================
// ALL PLOT STATEMENTS (GLOBAL SCOPE)
// ============================================
// Plot field bands
plot(show_holonomy_field ? field_upper_1 : na, "Holonomy Upper Core", color=color.new(holonomy_primary, field_intensity - 60), linewidth=2)
plot(show_holonomy_field ? field_lower_1 : na, "Holonomy Lower Core", color=color.new(holonomy_primary, field_intensity - 60), linewidth=2)
plot(show_holonomy_field ? field_upper_2 : na, "Holonomy Upper Secondary", color=color.new(holonomy_secondary, field_intensity), linewidth=1)
plot(show_holonomy_field ? field_lower_2 : na, "Holonomy Lower Secondary", color=color.new(holonomy_secondary, field_intensity), linewidth=1)
plot(show_holonomy_field ? field_upper_3 : na, "Holonomy Upper Outer", color=color.new(holonomy_accent, field_intensity + 60), linewidth=1, style=plot.style_circles)
plot(show_holonomy_field ? field_lower_3 : na, "Holonomy Lower Outer", color=color.new(holonomy_accent, field_intensity + 60), linewidth=1, style=plot.style_circles)
// Fill areas
upper_fill = plot(show_holonomy_field ? field_upper_1 : na, display=display.none)
base_fill = plot(show_holonomy_field ? field_base : na, display=display.none)
lower_fill = plot(show_holonomy_field ? field_lower_1 : na, display=display.none)
fill(upper_fill, base_fill, color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, field_intensity + 5), title="Upper Field Fill")
fill(base_fill, lower_fill, color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, field_intensity + 5), title="Lower Field Fill")
// Plot Fibonacci resonance levels
plot(show_field_resonance and field_strength > 0.5 ? fib_236 : na, "Fib 236", color=color.new(anomaly_weak, 60), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_382 : na, "Fib 382", color=color.new(anomaly_weak, 50), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_500 : na, "Fib 500", color=color.new(anomaly_strong, 60), linewidth=2, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_618 : na, "Fib 618", color=color.new(anomaly_weak, 50), linewidth=1, style=plot.style_circles)
plot(show_field_resonance and field_strength > 0.5 ? fib_786 : na, "Fib 786", color=color.new(anomaly_weak, 60), linewidth=1, style=plot.style_circles)
// Background intensity
intensity = math.min(field_strength * 100, 100)
bg_color = color.new(phase_intense, 95 - int(intensity * 0.1))
bgcolor(show_phase_flow ? bg_color : na, title="Field Intensity Background")
// ============================================
// Holonomy Field Boxes
// ============================================
if show_holonomy_field and barstate.isconfirmed
    var array<box> field_boxes = array.new<box>()
    if array.size(field_boxes) > 10
        for i = 0 to 4
            box.delete(array.shift(field_boxes))
    box_left = bar_index - 1
    box_right = bar_index + 15
    core_box = box.new(box_left, field_upper_1, box_right, field_lower_1,
                  border_color=color.new(holonomy_primary, 80),
                  bgcolor=color.new(holonomy_primary, 94),
                  border_width=2)
    secondary_box = box.new(box_left, field_upper_2, box_right, field_lower_2,
                       border_color=color.new(holonomy_secondary, 85),
                       bgcolor=color.new(holonomy_secondary, 96),
                       border_width=2, border_style=line.style_dashed)
    array.push(field_boxes, core_box)
    array.push(field_boxes, secondary_box)
// ============================================
// RESONANCE BANDS WITH LINES (LOCAL SCOPE)
// ============================================
if show_field_resonance and barstate.isconfirmed
    var array<line> resistance_lines = array.new<line>()
    var array<line> support_lines = array.new<line>()
    var array<label> resonance_labels = array.new<label>()
    // Clean up old elements
    if array.size(resistance_lines) > 8
        for i = 0 to 3
            line.delete(array.shift(resistance_lines))
    if array.size(support_lines) > 8
        for i = 0 to 3
            line.delete(array.shift(support_lines))
    if array.size(resonance_labels) > 15
        for i = 0 to 7
            label.delete(array.shift(resonance_labels))
    // Add new resistance levels
    if not na(pivot_high) and pivot_high > field_base
        resonance_strength = math.abs(signal_strength_confirmed) / signal_threshold
        line_color = color.new(anomaly_strong, 70 - int(resonance_strength * 15))
        line_width = resonance_strength > 1.5 ? 3 : resonance_strength > 1.0 ? 2 : 1
        // Add resonance label
        if resonance_strength > 0.8
            res_label = label.new(bar_index + 32, pivot_high, "⚡R",
                                 color=color.new(anomaly_strong, 75),
                                 textcolor=anomaly_strong,
                                 style=label.style_label_left,
                                 size=size.small)
            array.push(resonance_labels, res_label)
    // Add new support levels
    if not na(pivot_low) and pivot_low < field_base
        resonance_strength = math.abs(signal_strength_confirmed) / signal_threshold
        line_color = color.new(quantum_positive, 70 - int(resonance_strength * 15))
        line_width = resonance_strength > 1.5 ? 3 : resonance_strength > 1.0 ? 2 : 1
        // Add support label
        if resonance_strength > 0.8
            sup_label = label.new(bar_index + 32, pivot_low, "⚡S",
                                 color=color.new(quantum_positive, 75),
                                 textcolor=quantum_positive,
                                 style=label.style_label_left,
                                 size=size.small)
            array.push(resonance_labels, sup_label)
// ========================================
// QUANTUM PORTALS
// ========================================
if show_quantum_portals and (strong_long or strong_short)
    for i = 1 to portal_depth
        portal_size = i * atr_confirmed * 0.3
        portal_y = strong_long ? low - portal_size : high + portal_size
        portal_outer_color = strong_long ? color.new(quantum_positive, 60 + i * 10) : color.new(quantum_negative, 60 + i * 10)
        portal_inner_color = strong_long ? color.new(quantum_positive, 40 + i * 5) : color.new(anomaly_strong, 40 + i * 5)
        label.new(bar_index, portal_y, "◉", color=portal_outer_color, textcolor=portal_outer_color, style=label.style_none, size=size.huge)
        label.new(bar_index, portal_y, "●", color=portal_inner_color, textcolor=portal_inner_color, style=label.style_none, size=size.large)
// ========================================
// ENHANCED FRACTAL GRID VISUALIZATION
// ========================================
if show_anomaly_grid
    // Pre-calculate all holonomy periods
    h8_high = ta.highest(high, 8)
    h8_low = ta.lowest(low, 8)
    h13_high = ta.highest(high, 13)
    h13_low = ta.lowest(low, 13)
    h21_high = ta.highest(high, 21)
    h21_low = ta.lowest(low, 21)
    h34_high = ta.highest(high, 34)
    h34_low = ta.lowest(low, 34)
    h55_high = ta.highest(high, 55)
    h55_low = ta.lowest(low, 55)
    // Arrays fractal levels
    fractalHighs = array.from(h8_high, h13_high, h21_high, h34_high, h55_high)
    fractalLows = array.from(h8_low, h13_low, h21_low, h34_low, h55_low)
    // Visual storage arrays
    var array<line> fractalHighGlowLines = array.new<line>()
    var array<line> fractalHighQuantumLines = array.new<line>()
    var array<line> fractalHighShadowLines = array.new<line>()
    var array<line> fractalLowGlowLines = array.new<line>()
    var array<line> fractalLowQuantumLines = array.new<line>()
    var array<line> fractalLowShadowLines = array.new<line>()
    var array<label> fractalHighLabels = array.new<label>()
    var array<label> fractalLowLabels = array.new<label>()
    // Update only on real-time bars
    if barstate.isconfirmed
        // Clear previous visualizations
        for l in fractalHighGlowLines
            line.delete(l)
        for l in fractalHighQuantumLines
            line.delete(l)
        for l in fractalHighShadowLines
            line.delete(l)
        for l in fractalLowGlowLines
            line.delete(l)
        for l in fractalLowQuantumLines
            line.delete(l)
        for l in fractalLowShadowLines
            line.delete(l)
        for lbl in fractalHighLabels
            label.delete(lbl)
        for lbl in fractalLowLabels
            label.delete(lbl)
        array.clear(fractalHighGlowLines)
        array.clear(fractalHighQuantumLines)
        array.clear(fractalHighShadowLines)
        array.clear(fractalLowGlowLines)
        array.clear(fractalLowQuantumLines)
        array.clear(fractalLowShadowLines)
        array.clear(fractalHighLabels)
        array.clear(fractalLowLabels)
        // Holonomy periods for labeling
        holonomy_periods = array.from(8, 13, 21, 34, 55)
        used_positions = array.new<float>()
        min_spacing = atr_confirmed * 0.2
        // Draw fractal levels with enhanced effects
        for i = 0 to 4
            period = array.get(holonomy_periods, i)
            // Dynamic transparency based on period
            base_alpha = 50 + i * 10
            glow_alpha = 70 + i * 6
            shadow_alpha = 85 + i * 3
            // High fractals with triple-layer effect
            hi = array.get(fractalHighs, i)
            if not na(hi)
                // Shadow layer (darkest, widest)
                array.push(fractalHighShadowLines, line.new(bar_index - 5, hi, bar_index + 30, hi, color=color.new(phase_intense, shadow_alpha), width=5, style=line.style_solid))
                // Main glow line
                array.push(fractalHighGlowLines, line.new(bar_index - 5, hi, bar_index + 30, hi, color=color.new(anomaly_strong, glow_alpha), width=3, style=line.style_solid))
                // Quantum field line (dotted overlay)
                array.push(fractalHighQuantumLines, line.new(bar_index - 6, hi, bar_index + 31, hi, color=color.new(quantum_negative, base_alpha), width=1, style=line.style_dotted))
                // Check label spacing
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(hi - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break
                if can_place_label
                    // Calculate holonomy impact
                    price_distance = (hi - close) / atr_confirmed
                    holonomy_impact = signal_strength_confirmed - (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / signal_threshold
                    // Enhanced label with gradient background
                    label_text = "H" + str.tostring(period) + ": " + str.tostring(hi, "#.##") + " φ: " + str.tostring(anomaly_strength, "#.##") + (anomaly_strength > 1.5 ? " ⚡" : anomaly_strength > 1.0 ? " ●" : " ○")
                    label_bg_color = anomaly_strength > 1.5 ? color.new(anomaly_strong, 75) : anomaly_strength > 1.0 ? color.new(holonomy_accent, 80) : color.new(visual_theme == "Void Resonance" ? #111111 : #1A1E2A, 85)
                    label_text_color = anomaly_strength > 1.0 ? anomaly_strong : holonomy_accent
                    new_label = label.new(bar_index + 31, hi, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)
                    array.push(fractalHighLabels, new_label)
                    array.push(used_positions, hi)
            // Low fractals with triple-layer effect
            lo = array.get(fractalLows, i)
            if not na(lo)
                // Shadow layer (darkest, widest)
                array.push(fractalLowShadowLines, line.new(bar_index - 5, lo, bar_index + 30, lo, color=color.new(phase_intense, shadow_alpha), width=5, style=line.style_solid))
                // Main glow line
                array.push(fractalLowGlowLines, line.new(bar_index - 5, lo, bar_index + 30, lo, color=color.new(quantum_positive, glow_alpha), width=3, style=line.style_solid))
                // Quantum field line (dotted overlay)
                array.push(fractalLowQuantumLines, line.new(bar_index - 6, lo, bar_index + 31, lo, color=color.new(holonomy_primary, base_alpha), width=1, style=line.style_dotted))
                // Check label spacing
                can_place_label = true
                if array.size(used_positions) > 0
                    for j = 0 to array.size(used_positions) - 1
                        if math.abs(lo - array.get(used_positions, j)) < min_spacing
                            can_place_label := false
                            break
                if can_place_label
                    // Calculate holonomy impact
                    price_distance = (close - lo) / atr_confirmed
                    holonomy_impact = signal_strength_confirmed + (price_distance * SCORE_AMPLIFIER / 10)
                    anomaly_strength = math.abs(holonomy_impact) / signal_threshold
                    // Enhanced label with gradient background
                    label_text = "L" + str.tostring(period) + ": " + str.tostring(lo, "#.##") + " φ: " + str.tostring(anomaly_strength, "#.##") + (anomaly_strength > 1.5 ? " ⚡" : anomaly_strength > 1.0 ? " ●" : " ○")
                    label_bg_color = anomaly_strength > 1.5 ? color.new(quantum_positive, 75) : anomaly_strength > 1.0 ? color.new(holonomy_primary, 80) : color.new(visual_theme == "Void Resonance" ? #111111 : #1A1E2A, 85)
                    label_text_color = anomaly_strength > 1.0 ? quantum_positive : holonomy_primary
                    new_label = label.new(bar_index + 31, lo, label_text, color=label_bg_color, textcolor=label_text_color, style=label.style_label_left, size=size.small)
                    array.push(fractalLowLabels, new_label)
                    array.push(used_positions, lo)
// ========================================
// PHASE SPACE FLOW
// ========================================
phase_x = (close - ta.sma(close, 21)) / atr_confirmed
phase_y = (volume - ta.sma(volume, 21)) / ta.sma(volume, 21)
flow_strength = math.sqrt(phase_x * phase_x + phase_y * phase_y)
flow_angle = phase_x != 0 ? math.atan(phase_y / phase_x) : 0
flow_color = flow_strength > 2 ? color.new(phase_intense, 85) : flow_strength > 1 ? color.new(phase_normal, 90) : color.new(holonomy_secondary, 95)
bgcolor(show_phase_flow ? flow_color : na, title="Phase Space Flow")
phase_x_val = phase_x
phase_y_val = phase_y
// ========================================
// HOLONOMY PATH TRACERS
// ========================================
if show_holonomy_field
    for i = 1 to 10
        if i <= bar_index
            hist_signal = signal_strength_confirmed[i]
            path_y = close[i]
            path_color = hist_signal > 0 ? color.new(quantum_positive, 70 + i * 3) : color.new(quantum_negative, 70 + i * 3)
            label.new(bar_index - i, path_y, "·", color=path_color, textcolor=path_color, style=label.style_none, size=size.small)
// ============================================
// CORE CALCULATIONS (Add this before dashboard)
// ============================================
// Basic indicators
atr = ta.atr(14)
rsi = ta.rsi(close, 14)
sma20 = ta.sma(close, 20)  // Extract SMA calculation
ema50 = ta.ema(close, 50)
// Trend direction (fixed)
trend_direction = close > sma20 ? 1 : close < sma20 ? -1 : 0
// Holonomy Score calculation (0-1 range)
momentum = ta.mom(close, 10)
price_position = (close - ta.lowest(low, 50)) / (ta.highest(high, 50) - ta.lowest(low, 50))
holonomy_score = (rsi/100 + price_position) / 2
// Anomaly Level calculation (0-100 range)
bb_upper = ta.sma(close, 20) + 2 * ta.stdev(close, 20)
bb_lower = ta.sma(close, 20) - 2 * ta.stdev(close, 20)
bb_position = close > bb_upper ? 100 : close < bb_lower ? 100 : 0
volume_spike = volume > ta.sma(volume, 20) * 1.5 ? 50 : 0
anomaly_level = math.min(bb_position + volume_spike, 100)
// Quantum State calculation (-1, 0, 1)
bullish_conditions = close > sma20 and rsi > 50 and momentum > 0
bearish_conditions = close < sma20 and rsi < 50 and momentum < 0
quantum_state = bullish_conditions ? 1 : bearish_conditions ? -1 : 0
// Volatility
volatility = ta.stdev(close, 20) / sma20 * 100
// ============================================
// COLOR THEME DEFINITIONS
// ============================================
[theme_bg, theme_primary, theme_accent1, theme_accent2, theme_text] = switch visual_theme
    "Quantum Nebula" => [color.new(#0a0a0f, 95), color.new(#6b46c1, 0), color.new(#9333ea, 0), color.new(#c084fc, 0), color.new(#e9d5ff, 0)]
    "Ethereal Prism" => [color.new(#0f0a0f, 95), color.new(#f97316, 0), color.new(#eab308, 0), color.new(#10b981, 0), color.new(#fef3c7, 0)]
    "Dark Matter" => [color.new(#000000, 95), color.new(#ffffff, 0), color.new(#888888, 0), color.new(#444444, 0), color.new(#ffffff, 0)]
    "Cosmic Aurora" => [color.new(#001a1a, 95), color.new(#00ffcc, 0), color.new(#ff00ff, 0), color.new(#00ff00, 0), color.new(#e0ffff, 0)]
    "Void Resonance" => [color.new(#050505, 95), color.new(#ff00ff, 0), color.new(#00ffff, 0), color.new(#ffff00, 0), color.new(#ffffff, 0)]
    "Temporal Flux" => [color.new(#0a0a1a, 95), color.new(#4169e1, 0), color.new(#ff1493, 0), color.new(#00ced1, 0), color.new(#e6e6fa, 0)]
    "Astral Projection" => [color.new(#0d0d1a, 95), color.new(#9370db, 0), color.new(#ff69b4, 0), color.new(#87ceeb, 0), color.new(#f0e6ff, 0)]
    => [color.new(#0a0a0f, 95), color.new(#6b46c1, 0), color.new(#9333ea, 0), color.new(#c084fc, 0), color.new(#e9d5ff, 0)]
//==============================================================================
// ENHANCED DASHBOARD WITH PROFESSIONAL STYLING
//==============================================================================
var table dashboard = na
if show_dashboard and barstate.isconfirmed
    // Dashboard positioning and sizing
    dashboard_pos = dashboard_position_input == "Top Left" ? position.top_left : dashboard_position_input == "Top Right" ? position.top_right : dashboard_position_input == "Bottom Left" ? position.bottom_left : position.bottom_right
    cols = dashboard_size == "Large" ? 5 : 4
    rows = dashboard_size == "Large" ? 25 : dashboard_size == "Normal" ? 20 : 14
    // Clean up existing dashboard
    if not na(dashboard)
        table.delete(dashboard)
    // Create new dashboard
    dashboard := table.new(dashboard_pos, cols, rows, border_width = 1, border_color = color.new(holonomy_accent, 50), bgcolor = color.new(#1e222d, 20))
    // Color scheme
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_purple = holonomy_primary
    dc_aqua = holonomy_accent
    dc_orange = #FF8C00
    dc_cyan = #00FFFF
    bg_header = color.new(color.black, 30)
    bg_section = color.new(color.gray, 85)
    // Text sizing
    header_size = dashboard_size == "Large" ? size.normal : size.small
    value_size = dashboard_size == "Large" ? size.normal : size.small
    label_size = dashboard_size == "Large" ? size.small : size.tiny
    current_row = 0
    // ═══ MAIN HEADER ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "🌌 Anomalous Holonomy Field Theory | " + syminfo.ticker, text_halign=text.align_center, text_color=dc_white, bgcolor=bg_header, text_size=header_size)
    current_row += 1
    // ═══ HOLONOMY FIELD SECTION ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ ⚡ HOLONOMY FIELD STATUS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    // Field Strength
    table.cell(dashboard, 0, current_row, "Field Strength", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    field_color = math.abs(signal_strength_confirmed) > signal_threshold ? (signal_strength_confirmed > 0 ? dc_green : dc_red) : dc_gray
    field_emoji = math.abs(signal_strength_confirmed) > signal_threshold * 1.5 ? "⚡" : math.abs(signal_strength_confirmed) > signal_threshold ? "●" : "○"
    table.cell(dashboard, 1, current_row, field_emoji + " " + str.tostring(signal_strength_confirmed, "#.##"), text_halign=text.align_right, text_color=field_color, text_size=value_size)
    current_row += 1
    // Signal Quality
    table.cell(dashboard, 0, current_row, "Quality", text_color=dc_gray, text_size=label_size)
    table.merge_cells(dashboard, 1, current_row, cols - 1, current_row)
    quality_emoji = signal_quality_rating == "ELITE" ? "🌟" : signal_quality_rating == "STRONG" ? "💪" : signal_quality_rating == "GOOD" ? "👍" : "⚠️"
    quality_color = signal_quality_rating == "ELITE" ? dc_gold : signal_quality_rating == "STRONG" ? dc_green : signal_quality_rating == "GOOD" ? dc_aqua : dc_gray
    table.cell(dashboard, 1, current_row, quality_emoji + " " + signal_quality_rating, text_halign=text.align_right, text_color=quality_color, text_size=value_size)
    current_row += 1
    // Threshold and Anomaly Level
    if dashboard_size != "Small"
        table.cell(dashboard, 0, current_row, "Threshold", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(signal_threshold, "#.##"), text_halign=text.align_right, text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Anomaly", text_color=dc_gray, text_size=label_size)
        anomaly_color = anomaly_level > 70 ? dc_red : anomaly_level > 30 ? dc_orange : dc_green
        table.cell(dashboard, 3, current_row, str.tostring(anomaly_level, "#") + "%", text_halign=text.align_right, text_color=anomaly_color, text_size=label_size)
        current_row += 1
    // ═══ QUANTUM STATE ANALYSIS ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ 🔮 QUANTUM STATE ANALYSIS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    // Quantum State with visual gauge
    quantum_gauge = quantum_state == 1 ? "🟢🟢🟢⚪⚪" : quantum_state == -1 ? "⚪⚪🔴🔴🔴" : "⚪⚪🟡⚪⚪"
    table.cell(dashboard, 0, current_row, "Quantum State", text_color=dc_gray, text_size=label_size)
    state_color = quantum_state == 1 ? dc_green : quantum_state == -1 ? dc_red : dc_orange
    state_text = quantum_state == 1 ? "↑ BULL" : quantum_state == -1 ? "↓ BEAR" : "◈ SUPER"
    table.cell(dashboard, 1, current_row, state_text, text_halign=text.align_right, text_color=state_color, text_size=value_size)
    if dashboard_size == "Large"
        table.cell(dashboard, 2, current_row, "State", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, quantum_gauge, text_halign=text.align_right, text_color=state_color, text_size=label_size)
    else
        table.merge_cells(dashboard, 2, current_row, cols - 1, current_row)
        table.cell(dashboard, 2, current_row, quantum_gauge, text_halign=text.align_right, text_color=state_color, text_size=label_size)
    current_row += 1
    // Trend Direction and Phase
    table.cell(dashboard, 0, current_row, "Trend", text_color=dc_gray, text_size=label_size)
    trend_text = trend_direction > 0 ? "📈 BULL" : trend_direction < 0 ? "📉 BEAR" : "➡️ NEUTRAL"
    trend_color = trend_direction > 0 ? dc_green : trend_direction < 0 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, trend_text, text_color=trend_color, text_size=label_size)
    table.cell(dashboard, 2, current_row, "Phase", text_color=dc_gray, text_size=label_size)
    phase_text = flow_strength > 2 ? "🌪️ CHAOS" : flow_strength > 1 ? "⚡ ACTIVE" : "😴 CALM"
    phase_color = flow_strength > 2 ? dc_red : flow_strength > 1 ? dc_gold : dc_gray
    table.cell(dashboard, 3, current_row, phase_text, text_color=phase_color, text_size=label_size)
    current_row += 1
    // ═══ TRADING SIGNALS ═══
    table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
    table.cell(dashboard, 0, current_row, "═══ 🎯 TRADING SIGNALS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
    current_row += 1
    // Long and Short Signals
    long_active = signal_strength_confirmed >= signal_threshold and can_trade
    short_active = signal_strength_confirmed <= -signal_threshold and can_trade
    table.cell(dashboard, 0, current_row, "Long Signal", text_color=dc_gray, text_size=label_size)
    long_text = long_active ? "🟢 ACTIVE" : "⚪ INACTIVE"
    table.cell(dashboard, 1, current_row, long_text, text_color=long_active ? dc_green : dc_gray, text_size=label_size)
    table.cell(dashboard, 2, current_row, "Short Signal", text_color=dc_gray, text_size=label_size)
    short_text = short_active ? "🔴 ACTIVE" : "⚪ INACTIVE"
    table.cell(dashboard, 3, current_row, short_text, text_color=short_active ? dc_red : dc_gray, text_size=label_size)
    current_row += 1
    // Current Position Status
    table.cell(dashboard, 0, current_row, "Position", text_color=dc_gray, text_size=label_size)
    position_text = strategy.position_size > 0 ? "🟢 LONG" : strategy.position_size < 0 ? "🔴 SHORT" : "⚪ NONE"
    position_color = strategy.position_size > 0 ? dc_green : strategy.position_size < 0 ? dc_red : dc_gray
    table.cell(dashboard, 1, current_row, position_text, text_color=position_color, text_size=value_size)
    // Trade Count and Risk
    table.cell(dashboard, 2, current_row, "Daily Trades", text_color=dc_gray, text_size=label_size)
    trade_color = daily_trades > MAX_DAILY_TRADES * 0.8 ? dc_red : daily_trades > MAX_DAILY_TRADES * 0.5 ? dc_orange : dc_green
    table.cell(dashboard, 3, current_row, str.tostring(daily_trades) + "/" + str.tostring(int(max_trades_adjusted)), text_color=trade_color, text_size=label_size)
    current_row += 1
    // ═══ PERFORMANCE METRICS ═══ (Normal and Large only)
    if dashboard_size != "Small"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ 🏆 PERFORMANCE METRICS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        // Win Rate and P&L
        win_rate_display = win_rate * 100
        win_rate_color = win_rate >= 0.6 ? dc_green : win_rate >= 0.45 ? dc_orange : dc_red
        win_rate_emoji = win_rate >= 0.6 ? "🔥" : win_rate >= 0.45 ? "👍" : "⚠️"
        table.cell(dashboard, 0, current_row, "Win Rate", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, win_rate_emoji + str.tostring(win_rate_display, "#.#") + "%", text_halign=text.align_right, text_color=win_rate_color, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Daily P&L", text_color=dc_gray, text_size=label_size)
        pnl_emoji = daily_pnl > 0 ? "💚" : daily_pnl < 0 ? "🔴" : "⚪"
        table.cell(dashboard, 3, current_row, pnl_emoji + str.tostring(daily_pnl, "#.##"), text_halign=text.align_right, text_color=daily_pnl > 0 ? dc_green : daily_pnl < 0 ? dc_red : dc_gray, text_size=label_size)
        current_row += 1
        // Adaptive Risk and Learning
        if ENABLE_LEARNING
            table.cell(dashboard, 0, current_row, "Adapt Risk", text_color=dc_gray, text_size=label_size)
            risk_text = adaptive_risk_multiplier > 1.2 ? "🚀 HIGH" : adaptive_risk_multiplier > 0.8 ? "📊 NORM" : "🛡️ LOW"
            risk_color = adaptive_risk_multiplier > 1.2 ? dc_red : adaptive_risk_multiplier > 0.8 ? dc_aqua : dc_green
            table.cell(dashboard, 1, current_row, risk_text, text_color=risk_color, text_size=label_size)
            table.cell(dashboard, 2, current_row, "Learning", text_color=dc_gray, text_size=label_size)
            table.cell(dashboard, 3, current_row, "✅ ACTIVE", text_color=dc_purple, text_size=label_size)
            current_row += 1
    // ═══ MARKET STRUCTURE ═══ (Large only)
    if dashboard_size == "Large"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ 🌌 MARKET STRUCTURE ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        // Volatility and Execution Mode
        vol_text = high_vol ? "🔥 HIGH" : low_vol ? "😴 LOW" : "📊 NORMAL"
        vol_color = high_vol ? dc_red : low_vol ? dc_green : dc_aqua
        table.cell(dashboard, 0, current_row, "Volatility", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, vol_text, text_color=vol_color, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Mode", text_color=dc_gray, text_size=label_size)
        mode_color = EXECUTION_MODE == "Aggressive" ? dc_red : EXECUTION_MODE == "Conservative" ? dc_green : dc_aqua
        table.cell(dashboard, 3, current_row, EXECUTION_MODE, text_color=mode_color, text_size=label_size)
        current_row += 1
        // Session and Market Regime
        session_text = trade_allowed ? "🟢 OPEN" : "🔴 CLOSED"
        session_color = trade_allowed ? dc_green : dc_red
        table.cell(dashboard, 0, current_row, "Session", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, session_text, text_color=session_color, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Regime", text_color=dc_gray, text_size=label_size)
        regime_text = market_regime_bullish ? "🐂 BULL" : "🐻 BEAR"
        regime_color = market_regime_bullish ? dc_green : dc_red
        table.cell(dashboard, 3, current_row, regime_text, text_color=regime_color, text_size=label_size)
        current_row += 1
    // ═══ SETTINGS SUMMARY ═══ (Large only)
    if dashboard_size == "Large"
        table.merge_cells(dashboard, 0, current_row, cols - 1, current_row)
        table.cell(dashboard, 0, current_row, "═══ ⚙️ ACTIVE SETTINGS ═══", text_halign=text.align_center, text_color=dc_gold, bgcolor=bg_section, text_size=label_size)
        current_row += 1
        // Key Settings
        table.cell(dashboard, 0, current_row, "Sensitivity", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, str.tostring(SIGNAL_SENSITIVITY, "#.#"), text_color=dc_cyan, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Base Risk", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, str.tostring(BASE_RISK * 100, "#.##") + "%", text_color=dc_cyan, text_size=label_size)
        current_row += 1
        table.cell(dashboard, 0, current_row, "Theme", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 1, current_row, visual_theme, text_color=dc_purple, text_size=label_size)
        table.cell(dashboard, 2, current_row, "Timezone", text_color=dc_gray, text_size=label_size)
        table.cell(dashboard, 3, current_row, session_timezone, text_color=dc_cyan, text_size=label_size)
        current_row += 1
// ========================================
// ADAPTATION LEARNING DASHBOARD
// ========================================
var table learning_dashboard = na
if show_learning_dashboard and barstate.isconfirmed
    if not na(learning_dashboard)
        table.delete(learning_dashboard)
    // 3 COLUMNS:
    learning_dashboard := table.new(position.bottom_left, 12, 7, border_width = 1, border_color = color.new(holonomy_accent, 50), bgcolor = color.new(#1e222d, 20))
    // Colors
    dc_white = color.white
    dc_gray = #B2B5BE
    dc_green = #26A69A
    dc_red = #EF5350
    dc_gold = #FFD700
    dc_aqua = holonomy_accent
    bg_header = color.new(color.black, 30)
    text_size = size.tiny
    // ROW 0: Main Header
    table.merge_cells(learning_dashboard, 0, 0, 11, 0)
    status_text = reset_performance_data ? "🔄 Performance Reset Active" : ENABLE_LEARNING ? "═══ 🎓 Adaptation Learning Dashboard  ═══" : "🔴 Learning Disabled"
    status_color = reset_performance_data ? dc_red : ENABLE_LEARNING ? dc_gold : dc_red
    table.cell(learning_dashboard, 0, 0, status_text, text_halign=text.align_center, text_color=status_color, bgcolor=bg_header, text_size=text_size)
    // Calculate performance metrics
    actual_trades_analyzed = array.size(trade_performance)
    winning_trades_display = 0
    if actual_trades_analyzed > 0
        for i = 0 to actual_trades_analyzed - 1
            if array.get(trade_performance, i) > 0
                winning_trades_display += 1
    current_win_rate_display = actual_trades_analyzed > 0 ? winning_trades_display / actual_trades_analyzed : 0
    // ROW 1: Signal Configuration (Column 1)
    table.cell(learning_dashboard, 0, 1, "SIGNAL_SENSITIVITY", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 1, 1, str.tostring(SIGNAL_SENSITIVITY, "#.#"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 2, 1, "→", text_color=dc_gold, text_size=text_size)
    sensitivity_color = learned_signal_sensitivity != SIGNAL_SENSITIVITY ? dc_green : dc_gray
    table.cell(learning_dashboard, 3, 1, str.tostring(learned_signal_sensitivity, "#.#"), text_color=sensitivity_color, text_size=text_size)
    // SCORE_AMPLIFIER (Column 2)
    table.cell(learning_dashboard, 4, 1, "SCORE_AMPLIFIER", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 5, 1, str.tostring(SCORE_AMPLIFIER, "#.#"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 6, 1, "→", text_color=dc_gold, text_size=text_size)
    amplifier_color = learned_score_amplifier != SCORE_AMPLIFIER ? dc_green : dc_gray
    table.cell(learning_dashboard, 7, 1, str.tostring(learned_score_amplifier, "#.#"), text_color=amplifier_color, text_size=text_size)
    // MIN_SIGNAL_SEP (Column 3)
    table.cell(learning_dashboard, 8, 1, "MIN_SIGNAL_SEP", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 9, 1, str.tostring(MIN_SIGNAL_SEPARATION), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 10, 1, "→", text_color=dc_gold, text_size=text_size)
    separation_color = learned_min_signal_separation != MIN_SIGNAL_SEPARATION ? dc_green : dc_gray
    table.cell(learning_dashboard, 11, 1, str.tostring(learned_min_signal_separation), text_color=separation_color, text_size=text_size)
    // ROW 2: Execution & Risk
    table.cell(learning_dashboard, 0, 2, "EXECUTION_MODE", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 1, 2, EXECUTION_MODE, text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 2, 2, "→", text_color=dc_gold, text_size=text_size)
    mode_color = learned_execution_mode != EXECUTION_MODE ? dc_green : dc_gray
    table.cell(learning_dashboard, 3, 2, learned_execution_mode, text_color=mode_color, text_size=text_size)
    table.cell(learning_dashboard, 4, 2, "BASE_RISK", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 5, 2, str.tostring(BASE_RISK, "#.###"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 6, 2, "→", text_color=dc_gold, text_size=text_size)
    risk_color = learned_base_risk != BASE_RISK ? dc_green : dc_gray
    table.cell(learning_dashboard, 7, 2, str.tostring(learned_base_risk, "#.###"), text_color=risk_color, text_size=text_size)
    table.cell(learning_dashboard, 8, 2, "MAX_DAILY_TRADES", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 9, 2, str.tostring(MAX_DAILY_TRADES), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 10, 2, "→", text_color=dc_gold, text_size=text_size)
    trades_color = learned_max_daily_trades != MAX_DAILY_TRADES ? dc_green : dc_gray
    table.cell(learning_dashboard, 11, 2, str.tostring(learned_max_daily_trades), text_color=trades_color, text_size=text_size)
    // ROW 3: Session & Advanced
    table.cell(learning_dashboard, 0, 3, "session_start", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 1, 3, str.tostring(session_start), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 2, 3, "→", text_color=dc_gold, text_size=text_size)
    start_color = learned_session_start != session_start ? dc_green : dc_gray
    table.cell(learning_dashboard, 3, 3, str.tostring(learned_session_start), text_color=start_color, text_size=text_size)
    table.cell(learning_dashboard, 4, 3, "session_end", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 5, 3, str.tostring(session_end), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 6, 3, "→", text_color=dc_gold, text_size=text_size)
    end_color = learned_session_end != session_end ? dc_green : dc_gray
    table.cell(learning_dashboard, 7, 3, str.tostring(learned_session_end), text_color=end_color, text_size=text_size)
    table.cell(learning_dashboard, 8, 3, "LEARNING_SPEED", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 9, 3, str.tostring(LEARNING_SPEED, "#.##"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 10, 3, "→", text_color=dc_gold, text_size=text_size)
    speed_color = learned_learning_speed != LEARNING_SPEED ? dc_green : dc_gray
    table.cell(learning_dashboard, 11, 3, str.tostring(learned_learning_speed, "#.##"), text_color=speed_color, text_size=text_size)
    // ROW 4: Advanced Configuration
    table.cell(learning_dashboard, 0, 4, "PERF_TRACKING", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 1, 4, str.tostring(PERFORMANCE_TRACKING), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 2, 4, "→", text_color=dc_gold, text_size=text_size)
    tracking_color = learned_performance_tracking != PERFORMANCE_TRACKING ? dc_green : dc_gray
    table.cell(learning_dashboard, 3, 4, str.tostring(learned_performance_tracking), text_color=tracking_color, text_size=text_size)
    table.cell(learning_dashboard, 4, 4, "anomaly_threshold", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 5, 4, str.tostring(anomaly_threshold, "#.#"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 6, 4, "→", text_color=dc_gold, text_size=text_size)
    anomaly_color = learned_anomaly_threshold != anomaly_threshold ? dc_green : dc_gray
    table.cell(learning_dashboard, 7, 4, str.tostring(learned_anomaly_threshold, "#.#"), text_color=anomaly_color, text_size=text_size)
    table.cell(learning_dashboard, 8, 4, "portal_threshold", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 9, 4, str.tostring(portal_threshold, "#.#"), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 10, 4, "→", text_color=dc_gold, text_size=text_size)
    portal_color = learned_portal_threshold != portal_threshold ? dc_green : dc_gray
    table.cell(learning_dashboard, 11, 4, str.tostring(learned_portal_threshold, "#.#"), text_color=portal_color, text_size=text_size)
    // ROW 5: Performance Metrics
    table.cell(learning_dashboard, 0, 5, "Win Rate", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 1, 5, str.tostring(current_win_rate_display * 100, "#.#") + "%", text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 2, 5, "Analyzed", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 3, 5, str.tostring(actual_trades_analyzed), text_color=dc_white, text_size=text_size)
    table.cell(learning_dashboard, 4, 5, "Losses", text_color=dc_gold, text_size=text_size)
    loss_color = consecutive_losses > 3 ? dc_red : consecutive_losses > 1 ? #FF8C00 : dc_green
    table.cell(learning_dashboard, 5, 5, str.tostring(consecutive_losses), text_color=loss_color, text_size=text_size)
    table.cell(learning_dashboard, 6, 5, "Position", text_color=dc_gold, text_size=text_size)
    position_text = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "NONE"
    position_color = strategy.position_size > 0 ? dc_green : strategy.position_size < 0 ? dc_red : dc_gray
    table.cell(learning_dashboard, 7, 5, position_text, text_color=position_color, text_size=text_size)
    table.cell(learning_dashboard, 8, 5, "P&L", text_color=dc_gold, text_size=text_size)
    pnl_color = total_learning_pnl > 0 ? dc_green : total_learning_pnl < 0 ? dc_red : dc_gray
    pnl_display = total_learning_pnl == 0 ? "0" : str.tostring(total_learning_pnl, "#.##")
    table.cell(learning_dashboard, 9, 5, pnl_display, text_color=pnl_color, text_size=text_size)
    table.cell(learning_dashboard, 10, 5, "Updates", text_color=dc_gold, text_size=text_size)
    table.cell(learning_dashboard, 11, 5, str.tostring(learning_update_count), text_color=dc_white, text_size=text_size)
    // ROW 6: Learning Recommendations
    if reset_performance_data
        table.merge_cells(learning_dashboard, 0, 6, 11, 6)
        table.cell(learning_dashboard, 0, 6, "🔄 Performance Reset: P&L, win rate, trades reset. Learned parameters preserved. Toggle OFF to resume.", text_halign=text.align_center, text_color=dc_red, text_size=text_size)
    else if not ENABLE_LEARNING
        table.merge_cells(learning_dashboard, 0, 6, 11, 6)
        table.cell(learning_dashboard, 0, 6, "🔴 Learning Disabled: Enable 'Adaptive Learning' to see parameter optimizations.", text_halign=text.align_center, text_color=dc_red, text_size=text_size)
    else if array.size(trade_performance) < learning_min_trades
        table.merge_cells(learning_dashboard, 0, 6, 11, 6)
        trades_needed = learning_min_trades - array.size(trade_performance)
        table.cell(learning_dashboard, 0, 6, "⏳ Need " + str.tostring(trades_needed) + " more trades for learning. Green values = optimized parameters.", text_halign=text.align_center, text_color=#FF8C00, text_size=text_size)
    else
        recommendation_text = ""
        recommendation_color = dc_green
        if current_win_rate_display > 0.7
            recommendation_text := "🔥 System performing excellently (" + str.tostring(current_win_rate_display * 100, "#.#") + "% win rate) - consider aggressive mode"
            recommendation_color := dc_green
        else if current_win_rate_display > 0.6
            recommendation_text := "💪 Strong performance (" + str.tostring(current_win_rate_display * 100, "#.#") + "% win rate) - system working well"
            recommendation_color := dc_green
        else if current_win_rate_display < 0.4
            recommendation_text := "⚠️ Low win rate (" + str.tostring(current_win_rate_display * 100, "#.#") + "%) - consider conservative settings until performance improves"
            recommendation_color := dc_red
        else if current_win_rate_display < 0.5
            recommendation_text := "📊 Below average performance (" + str.tostring(current_win_rate_display * 100, "#.#") + "%) - monitor and consider adjustments"
            recommendation_color := #FF8C00
        else
            significant_changes = 0
            change_details = ""

            if math.abs(learned_signal_sensitivity - SIGNAL_SENSITIVITY) > 0.3
                significant_changes += 1
                if learned_signal_sensitivity > SIGNAL_SENSITIVITY
                    change_details += "🔼 Increase sensitivity, "
                else
                    change_details += "🔽 Decrease sensitivity, "
            if math.abs(learned_base_risk - BASE_RISK) > 0.002
                significant_changes += 1
                if learned_base_risk < BASE_RISK
                    change_details += "🛡️ Reduce risk, "
                else
                    change_details += "🚀 Increase risk, "
            if learned_execution_mode != EXECUTION_MODE
                significant_changes += 1
                change_details += "⚙️ Switch to " + learned_execution_mode + " mode, "
            if math.abs(learned_session_start - session_start) > 1 or math.abs(learned_session_end - session_end) > 1
                significant_changes += 1
                change_details += "⏰ Optimize session timing, "
            if significant_changes > 0
                if str.length(change_details) > 2
                    change_details := str.substring(change_details, 0, str.length(change_details) - 2)
                recommendation_text := "📈 Suggested optimizations: " + change_details
                recommendation_color := dc_aqua
            else
                recommendation_text := "✅ Current settings appear optimal - green values show fine-tuned parameters"
                recommendation_color := dc_green
        table.merge_cells(learning_dashboard, 0, 6, 11, 6)
        table.cell(learning_dashboard, 0, 6, recommendation_text, text_halign=text.align_center, text_color=recommendation_color, text_size=text_size)
// ========================================
// ANIMATED WATERMARK
// ========================================
var table watermark = table.new(position.bottom_center, 3, 1, bgcolor=color.new(color.black, 100), border_width=0)
var int anim_frame = 0
var float pulse_alpha = 90
if barstate.isconfirmed
    anim_frame += 1
    pulse_alpha := 80 + math.sin(anim_frame * 0.1) * 15
    wm_color = signal_strength_confirmed > signal_threshold ? color.new(quantum_positive, int(pulse_alpha)) : signal_strength_confirmed < -signal_threshold ? color.new(quantum_negative, int(pulse_alpha)) : color.new(holonomy_accent, int(pulse_alpha))
    left_symbol = anim_frame % 30 < 15 ? "⟨" : "《"
    right_symbol = anim_frame % 30 < 15 ? "⟩" : "》"
    center_symbol = anim_frame % 20 < 10 ? "◈" : "◆"
    table.cell(watermark, 0, 0, left_symbol, text_color=wm_color, text_size=size.normal)
    table.cell(watermark, 1, 0, center_symbol + " AHFT | Holonomy Field Theory " + center_symbol, text_color=wm_color, text_size=dashboard_size == "Large" ? size.normal : size.small)
    table.cell(watermark, 2, 0, right_symbol, text_color=wm_color, text_size=size.normal)
// ========================================
// SIGNAL PLOTS
// ========================================
plot(signal_strength_confirmed, "Holonomy Field Strength", color=signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, linewidth=3)
plot(signal_strength_confirmed, "Field Glow 1", color=color.new(signal_strength_confirmed > 0 ? quantum_positive : quantum_negative, 50), linewidth=5, display=display.none)
plot(signal_threshold, "Upper Anomaly Threshold", color=color.new(holonomy_accent, 50), linewidth=2, style=plot.style_line)
plot(-signal_threshold, "Lower Anomaly Threshold", color=color.new(holonomy_accent, 50), linewidth=2, style=plot.style_line)
hline(0, "Equilibrium", color=color.new(#B8B8B8, 80), linestyle=hline.style_dotted)
plotshape(strong_long and can_trade, style=shape.triangleup, location=location.belowbar, color=quantum_positive, size=size.small, title="Quantum Entry")
plotshape(strong_short and can_trade, style=shape.triangledown, location=location.abovebar, color=quantum_negative, size=size.small, title="Anomaly Entry")
// ============================================
// ADAPTIVE DATA EXPORTS
// ============================================
plot(SIGNAL_SENSITIVITY, "AdaptiveSensitivity", display=display.data_window)
plot(adaptive_risk_multiplier, "AdaptiveRisk", display=display.data_window)
plot(signal_threshold, "AdaptiveThreshold", display=display.data_window)
plot(field_strength, "AdaptiveFieldStrength", display=display.data_window)
plot(win_rate * 100, "AdaptiveWinRate", display=display.data_window)
plot(current_position_size, "AdaptivePositionSize", display=display.data_window)
plot(daily_trades, "AdaptiveDailyTrades", display=display.data_window)
plot(max_trades_adjusted, "AdaptiveMaxTrades", display=display.data_window)
plot(volatility_regime, "AdaptiveVolatility", display=display.data_window)
plot(trade_allowed ? 1 : 0, "AdaptiveSessionActive", display=display.data_window)
plot(EXECUTION_MODE == "Aggressive" ? 2 : EXECUTION_MODE == "Conservative" ? 0 : 1, "AdaptiveMode", display=display.data_window)
plot(ENABLE_LEARNING ? 1 : 0, "AdaptiveLearning", display=display.data_window)