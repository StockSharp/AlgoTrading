//@version=6
strategy("RSI Divergence Strategy - AliferCrypto", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// === RSI Settings ===

// Number of periods for RSI calculation
rsiLength      = input.int(14, minval=1, title="RSI Length", group="RSI Settings", tooltip="Number of periods for RSI calculation")
// Price source used for RSI calculation
rsiSource      = input.source(close, title="RSI Source", group="RSI Settings", tooltip="Price source used for RSI calculation")

// === Divergence Settings ===

// Bars to the left for pivot detection
lookLeft       = input.int(5, minval=1, title="Pivot Lookback Left", group="Divergence Settings", tooltip="Bars to the left for pivot detection")
// Bars to the right for pivot detection
lookRight      = input.int(5, minval=1, title="Pivot Lookback Right", group="Divergence Settings", tooltip="Bars to the right for pivot detection")
// Minimum bars between pivots to validate divergence
rangeLower     = input.int(5, minval=1, title="Min Bars Between Pivots", group="Divergence Settings", tooltip="Minimum bars between pivots to validate divergence")
// Maximum bars between pivots to validate divergence
rangeUpper     = input.int(60, minval=1, title="Max Bars Between Pivots", group="Divergence Settings", tooltip="Maximum bars between pivots to validate divergence")

// === Filter Settings ===

// Enable RSI zone filter (bull after oversold, bear after overbought)
enableRSIFilter  = input.bool(false, title="Enable RSI Zone Filter", group="Filter Settings", tooltip="Only allow bullish after RSI < oversold, bearish after RSI > overbought")
// Level to arm bullish divergences
oversoldLevel    = input.int(30, minval=1, maxval=49, title="RSI Oversold Level", group="Filter Settings", tooltip="Level to arm bullish divergences")
// Level to arm bearish divergences
overboughtLevel  = input.int(70, minval=51, maxval=99, title="RSI Overbought Level", group="Filter Settings", tooltip="Level to arm bearish divergences")
// Enable trend filter (only long above MA, short below MA)
enableTrendFilter = input.bool(false, title="Enable Trend Filter", group="Filter Settings", tooltip="Only take longs when price > MA, shorts when price < MA")
// Timeframe for trend MA (blank = current)
maTimeframe      = input.timeframe("", title="MA Timeframe", group="Filter Settings", tooltip="Timeframe for trend MA (blank = current)")
// Type of moving average for trend filter
maType           = input.string("SMA", options=["SMA","EMA","SMMA (RMA)","WMA","VWMA"], title="MA Type", group="Filter Settings", tooltip="Type of moving average for trend filter")
// Periods for moving average trend filter
maLength         = input.int(200, minval=1, title="MA Length", group="Filter Settings", tooltip="Periods for moving average trend filter")
// Price source for trend MA
maSource         = input.source(close, title="MA Source", group="Filter Settings", tooltip="Price source for trend MA")
// Color for plotted trend MA
maColor          = input.color(color.yellow, title="MA Color", group="Filter Settings", tooltip="Color for plotted trend MA")

// === SL/TP Method ===
// Choose between swing-based or ATR-based stop and target
method      = input.string("Swing", options=["Swing","ATR"], title="SL/TP Method", group="SL/TP Settings", tooltip="Choose between swing-based or ATR-based stop and target")
// **New**: Dynamic vs. Static exit levels
exitMode    = input.string("Dynamic",
                           options=["Dynamic","Static"],
                           title="Exit Levels Mode",
                           group="SL/TP Settings",
                           tooltip="Dynamic updates SL/TP each bar; Static locks levels at entry")

// === Swing Settings ===

// Bars to look back for swing high/low
swingLook      = input.int(20, minval=1, title="Swing Lookback (bars)", group="Swing Settings", tooltip="Bars to look back for swing high/low")
// Margin around swing levels as percentage of price
swingMarginPct = input.float(1.0, minval=0.0, title="Swing Margin (%)", group="Swing Settings", tooltip="Margin around swing levels as percentage of price")
// Risk/reward ratio when using swing-based method
rrSwing        = input.float(2.0, title="R/R Ratio (Swing)", group="Swing Settings", tooltip="Risk/reward ratio when using swing-based method")

// === ATR Settings ===

// Number of periods for ATR calculation
atrLen         = input.int(14, minval=1, title="ATR Length", group="ATR Settings", tooltip="Number of periods for ATR calculation")
// Multiplier for ATR-based stop loss calculation
atrMult        = input.float(1.5, minval=0.1, title="ATR SL Multiplier", group="ATR Settings", tooltip="Multiplier for ATR-based stop loss calculation")
// Risk/reward ratio when using ATR-based method
rrAtr          = input.float(2.0, title="R/R Ratio (ATR)", group="ATR Settings", tooltip="Risk/reward ratio when using ATR-based method")

// === RSI Calculation ===

_d    = ta.change(rsiSource)
up    = ta.rma(math.max(_d, 0), rsiLength)
down  = ta.rma(-math.min(_d, 0), rsiLength)
rsi   = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))

// === Divergence Detection ===

defPl      = not na(ta.pivotlow(rsi, lookLeft, lookRight))
defPh      = not na(ta.pivothigh(rsi, lookLeft, lookRight))
rsiAtRR   = rsi[lookRight]
barsPl    = ta.barssince(defPl)
barsPl1   = barsPl[1]
inRangePL = barsPl1 >= rangeLower and barsPl1 <= rangeUpper
barsPh    = ta.barssince(defPh)
barsPh1   = barsPh[1]
inRangePH = barsPh1 >= rangeLower and barsPh1 <= rangeUpper
prevPlRsi   = ta.valuewhen(defPl, rsiAtRR, 1)
prevPhRsi   = ta.valuewhen(defPh, rsiAtRR, 1)
prevPlPrice = ta.valuewhen(defPl, low[lookRight], 1)
prevPhPrice = ta.valuewhen(defPh, high[lookRight], 1)
rawBull    = defPl and low[lookRight] < prevPlPrice and rsiAtRR > prevPlRsi and inRangePL
rawBear    = defPh and high[lookRight] > prevPhPrice and rsiAtRR < prevPhRsi and inRangePH

// === RSI Zone Flags ===

var bool rsiOversoldFlag   = false
var bool rsiOverboughtFlag = false
rsiOversoldFlag   := rsiOversoldFlag or (rsi < oversoldLevel)
rsiOverboughtFlag := rsiOverboughtFlag or (rsi > overboughtLevel)

// === Moving Average Function ===

ma(source, length, type) =>
    if type == "SMA"
        ta.sma(source, length)
    else if type == "EMA"
        ta.ema(source, length)
    else if type == "SMMA (RMA)"
        ta.rma(source, length)
    else if type == "WMA"
        ta.wma(source, length)
    else if type == "VWMA"
        ta.vwma(source, length)
    else
        na
trendMAraw = ma(maSource, maLength, maType)
trendMA    = request.security(syminfo.tickerid, maTimeframe, trendMAraw, gaps=barmerge.gaps_on)

// Plot Trend MA
plot(enableTrendFilter ? trendMA : na, title="Trend MA", color=maColor)

// === Final Conditions ===

bullCond = rawBull and (not enableRSIFilter or rsiOversoldFlag) and (not enableTrendFilter or close > trendMA)
bearCond = rawBear and (not enableRSIFilter or rsiOverboughtFlag) and (not enableTrendFilter or close < trendMA)

// === Entries ===

if bullCond
    strategy.entry("Long", strategy.long)
    rsiOversoldFlag := false
if bearCond
    strategy.entry("Short", strategy.short)
    rsiOverboughtFlag := false

// === Pre-calculate SL/TP components ===

swingLow  = ta.lowest(low, swingLook)
swingHigh = ta.highest(high, swingLook)
atrValue  = ta.atr(atrLen)

// === SL/TP Calculation & Exits ===
// **New**: storage for “locked” exit levels (Static mode)
var float entrySL = na
var float entryTP = na

var float slPrice = na
var float tpPrice = na
var float rr      = na

// Long exits
if strategy.position_size > 0
    // 1) Grab entry price
    entryPrice = strategy.position_avg_price

    // 2) Compute “base” SL/TP
    float slCalc = na
    float tpCalc = na
    // SL calculation
    if method == "Swing"
        slCalc := swingLow * (1 - swingMarginPct/100)
        rr     := rrSwing
    else
        slCalc := entryPrice - atrValue * atrMult
        rr     := rrAtr
    // TP calculation
    risk   = entryPrice - slCalc
    tpCalc := entryPrice + risk * rr

    // 3) Capture static levels on the bar we entered
    if exitMode == "Static" and strategy.position_size[1] <= 0
        entrySL := slCalc
        entryTP := tpCalc

    // 4) Select dynamic vs. static
    if exitMode == "Dynamic"
        slPrice := slCalc
        tpPrice := tpCalc
    else
        slPrice := entrySL
        tpPrice := entryTP

    // 5) Fire the exit
    strategy.exit("Exit Long", from_entry="Long", stop=slPrice, limit=tpPrice)


// Short exits
if strategy.position_size < 0
    // 1) Grab entry price
    entryPrice = strategy.position_avg_price

    // 2) Compute “base” SL/TP
    float slCalc = na
    float tpCalc = na
    // SL calculation
    if method == "Swing"
        slCalc := swingHigh * (1 + swingMarginPct/100)
        rr     := rrSwing
    else
        slCalc := entryPrice + atrValue * atrMult
        rr     := rrAtr
    // TP calculation
    risk   = slCalc - entryPrice
    tpCalc := entryPrice - risk * rr

    // 3) Capture static levels on the bar we entered
    if exitMode == "Static" and strategy.position_size[1] >= 0
        entrySL := slCalc
        entryTP := tpCalc

    // 4) Select dynamic vs. static
    if exitMode == "Dynamic"
        slPrice := slCalc
        tpPrice := tpCalc
    else
        slPrice := entrySL
        tpPrice := entryTP

    // 5) Fire the exit
    strategy.exit("Exit Short", from_entry="Short", stop=slPrice, limit=tpPrice)

// === Plot SL/TP Levels ===

plot(strategy.position_size != 0 ? slPrice : na, title="Stop Loss", style=plot.style_linebr, color=color.red)
plot(strategy.position_size != 0 ? tpPrice : na, title="Take Profit", style=plot.style_linebr, color=color.green)

// === Alerts ===

alertcondition(bullCond, title="Bull RSI Divergence", message="Bullish RSI divergence detected")
alertcondition(bearCond, title="Bear RSI Divergence", message="Bearish RSI divergence detected")