// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © wanghuacrow
//@version=5
strategy("Hierarchical + K-Means Clustering Strategy", "Hier+K-Means", overlay = true, max_labels_count = 500, calc_on_every_tick = true)
import TradingView/ta/6 as ta

// SuperTrend Settings
atr_len = input.int(11, "ATR Length", group = "SuperTrend Settings")
fact = input.float(3, "SuperTrend Factor", group = "SuperTrend Settings")

// Hierarchical Clustering Settings
training_data_period = input.int(200, "Training Data Length", group = "Hierarchical Clustering Settings")

// Appearance Settings
t1 = input.int(70, "Transparency 1", maxval = 100, minval = 0, group = "Appearance")
t2 = input.int(95, "Transparency 2", maxval = 100, minval = 0, group = "Appearance")
green = input.color(#00ffbb, "Bullish Color", group = "Appearance")
red = input.color(#ff1100, "Bearish Color", group = "Appearance")

// Custom SuperTrend Function
pine_supertrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    // Update upper and lower limits
    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int _direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        _direction := 1
    else if prevSuperTrend == prevUpperBand
        _direction := close > upperBand ? -1 : 1
    else
        _direction := close < lowerBand ? 1 : -1
    superTrend := _direction == -1 ? lowerBand : upperBand
    [superTrend, _direction]

// Calculate Volatility
volatility = ta.atr(atr_len)

// Calculate volatility upper and lower limits
upper = ta.highest(volatility, training_data_period)
lower = ta.lowest(volatility, training_data_period)

// Optimized hierarchical clustering algorithm to find cluster centers
hierarchical_clustering_optimized(volatility) =>
    // More precise cluster center calculation
    low_cluster = array.new_float(0)
    mid_cluster = array.new_float(0)
    high_cluster = array.new_float(0)

    // Classify data points into three clusters
    for i = 0 to training_data_period - 1
        vol = volatility[i]
        range_size = (upper - lower) / 3
        if vol < lower + range_size
            array.push(low_cluster, vol)
        else if vol < lower + 2 * range_size
            array.push(mid_cluster, vol)
        else
            array.push(high_cluster, vol)

    // Calculate center point for each cluster
    cluster_centers = array.new_float(size=3)
    array.set(cluster_centers, 0, array.size(low_cluster) > 0 ? array.avg(low_cluster) : lower)
    array.set(cluster_centers, 1, array.size(mid_cluster) > 0 ? array.avg(mid_cluster) : (upper + lower) / 2)
    array.set(cluster_centers, 2, array.size(high_cluster) > 0 ? array.avg(high_cluster) : upper)
    cluster_centers

cluster_centers = hierarchical_clustering_optimized(volatility)

// Optimized K-Means trend detection
kmeans_trend_detection_optimized(volatility, cluster_centers) =>
    // Distance calculation and cluster assignment
    current_vol = volatility
    dist_to_low = math.abs(current_vol - array.get(cluster_centers, 0))
    dist_to_mid = math.abs(current_vol - array.get(cluster_centers, 1))
    dist_to_high = math.abs(current_vol - array.get(cluster_centers, 2))

    // Determine which cluster the current volatility belongs to
    cluster_id = dist_to_low < dist_to_mid and dist_to_low < dist_to_high ? 0 :
                 dist_to_mid < dist_to_low and dist_to_mid < dist_to_high ? 1 : 2

    // Cluster trend direction determination (more complex logic)
    trend = cluster_id == 0 ? -1 :  // Low volatility typically corresponds to downtrend
           cluster_id == 2 ? 1 :    // High volatility typically corresponds to uptrend
           volatility > volatility[1] ? 1 : -1  // Medium volatility, look at volatility direction
    trend

trend_direction = kmeans_trend_detection_optimized(volatility, cluster_centers)

// Calculate SuperTrend
[ST, dir] = pine_supertrend(fact, volatility)

// Draw trend lines
upTrend = plot(close > ST ? ST : na, color = color.new(green, t1), style = plot.style_linebr)
downTrend = plot(close < ST ? ST : na, color = color.new(red, t1), style = plot.style_linebr, force_overlay = false)
bodyMiddle = plot(barstate.isfirst ? na : (open + close) / 2, "Body Middle", display = display.none)

// Fill area between trend lines
fill(bodyMiddle, upTrend, (open + close) / 2, ST, color.new(green, t2), color.new(green, t1))
fill(bodyMiddle, downTrend, ST, (open + close) / 2, color.new(red, t1), color.new(red, t2))

// Draw trend change markers
plotshape(ta.crossunder(dir, 0) ? ST : na, "Bullish Trend", shape.labelup, location.absolute, green, text = "▲H", textcolor = chart.fg_color, size = size.small)
plotshape(ta.crossover(dir, 0) ? ST : na, "Bearish Trend", shape.labeldown, location.absolute, red, text = "▼H", textcolor = chart.fg_color, size = size.small)


// Add start time settings
start_year = input.int(2020, "Start Year", minval=1970, maxval=2100, group="Time Settings")
start_month = input.int(1, "Start Month", minval=1, maxval=12, group="Time Settings")

// Check if after start time
is_after_start_time = year >= start_year and (year > start_year or month >= start_month)

// Add moving average filter
ma_length = input.int(50, "Moving Average Length", group = "Filter Settings")
ma_filter = input.bool(true, "Use Moving Average Filter", group = "Filter Settings")
ma_line = ta.sma(close, ma_length)
plot(ma_filter ? ma_line : na, "Moving Average", color = color.new(#fbc02d, 50), linewidth = 1)

// Add trend strength indicator
trend_strength = input.int(14, "Trend Strength Period", group = "Filter Settings")
trend_strength_threshold = input.int(20, "Trend Strength Threshold", group = "Filter Settings")
use_trend_strength = input.bool(true, "Use Trend Strength Filter", group = "Filter Settings")
[plus_di, minus_di, adx_value] = ta.dmi(trend_strength, trend_strength)
strong_trend = adx_value > trend_strength_threshold

// Update buy and sell conditions, combining volatility clustering and moving average filtering
// kmeans_trend = kmeans_trend_detection_optimized(volatility, cluster_centers)
ma_condition_long = not ma_filter or close > ma_line
ma_condition_short = not ma_filter or close < ma_line
trend_strength_condition = not use_trend_strength or strong_trend

longCondition = ta.crossunder(dir, 0) and is_after_start_time and ma_condition_long and trend_strength_condition
shortCondition = ta.crossover(dir, 0) and is_after_start_time and ma_condition_short and trend_strength_condition

// Add volume-based stop loss and take profit settings
volume_sl_enabled = input.bool(true, "Enable Volume Stop Loss/Take Profit", group="Volume Stop Loss Settings")
volume_ratio_threshold = input.float(0.9, "Volume Ratio Threshold", minval=0.5, maxval=2, step=0.1, group="Volume Stop Loss Settings",
     tooltip="Triggers stop loss/take profit when bull/bear volume ratio approaches this threshold (1.0 means perfect balance)")
delay_bars = input.int(4, "Monitoring Delay Bars", minval=1, maxval=20, group="Volume Stop Loss Settings")

// Track trade status
var int entry_bar = 0
var bool in_long_trade = false
var bool in_short_trade = false
var float entry_volume_ratio = 0.0

// Calculate bull/bear volume ratio
bull_volume = volume * (close > open ? 1 : 0)
bear_volume = volume * (close < open ? 1 : 0)
bull_volume_sum = ta.sma(bull_volume, 3) * 3  // Use SMA×period instead of sum
bear_volume_sum = ta.sma(bear_volume, 3) * 3  // Use SMA×period instead of sum
volume_ratio = bull_volume_sum / math.max(bear_volume_sum, 0.01)  // Prevent division by zero

// Volume-based stop loss/take profit conditions
long_volume_exit = in_long_trade and (bar_index - entry_bar >= delay_bars) and math.abs(volume_ratio - 1.0) <= (1.0 - volume_ratio_threshold) // Bull/bear power approaching balance

short_volume_exit = in_short_trade and (bar_index - entry_bar >= delay_bars) and math.abs(volume_ratio - 1.0) <= (1.0 - volume_ratio_threshold) // Bull/bear power approaching balance

// Modify entry and exit logic
if (longCondition)
    // if in_short_trade
    //     strategy.close("Sell", comment="Close short on long entry")
    //     in_short_trade := false
    strategy.entry("Buy", strategy.long)
    entry_bar := bar_index
    entry_volume_ratio := volume_ratio
    in_long_trade := true
    in_short_trade := false

if (shortCondition)
    // if in_long_trade
    //     strategy.close("Buy", comment="Close long on short entry")
    //     in_long_trade := false
    strategy.entry("Sell", strategy.short)
    entry_bar := bar_index
    entry_volume_ratio := volume_ratio
    in_long_trade := false
    in_short_trade := true

// Apply stop loss/take profit logic
if (in_long_trade or in_short_trade)
    // Traditional stop loss/take profit
    // strategy.exit("Traditional SL/TP", loss=risk_stop_ratio * ta.atr(atr_len), profit=risk_take_ratio * ta.atr(atr_len))

    // Volume-based stop loss/take profit
    if volume_sl_enabled
        if long_volume_exit
            strategy.close("Buy", comment="Volume Balance Exit")
            in_long_trade := false
        if short_volume_exit
            strategy.close("Sell", comment="Volume Balance Exit")
            in_short_trade := false