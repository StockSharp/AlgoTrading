//@version=6
strategy("Liquidity + Internal Market Shift Strategy", overlay=true)

// ======== Mode Selection ========
mode = input.string("Both", title="Mode", options=["Both", "Bullish Only", "Bearish Only"])

// ======== Time Range Selection ========
start_date = input.time(timestamp("2024-01-01 00:00 +0000"), title="Start Date and Time")
end_date = input.time(timestamp("2024-12-31 23:59 +0000"), title="End Date and Time")

// ======== Stop-Loss and Take-Profit Input (in pips) ========
enableTakeProfit = input.bool(true, title="Enable Custom Take Profit")  // Option to enable/disable take profit
stopLossPips = input.int(10, title="Stop Loss (in pips)", minval=1)  // Stop loss in pips
takeProfitPips = input.int(20, title="Take Profit (in pips)", minval=1)  // Take profit in pips

// ======== Internal Shift Logic ========

// Fixed number of consecutive candles to track (set to 1)
consecutiveBullishCount = 1
consecutiveBearishCount = 1

// Function to check for bullish and bearish candles
isBullish = close > open
isBearish = close < open

// Variables to track consecutive candles and mark lowest/highest
var int bullishCount = 0
var int bearishCount = 0
var float lowestBullishPrice = na
var float highestBearishPrice = na
var float previousBullishPrice = na // For the previous bullish lowest price
var float previousBearishPrice = na // For the previous bearish highest price

// Variables to track last internal shift type (1 = Bullish, -1 = Bearish, 0 = None)
var int lastInternalShift = 0

// Counting consecutive bullish and bearish candles
if isBullish
    bullishCount := bullishCount + 1
    bearishCount := 0
    if bullishCount == 1 or low < lowestBullishPrice
        lowestBullishPrice := low
else if isBearish
    bearishCount := bearishCount + 1
    bullishCount := 0
    if bearishCount == 1 or high > highestBearishPrice
        highestBearishPrice := high
else
    bullishCount := 0
    bearishCount := 0
    lowestBullishPrice := na
    highestBearishPrice := na

// Internal shift conditions
internalShiftBearish = close < previousBullishPrice and close < lowestBullishPrice
internalShiftBullish = close > previousBearishPrice and close > highestBearishPrice

// Condition to alternate internal shifts
allowInternalShiftBearish = internalShiftBearish and lastInternalShift != -1
allowInternalShiftBullish = internalShiftBullish and lastInternalShift != 1

// Tracking shifts
if bullishCount >= consecutiveBullishCount
    previousBullishPrice := lowestBullishPrice

if bearishCount >= consecutiveBearishCount
    previousBearishPrice := highestBearishPrice

// ======== Liquidity Seal-Off Points Logic ========
upperLiquidityLookback = input.int(10, title="Lookback Period for Upper Liquidity Line")
lowerLiquidityLookback = input.int(10, title="Lookback Period for Lower Liquidity Line")

isLocalHigh = high == ta.highest(high, upperLiquidityLookback)
isLocalLow = low == ta.lowest(low, lowerLiquidityLookback)

var bool touchedLowerLiquidityLine = false
var bool touchedUpperLiquidityLine = false

if (low <= ta.lowest(low, lowerLiquidityLookback))
    touchedLowerLiquidityLine := true

if (high >= ta.highest(high, upperLiquidityLookback))
    touchedUpperLiquidityLine := true

var bool lockedBullish = false
var bool lockedBearish = false
var int barSinceLiquidityTouch = na

// ======== Combined Signals ========
bullishSignal = allowInternalShiftBullish and touchedLowerLiquidityLine and not lockedBullish
bearishSignal = allowInternalShiftBearish and touchedUpperLiquidityLine and not lockedBearish

if bullishSignal
    lockedBullish := true
    touchedLowerLiquidityLine := false
    barSinceLiquidityTouch := 0

if bearishSignal
    lockedBearish := true
    touchedUpperLiquidityLine := false
    barSinceLiquidityTouch := 0

if not na(barSinceLiquidityTouch)
    barSinceLiquidityTouch := barSinceLiquidityTouch + 1

if barSinceLiquidityTouch >= 3
    lockedBullish := false
    lockedBearish := false

if touchedLowerLiquidityLine
    lockedBullish := false

if touchedUpperLiquidityLine
    lockedBearish := false

// ======== Plot Combined Signals ========
plotshape(bullishSignal, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny, title="Bullish Signal")
plotshape(bearishSignal, style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny, title="Bearish Signal")

plot(isLocalHigh ? high : na, color=color.red, linewidth=2, style=plot.style_stepline, title="Local High Line")
plot(isLocalLow ? low : na, color=color.green, linewidth=2, style=plot.style_stepline, title="Local Low Line")

// ======== Time Range Condition ========
inTimeRange = (time >= start_date) and (time <= end_date)

// ======== Track Entry and Opposing Signals ========
var float entryPrice = na
var int entryTime = na
var string positionSide = ""

// ======== Strategy Execution (Mode Logic) ========
if (mode == "Both")
    // Short Entry Logic (Bearish Signal)
    if (bearishSignal and inTimeRange and na(entryPrice))
        strategy.entry("Short", strategy.short)
        entryPrice := close
        entryTime := time
        positionSide := "short"

    // Long Entry Logic (Bullish Signal)
    if (bullishSignal and inTimeRange and na(entryPrice))
        strategy.entry("Long", strategy.long)
        entryPrice := close
        entryTime := time
        positionSide := "long"

    // Exit Logic: Close on Opposing Signal (after the current signal is triggered)
    if (positionSide == "short" and bullishSignal and time > entryTime)
        strategy.close("Short")
        entryPrice := na
        positionSide := ""

    if (positionSide == "long" and bearishSignal and time > entryTime)
        strategy.close("Long")
        entryPrice := na
        positionSide := ""

    // Stop-Loss and Take-Profit Logic (in pips)
    stopLossPriceLong = entryPrice - stopLossPips * syminfo.mintick
    takeProfitPriceLong = entryPrice + takeProfitPips * syminfo.mintick
    stopLossPriceShort = entryPrice + stopLossPips * syminfo.mintick
    takeProfitPriceShort = entryPrice - takeProfitPips * syminfo.mintick

    // Long Stop-Loss and Take-Profit Conditions
    if (positionSide == "long" and close <= stopLossPriceLong)
        strategy.close("Long", comment="Stop Loss Triggered")
        entryPrice := na
        positionSide := ""

    if (positionSide == "long" and enableTakeProfit and close >= takeProfitPriceLong)
        strategy.close("Long", comment="Take Profit Triggered")
        entryPrice := na
        positionSide := ""

    // Short Stop-Loss and Take-Profit Conditions
    if (positionSide == "short" and close >= stopLossPriceShort)
        strategy.close("Short", comment="Stop Loss Triggered")
        entryPrice := na
        positionSide := ""

    if (positionSide == "short" and enableTakeProfit and close <= takeProfitPriceShort)
        strategy.close("Short", comment="Take Profit Triggered")
        entryPrice := na
        positionSide := ""

if (mode == "Bullish Only")
    if (bullishSignal and inTimeRange and na(entryPrice))
        strategy.entry("Long", strategy.long)
        entryPrice := close
        entryTime := time
        positionSide := "long"

    if (positionSide == "long" and bearishSignal and time > entryTime)
        strategy.close("Long")
        entryPrice := na
        positionSide := ""

    // Stop-Loss and Take-Profit Logic (in pips)
    stopLossPriceLong = entryPrice - stopLossPips * syminfo.mintick
    takeProfitPriceLong = entryPrice + takeProfitPips * syminfo.mintick

    if (positionSide == "long" and close <= stopLossPriceLong)
        strategy.close("Long", comment="Stop Loss Triggered")
        entryPrice := na
        positionSide := ""

    if (positionSide == "long" and enableTakeProfit and close >= takeProfitPriceLong)
        strategy.close("Long", comment="Take Profit Triggered")
        entryPrice := na
        positionSide := ""

if (mode == "Bearish Only")
    if (bearishSignal and inTimeRange and na(entryPrice))
        strategy.entry("Short", strategy.short)
        entryPrice := close
        entryTime := time
        positionSide := "short"

    if (positionSide == "short" and bullishSignal and time > entryTime)
        strategy.close("Short")
        entryPrice := na
        positionSide := ""

    // Stop-Loss and Take-Profit Logic (in pips)
    stopLossPriceShort = entryPrice + stopLossPips * syminfo.mintick
    takeProfitPriceShort = entryPrice - takeProfitPips * syminfo.mintick

    if (positionSide == "short" and close >= stopLossPriceShort)
        strategy.close("Short", comment="Stop Loss Triggered")
        entryPrice := na
        positionSide := ""

    if (positionSide == "short" and enableTakeProfit and close <= takeProfitPriceShort)
        strategy.close("Short", comment="Take Profit Triggered")
        entryPrice := na
        positionSide := ""