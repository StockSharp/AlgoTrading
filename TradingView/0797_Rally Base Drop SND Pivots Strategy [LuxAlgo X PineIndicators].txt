//@version=6
strategy("Rally Base Drop SND Pivots Strategy [LuxAlgo X PineIndicators]", overlay=true, initial_capital=100000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_boxes_count=500, max_labels_count=500, max_lines_count=500, commission_value=0.01, process_orders_on_close=true, margin_long=20, margin_short=20, slippage=2)

//---------------------------------------------------------------------
// Inputs
//---------------------------------------------------------------------
tradeMode         = input.string("Long & Short", "Trade Mode", options=["Long Only", "Short Only", "Long & Short"])
reverseConditions = input.bool(false, "Reverse Long/Short Conditions")
mult              = input(1.0, "ATR Exit Multiplier")
rr                = input(6.0, "Risk Reward Ratio")
len               = input.int(3, title="Length")
rallyCol          = input.color(color.new(#089981,50), title="Rally Color")
dropCol           = input.color(color.new(#f23645,50), title="Drop Color")
hideLen           = input.int(0, title="Historical Lookback", minval=0, tooltip="Hide levels further back than this number of bars.\n\nNote: 0 = Show All")

//---------------------------------------------------------------------
// User Defined Types (UDTs)
//---------------------------------------------------------------------
type pb
    float price
    int bar

//---------------------------------------------------------------------
// Basic Variables
//---------------------------------------------------------------------
gc    = close > open
rc    = close < open
rally = gc and gc[1]
drop  = rc and rc[1]
base  = not rally and not drop

//---------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------
check_rb_piv(_len) =>
    var pb piv_hi = pb.new(na, na)
    var pb piv_lo = pb.new(na, na)
    hst = ta.highest(math.max(close, open), _len)
    lst = ta.lowest(math.min(close, open), _len)
    for i = 0 to len - 1
        if not gc[i] or not rc[len + i]
            piv_lo := pb.new(na, na)
            break
        if i == len - 1 and close > open[len + i] and close[len] < close[len + i]
            piv_lo := pb.new(low[i], bar_index[i])
            box.new(bar_index[len + i], hst[len], bar_index[len], lst[len], bgcolor=dropCol, border_color=dropCol)
            box.new(bar_index[i], hst, bar_index, lst, bgcolor=rallyCol, border_color=rallyCol)
    for i = 0 to len - 1
        if not rc[i] or not gc[len + i]
            piv_hi := pb.new(na, na)
            break
        if i == len - 1 and close < open[len + i] and close[len] > close[len + i]
            piv_hi := pb.new(high[i], bar_index[i])
            box.new(bar_index[len + i], hst[len], bar_index[len], lst[len], bgcolor=rallyCol, border_color=rallyCol)
            box.new(bar_index[i], hst, bar_index, lst, bgcolor=dropCol, border_color=dropCol)
    [piv_hi, piv_lo]

//---------------------------------------------------------------------
// Global Persistent Variables
//---------------------------------------------------------------------
var float up   = na
var float down = na  // Used for the opposite condition
var float lastEntryLevel      = na  // For long entry (based on up or down depending on settings)
var float lastShortEntryLevel = na  // For short entry
var float lastLongEntryPrice  = na
var float lastLongEntryATR    = na
var float lastShortEntryPrice = na
var float lastShortEntryATR   = na

// Persistent horizontal lines (created during a trade; after trade closure, they remain on the chart)
var line entryLine  = na
var line profitLine = na
var line lossLine   = na

// Persistent labels for the horizontal display
var label entryLabel = na
var label slLabel    = na
var label tpLabel    = na

// ATR calculation (Period 14)
atrValue = ta.atr(14)

//---------------------------------------------------------------------
// Ensure enough historical bars exist (e.g. len*2 and ATR period)
//---------------------------------------------------------------------
if bar_index >= math.max(len * 2, 14) and not na(atrValue)
    //-----------------------------------------------------------------
    // Pivot Detection & Drawing
    //-----------------------------------------------------------------
    [ph, pl] = check_rb_piv(len)

    var his = array.new_line(na)
    var los = array.new_line(na)

    if not na(ph.price)
        his.push(line.new(ph.bar, ph.price, bar_index, ph.price, color=dropCol))
        up := ph.price
    if not na(pl.price)
        los.push(line.new(pl.bar, pl.price, bar_index, pl.price, color=rallyCol))
        down := pl.price

    for [i, ln] in los
        if close[1] < ln.get_y1()
            los.remove(i)
            continue
        ln.set_x2(bar_index)
    for [i, ln] in his
        if close[1] > ln.get_y1()
            his.remove(i)
            continue
        ln.set_x2(bar_index)

    if hideLen > 0
        for bx in box.all
            if bx.get_right() < bar_index - (hideLen + (len * 2))
                bx.delete()
        for ln in line.all
            if ln.get_x1() < bar_index - (hideLen + (len * 2))
                ln.delete()

    //-----------------------------------------------------------------
    // Entry Logic
    //-----------------------------------------------------------------
    if not reverseConditions
        // Normal Conditions:
        // Long entry based on the up-level; Short entry based on the down-level.
        if (tradeMode == "Long Only" or tradeMode == "Long & Short") and not na(up) and ta.crossover(close, up) and (na(lastEntryLevel) or lastEntryLevel != up)
            strategy.entry("L", strategy.long)
            lastEntryLevel     := up
            lastLongEntryPrice := close
            lastLongEntryATR   := atrValue
        if (tradeMode == "Short Only" or tradeMode == "Long & Short") and not na(down) and ta.crossunder(close, down) and (na(lastShortEntryLevel) or lastShortEntryLevel != down)
            strategy.entry("S", strategy.short)
            lastShortEntryLevel := down
            lastShortEntryPrice := close
            lastShortEntryATR   := atrValue
    else
        // Reversed Conditions:
        // Long entry based on the down-level; Short entry based on the up-level.
        if (tradeMode == "Long Only" or tradeMode == "Long & Short") and not na(down) and ta.crossunder(close, down) and (na(lastEntryLevel) or lastEntryLevel != down)
            strategy.entry("L", strategy.long)
            lastEntryLevel     := down
            lastLongEntryPrice := close
            lastLongEntryATR   := atrValue
        if (tradeMode == "Short Only" or tradeMode == "Long & Short") and not na(up) and ta.crossover(close, up) and (na(lastShortEntryLevel) or lastShortEntryLevel != up)
            strategy.entry("S", strategy.short)
            lastShortEntryLevel := up
            lastShortEntryPrice := close
            lastShortEntryATR   := atrValue

    //-----------------------------------------------------------------
    // Exit Logic: Based on the entry price and ATR at the time of entry
    //-----------------------------------------------------------------
    var float longProfit  = na
    var float longStop    = na
    var float shortProfit = na
    var float shortStop   = na
    if strategy.position_size > 0 and not na(lastLongEntryPrice) and not na(lastLongEntryATR)
        longProfit := lastLongEntryPrice + lastLongEntryATR * mult * rr
        longStop   := lastLongEntryPrice - lastLongEntryATR * mult
        strategy.exit("L Exit", "L", limit=longProfit, stop=longStop)
    if strategy.position_size < 0 and not na(lastShortEntryPrice) and not na(lastShortEntryATR)
        shortProfit := lastShortEntryPrice - lastShortEntryATR * mult * rr
        shortStop   := lastShortEntryPrice + lastShortEntryATR * mult
        strategy.exit("S Exit", "S", limit=shortProfit, stop=shortStop)

    //-----------------------------------------------------------------
    // Display Horizontal Levels (Lines & Labels) – From Entry to Exit
    //-----------------------------------------------------------------
    // If a trade is active, create or update the horizontal lines and labels.
    if strategy.position_size != 0
        if na(entryLine)
            // New trade: create lines and labels without automatic extension (extend = none)
            if strategy.position_size > 0
                entryLine  := line.new(bar_index, lastLongEntryPrice, bar_index, lastLongEntryPrice, extend=extend.none, color=color.white, width=2)
                profitLine := line.new(bar_index, longProfit, bar_index, longProfit, extend=extend.none, color=rallyCol, width=2)
                lossLine   := line.new(bar_index, longStop, bar_index, longStop, extend=extend.none, color=dropCol, width=2)
                entryLabel := label.new(bar_index, lastLongEntryPrice, "ENTRY: " + str.tostring(lastLongEntryPrice, format.mintick), style=label.style_label_left, size=size.tiny, color=color.white, textcolor=color.black, yloc=yloc.price)
                slLabel    := label.new(bar_index, longStop,    "SL: "    + str.tostring(longStop, format.mintick),    style=label.style_label_left, size=size.tiny, color=dropCol, textcolor=color.white, yloc=yloc.price)
                tpLabel    := label.new(bar_index, longProfit,  "TP: "    + str.tostring(longProfit, format.mintick),  style=label.style_label_left, size=size.tiny, color=rallyCol, textcolor=color.white, yloc=yloc.price)
            else if strategy.position_size < 0
                entryLine  := line.new(bar_index, lastShortEntryPrice, bar_index, lastShortEntryPrice, extend=extend.none, color=color.white, width=2)
                profitLine := line.new(bar_index, shortProfit, bar_index, shortProfit, extend=extend.none, color=dropCol, width=2)
                lossLine   := line.new(bar_index, shortStop, bar_index, shortStop, extend=extend.none, color=rallyCol, width=2)
                entryLabel := label.new(bar_index, lastShortEntryPrice, "ENTRY: " + str.tostring(lastShortEntryPrice, format.mintick), style=label.style_label_left, size=size.tiny, color=color.white, textcolor=color.black, yloc=yloc.price)
                slLabel    := label.new(bar_index, shortStop,    "SL: "    + str.tostring(shortStop, format.mintick),    style=label.style_label_left, size=size.tiny, color=rallyCol, textcolor=color.white, yloc=yloc.price)
                tpLabel    := label.new(bar_index, shortProfit,  "TP: "    + str.tostring(shortProfit, format.mintick),  style=label.style_label_left, size=size.tiny, color=dropCol, textcolor=color.white, yloc=yloc.price)
        else
            // Trade is still active – update the right end (x2) of the lines and move the labels
            line.set_x2(entryLine, bar_index)
            line.set_x2(profitLine, bar_index)
            line.set_x2(lossLine, bar_index)
            if strategy.position_size > 0
                label.set_xy(entryLabel, bar_index+1, lastLongEntryPrice)
                label.set_xy(slLabel,    bar_index+1, longStop)
                label.set_xy(tpLabel,    bar_index+1, longProfit)
            else if strategy.position_size < 0
                label.set_xy(entryLabel, bar_index+1, lastShortEntryPrice)
                label.set_xy(slLabel,    bar_index+1, shortStop)
                label.set_xy(tpLabel,    bar_index+1, shortProfit)
    // Once the trade is closed, finalize the lines (set x2 = exit bar) and reset the internal references so that new trades create new objects.
    else if strategy.position_size == 0 and (not na(strategy.position_size[1]) and strategy.position_size[1] != 0)
        if not na(entryLine)
            line.set_x2(entryLine, bar_index)
            line.set_x2(profitLine, bar_index)
            line.set_x2(lossLine, bar_index)
            entryLine  := na
            profitLine := na
            lossLine   := na
            entryLabel := na
            slLabel    := na
            tpLabel    := na