// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Crunchster1

//@version=6
strategy(title = 'Crunchster\'s Turtle and Trend System', shorttitle = 'TurtleTr', overlay = true, slippage = 10, pyramiding = 1, precision = 4, calc_on_order_fills = false, calc_on_every_tick = false, default_qty_value = 0.1, initial_capital = 1000, commission_value = 0.06, process_orders_on_close = true)

// Inputs and Parameters
src = input(close, 'Source', group = 'Strategy Settings')
length = input.int(title = 'Lookback period for fast EMA', defval = 10, minval = 2, group = 'Strategy Settings', tooltip = 'This sets the lookback period for the fast exponential moving average. The slow EMA is 5x the fast EMA length')
blength = input.int(title = 'Lookback period for Breakout', defval = 20, minval = 5, step = 5, group = 'Strategy Settings')

long = input(true, 'Long', inline = '08', group = 'Strategy toggle')
short = input(true, 'Short', inline = '08', group = 'Strategy toggle', tooltip = 'Toggle long/short strategy on/off')

EMAwt = input(true, 'Trend', inline = '01', group = 'Strategy toggle')
breakwt = input(false, 'Breakout', inline = '01', group = 'Strategy toggle', tooltip = 'Toggle trend/breakout strategy on/off')

stopMultiple = input.float(20, 'Stop multiple', step = 0.5, group = 'Risk Management Settings', tooltip = 'Multiple for ATR, setting hard stop loss from entry price')
trail = input.int(1000, 'Trail lookback', step = 5, group = 'Risk Management Settings', tooltip = 'Lookback period for the trailing stop')
lev = input.float(1, 'Max Leverage', step = 0.5, group = 'Risk Management Settings', tooltip = 'Max leverage sets maximum allowable leverage of total capital (initial capital + any net profit), capping maximum volatility adjusted position size')
riskT = input.float(15, maxval = 75, title = 'Annualised Volatility Target %', group = 'Risk Management Settings', tooltip = 'Specify annual risk target, used to determine volatility adjusted position size. Annualised daily volatility is referenced to this value and position size adjusted accordingly')
comp = input(false, 'Compounding', inline = '09', group = 'Risk Management Settings')
Comppct = input.float(50, '%', step = 5, inline = '09', group = 'Risk Management Settings', tooltip = 'Toggle compounding of profit, and set % of profit to compound')

string ind = input.symbol(defval = 'BTCUSD', title = 'Index', group = 'Inputs for Statistical Data', tooltip = 'Index symbol for statistical comparison')
SRlb = input.int(title="Statistics lookback", defval=365, step=365, group = 'Inputs for Statistical Data', tooltip = 'Lookback period for calculating annualised statistics')

// Backtesting period
FromDay = input.int(defval = 1, title = 'From Day', minval = 1, maxval = 31, inline = '04', group = 'Backtest range')
FromMonth = input.int(defval = 1, title = 'From Mon', minval = 1, maxval = 12, inline = '04', group = 'Backtest range')
FromYear = input.int(defval = 2018, title = 'From Yr', minval = 1900, inline = '04', group = 'Backtest range', tooltip = 'Set start of backtesting period')
ToDay = input.int(defval = 1, title = 'To Day', minval = 1, maxval = 31, inline = '05', group = 'Backtest range')
ToMonth = input.int(defval = 1, title = 'To Mon', minval = 1, maxval = 12, inline = '05', group = 'Backtest range')
ToYear = input.int(defval = 9999, title = 'To Yr', minval = 1900, inline = '05', group = 'Backtest range', tooltip = 'Set end of backtesting period')

start = timestamp(FromYear, FromMonth, FromDay, 00, 00)
finish = timestamp(ToYear, ToMonth, ToDay, 23, 59)
window = time >= start and time <= finish

// Scaling factor switch for annualisation
tf(source) =>
    switch timeframe.main_period
        "1D" => 365
        "720" => 720
        "360" => 1460
        "480" => 1095
        "240" => 2190
        "120" => 4380
        "60" => 8760

// Breakout strategy
lower = ta.lowest(low[1], blength)
upper = ta.highest(high[1], blength)
basis = math.avg(upper, lower)
signal = 20 * (close - basis) / (upper - lower)

// Trend strategy
fEMA = ta.ema(close[1], length)
sEMA = ta.ema(close[1], length * 5)
emadiff = fEMA - sEMA
nemadiff = 5 * emadiff / ta.stdev(close - close[1], 252)

//Risk Management formulae

tr = math.max(high - low, math.abs(high - close), math.abs(low - close)) //True range
stopL = ta.sma(tr, 14) //Average true range
stdev = ta.stdev(close / close[1] - 1, tf(timeframe.main_period)/20) //volatility of recent returns
maxcapital = strategy.initial_capital + strategy.netprofit //Maximum capital available to invest - initial capital net of profit
annvol = 100 * math.sqrt(tf(timeframe.main_period)) * stdev //converts recent volatility of returns into annualised volatility of returns - assumes daily timeframe

risk = 1.1
if comp
    risk := strategy.initial_capital + Comppct * strategy.netprofit / 100 //adjust investment capital to include compounding
    risk
else
    risk := strategy.initial_capital
    risk

shares = risk * (riskT / annvol) / close //calculates volatility adjusted position size, dependent on user specified annualised risk target
if shares * close > lev * maxcapital //ensures position size does not exceed available capital multiplied by user specified maximum leverage
    shares := lev * maxcapital / close
    shares

//To set the price at the entry point of trade
Posopen() =>
    math.abs(strategy.position_size[1]) <= 0 and math.abs(strategy.position_size) > 0

var float openN = na
if Posopen()
    openN := stopL
    openN

// Trailing stop
tlower = ta.lowest(low[1], trail)
tupper = ta.highest(high[1], trail)
tbasis = math.avg(tupper, tlower)
tsignal = 20 * (close - tbasis) / (tupper - tlower)

// Strategy Rules
if EMAwt
    if long
        longCondition2 = ta.crossover(nemadiff, 2.5) and window
        closelong = ta.crossunder(nemadiff, 2.5)
        exitlong = tsignal <= -10 or closelong
        if longCondition2
            strategy.entry('Trend Long!', strategy.long, qty = shares)
        if strategy.position_size > 0
            strategy.exit('Stop Long', from_entry = 'Trend Long!', stop = strategy.opentrades.entry_price(0) - openN * stopMultiple)
        if exitlong
            strategy.close('Trend Long!', immediately = true)

    if short
        shortCondition2 = ta.crossunder(nemadiff, -2.5) and window
        closeshort = ta.crossover(nemadiff, -2.5)
        exitshort = tsignal >= 10 or closeshort
        if shortCondition2
            strategy.entry('Trend Short!', strategy.short, qty = shares)
        if strategy.position_size < 0
            strategy.exit('Stop Short', from_entry = 'Trend Short!', stop = strategy.opentrades.entry_price(0) + openN * stopMultiple)
        if exitshort
            strategy.close('Trend Short!', immediately = true)

if breakwt
    if long
        longCondition1 = signal >= 10 and window
        exitlong = tsignal <= -10
        if longCondition1
            strategy.entry('Break Long!', strategy.long, qty = shares)
        if strategy.position_size > 0
            strategy.exit('Stop Long', from_entry = 'Break Long!', stop = strategy.opentrades.entry_price(0) - openN * stopMultiple)
        if exitlong
            strategy.close('Break Long!', immediately = true)

    if short
        shortCondition1 = signal <= -10 and window
        exitshort = tsignal >= 10
        if shortCondition1
            strategy.entry('Break Short!', strategy.short, qty = shares)
        if strategy.position_size < 0
            strategy.exit('Stop Short', from_entry = 'Break Short!', stop = strategy.opentrades.entry_price(0) + openN * stopMultiple)
        if exitshort
            strategy.close('Break Short!', immediately = true)

// Visuals of trend and direction
plot(nemadiff, title = 'EMA Forecast', color = color.black, display = display.none)
plot(ta.sma(ta.median(math.sqrt(math.pow(nemadiff, 2)), 700), 350), 'Forecast mean', color = color.rgb(245, 0, 0), display = display.none)

MAColor = fEMA > sEMA ? #00ff00 : #ff0000
MA1 = plot(fEMA, title = 'Fast EMA', color = MAColor)
MA2 = plot(sEMA, title = 'Slow EMA', color = MAColor)
fill(MA1, MA2, title = 'Band Filler', color = MAColor)

//Strategy statistics
eq = strategy.equity
drtn = eq-eq[1] // Daily return $

lrtn = math.log(eq/eq[1]) // Log returns of open equity
mlrtn = ta.sma(lrtn, SRlb) // Mean log returns
sdlrtn = ta.stdev(lrtn, SRlb) // Standard deviation of log returns
rVol = 100 * math.sqrt(tf(timeframe.main_period)) * sdlrtn // Annualised strategy realised volatility of open equity
rVaR = 100 * math.sqrt(tf(timeframe.main_period)/12) * (mlrtn-2.33*sdlrtn) * -1  // Monthly strategy Value at Risk at 99% confidence level
dSR = mlrtn/sdlrtn
annSR = math.sqrt(tf(timeframe.main_period))*dSR  // Annualised sharpe ratio of open equity returns

// Plots of stats
plot(drtn, 'Daily return, $', display = display.none)
plot(eq, 'Open Equity curve', color.black, 2, display = display.none)
plot(annSR, 'Annualised Sharpe Ratio', color.red, display = display.none)
plot(rVol, 'Strategy Realised Volatility', color.green, display = display.none)
plot(rVaR, 'Strategy 99% monthly VaR', color.blue, display = display.none)

// Calculate maximum drawdown of open equity
f_DDath(S) =>
    var ath = 0.0
    if S > ath
        ath := S
    var leq = 0.0
    if strategy.position_size > 0
        leq := S[1] - (open-low) * strategy.position_size
    else
        leq := S[1] - (high-open) * math.abs(strategy.position_size)
    leq / ath - 1
DD = f_DDath(eq)
f_maxDD(S) =>
    var maxDD = 0.0
    if S < maxDD
        maxDD := S

    maxDD

// Strategy Summary Table
var T = table.new(position=position.bottom_right, columns=2, rows=7, bgcolor=color.rgb(120, 123, 134, 77), frame_color=color.gray, frame_width=2, border_color=color.gray, border_width=0)
f_table_set_titles() =>
    // X
    table.cell(table_id=T, column=0, row=0, text='', width=0, height=0)
    // vertical
    table.cell(table_id=T, column=0, row=1, text='Open position', width=0, height=0)
    table.cell(table_id=T, column=0, row=2, text='Annualised SR', width=0, height=0)
    table.cell(table_id=T, column=0, row=3, text='Strategy RVOL, %', width=0, height=0)
    table.cell(table_id=T, column=0, row=4, text='Strategy 99% mVaR, %', width=0, height=0)
    table.cell(table_id=T, column=0, row=5, text='Max Drawdown, %', width=0, height=0)
    table.cell(table_id=T, column=0, row=6, text='Target volatility, %', width=0, height=0)

    // horizontal
    table.cell(table_id=T, column=1, row=0, text='Value', width=0, height=0)
f_table_set_titles()
f_table_set_row_values(_r, _0) =>
    table.cell(table_id=T, column=1, row=_r, text=str.tostring(_0, '#.####'))
f_table_set_row_values(1, strategy.position_size)
f_table_set_row_values(2, annSR)
f_table_set_row_values(3, rVol)
f_table_set_row_values(4, rVaR)
f_table_set_row_values(5, 100*f_maxDD(DD))
f_table_set_row_values(6, riskT)

// INDEX COMPARISON

rb = request.security(ind, timeframe.period, close)
ra = eq

// Log returns function
f_rtn(S) =>
    math.log(S / S[1])

// Cumulative log returns function
f_crtn(S) =>
    rtn = math.log(S / S[1])
    math.sum(rtn, SRlb)

rtna = f_rtn(ra)
rtnb = f_rtn(rb)
crtna = f_crtn(ra)
crtnb = f_crtn(rb)

// Construct array of returns data
returns_array = array.new_float(0)
returns_base_array = array.new_float(0)
for i = 0 to SRlb - 1 by 1
    array.push(returns_array, rtna[i])
    array.push(returns_base_array, rtnb[i])

beta = array.covariance(returns_array, returns_base_array) / array.variance(returns_base_array)

alpha = math.sum(rtna, SRlb) - math.sum(rtnb, SRlb) * beta

// Sharpe ratio function
f_sharpe(S) =>
    m = ta.sma(S, SRlb)
    sd = ta.stdev(S, SRlb)
    math.sqrt(tf(timeframe.main_period)) * m / sd

// Sortino ratio function
f_sortino(S) =>
    float rtn = S
    rtn_array = array.new_float(0)
    neg_rtn_array = array.new_float(0)
    for i = 0 to SRlb - 1 by 1
        array.push(rtn_array, rtn[i])
        if rtn[i] <= 0.0
            array.push(neg_rtn_array, rtn[i])

    neg_rtn_stdev = array.stdev(neg_rtn_array)
    mean = array.avg(rtn_array)
    mean / neg_rtn_stdev * math.sqrt(tf(timeframe.main_period))

// Drawdown from all time high
f_DDath2(S) =>
    var ath = 0.0
    if S > ath
        ath := S
        ath

    S / ath - 1

// Calculate correlation between strategy and index
corr = ta.correlation(rtna, rtnb, SRlb)

plot(corr, 'Correlation', color = color.blue, linewidth = 2, display = display.none)

// Table displaying strategy comparison with user selected index
var T1 = table.new(position = position.top_right, columns = 7, rows = 3, bgcolor = color.rgb(120, 123, 134, 77), frame_color = color.gray, frame_width = 2, border_color = color.gray, border_width = 0)
f_table_set_titles1() =>
    // X
    table.cell(table_id = T1, column = 0, row = 0, text = '', width = 0, height = 0)
    // vertical
    table.cell(table_id = T1, column = 0, row = 1, text = "Strategy", width = 0, height = 0)
    table.cell(table_id = T1, column = 0, row = 2, text = ind, width = 0, height = 0)
    // horizontal
    table.cell(table_id = T1, column = 1, row = 0, text = 'Cum Return', width = 0, height = 0)
    table.cell(table_id = T1, column = 2, row = 0, text = 'Beta', width = 0, height = 0)
    table.cell(table_id = T1, column = 3, row = 0, text = 'Alpha', width = 0, height = 0)
    table.cell(table_id = T1, column = 4, row = 0, text = 'Sharpe', width = 0, height = 0)
    table.cell(table_id = T1, column = 5, row = 0, text = 'Sortino', width = 0, height = 0)
    table.cell(table_id = T1, column = 6, row = 0, text = 'ATH DD', width = 0, height = 0)

f_table_set_titles1()
f_table_set_row_values1(_r, _0, _1, _2, _3, _4, _5) =>
    table.cell(table_id = T1, column = 1, row = _r, text = str.tostring(_0, '#.#%'))
    table.cell(table_id = T1, column = 2, row = _r, text = str.tostring(_1, '#.##'))
    table.cell(table_id = T1, column = 3, row = _r, text = str.tostring(_2, '#.##'))
    table.cell(table_id = T1, column = 4, row = _r, text = str.tostring(_3, '#.##'))
    table.cell(table_id = T1, column = 5, row = _r, text = str.tostring(_4, '#.##'))
    table.cell(table_id = T1, column = 6, row = _r, text = str.tostring(_5, '#%'))
f_table_set_row_values1(1, crtna, beta, alpha, f_sharpe(rtna), f_sortino(rtna), f_DDath2(ra))
f_table_set_row_values1(2, crtnb, 1., 0., f_sharpe(rtnb), f_sortino(rtnb), f_DDath2(rb))