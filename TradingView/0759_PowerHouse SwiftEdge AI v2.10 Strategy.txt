//@version=5
strategy("PowerHouse SwiftEdge AI v2.10 Strategy", overlay=true, calc_on_every_tick=true)

// Inputs med fleksible indstillinger
length = input.int(5, "Pivot Length", minval=1, maxval=20, step=1, tooltip="Number of bars to identify pivot highs and lows.")
momentum_threshold_base = input.float(0.01, "Base Momentum Threshold (%)", minval=0.001, maxval=1.0, step=0.001, tooltip="Base percentage change for signals.")
tp_points = input.int(10, "Take Profit (points)", minval=5, maxval=500, step=5)
sl_points = input.int(10, "Stop Loss (points)", minval=5, maxval=500, step=5)
min_signal_distance = input.int(5, "Min Signal Distance (bars)", minval=1, maxval=50, step=1)
tp_box_height = input.float(0.5, "TP Box Height % (Optional)", minval=0.1, maxval=2.0, step=0.1)
pre_momentum_factor_base = input.float(0.5, "Base Pre-Momentum Factor", minval=0.1, maxval=1.0, step=0.1, tooltip="Base factor for Get Ready signals.")
shortTrendPeriod = input.int(30, title="Short Trend Period", minval=10, maxval=100)
longTrendPeriod = input.int(100, title="Long Trend Period", minval=50, maxval=200)

// Brugerdefinerede filtre
use_momentum_filter = input.bool(true, "Use Momentum Filter", group="Signal Filters", tooltip="Require price change to exceed momentum threshold.")
use_trend_filter = input.bool(true, "Use Higher Timeframe Trend Filter", group="Signal Filters", tooltip="Require alignment with the selected higher timeframe trend.")
higher_tf_choice = input.string("60", "Higher Timeframe", options=["60", "240", "D"], group="Signal Filters", tooltip="Choose the timeframe for the higher timeframe filter.")
use_lower_tf_filter = input.bool(true, "Use Lower Timeframe Filter", group="Signal Filters", tooltip="Prevent signals against the selected lower timeframe trend.")
lower_tf_choice = input.string("60", "Lower Timeframe", options=["60", "240", "D"], group="Signal Filters", tooltip="Choose the timeframe for the lower timeframe filter.")
use_volume_filter = input.bool(false, "Use Volume Filter", group="Signal Filters", tooltip="Require volume above average (optional).")
use_breakout_filter = input.bool(false, "Use Breakout Filter", group="Signal Filters", tooltip="Require price to break previous high/low (optional).")
show_get_ready = input.bool(true, "Show Get Ready Signals", group="Signal Filters", tooltip="Enable or disable Get Ready signals.")
restrict_repeated_signals = input.bool(false, "Restrict Repeated Signals", group="Signal Filters", tooltip="Prevent multiple signals in the same trend direction until trend changes.")
restrict_trend_tf_choice = input.string("60", "Restrict Trend Timeframe", options=["60", "240", "D"], group="Signal Filters", tooltip="Choose the timeframe to check trend for restricting repeated signals.")
enable_ai_analysis = input.bool(true, "Enable AI Market Analysis", group="AI Market Analysis", tooltip="Show AI predictions for future trends across timeframes.")
ai_table_position = input.string("Bottom Center", "AI Market Analysis Table Position", options=["Top Left", "Top Center", "Top Right", "Middle Left", "Middle Center", "Middle Right", "Bottom Left", "Bottom Center", "Bottom Right"], group="AI Market Analysis", tooltip="Choose the position of the AI Market Analysis table.")

// Ekstra inputs til valgfrie filtre
volumeLongPeriod = input.int(50, "Long Volume Period", minval=10, maxval=100, group="Volume Filter Settings")
volumeShortPeriod = input.int(5, "Short Volume Period", minval=1, maxval=20, group="Volume Filter Settings")
breakoutPeriod = input.int(5, "Breakout Period", minval=1, maxval=50, group="Breakout Filter Settings")

// Funktion til at konvertere streng til position
f_getTablePosition(position_string) =>
    switch position_string
        "Top Left" => position.top_left
        "Top Center" => position.top_center
        "Top Right" => position.top_right
        "Middle Left" => position.middle_left
        "Middle Center" => position.middle_center
        "Middle Right" => position.middle_right
        "Bottom Left" => position.bottom_left
        "Bottom Center" => position.bottom_center
        "Bottom Right" => position.bottom_right
        => position.middle_right  // Standard fallback

// AI-drevet adaptiv signaljustering med ATR
atr_raw = ta.atr(14)
atr = na(atr_raw) and bar_index > 0 ? (high - low) : atr_raw
volatility_factor = atr / close
momentum_threshold = momentum_threshold_base * (1 + volatility_factor * 2)
pre_momentum_factor = pre_momentum_factor_base * (1 - volatility_factor * 0.5)
pre_momentum_threshold = momentum_threshold * pre_momentum_factor

// Raw CVD-beregning
var float raw_cvd = 0.0
delta_volume = close > close[1] ? volume : close < close[1] ? -volume : 0
raw_cvd := raw_cvd + delta_volume

// Volatility Context baseret på absolut CVD
cvd_level = math.abs(raw_cvd) < 10000 ? "Low" : math.abs(raw_cvd) < 50000 ? "Medium" : "High"
cvd_color = raw_cvd > 0 ? color.lime : raw_cvd < 0 ? color.red : color.yellow

// Beregn prisændring (momentum)
price_change = ((close - close[1]) / close[1]) * 100

// Find højder og lavpunkter
pivot_high = ta.pivothigh(high, length, length)
pivot_low = ta.pivotlow(low, length, length)

// Variabler til at gemme seneste højder og lavpunkter
var float last_high = na
var float last_low = na
if not na(pivot_high)
    last_high := pivot_high
if not na(pivot_low)
    last_low := pivot_low

// Variabler til signalstyring
var float choch_sell_level = na
var float choch_buy_level = na
var float bos_sell_level = na
var float bos_buy_level = na
var float tp_sell_level = na
var float tp_buy_level = na
var int last_signal_bar = -min_signal_distance - 1
var string last_signal = "Neutral"
var int last_trend = 0  // Sporer den sidste trendretning for restrict_repeated_signals

// Multi-tidsramme trendanalyse med robust fallback
// Beregn EMA og VWAP for hver tidsramme
ema60_raw = request.security(syminfo.tickerid, "60", ta.ema(close, 20), lookahead=barmerge.lookahead_on)
vwap60_raw = request.security(syminfo.tickerid, "60", ta.vwap(hlc3), lookahead=barmerge.lookahead_on)
ema240_raw = request.security(syminfo.tickerid, "240", ta.ema(close, 20), lookahead=barmerge.lookahead_on)
vwap240_raw = request.security(syminfo.tickerid, "240", ta.vwap(hlc3), lookahead=barmerge.lookahead_on)
emaD_raw = request.security(syminfo.tickerid, "D", ta.ema(close, 20), lookahead=barmerge.lookahead_on)
vwapD_raw = request.security(syminfo.tickerid, "D", ta.vwap(hlc3), lookahead=barmerge.lookahead_on)

// Lokale EMA og VWAP som fallback
local_ema = ta.ema(close, 20)
local_vwap = ta.vwap(hlc3)

// Fallback for manglende data
ema60 = na(ema60_raw) ? local_ema : ema60_raw
vwap60 = na(vwap60_raw) ? local_vwap : vwap60_raw
ema240 = na(ema240_raw) ? local_ema : ema240_raw
vwap240 = na(vwap240_raw) ? local_vwap : vwap240_raw
emaD = na(emaD_raw) ? local_ema : emaD_raw
vwapD = na(vwapD_raw) ? local_vwap : vwapD_raw

// Trendbestemmelse (1 = op, -1 = ned, 0 = neutral)
trend60 = close > ema60 and close > vwap60 ? 1 : close < ema60 and close < vwap60 ? -1 : 0
trend240 = close > ema240 and close > vwap240 ? 1 : close < ema240 and close < vwap240 ? -1 : 0
trendD = close > emaD and close > vwapD ? 1 : close < emaD and close < vwapD ? -1 : 0

// AI-Trend Strength (-100 til +100)
trend_strength_raw = trend60 + trend240 + trendD
trend_strength = (trend_strength_raw / 3) * 100

// AI Confidence (simuleret succesrate)
var float ai_confidence = 50.0
if trend_strength_raw == 3 or trend_strength_raw == -3
    ai_confidence := 90.0
else if trend_strength_raw >= 2 or trend_strength_raw <= -2
    ai_confidence := 75.0
else
    ai_confidence := 60.0

// Filterbetingelser
// Dynamisk valg af higher timeframe trend (til signalfiltrering)
var int higher_tf_trend = 0
switch higher_tf_choice
    "60" => higher_tf_trend := trend60
    "240" => higher_tf_trend := trend240
    "D" => higher_tf_trend := trendD

bullish_trend_ok = higher_tf_trend == 1
bearish_trend_ok = higher_tf_trend == -1

// Dynamisk valg af lower timeframe trend (til signalfiltrering)
var int lower_tf_trend = 0
switch lower_tf_choice
    "60" => lower_tf_trend := trend60
    "240" => lower_tf_trend := trend240
    "D" => lower_tf_trend := trendD

lower_tf_bullish = lower_tf_trend == 1
lower_tf_bearish = lower_tf_trend == -1
lower_tf_not_neutral = lower_tf_trend != 0

// Dynamisk valg af trend-tidsramme til restrict_repeated_signals
var int restrict_tf_trend = 0
switch restrict_trend_tf_choice
    "60" => restrict_tf_trend := trend60
    "240" => restrict_tf_trend := trend240
    "D" => restrict_tf_trend := trendD

volAvg50 = ta.sma(volume, volumeLongPeriod)
volShort = ta.sma(volume, volumeShortPeriod)
volCondition = volume > volAvg50 and ta.change(volShort) > 0
highestBreakout = ta.highest(high, breakoutPeriod)
lowestBreakout = ta.lowest(low, breakoutPeriod)

// CHoCH og BOS definitioner
choch_sell = ta.crossunder(low, last_high) and close < open
choch_buy = ta.crossover(high, last_low) and close > open
bos_sell = ta.crossunder(low, last_low[1]) and low < last_low[1] and close < open
bos_buy = ta.crossover(high, last_high[1]) and high > last_high[1] and close > open

// Signalbetingelser med valgbare filtre
early_sell_signal = use_momentum_filter ? price_change < -momentum_threshold : true
early_buy_signal = use_momentum_filter ? price_change > momentum_threshold : true
sell_trend_ok = use_trend_filter ? bearish_trend_ok : true
buy_trend_ok = use_trend_filter ? bullish_trend_ok : true
sell_lower_tf_ok = use_lower_tf_filter ? (not lower_tf_bullish and lower_tf_not_neutral) : true
buy_lower_tf_ok = use_lower_tf_filter ? (not lower_tf_bearish and lower_tf_not_neutral) : true
sell_volume_ok = use_volume_filter ? volCondition : true
buy_volume_ok = use_volume_filter ? volCondition : true
sell_breakout_ok = use_breakout_filter ? close < lowestBreakout[1] : true
buy_breakout_ok = use_breakout_filter ? close > highestBreakout[1] : true

// Logik for at begrænse gentagne signaler baseret på restrict_tf_trend
sell_allowed = not restrict_repeated_signals or (last_signal != "Sell" or (last_signal == "Sell" and restrict_tf_trend != last_trend and restrict_tf_trend != -1))
buy_allowed = not restrict_repeated_signals or (last_signal != "Buy" or (last_signal == "Buy" and restrict_tf_trend != last_trend and restrict_tf_trend != 1))

sell_condition = early_sell_signal and (bar_index - last_signal_bar >= min_signal_distance) and sell_trend_ok and sell_lower_tf_ok and sell_volume_ok and sell_breakout_ok and sell_allowed
buy_condition = early_buy_signal and (bar_index - last_signal_bar >= min_signal_distance) and buy_trend_ok and buy_lower_tf_ok and buy_volume_ok and buy_breakout_ok and buy_allowed

get_ready_sell = use_momentum_filter ? (price_change < -pre_momentum_threshold and price_change > -momentum_threshold) : true and (bar_index - last_signal_bar >= min_signal_distance) and sell_trend_ok and sell_lower_tf_ok and sell_volume_ok and sell_breakout_ok
get_ready_buy = use_momentum_filter ? (price_change > pre_momentum_threshold and price_change < momentum_threshold) : true and (bar_index - last_signal_bar >= min_signal_distance) and buy_trend_ok and buy_lower_tf_ok and buy_volume_ok and buy_breakout_ok

// Strategy logic
if buy_condition
    strategy.entry("Long", strategy.long)
    strategy.exit("TP/SL Long", "Long", limit=close + tp_points, stop=close - sl_points)
    label.new(bar_index, low, "Buy", color=color.green, style=label.style_label_up, textcolor=color.white)
    tp_buy_level := high + tp_points
    last_signal := "Buy"
    last_signal_bar := bar_index
    last_trend := restrict_tf_trend

if sell_condition
    strategy.entry("Short", strategy.short)
    strategy.exit("TP/SL Short", "Short", limit=close - tp_points, stop=close + sl_points)
    label.new(bar_index, high, "Sell", color=color.red, style=label.style_label_down, textcolor=color.white)
    tp_sell_level := low - tp_points
    last_signal := "Sell"
    last_signal_bar := bar_index
    last_trend := restrict_tf_trend

// Plot Get Ready signals
if show_get_ready and get_ready_sell
    label.new(bar_index, high, "Get Ready SELL", color=color.orange, style=label.style_label_down, textcolor=color.black, size=size.small)

if show_get_ready and get_ready_buy
    label.new(bar_index, low, "Get Ready BUY", color=color.yellow, style=label.style_label_up, textcolor=color.black, size=size.small)

// Plot CHoCH og BOS som fulde linjer med AI-agtige farver
var line choch_sell_line = na
var line choch_buy_line = na
var line bos_sell_line = na
var line bos_buy_line = na

if choch_sell
    line.delete(choch_sell_line)
    choch_sell_level := last_high
    choch_sell_line := line.new(bar_index, choch_sell_level, bar_index + 1, choch_sell_level, color=color.aqua, style=line.style_solid, width=1)
    label.new(bar_index, choch_sell_level, "CHCH", color=color.new(color.aqua, 90), textcolor=color.aqua, style=label.style_none, size=size.small)

if choch_buy
    line.delete(choch_buy_line)
    choch_buy_level := last_low
    choch_buy_line := line.new(bar_index, choch_buy_level, bar_index + 1, choch_buy_level, color=color.lime, style=line.style_solid, width=1)
    label.new(bar_index, choch_buy_level, "CHCH", color=color.new(color.lime, 90), textcolor=color.lime, style=label.style_none, size=size.small)

if bos_sell
    line.delete(bos_sell_line)
    bos_sell_level := last_low[1]
    bos_sell_line := line.new(bar_index, bos_sell_level, bar_index + 1, bos_sell_level, color=color.fuchsia, style=line.style_solid, width=1)
    label.new(bar_index, bos_sell_level, "BOS", color=color.new(color.fuchsia, 90), textcolor=color.fuchsia, style=label.style_none, size=size.small)

if bos_buy
    line.delete(bos_buy_line)
    bos_buy_level := last_high[1]
    bos_buy_line := line.new(bar_index, bos_buy_level, bar_index + 1, bos_buy_level, color=color.teal, style=line.style_solid, width=1)
    label.new(bar_index, bos_buy_level, "BOS", color=color.new(color.teal, 90), textcolor=color.teal, style=label.style_none, size=size.small)

// Trendlinjer med bufferkontrol og AI-laser-look
var line sup = na
var line res = na

if barstate.islast
    float lowest_y2 = 60000
    int lowest_x2 = 0
    float highest_y2 = 0
    int highest_x2 = 0

    // Begræns lookback til max 2000 bars for at undgå bufferfejl
    int maxShortBars = math.min(math.min(shortTrendPeriod, bar_index), 2000)
    for i = 1 to maxShortBars
        if low[i] < lowest_y2
            lowest_y2 := low[i]
            lowest_x2 := i
        if high[i] > highest_y2
            highest_y2 := high[i]
            highest_x2 := i

    float lowest_y1 = 60000
    int lowest_x1 = 0
    float highest_y1 = 0
    int highest_x1 = 0

    // Begræns lookback til max 2000 bars for at undgå bufferfejl
    int maxLongBars = math.min(math.min(longTrendPeriod, bar_index), 2000)
    for j = shortTrendPeriod + 1 to maxLongBars
        if low[j] < lowest_y1
            lowest_y1 := low[j]
            lowest_x1 := j
        if high[j] > highest_y1
            highest_y1 := high[j]
            highest_x1 := j

    int trendStrength = trend_strength_raw
    if lowest_x1 > 0 and lowest_x2 > 0
        line.delete(sup)
        sup := line.new(int(bar_index - lowest_x1), lowest_y1, int(bar_index - lowest_x2), lowest_y2, extend=extend.right, style=line.style_dashed, width=2, color=trendStrength >= 1 ? (trendStrength >= 2 ? color.green : color.lime) : color.gray)
    if highest_x1 > 0 and highest_x2 > 0
        line.delete(res)
        res := line.new(int(bar_index - highest_x1), highest_y1, int(bar_index - highest_x2), highest_y2, extend=extend.right, style=line.style_dashed, width=2, color=trendStrength <= -1 ? (trendStrength <= -2 ? color.fuchsia : color.purple) : color.gray)

// Plot niveauer
plot(choch_sell_level, title="Last High at CHoCH", color=color.aqua, style=plot.style_circles, linewidth=1, trackprice=false)
plot(choch_buy_level, title="Last Low at CHoCH", color=color.lime, style=plot.style_circles, linewidth=1, trackprice=false)
plot(bos_sell_level, title="Last Low at BOS", color=color.fuchsia, style=plot.style_circles, linewidth=1, trackprice=false)
plot(bos_buy_level, title="Last High at BOS", color=color.teal, style=plot.style_circles, linewidth=1, trackprice=false)
plot(tp_sell_level, title="TP Sell", color=color.red, style=plot.style_circles, linewidth=1, trackprice=false)
plot(tp_buy_level, title="TP Buy", color=color.green, style=plot.style_circles, linewidth=1, trackprice=false)
plot(last_high, title="Last High", color=color.red, style=plot.style_histogram, linewidth=1, trackprice=true)
plot(last_low, title="Last Low", color=color.green, style=plot.style_histogram, linewidth=1, trackprice=true)

// AI Markedsanalyse - Beregn data uanset betingelse
momentum_1h = request.security(syminfo.tickerid, "60", close - close[3], lookahead=barmerge.lookahead_on)
momentum_4h = request.security(syminfo.tickerid, "240", close - close[3], lookahead=barmerge.lookahead_on)
momentum_d = request.security(syminfo.tickerid, "D", close - close[3], lookahead=barmerge.lookahead_on)

// Beregn ATR og SMA(ATR) for hver tidsramme
atr_1h = request.security(syminfo.tickerid, "60", ta.atr(14), lookahead=barmerge.lookahead_on)
atr_4h = request.security(syminfo.tickerid, "240", ta.atr(14), lookahead=barmerge.lookahead_on)
atr_d = request.security(syminfo.tickerid, "D", ta.atr(14), lookahead=barmerge.lookahead_on)
sma_atr_1h = request.security(syminfo.tickerid, "60", ta.sma(ta.atr(14), 20), lookahead=barmerge.lookahead_on)
sma_atr_4h = request.security(syminfo.tickerid, "240", ta.sma(ta.atr(14), 20), lookahead=barmerge.lookahead_on)
sma_atr_d = request.security(syminfo.tickerid, "D", ta.sma(ta.atr(14), 20), lookahead=barmerge.lookahead_on)

// Lokale ATR og SMA(ATR) som fallback
local_atr = ta.atr(14)
local_sma_atr = ta.sma(ta.atr(14), 20)

// Fallback for manglende data
volatility_1h = na(atr_1h) ? local_atr : atr_1h
volatility_4h = na(atr_4h) ? local_atr : atr_4h
volatility_d = na(atr_d) ? local_atr : atr_d
volatility_avg_1h = na(sma_atr_1h) ? local_sma_atr : sma_atr_1h
volatility_avg_4h = na(sma_atr_4h) ? local_sma_atr : sma_atr_4h
volatility_avg_d = na(sma_atr_d) ? local_sma_atr : sma_atr_d
momentum_1h := na(momentum_1h) ? 0 : momentum_1h
momentum_4h := na(momentum_4h) ? 0 : momentum_4h
momentum_d := na(momentum_d) ? 0 : momentum_d

// Analyse baseret på trend, momentum og volatilitet
score_1h = trend60 + (momentum_1h > 0 ? 0.5 : momentum_1h < 0 ? -0.5 : 0) + (volatility_1h > volatility_avg_1h ? 0.5 : 0)
score_4h = trend240 + (momentum_4h > 0 ? 0.5 : momentum_4h < 0 ? -0.5 : 0) + (volatility_4h > volatility_avg_4h ? 0.5 : 0)
score_d = trendD + (momentum_d > 0 ? 0.5 : momentum_d < 0 ? -0.5 : 0) + (volatility_d > volatility_avg_d ? 0.5 : 0)

// Forudsigelser
pred_1h = score_1h > 0.5 ? "Up" : score_1h < -0.5 ? "Down" : "Neutral"
pred_4h = score_4h > 0.5 ? "Up" : score_4h < -0.5 ? "Down" : "Neutral"
pred_d = score_d > 0.5 ? "Up" : score_d < -0.5 ? "Down" : "Neutral"

// Futuristisk AI-Trend Dashboard
var table trendTable = table.new(position.top_right, columns=2, rows=6, bgcolor=color.new(color.black, 50), border_width=2, border_color=color.new(color.teal, 20))
table.cell(trendTable, 0, 0, "AI-Trend Matrix v2.10", text_color=color.new(color.aqua, 0), bgcolor=color.new(color.navy, 60))
table.cell(trendTable, 1, 0, "", bgcolor=color.new(color.navy, 60))
table.merge_cells(trendTable, 0, 0, 1, 0)
table.cell(trendTable, 0, 1, "Trend Strength", text_color=color.white)
table.cell(trendTable, 1, 1, str.tostring(math.round(trend_strength)), text_color=trend_strength > 0 ? color.rgb(0, math.min(255, trend_strength * 2.55), 0) : color.rgb(math.min(255, math.abs(trend_strength) * 2.55), 0, 0))
table.cell(trendTable, 0, 2, "AI Confidence", text_color=color.white)
table.cell(trendTable, 1, 2, str.tostring(ai_confidence) + "%", text_color=color.teal)
table.cell(trendTable, 0, 3, "AI Calibration", text_color=color.white)
table.cell(trendTable, 1, 3, "CVD: " + str.tostring(math.round(raw_cvd)) + " (" + cvd_level + ")", text_color=cvd_color)
table.cell(trendTable, 0, 4, "1H", text_color=color.white)
table.cell(trendTable, 1, 4, trend60 == 1 ? "Up" : trend60 == -1 ? "Down" : "Neutral", text_color=trend60 == 1 ? color.lime : trend60 == -1 ? color.fuchsia : color.yellow)
table.cell(trendTable, 0, 5, "4H", text_color=color.white)
table.cell(trendTable, 1, 5, trend240 == 1 ? "Up" : trend240 == -1 ? "Down" : "Neutral", text_color=trend240 == 1 ? color.lime : trend240 == -1 ? color.fuchsia : color.yellow)

// Tabel for AI Markedsanalyse
if enable_ai_analysis
    var table ai_table = table.new(f_getTablePosition(ai_table_position), columns=4, rows=2, bgcolor=color.new(color.black, 50), border_width=2, border_color=color.new(color.teal, 20))
    table.cell(ai_table, 0, 0, "AI Market Analysis", text_color=color.new(color.aqua, 0), bgcolor=color.new(color.navy, 60))
    table.cell(ai_table, 1, 0, "1H", text_color=color.white)
    table.cell(ai_table, 2, 0, "4H", text_color=color.white)
    table.cell(ai_table, 3, 0, "1D", text_color=color.white)
    table.cell(ai_table, 0, 1, "Prediction", text_color=color.white)
    table.cell(ai_table, 1, 1, pred_1h, text_color=pred_1h == "Up" ? color.lime : pred_1h == "Down" ? color.fuchsia : color.yellow)
    table.cell(ai_table, 2, 1, pred_4h, text_color=pred_4h == "Up" ? color.lime : pred_4h == "Down" ? color.fuchsia : color.yellow)
    table.cell(ai_table, 3, 1, pred_d, text_color=pred_d == "Up" ? color.lime : pred_d == "Down" ? color.fuchsia : color.yellow)

// Debug alerts for null data
if na(ema60) or na(vwap60)
    alert("Warning: 60-minute timeframe data is null!", alert.freq_once_per_bar)
if na(ema240) or na(vwap240)
    alert("Warning: 240-minute timeframe data is null!", alert.freq_once_per_bar)
if na(emaD) or na(vwapD)
    alert("Warning: Daily timeframe data is null!", alert.freq_once_per_bar)