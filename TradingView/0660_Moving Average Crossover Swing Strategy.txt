//@version=6
// D Rocks Moving Average Crossover Strategy with Clouds v3
// ------------------------------------------
// Author: D_RockeFeller

// Overview:
//  This strategy combines multiple moving average crossovers and Ripster-inspired clouds (for visuals only) with MACD and further Moving Average confirmations to generate trade signals.
//  Features include adjustable moving average types and lengths, risk management settings, and ATR-based stop loss/take profit levels.
//  If you want to provide feedback, both constructive and supportive, please don't hesitate!


// { Script

strategy('D_Rock\'s MA Strategy', overlay = true, shorttitle = 'D_Rock\'s MA Strategy', initial_capital = 25000, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, pyramiding = 0, currency = currency.USD, calc_on_order_fills = false, commission_type = strategy.commission.cash_per_order, commission_value = .10, backtest_fill_limits_assumption = 0, slippage = 0)


// Variable to hold ATR at entry
var float entryATR = na

// User Settings {

// Risk and Trade Management Group
enablelong          = input.bool(true, title = 'Enable Long', tooltip = 'Choose which trade direction(s) to enable', group = 'Risk & Trade Management', inline = 'strat')
enableshort         = input.bool(false, title = 'Enable Short', tooltip = 'Choose which trade direction(s) to enable', group = 'Risk & Trade Management', inline = 'strat')
maxRiskPercent      = input.float(1.0, title = 'Max Risk % per Trade', group = 'Risk & Trade Management', step = 0.1, tooltip = 'Maximum risk allowed per trade as a percentage of total equity.')
equityPercent       = input.float(25.0, title = 'Equity Percentage for Position Sizing', group = 'Risk & Trade Management', step = 0.1, tooltip = 'Enter the same percentage as set in default_qty_value for consistent behavior.')
atrMultiplierSL     = input.float(1.4, title = 'ATR Multiplier for Stop Loss', tooltip = 'Calculated as \'Entry Price - (ATR * Multiplier)\'', group = 'Risk & Trade Management', step = 0.1)
atrMultiplierTP     = input.float(3.2, title = 'ATR Multiplier for Take Profit', tooltip = 'Calculated as \'Entry Price + (ATR * Multiplier)\'', group = 'Risk & Trade Management', step = 0.1)
atrLength           = input.int(14, title = 'ATR Length', tooltip = 'The amount of previous bars used to calculate ATR', group = 'Risk & Trade Management')

// Moving Averages Group
cloud1              = input.bool(true, title = 'Show Cloud-1', tooltip = 'Only toggles the cloud inbetween the 2 MAs. To toggle the lines, visit the \'Styles\' Tab!', group = 'Moving Averages Settings')
ma_1a_len           = input.int(5, title = 'MA 1a', tooltip = 'Cloud-1', group = 'Moving Averages Settings', inline = 'ma1')
ma_1b_len           = input.int(10, title = 'MA 1b', tooltip = 'Cloud-1', group = 'Moving Averages Settings', inline = 'ma2')
cloud2              = input.bool(true, title = 'Show Cloud-2', tooltip = 'Only toggles the cloud inbetween the 2 MAs. To toggle the lines, visit the \'Styles\' Tab!', group = 'Moving Averages Settings')
ma_2a_len           = input.int(5, title = 'MA 2a', tooltip = 'Cloud-2', group = 'Moving Averages Settings', inline = 'ma3')
ma_2b_len           = input.int(20, title = 'MA 2b', tooltip = 'Cloud-2', group = 'Moving Averages Settings', inline = 'ma4')
cloud3              = input.bool(false, title = 'Show Cloud-3', tooltip = 'Only toggles the cloud inbetween the 2 MAs. To toggle the lines, visit the \'Styles\' Tab!', group = 'Moving Averages Settings')
ma_3a_len           = input.int(50, title = 'MA 3a', tooltip = 'Cloud-3', group = 'Moving Averages Settings', inline = 'ma5')
ma_3b_len           = input.int(50, title = 'MA 3b', tooltip = 'Cloud-3', group = 'Moving Averages Settings', inline = 'ma6')
cloud4              = input.bool(false, title = 'Show Cloud-4', tooltip = 'Only toggles the cloud inbetween the 2 MAs. To toggle the lines, visit the \'Styles\' Tab!', group = 'Moving Averages Settings')
ma_4a_len           = input.int(100, title = 'MA 4a', tooltip = 'Cloud-4', group = 'Moving Averages Settings', inline = 'ma7')
ma_4b_len           = input.int(200, title = 'MA 4b', tooltip = 'Cloud-4', group = 'Moving Averages Settings', inline = 'ma8')
cloud5              = input.bool(false, title = 'Show Cloud-5', tooltip = 'Only toggles the cloud inbetween the 2 MAs. To toggle the lines, visit the \'Styles\' Tab!', group = 'Moving Averages Settings')
ma_5a_len           = input.int(500, title = 'MA 5a', tooltip = 'Cloud-5', group = 'Moving Averages Settings', inline = 'ma9')
ma_5b_len           = input.int(1000, title = 'MA 5b', tooltip = 'Cloud-5', group = 'Moving Averages Settings', inline = 'ma10')

ma_1a_type = input.string('EMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma1')
ma_1b_type = input.string('EMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma2')
ma_2a_type = input.string('EMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma3')
ma_2b_type = input.string('EMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma4')
ma_3a_type = input.string('EMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma5')
ma_3b_type = input.string('SMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma6')
ma_4a_type = input.string('SMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma7')
ma_4b_type = input.string('SMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma8')
ma_5a_type = input.string('SMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma9')
ma_5b_type = input.string('SMA', title = 'Type', options = ['EMA', 'SMA', 'WMA'], group = 'Moving Averages Settings', inline = 'ma10')

// Additional MA Group
src = input.source(close, title = 'MA Source', group = 'Additional Moving Averages Settings', inline = 'src')
showVWAP = input.bool(true, title = 'Show VWAP on intraday?', group = 'Additional Moving Averages Settings')
isIntraday = timeframe.isintraday
VWAPvalue = ta.vwap
plot(showVWAP and isIntraday ? VWAPvalue : na, title="VWAP", color=color.orange, linewidth=2)

//ma_offset = input.int(0, title = 'MA Offset', group = 'Additional Moving Averages Settings', inline = 'src')
//cloudleading = input.int(0, minval = 0, title = 'Leading Period For the Clouds', tooltip = 'Adjust the leading period for the clouds', group = 'Additional Moving Averages Settings')

// Signal Choices
fastsiginput = input.string(defval = 'MA 1a', title = 'Fast Leading MA', tooltip = 'Signal is when Fast MA crosses the Medium MA, either up & over(longs) or down & under(shorts)', options = ['MA 1a', 'MA 1b', 'MA 2a', 'MA 2b', 'MA 3a', 'MA 3b', 'MA 4a', 'MA 4b', 'MA 5a', 'MA 5b'], group = 'Signal Choices')
medsiginput = input.string(defval = 'MA 1b', title = 'Medium Crossing MA', tooltip = 'Signal is when Fast MA crosses the Medium MA, either up & over(longs) or down & under(shorts)', options = ['MA 1a', 'MA 1b', 'MA 2a', 'MA 2b', 'MA 3a', 'MA 3b', 'MA 4a', 'MA 4b', 'MA 5a', 'MA 5b'], group = 'Signal Choices')
enableSlow = input.bool(defval = true, title = 'Enable Slow MA Confirmation', tooltip = 'Check if the bar closed above(below for shorts) the Slow MA for an additional entry condition', group = 'Confirmation Choices', inline = 'slow')
slowsiginput = input.string(defval = 'MA 2b', title = '', tooltip = 'If selected, this MA will be used as additional entry confirmation on candle close', options = ['MA 1a', 'MA 1b', 'MA 2a', 'MA 2b', 'MA 3a', 'MA 3b', 'MA 4a', 'MA 4b', 'MA 5a', 'MA 5b'], group = 'Confirmation Choices', inline = 'slow')

// Inputs for MACD
enablemacd = input.bool(true, title = 'MACD Confirmation & Cross Relation', tooltip = 'Checks if the MACD value crosses over (long) or under (short) the MACD Avg on the same bar as the MA Cross Signal above.', group = 'Confirmation Choices', inline = 'macd')
macdzeroline = input.string('Either', title = '', options = ['Above', 'Under', 'Either'], tooltip = 'If selected, the MACD is used as confirmation and then determines if the MACD cross should occur above, below, or indifferent to the zero line.', group = 'Confirmation Choices', inline = 'macd')
macdFastLength = input.int(12, title = 'MACD Fast', tooltip = 'Length of the fast line in MACD calculation.', group = 'Confirmation Choices')
macdSlowLength = input.int(26, title = 'MACD Slow', tooltip = 'Length of the slow line in MACD calculation.', group = 'Confirmation Choices')
macdSigSmooth = input.int(9, title = 'MACD Signal', tooltip = 'Smoothing factor for the MACD signal line.', group = 'Confirmation Choices')
macdSource = input.source(close, title = 'MACD Source', tooltip = 'Price input for MACD calculation.', group = 'Confirmation Choices')
macdsmaSource = input.bool(false, title = 'Simple MA (Oscillator)', tooltip = 'Use SMA instead of EMA for the oscillator line in MACD.', group = 'Confirmation Choices', inline = 'macd2')
macdsmaSignal = input.bool(false, title = 'Simple MA (Signal Line)', tooltip = 'Use SMA instead of EMA for the oscillator or signal line in MACD.', group = 'Confirmation Choices', inline = 'macd2')

//Exit Criteria
enableCrossExit = input.bool(defval = true, title = 'Enable MA Cross Exit', tooltip = 'Further exit criteria. It will exit early if the Fast MA crosses the Medium MA (under for longs, over for shorts), suggesting a possible reversal.', group = 'Exit Criteria')
fastexitinput = input.string(defval = 'MA 1a', title = 'Fast Exit Leading MA', options = ['MA 1a', 'MA 1b', 'MA 2a', 'MA 2b', 'MA 3a', 'MA 3b', 'MA 4a', 'MA 4b', 'MA 5a', 'MA 5b'], group = 'Exit Criteria')
medexitinput = input.string(defval = 'MA 1b', title = 'Medium Exit Crossing MA', options = ['MA 1a', 'MA 1b', 'MA 2a', 'MA 2b', 'MA 3a', 'MA 3b', 'MA 4a', 'MA 4b', 'MA 5a', 'MA 5b'], group = 'Exit Criteria')
enableBarsExit = input.bool(defval = true, title = 'Max Bars in Trades: ', tooltip = 'Closes the position after a set number of bars.', group = 'Exit Criteria', inline = 'mb')
maxBarsInTrade = input.int(defval = 8, title = '', tooltip = 'If selected, specify the maximum number of bars (days) for all trades to be open. If the position does not reach or meet any other exit criteria by the end of the final bar, the position will close at the opening price of the next bar.', group = 'Exit Criteria', inline = 'mb')


// } End User Settings

// { Calculate MAs

// Function to calculate MA's
f_ma(type, src, length) =>
    float result = na
    if type == 'SMA'
        result := ta.sma(src, length)
    else if type == 'WMA'
        result := ta.wma(src, length)
    else
        result := ta.ema(src, length)
    result

// Using the MA Function
ma_1a = f_ma(ma_1a_type, src, ma_1a_len)
ma_1b = f_ma(ma_1b_type, src, ma_1b_len)
ma_2a = f_ma(ma_2a_type, src, ma_2a_len)
ma_2b = f_ma(ma_2b_type, src, ma_2b_len)
ma_3a = f_ma(ma_3a_type, src, ma_3a_len)
ma_3b = f_ma(ma_3b_type, src, ma_3b_len)
ma_4a = f_ma(ma_4a_type, src, ma_4a_len)
ma_4b = f_ma(ma_4b_type, src, ma_4b_len)
ma_5a = f_ma(ma_5a_type, src, ma_5a_len)
ma_5b = f_ma(ma_5b_type, src, ma_5b_len)

// Determine signal MA's based on user choices
fastsig = switch fastsiginput
    'MA 1a' => ma_1a
    'MA 2a' => ma_2a
    'MA 3a' => ma_3a
    'MA 4a' => ma_4a
    'MA 5a' => ma_5a
    'MA 1b' => ma_1b
    'MA 2b' => ma_2b
    'MA 3b' => ma_3b
    'MA 4b' => ma_4b
    'MA 5b' => ma_5b

medsig = switch medsiginput
    'MA 1a' => ma_1a
    'MA 2a' => ma_2a
    'MA 3a' => ma_3a
    'MA 4a' => ma_4a
    'MA 5a' => ma_5a
    'MA 1b' => ma_1b
    'MA 2b' => ma_2b
    'MA 3b' => ma_3b
    'MA 4b' => ma_4b
    'MA 5b' => ma_5b

slowsig = switch slowsiginput
    'MA 1a' => ma_1a
    'MA 2a' => ma_2a
    'MA 3a' => ma_3a
    'MA 4a' => ma_4a
    'MA 5a' => ma_5a
    'MA 1b' => ma_1b
    'MA 2b' => ma_2b
    'MA 3b' => ma_3b
    'MA 4b' => ma_4b
    'MA 5b' => ma_5b

fastexitma = switch fastexitinput
    'MA 1a' => ma_1a
    'MA 2a' => ma_2a
    'MA 3a' => ma_3a
    'MA 4a' => ma_4a
    'MA 5a' => ma_5a
    'MA 1b' => ma_1b
    'MA 2b' => ma_2b
    'MA 3b' => ma_3b
    'MA 4b' => ma_4b
    'MA 5b' => ma_5b

medexitma = switch medexitinput
    'MA 1a' => ma_1a
    'MA 2a' => ma_2a
    'MA 3a' => ma_3a
    'MA 4a' => ma_4a
    'MA 5a' => ma_5a
    'MA 1b' => ma_1b
    'MA 2b' => ma_2b
    'MA 3b' => ma_3b
    'MA 4b' => ma_4b
    'MA 5b' => ma_5b

// } End Calculate MAs



// MACD calculation
zeroline = 0
macdFastMA = macdsmaSource ? ta.sma(macdSource, macdFastLength) : ta.ema(macdSource, macdFastLength)
macdSlowMA = macdsmaSource ? ta.sma(macdSource, macdSlowLength) : ta.ema(macdSource, macdSlowLength)
macdValue = macdFastMA - macdSlowMA
macdSignal = macdsmaSignal ? ta.sma(macdValue, macdSigSmooth) : ta.ema(macdValue, macdSigSmooth)
macdHist = macdValue - macdSignal
macdCrossOver = ta.crossover(macdValue, macdSignal)
macdCrossUnder = ta.crossunder(macdValue, macdSignal)
macdAboveZero = macdValue > zeroline
macdBelowZero = macdValue < zeroline

// Calculate Entry Signals & Confirmations
longCross = ta.crossover(fastsig, medsig)
shortCross = ta.crossunder(fastsig, medsig)
longCrossExit = ta.crossunder(fastexitma, medexitma)
shortCrossExit = ta.crossover(fastexitma, medexitma)
slowConfirmLong = close > slowsig
slowConfirmShrt = close < slowsig
macdLongSig = longCross and macdCrossOver and (macdzeroline == 'Above' and macdAboveZero or macdzeroline == 'Under' and macdBelowZero or macdzeroline == 'Either')
macdShortSig = shortCross and macdCrossUnder and (macdzeroline == 'Above' and macdAboveZero or macdzeroline == 'Under' and macdBelowZero or macdzeroline == 'Either')



// Strategy Entry Conditions
confirmLong1 = slowConfirmLong
confirmLong2 = macdLongSig

longcombo1 = confirmLong1 and confirmLong2
longcombo2 = confirmLong1
longcombo3 = confirmLong2

confirmShort1 = slowConfirmShrt
confirmShort2 = macdShortSig

shortcombo1 = confirmShort1 and confirmShort2
shortcombo2 = confirmShort1
shortcombo3 = confirmShort2

//Strategy Buy Long
enterlong = false
if enablelong == true and longCross and enableSlow == true and enablemacd == true and longcombo1 and strategy.opentrades < 1
    enterlong := longCross and longcombo1
    enterlong
if enablelong == true and longCross and enableSlow == true and enablemacd == false and longcombo2 and strategy.opentrades < 1
    enterlong := longCross and longcombo2
    enterlong
if enablelong == true and longCross and enableSlow == false and enablemacd == true and longcombo3 and strategy.opentrades < 1
    enterlong := longCross and longcombo3
    enterlong
if enablelong == true and longCross and enableSlow == false and enablemacd == false and strategy.opentrades < 1
    enterlong := longCross
    enterlong

//Strategy Buy Short
entershort = false
if enableshort == true and shortCross and enableSlow == true and enablemacd == true and shortcombo1 and strategy.opentrades < 1
    entershort := shortCross and shortcombo1
    entershort
if enableshort == true and shortCross and enableSlow == true and enablemacd == false and shortcombo2 and strategy.opentrades < 1
    entershort := shortCross and shortcombo2
    entershort
if enableshort == true and shortCross and enableSlow == false and enablemacd == true and shortcombo3 and strategy.opentrades < 1
    entershort := shortCross and shortcombo3
    entershort
if enableshort == true and shortCross and enableSlow == false and enablemacd == false and strategy.opentrades < 1
    entershort := shortCross
    entershort


// Count number of bars since entry conditions
barCountLong = ta.barssince(enterlong)
barCountShort = ta.barssince(entershort)
longBarExit = barCountLong >= maxBarsInTrade
shortBarExit = barCountShort >= maxBarsInTrade

// ATR calculation
atr = ta.atr(atrLength) // Current ATR
if enterlong or entershort
    entryATR := atr
    entryATR

// Risk calculation -
riskPerShare = atr * atrMultiplierSL
maxRiskCash = strategy.equity * (maxRiskPercent / 100)
qtyRiskBased = maxRiskCash / riskPerShare
qtyEquityBased = strategy.equity * (equityPercent / 100) / close
finalQty = math.min(qtyRiskBased, qtyEquityBased) // Dynamic usage

// Variables to track trade counts
var int lgcount = 0 // Long trades
var int stcount = 0 // Short trades
var int tpcount = 0 // Take Profit exits (not yet available)
var int slcount = 0 // Stop Loss exits (not yet available)
var int lmcount = 0 // Counting each trade that exits via SL or TP. Currently the workaround for being unable to count each individually
var int crcount = 0 // Cross exits count (if enabled)
var int mbcount = 0 // Max bars exits (if enabled)

// Strategy Enter trades
if enterlong and enablelong
    lgcount := lgcount + 1
    strategy.entry('LONG', strategy.long, qty = finalQty)

if entershort and enableshort
    strategy.entry('SHORT', strategy.short, qty = finalQty)
    stcount := stcount + 1
    stcount


// Strategy Exit Long trades
if enablelong and strategy.position_size > 0
    longSLprice = strategy.position_avg_price - entryATR * atrMultiplierSL
    longTPprice = strategy.position_avg_price + entryATR * atrMultiplierTP
    longSLexit = close <= longSLprice
    longTPexit = close >= longTPprice
    longSize = strategy.position_size
    lngEntryBar = strategy.opentrades.entry_bar_index(0) // Identify the entry bar for proper label placement

    if enableCrossExit == true and longCrossExit
        strategy.close_all('Long Cross Exit')
        crcount := crcount + 1
        crcount
    else if enableBarsExit == true and longBarExit
        strategy.close_all('Long MaxBars Exit')
        mbcount := mbcount + 1
        mbcount
    else
        strategy.exit('Long SL/TP Exit', qty_percent = 100, from_entry = 'LONG', stop = longSLprice, limit = longTPprice) // Stop loss and Take profit in one exit line
        lmcount := lmcount + 1 // Workaround to count both stop loss and take profit exits in one. Cannot crack how to seperate these to count properly yet. If anyone knows LMK!
        lmcount

    // Position Label - This can be turned off in the Style tab
    longLabel = label.new(lngEntryBar, low, color = color.new(color.navy, 95), textcolor = color.new(color.blue, 0), style = label.style_arrowup, yloc = yloc.belowbar, textalign = text.align_center, size = size.normal)
    label.set_text(id = longLabel, text = '' + '\n' + '' + '\n' + 'Entry: ' + str.tostring(strategy.position_avg_price, format.mintick) + '\n' + 'ATR: ' + str.tostring(entryATR, format.mintick) + '\n' + 'TP: ' + str.tostring(longTPprice, format.mintick) + '\n' + 'SL: ' + str.tostring(longSLprice, format.mintick) + '\n' + 'Size: ' + str.tostring(longSize))


// Strategy Exit Short Trades
if enableshort and strategy.position_size < 0
    shortSLprice = strategy.position_avg_price + entryATR * atrMultiplierSL
    shortTPprice = strategy.position_avg_price - entryATR * atrMultiplierTP
    shortSLexit = close <= shortSLprice
    shortTPexit = close >= shortTPprice
    shortSize = strategy.position_size
    srtEntryBar = strategy.opentrades.entry_bar_index(0) // Identify the entry bar for proper label placement

    if enableCrossExit == true and shortCrossExit
        strategy.close_all('Short Cross Exit')
        crcount := crcount + 1
        crcount
    else if enableBarsExit == true and shortBarExit
        strategy.close_all('Short MaxBars Exit')
        mbcount := mbcount + 1
        mbcount
    else
        strategy.exit('Short SL/TP Exit', qty_percent = 100, from_entry = 'SHORT', stop = shortSLprice, limit = shortTPprice) // Stop loss and Take profit in one exit line
        lmcount := lmcount + 1 // Workaround to count both stop loss and take profit exits in one. Cannot crack how to seperate these to count properly yet. If anyone knows LMK!
        lmcount

    // Position Label - This can be turned off in the Style tab
    shortLabel = label.new(srtEntryBar, low, color = color.new(color.maroon, 90), textcolor = color.new(color.maroon, 0), style = label.style_triangledown, yloc = yloc.abovebar, size = size.normal)
    label.set_text(id = shortLabel, text = 'Entry Price: ' + str.tostring(strategy.position_avg_price, format.mintick) + '\n' + 'ATR: ' + str.tostring(entryATR, format.mintick) + '\n' + 'TP: ' + str.tostring(shortTPprice, format.mintick) + '\n' + 'SL: ' + str.tostring(shortSLprice, format.mintick) + '\n' + 'Size: ' + str.tostring(shortSize) + '\n' + '' + '\n' + '' + '\n')



// Calculate trades and exit couts
totalTrades = lgcount + stcount

// percentExitSL   = slcount > 0 ? (tpcount / totalTrades) * 100 : na  // Percentage of trades exited via SL only (currently not functioning)
// percentExitTP   = tpcount > 0 ? (tpcount / totalTrades) * 100 : na  // Percentage of trades exited via TP only (currently not functioning)
percentExitLM = lmcount > 0 ? lmcount / totalTrades * 100 : na // Percentage of trades exited via SL or TP
percentExitCR = crcount > 0 ? crcount / totalTrades * 100 : na // Percentage of trades exited via Cross Exit (if enabled)
percentExitMB = mbcount > 0 ? mbcount / totalTrades * 100 : na // Percentage of trades exited via Max Bars Exit (if enabled)
percentLongTr = lgcount > 0 ? lgcount / totalTrades * 100 : na // Percentage of Long trades taken (if both are enabled)
percentShrtTr = stcount > 0 ? stcount / totalTrades * 100 : na // Percentage of Short trades taken (if both are enabled)


// Visualizations
// ----------------------------------------------------------------

// Create a table - This can be turned off in the Style tab
var table displayTable = table.new(position.top_right, 5, 3, bgcolor = color.new(color.white, 25), border_color = color.new(color.gray, 0), border_width = 1, frame_color = color.new(color.gray, 0), frame_width = 2)

// Populate the table
table.cell(displayTable, 0, 0, 'Long Trades', text_color = color.new(color.teal, 0))
table.cell(displayTable, 0, 1, str.tostring(lgcount, format.volume), text_color = color.new(color.black, 0))
table.cell(displayTable, 0, 2, str.tostring(percentLongTr, format.percent), text_color = color.new(color.black, 0))
table.cell(displayTable, 1, 0, 'Short Trades', text_color = color.new(color.maroon, 0))
table.cell(displayTable, 1, 1, str.tostring(stcount, format.volume), text_color = color.new(color.black, 0))
table.cell(displayTable, 1, 2, str.tostring(percentShrtTr, format.percent), text_color = color.new(color.black, 0))
table.cell(displayTable, 2, 0, 'Cross Exit', text_color = color.new(color.purple, 0))
table.cell(displayTable, 2, 1, str.tostring(crcount, format.volume), text_color = color.new(color.black, 0))
table.cell(displayTable, 2, 2, str.tostring(percentExitCR, format.percent), text_color = color.new(color.black, 0))
table.cell(displayTable, 3, 0, 'Bars Exit', text_color = color.new(color.blue, 0))
table.cell(displayTable, 3, 1, str.tostring(mbcount, format.volume), text_color = color.new(color.black, 0))
table.cell(displayTable, 3, 2, str.tostring(percentExitMB, format.percent), text_color = color.new(color.black, 0))

// Plot entry signals
plotshape(enterlong, style = shape.triangleup, location = location.belowbar, color = color.lime, size = size.normal)
plotshape(entershort, style = shape.triangledown, location = location.abovebar, color = color.fuchsia, size = size.normal)


// { Clouds & Plots. Clouds are simply used for a visualization effect

// Set the Default Colors
cloudcolour1 = ma_1a >= ma_1b ? color.new(#5b9cf6, 80) : color.new(#9575cd, 80)
cloudcolour2 = ma_2a >= ma_2b ? color.new(#5b9cf6, 80) : color.new(#9575cd, 80)
cloudcolour3 = ma_3a >= ma_3b ? color.new(#009688, 80) : color.new(#f06292, 80)
cloudcolour4 = ma_4a >= ma_4b ? color.new(#ffffff, 80) : color.new(#9575cd, 80)
cloudcolour5 = ma_5a >= ma_5b ? color.new(#036103, 80) : color.new(#880e4f, 80)


mashortcolor1 = ma_1a >= ma_1a[1] ? color.new(color.yellow, 0) : color.new(color.yellow, 0)
malongcolor1 = ma_1b >= ma_1b[1] ? color.new(color.purple, 0) : color.new(color.purple, 0)

mashortcolor2 = ma_2a >= ma_2a[1] ? color.new(color.teal, 0) : color.new(color.teal, 0)
malongcolor2 = ma_2b >= ma_2b[1] ? color.new(color.blue, 0) : color.new(color.blue, 0)

mashortcolor3 = ma_3a >= ma_3a[1] ? color.new(#1848cc, 0) : color.new(#1848cc, 0)
malongcolor3 = ma_3b >= ma_3b[1] ? color.new(#5b9cf6, 0) : color.new(#5b9cf6, 0)

mashortcolor4 = ma_4a >= ma_4a[1] ? color.new(#801922, 0) : color.new(#801922, 0)
malongcolor4 = ma_4b >= ma_4b[1] ? color.new(color.white, 0) : color.new(color.white, 0)

mashortcolor5 = ma_5a >= ma_5a[1] ? color.new(color.gray, 0) : color.new(color.gray, 0)
malongcolor5 = ma_5b >= ma_5b[1] ? color.new(color.olive, 0) : color.new(color.olive, 0)

// Plots and names organized for better visual display on the "Styles" tab
ma_1a_line = plot(ma_1a, color = mashortcolor1, linewidth = 1, display = display.none, title = 'MA 1a')
ma_1b_line = plot(ma_1b, color = malongcolor1, linewidth = 1, display = display.none, title = 'MA 1b')
fill(ma_1a_line, ma_1b_line, color = cloud1 ? cloudcolour1 : na, title = 'MA Cloud1')

ma_2a_line = plot(ma_2a, color = mashortcolor2, linewidth = 1, display = display.none, title = 'MA 2a')
ma_2b_line = plot(ma_2b, color = malongcolor2, linewidth = 2,display = display.none, title = 'MA 2b')
fill(ma_2a_line, ma_2b_line, color = cloud2 ? cloudcolour2 : na, title = 'MA Cloud2')

ma_3a_line = plot(ma_3a, color = mashortcolor3, linewidth = 2, display = display.all, title = 'MA 3a')
ma_3b_line = plot(ma_3b, color = malongcolor3, linewidth = 2, display = display.none, title = 'MA 3b')
fill(ma_3a_line, ma_3b_line, color = cloud3 ? cloudcolour3 : na, title = 'MA Cloud3')

ma_4a_line = plot(ma_4a, color = mashortcolor4, linewidth = 2, display = display.all, title = 'MA 4a')
ma_4b_line = plot(ma_4b, color = malongcolor4, linewidth = 2, display = display.all, title = 'MA 4b')
fill(ma_4a_line, ma_4b_line, color = cloud4 ? cloudcolour4 : na, title = 'MA Cloud4')

ma_5a_line = plot(ma_5a, color = mashortcolor5, linewidth = 2, display = display.none, title = 'MA 5a')
ma_5b_line = plot(ma_5b, color = malongcolor5, linewidth = 2, display = display.none, title = 'MA 5b')
fill(ma_5a_line, ma_5b_line, color = cloud5 ? cloudcolour5 : na, title = 'MA Cloud5')

// } End Clouds & Plots

// } End Script