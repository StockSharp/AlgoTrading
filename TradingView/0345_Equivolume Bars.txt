// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© rumpypumpydumpy

//@version=4
study("Equivolume Bars", overlay = true, max_boxes_count = 500, scale = scale.right)

num_boxes =     input(165, title = "Number of equivolume boxes to display", maxval = 165, tooltip = "Maximum 165")
lb =            input(60, title = "Volume lookback", tooltip = "Number of bars to sum")
full_width =    input(500, title = "Full width in number of bars", tooltip = "Width where current bar's volume = sum of volume lookback\nHigher values result in less rounding with the trade off of using more chart space")
up_col =        input(color.white, title = "Up bar color")
dn_col =        input(color.blue, title = "Down bar color")
hl_col =        input(color.gray, title = "Wick color")
border_col =    input(color.rgb(255, 255, 255, 66), title = "Border color")
top_perc =    input(8, title = "Top margin %")
bottom_perc = input(20, title = "Bottom margin %")



// -----------------------------------------------------------------------------
// Equivolume Calculation
// -----------------------------------------------------------------------------
float   sum_volume =    sum(volume, lb)
float   ratio =         volume / sum_volume[1]
int     width =         max(round(ratio * full_width), 1) // Determines width of equivolume box in bars
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Current live bar
// -----------------------------------------------------------------------------
var box current_body =  box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col)
var box current_high =  box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col, bgcolor = hl_col)
var box current_low =   box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col, bgcolor = hl_col)

box.set_lefttop(current_body,       left = bar_index,           top = max(close,open))
box.set_rightbottom(current_body,   right = bar_index + width,  bottom = min(close, open))

box.set_bgcolor(current_body,       color = close >= open ? up_col : dn_col)

box.set_lefttop(current_high,       left = bar_index,           top = high)
box.set_rightbottom(current_high,   right = bar_index + width,  bottom = max(close, open))

box.set_lefttop(current_low,        left = bar_index,           top = min(close, open))
box.set_rightbottom(current_low,    right = bar_index + width,  bottom = low)
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Historical bars
// -----------------------------------------------------------------------------

// Historical bar values
var float[] historical_body_tops = array.new_float(num_boxes)
var float[] historical_body_bottoms = array.new_float(num_boxes)
var float[] historical_highs = array.new_float(num_boxes)
var float[] historical_lows = array.new_float(num_boxes)
var bool[]  historical_direction = array.new_bool(num_boxes)
var int[]   historical_widths = array.new_int(num_boxes)

// Historical equivolume boxes
var box[]   historical_bodies = array.new_box(na)
var box[]   historical_high_wicks = array.new_box(na)
var box[]   historical_low_wicks = array.new_box(na)

// Initialize historical box arrays
if barstate.isfirst
    for i = 0 to num_boxes - 1
        array.unshift(historical_bodies,        box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col))
        array.unshift(historical_high_wicks,    box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col, bgcolor = hl_col))
        array.unshift(historical_low_wicks,     box.new(left = na, top = na, right = na, bottom = na, border_width = 1, border_color = border_col, bgcolor = hl_col))

// Once the current live bar is on it's last update
if barstate.isconfirmed
    // Add the latest bar's values to historical arrays and remove the oldest
    array.unshift(historical_body_tops, max(open, close)),      array.pop(historical_body_tops)
    array.unshift(historical_body_bottoms, min(open, close)),   array.pop(historical_body_bottoms)
    array.unshift(historical_highs, high),                      array.pop(historical_highs)
    array.unshift(historical_lows, low),                        array.pop(historical_lows)
    array.unshift(historical_direction, close >= open),         array.pop(historical_direction)
    array.unshift(historical_widths, width),                    array.pop(historical_widths)

    int offset = 0 // used to track the starting bar_index for subsequent historical bars

    for i = 0 to num_boxes - 1
        // Ensure we don't try and draw on a negative bar index
        if offset < bar_index
            // get values for historical bar : i
            high_box =  array.get(historical_high_wicks, i)
            low_box =   array.get(historical_low_wicks, i)
            body_box =  array.get(historical_bodies, i)
            box_width = array.get(historical_widths, i)

            left_index =    bar_index - offset - box_width
            right_index =   bar_index - offset

            body_top_val =      array.get(historical_body_tops, i)
            body_bottom_val =   array.get(historical_body_bottoms, i)
            high_val =          array.get(historical_highs, i)
            low_val =           array.get(historical_lows, i)
            up_bar =            array.get(historical_direction, i)

            //update offset for next historical bar
            offset := offset + box_width + 1

            // adjust box properties for historical bar
            box.set_lefttop(body_box, left = left_index, top = body_top_val)
            box.set_rightbottom(body_box, right = right_index, bottom = body_bottom_val)
            box.set_bgcolor(body_box, color = up_bar ? up_col : dn_col)

            box.set_lefttop(high_box, left = left_index, top = high_val)
            box.set_rightbottom(high_box, right = right_index, bottom = body_top_val)

            box.set_lefttop(low_box, left = left_index, top = body_bottom_val)
            box.set_rightbottom(low_box, right = right_index, bottom = low_val)
        else
            break
// -----------------------------------------------------------------------------



// -----------------------------------------------------------------------------
// Setup margin lines
// -----------------------------------------------------------------------------

var line top_margin_line = line.new(x1 = na, y1 = na, x2 = na, y2 = na, extend = extend.both, color = color.rgb(0, 0, 0, 100))
var line bottom_margin_line = line.new(x1 = na, y1 = na, x2 = na, y2 = na, extend = extend.both, color = color.rgb(0, 0, 0, 100))

hh = highest(high, num_boxes)
ll = lowest(low, num_boxes)
range = hh - ll
bars_perc = 100 - top_perc - bottom_perc
interval = range / bars_perc
top_margin = hh + interval * top_perc
bottom_margin = ll - interval * bottom_perc

line.set_xy1(top_margin_line, x = bar_index, y = top_margin)
line.set_xy2(top_margin_line, x = bar_index + 1, y = top_margin)
line.set_xy1(bottom_margin_line, x = bar_index, y = bottom_margin)
line.set_xy2(bottom_margin_line, x = bar_index + 1, y = bottom_margin)