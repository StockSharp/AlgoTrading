//@version=4
//@author=LucF

// Delta Volume Realtime Action [LucF]
//  v12, 2022.12.30 14:12 â€” LucF

// Displays realtime, on-chart, volume and ticks delta information for trading on small timeframes. It replaces the chart's candles.

// This code was written using:
//  â€¢ The PineCoders Coding Conventions for Pine: http://www.pinecoders.com/coding_conventions/
//  â€¢ Code inspired by the PineCoders publication on `varip`: https://www.tradingview.com/script/ppQxBISk-Using-varip-variables-PineCoders/

// This indicator's page on TV: https://www.tradingview.com/script/Xh8tLDTe-Delta-Volume-Realtime-Action-LucF/


study("Delta Volume Realtime Action [LucF]", "Delta Volume Realtime Action", true, max_labels_count = 500, max_lines_count = 500)



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Constants {

// Input options.
var string ON  = "On"
var string OFF = "Off"

var string TD1 = "Up"
var string TD2 = "Down"
var string TD3 = "Up and Down"

var string TT_DIRECTIONS = "These settings allow you to filter the marker events you have selected in the section below.
  The filters you apply here will determine which markers trigger alerts.\nâ–º You can safely disregard the warning that will appear when you create alerts."
var string TT_CONDITIONS_LIST = "  1  â€“  Bar up/dn\n  2  â€“ `close` rises/falls\n  3  â€“  DV +/â€“\n  4  â€“  DV% rises\n  5  â€“  POC rises/falls\n  6  â€“
  Total ticks rises\n  7  â€“  DV > limit\n  8  â€“  DV% > limit\n  9  â€“  DV+ rises / DVâ€“ falls\n  10 â€“  Two consecutive DV+/DV-\n  11 â€“
  Total volume rises\n  12 â€“  DT +/â€“\n  13 â€“  DT% rises\n  14 â€“  DT+ rises / DTâ€“ falls\nSee the script's description for more information."
var string TT_STRONGBAR  = "Enter the number of each condition you require for a 'strong bar', separated by a comma, e.g., '1,4,8,11':\n"  + TT_CONDITIONS_LIST
var string TT_CONDITIONS = "Enter the number of each condition you require for the marker to trigger, separated by a comma, e.g., '1,4,8,11':\n" + TT_CONDITIONS_LIST

// Color constants.
var color C_GREEN       = #008000ff
var color C_LIME        = #00FF00ff
var color C_TEAL        = color.teal
var color C_MAROON      = #800000ff
var color C_PINK        = #FF0080ff
var color C_BAR_RED     = #EF5350
var color C_DK_RED      = #C90707
var color C_ORANGE      = #FF8000ff
var color C_DK_ORANGE   = #CE6F0F
var color C_GRAY        = #808080ff
var color C_DK_GRAY     = #434650ff
var color C_SILVER      = color.silver
// }



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Inputs {

var string GP1 = "Volume Delta (DV is below bar)"
bool    i_showDv            = input(true,           "Show volume delta",                                inline = "10", group = GP1)
bool    i_showDvVolRises    = input(true,           "With â–²â–¼",                                          inline = "10", group = GP1, tooltip = "When selected, on bars with increasing DV+ or falling DVâ€“, â–²/â–¼ will appear to the right of the delta volume value. It's the same as condition 9.")
bool    i_showTotalVolume   = input(true,           "Show total volume",                                inline = "11", group = GP1)
bool    i_showTotVolRises   = input(true,           "With â–²â–¼",                                          inline = "11", group = GP1, tooltip = "When selected, on up/dn bars with increasing total volume, â–²/â–¼ will appear to the right of the total volume value. It's the same as condition 11.")
bool    i_showDvPercent     = input(true,           "Show DV as % of total volume",                     inline = "12", group = GP1)
bool    i_showDvPctRises    = input(true,           "With â–²â–¼",                                          inline = "12", group = GP1, tooltip = "When selected, on up/dn bars with increasing DV%, â–²/â–¼ will appear to the right of the DV% value. It's the same as condition 4.")
bool    i_showDvValueSeps   = input(true,           "Show separators between values",                   group = GP1)
int     i_dvQtyOfValues     = input(50,             "Visible elapsed values",                           inline = "13", minval = 0, maxval = 245, group = GP1, tooltip = "0-245. Use only as many as you need for optimal chart speed.")
string  i_dvTextSize        = input("small",        "Text Size",                                        inline = "14", options = ["tiny", "small", "normal", "large", "huge", "auto"], group = GP1)
int     i_showDVPrec        = input(0,              "Precision of volume values",                       inline = "14", minval = 0, group = GP1)
color   i_c_dvBull          = input(C_GREEN,        "ðŸ¡‘",                                                inline = "15", group = GP1)
color   i_c_dvBear          = input(C_DK_RED,       "ðŸ¡“",                                                inline = "15", group = GP1)
bool    i_showDvDiv         = input(ON,             "Divergences",                                      inline = "15", options = [OFF, ON], group = GP1) == ON
color   i_c_dvDiv           = input(C_DK_ORANGE,    "",                                                 inline = "15", group = GP1, tooltip = "A divergence occurs when the polarity of delta volume does not match the direction of the bar.")

var string GP2 = "Ticks Delta (DT is above bar)"
bool    i_showDt            = input(true,           "Show ticks delta",                                 inline = "20", group = GP2)
bool    i_showDtVolRises    = input(true,           "With â–²â–¼",                                          inline = "20", group = GP2, tooltip = "When selected, on bars with increasing DT+ or falling DTâ€“, â–²/â–¼ will appear to the right of the delta ticks value. It's the same as condition 14.")
bool    i_showTotalTicks    = input(true,           "Show total ticks",                                 inline = "21", group = GP2)
bool    i_showTotTicksRises = input(true,           "With â–²â–¼",                                          inline = "21", group = GP2, tooltip = "When selected, on up/dn bars with increasing total ticks, â–²/â–¼ will appear to the right of the total ticks value. It's the same as condition 6.")
bool    i_showDtPercent     = input(true,           "Show DT as % of total ticks",                      inline = "22", group = GP2)
bool    i_showDtPctRises    = input(true,           "With â–²â–¼",                                          inline = "22", group = GP2, tooltip = "When selected, on up/dn bars with increasing DT%, â–²/â–¼ will appear to the right of the DT% value. It's the same as condition 13.")
bool    i_showDtValueSeps   = input(true,           "Show separators between values",                   group = GP2)
int     i_dtQtyOfValues     = input(50,             "Visible elapsed values",                           inline = "23", minval = 0, maxval = 245, group = GP2, tooltip = "0-245. Use only as many as you need for optimal chart speed.")
string  i_dtTextSize        = input("small",        "Text Size",                                        inline = "23", options = ["tiny", "small", "normal", "large", "huge", "auto"], group = GP2)
color   i_c_dtBull          = input(C_GREEN,        "ðŸ¡‘",                                                inline = "24", group = GP2)
color   i_c_dtBear          = input(C_DK_RED,       "ðŸ¡“",                                                inline = "24", group = GP2)
bool    i_showDtDiv         = input(ON,             "Divergences",                                      inline = "24", options = [OFF, ON], group = GP2) == ON
color   i_c_dtDiv           = input(C_DK_ORANGE,    "",                                                 inline = "24", group = GP2, tooltip = "A divergence occurs when the polarity of delta ticks does not match the direction of the bar.")

var string GP3 = "Point of Control (POC)"
bool    i_showPoc           = input(true,           "Show POC",                                         group = GP3)
int     i_pocQtyOfLines     = input(50,             "Visible elapsed POCs",                             inline = "30", minval = 0, maxval = 499, group = GP3, tooltip = "0-499. Use only as many as you need for optimal chart speed.")
int     i_pocLineWidth      = input(2,              "Line width",                                       inline = "30", minval = 0, maxval = 50, group = GP3)
color   i_c_pocBull         = input(C_LIME,         "ðŸ¡‘",                                                inline = "31", group = GP3)
color   i_c_pocBear         = input(C_PINK,         "ðŸ¡“",                                                inline = "31", group = GP3)
color   i_c_pocNeutral      = input(C_GRAY,         "â€¢",                                                inline = "31", group = GP3)
bool    i_showPocDiv        = input(ON,             "Divergences",                                      inline = "31", options = [OFF, ON], group = GP3) == ON
color   i_c_pocDiv          = input(C_ORANGE,       "",                                                 inline = "31", group = GP3, tooltip = "A divergence occurs when the bar's close is not above/below the POC for an up/dn bar.")
bool    i_pocDivAddDv       = input(ON,             "Add DV+/- requirement to avoid divergence",        options = [OFF, ON], group = GP3, tooltip = "This requires DV polarity to match that of a rising/falling POC to prevent a divergence.") == ON

var string GP4 = "Price Of Highest Volume Tick"
bool    i_showMaxVol        = input(false,          "Show Price Level",                                 inline = "41", group = GP4)
string  i_maxVolChar        = input("â€¢",            "Using",                                            inline = "41", group = GP4)
color   i_c_maxVolUp        = input(C_SILVER,       "ðŸ¡‘",                                                inline = "41", group = GP4)
color   i_c_maxVolDn        = input(C_SILVER,       "ðŸ¡“",                                                inline = "41", group = GP4, tooltip = "You can use distinct ðŸ¡‘ and ðŸ¡“ colors to distinguish the polarity of the highest volume tick.")

var string GP5 = "Candles"
color   i_c_bodyBull        = input(C_TEAL,         "Bodies: DV+",                                      inline = "51", group = GP5)
color   i_c_bodyBear        = input(C_MAROON,       "DVâ€“",                                              inline = "51", group = GP5)
color   i_c_bodyDiv         = input(C_ORANGE,       "Divergence",                                       inline = "51", group = GP5)
color   i_c_strongBarBull   = input(C_LIME,         "Strong bar outline: ðŸ¡‘",                            inline = "52", group = GP5)
color   i_c_strongBarBear   = input(C_PINK,         "ðŸ¡“",                                                inline = "52", group = GP5)
string  i_strongConditions  = input("1,3,5,6,9",    "Conditions",                                       inline = "52", group = GP5, tooltip = TT_STRONGBAR)

var string GP6 = "Marker and alert configuration"
string  i_markerDir         = input(TD3,            "Direction",                                        inline = "6A", group = GP6, options = [TD1, TD2, TD3], tooltip = TT_DIRECTIONS)
string  i_m1Conditions      = input("",             "M1",                                               inline = "60", group = GP6, tooltip = TT_CONDITIONS)
string  i_m2Conditions      = input("",             "M2",                                               inline = "60", group = GP6)
string  i_m3Conditions      = input("",             "M3",                                               inline = "60", group = GP6)
string  i_m4Conditions      = input("",             "M4",                                               inline = "61", group = GP6)
string  i_m5Conditions      = input("",             "M5",                                               inline = "61", group = GP6)
string  i_m6Conditions      = input("",             "M6",                                               inline = "61", group = GP6)
float   i_cond7Limit        = input(0,              "Condition 7: DV Limit",                            inline = "62", group = GP6, minval = 0.)
float   i_cond8Limit        = input(75.,            "Condition 8: DV% Limit",                           inline = "62", group = GP6, minval = 0., maxval = 100, step = 10)
color   i_c_markerUp        = input(C_LIME,         "Marker colors: ðŸ¡‘",                                 inline = "63", group = GP6)
color   i_c_markerDn        = input(C_PINK,         "ðŸ¡“",                                                inline = "63", group = GP6, tooltip = "These determine the color of the text above/below candles when a marker triggers.")
string  i_alertMsgUp        = input("",             "Alert message ðŸ¡‘",                                  inline = "6D", group = GP6)
string  i_alertMsgDn        = input("",             "Alert message ðŸ¡“",                                  inline = "6D", group = GP6, tooltip = "This text will replace the alert message for up/down alerts.")
// }



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Functions {

// â€”â€”â€”â€”â€” Function queues a new element in an array and de-queues its first element.
f_qDq(_array, _val) =>
    array.push(_array, _val)
    array.shift(_array)

// â€”â€”â€”â€”â€” Function creates a string by concatenating `_count` times the `_string`.
f_stringOf(_count, _string) =>
    array.join(array.new_string(_count, _string))

// â€”â€”â€”â€”â€” Function appends `_text` to `_msg` when `_cond` is true.
f_addTextIf(_cond, _msg, _text, _sep) =>
    string _return = _cond ? _msg + (_msg != "" ? _sep : "") + _text : _msg

// â€”â€”â€”â€”â€” Function rounding OHLC to tick precision.
f_roundedToTickOHLC() =>
    float _op = round_to_mintick(open)
    float _hi = round_to_mintick(high)
    float _lo = round_to_mintick(low)
    float _cl = round_to_mintick(close)
    [_op, _hi, _lo, _cl]

// â€”â€”â€”â€”â€” Function returning the delta volume polarity (+/-) for a historical bar or a realtime update.
//       When there is no movement since the last `close`, it uses the previous bar's polarity.
//       The function also works on historical bars and is particularly well-suited to smaller TFs with many bars with no movement.
//       WARNING: Note that one peculiarity of this logic is that a bar with `close > open` will always be considered positive, even if `close < close[1]`.
f_dvUpDn(_open, _close) =>
    // float _open : open price of current bar.
    // float _close: close price of current bar.
    varip bool _dvUp = false
    varip bool _dvDn = false
    varip float _prevClose = _open
    if barstate.isrealtime
        bool _flat = _close == _prevClose
        _dvUp := _flat ? _dvUp : _close > _prevClose
        _dvDn := _flat ? _dvDn : _close < _prevClose
    else
        bool _flat = _close == _open
        _dvUp := not _flat ? _close > _open : _close == _prevClose ? _dvUp : _close > _prevClose
        _dvDn := not _dvUp
    _prevClose := _close
    [_dvUp, _dvDn]

// â€”â€”â€”â€”â€” Function using realtime updates to calculate volume delta, ticks delta and POC.
f_realtimeDvPocDt(_op, _cl) =>
    // float _op: `open` for the bar.
    // float _cl: current price (`close`) of the realtime update.
    // Dependency: f_dvUpDn()
    [_updUp, _updDn]   = f_dvUpDn(_op, _cl)
    if barstate.isrealtime
        varip float _deltaVolume = 0.
        varip float _lastVolume  = 0.
        varip int   _ticksUp     = 0
        varip int   _ticksDn     = 0
        // `close` and volume values for each realtime update.
        varip float[] _weightedCloses  = array.new_float()
        varip float[] _closes  = array.new_float()
        varip float[] _volumes = array.new_float()
        if barstate.isnew
            // New realtime bar or first realtime update when script loads on the chart; reset data.
            _lastVolume  := 0.
            _deltaVolume := 0.
            _ticksUp     := 0
            _ticksDn     := 0
            array.clear(_weightedCloses)
            array.clear(_closes)
            array.clear(_volumes)

        // Volume and ticks delta.
        float _newVolume = nz(volume) - _lastVolume
        if _updUp
            _deltaVolume += _newVolume
            _ticksUp     += 1
        else if _updDn
            _deltaVolume -= _newVolume
            _ticksDn     += 1

        // POC (volume-weighted average of all prices during the bar's updates).
        array.push(_weightedCloses, _cl * _newVolume)
        array.push(_volumes, _newVolume)
        float _poc = array.avg(_weightedCloses) / array.avg(_volumes)
        // Maintain directional price and volume of ticks to determine price and direction of highest volume tick.
        array.push(_closes, _updUp ? _cl : - _cl)
        float _maxVolume = array.max(_volumes)
        float _priceOfMaxVolume = array.get(_closes, array.lastindexof(_volumes, _maxVolume))
        _maxVolume *= sign(_priceOfMaxVolume)
        // Save current volume to calculate DV in next update.
        _lastVolume := nz(volume)
        [_deltaVolume, _poc, _ticksUp, _ticksDn, abs(_priceOfMaxVolume), _maxVolume]

// â€”â€”â€”â€”â€” Function returning one of up/dn states for a bar.
//       When there is no movement in a bar, it uses the change in `close` from the previous bar to determine an up/dn state.
//       On consecutive bars with no movement and no change from the previous `close`, it uses the last known up/dn state.
f_barUpDn(_open, _close) =>
    // float open : open price of current bar.
    // float close: close price of current bar.
    var bool _barUp = false
    var bool _barDn = false
    bool _flat = _close == _open
    bool _noChange = _close == _close[1]
    _barUp := _close > _open or (_flat and (_close > nz(_close[1], _close) or (_noChange and _barUp)))
    _barDn := _close < _open or (_flat and (_close < nz(_close[1], _close) or (_noChange and _barDn)))
    [_barUp, _barDn]

// â€”â€”â€”â€”â€” Function that transforms strings of user selection of the conditions ("1,2,4,5", let's say) required to be true for each of the markers.
//       We set an element of the `_map` bool[] array to true for each selected condition. Only requires calling on first bar.
f_initMarkerConditionsMap(_condQty, _userConditions, _map) =>
    // int      _condQty       : quantity of conditions users can choose from.
    // string[] _userConditions: array containing, for each marker, the string of conditions entered by user.
    // bool[]   _map           : boolean translation of user choice of conditions for all markers.
    var int _marquerQty = array.size(_userConditions)
    // 1. Loop across all input strings containing marker conditions. Detect for each the conditions user has entered.
    // 2. For each condition required for a marker to trigger, set its corresponding element in the `_map` to `true`.
    for _markerNo = 0  to _marquerQty - 1
        // Get one input string.
        string[] _userSelections = str.split(array.get(_userConditions, _markerNo), ",")
        int _qtyOfuserConditions = array.size(_userSelections)
        if _qtyOfuserConditions > 0
            // Loop across all values parsed in the input string.
            for _condition = 0 to _qtyOfuserConditions - 1
                string _userChar = array.get(_userSelections, _condition)
                if str.length(_userChar) > 0
                    int _userConditionNo = int(nz(tonumber(_userChar))) - 1
                    if _userConditionNo >= 0 and _userConditionNo < _condQty
                        // Set the corresponding element to `true`; that's how `f_markerState()` will know the condition must be included in the compound condition check for the marker.
                        // This array concatenates all conditions for all markers, so must be indexed accordingly.
                        array.set(_map, (_markerNo * _condQty) + _userConditionNo, true)

// â€”â€”â€”â€”â€” Function returns `true` if all required user-selected conditions for a `_marker` are true.
f_markerState(_marker, _arrayOfConditions, _map) =>
    // int    _marker            : (1 to qty of markers) number of the marker whose required conditions are to be checked.
    // bool[] _arrayOfConditions : array containing the current state of all up or dn conditions on this bar.
    // bool[] _map               : map of user selection of conditions to be checked for each marker.
    var int _condQty = array.size(_arrayOfConditions)
    bool _compoundConditions = true
    bool _conditionsExist    = false
    for _condition = 0 to _condQty - 1
        bool _condMustBeIncluded = array.get(_map, ((_marker - 1) * _condQty) + _condition)
        _conditionsExist := _conditionsExist or _condMustBeIncluded
        if _condMustBeIncluded
            _compoundConditions := _compoundConditions and array.get(_arrayOfConditions, _condition)
    _conditionsExist ? _compoundConditions : false
// }



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Calculations {

// â€”â€”â€”â€”â€” Get rounded prices.
[op, hi, lo, cl] = f_roundedToTickOHLC()

// â€”â€”â€”â€”â€” Get DV, POC and DT.
[deltaVolume, poc, ticksUp, ticksDn, priceOfMaxVolume, maxVolume] = f_realtimeDvPocDt(op, cl)
float totalVolume  = nz(volume)
float dvPercent    = 100. * abs(deltaVolume) / totalVolume

float deltaTicks   = ticksUp - ticksDn
float totalTicks   = ticksUp + ticksDn
float dtPercent    = 100. * abs(deltaTicks) / totalTicks
// }

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Markers and alerts {

// User-selected marker directions.
var bool doLongs  = i_markerDir == TD1 or i_markerDir == TD3
var bool doShorts = i_markerDir == TD2 or i_markerDir == TD3

// â€”â€”â€”â€”â€” Set marker conditions.
// Cond 1: bar is up/dn.
[barUp, barDn]   = f_barUpDn(op, cl)
// Cond 2: `close` rises/falls.
bool clHigher    = cl > cl[1]
bool clLower     = cl < cl[1]
// Cond 3: DV is +/-.
bool dvPlus      = deltaVolume > 0
bool dvMinus     = deltaVolume < 0
// Cond 4: DV% rises.
bool dvPctRises  = dvPercent > dvPercent[1]
// Cond 5: POC rises/falls.
bool pocHigher   = poc > poc[1]
bool pocLower    = poc < poc[1]
// Cond 6: Total ticks rises.
bool totTicksRises = totalTicks > totalTicks[1]
// Cond 7: DV breaches limit.
bool dvLimitUp   = deltaVolume >  i_cond7Limit
bool dvLimitDn   = deltaVolume < -i_cond7Limit
// Cond 8: DV% breaches limit.
bool dvpLimit    = dvPercent > i_cond8Limit
// Cond 9: DV rises/falls.
bool dvHigher    = deltaVolume > deltaVolume[1] and dvPlus  and dvPlus[1]
bool dvLower     = deltaVolume < deltaVolume[1] and dvMinus and dvMinus[1]
// Cond 10: Two consecutive DV+/DV-.
bool dvPlusBump  = dvPlus  and dvPlus[1]
bool dvMinusBump = dvMinus and dvMinus[1]
// Cond 11: Total volume Rises.
bool totVolRises = totalVolume > totalVolume[1]
// Cond 12: DT is +/-.
bool dtPlus      = deltaTicks > 0
bool dtMinus     = deltaTicks < 0
// Cond 13: DT% rises.
bool dtPctRises  = dtPercent > dtPercent[1]
// Cond 14: DT rises/falls.
bool dtHigher    = deltaTicks > deltaTicks[1] and dtPlus  and dtPlus[1]
bool dtLower     = deltaTicks < deltaTicks[1] and dtMinus and dtMinus[1]

// Load arrays of states to test each marker's specific conditions against them.
bool[] conditionsUp = array.from(barUp, clHigher, dvPlus,  dvPctRises, pocHigher, totTicksRises, dvLimitUp, dvpLimit, dvHigher, dvPlusBump,  totVolRises, dtPlus,  dtPctRises, dtHigher)
bool[] conditionsDn = array.from(barDn, clLower,  dvMinus, dvPctRises, pocLower,  totTicksRises, dvLimitDn, dvpLimit, dvLower,  dvMinusBump, totVolRises, dtMinus, dtPctRises, dtLower)

// â€”â€”â€”â€”â€” Initialize user-selected marker conditions.
// This array contains one element for each of the input strings of conditions entered by the user for each marker.
// (We use one marker space at the end to put the conditions for "strong bars", but the visual cue for this marker is to outline candle bodies.)
string[] markerUserConditions = array.from(i_m1Conditions, i_m2Conditions, i_m3Conditions, i_m4Conditions, i_m5Conditions, i_m6Conditions, i_strongConditions)
var int markerQty = array.size(markerUserConditions)
var int conditionsQty = array.size(conditionsUp)
// Once initialized using `f_initMarkerConditionsMap()`, this fixed size array will contain the representation of the user's selection of conditions for each marker.
// After initialization, its elements will be `true` for each condition required by user for each marker. Aggregates all selections for all markers, sequentially.
var bool[] markerConditionsMap = array.new_bool(markerQty * conditionsQty, false)
// On first bar only, intialize the map of user conditions for the markers. This tells us which conditions must be true for each marker to trigger.
if barstate.isfirst
    f_initMarkerConditionsMap(conditionsQty, markerUserConditions, markerConditionsMap)

// â€”â€”â€”â€”â€” Test each marker's required conditions against their state and build relevant alert triggering conditions, label and alert texts.
string labelMsgUp   = ""
string labelMsgDn   = ""
string alertMsgUp   = ""
string alertMsgDn   = ""
if barstate.isconfirmed
    for _marker = 1 to markerQty - 1
        // Get up/dn state of one marker.
        bool _cUp = f_markerState(_marker, conditionsUp, markerConditionsMap) and doLongs
        bool _cDn = f_markerState(_marker, conditionsDn, markerConditionsMap) and doShorts
        // Build marker label's text.
        string _markerNo = "M" + tostring(_marker)
        labelMsgUp := f_addTextIf(_cUp, labelMsgUp, _markerNo + "â–²", "\n")
        labelMsgDn := f_addTextIf(_cDn, labelMsgDn, _markerNo + "â–¼", "\n")
        // Build alert's message.
        alertMsgUp := f_addTextIf(_cUp, alertMsgUp, _markerNo + "â–²", ", ")
        alertMsgDn := f_addTextIf(_cDn, alertMsgDn, _markerNo + "â–¼", ", ")

// â€”â€”â€”â€”â€” Triger alert if needed.
bool alertUp = alertMsgUp != ""
bool alertDn = alertMsgDn != ""
if alertUp
    alert(i_alertMsgUp == "" ? alertMsgUp : i_alertMsgUp, alert.freq_once_per_bar_close)
if alertDn
    alert(i_alertMsgDn == "" ? alertMsgDn : i_alertMsgDn, alert.freq_once_per_bar_close)
// }



// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Plots {

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Update realtime POC and labels above/below bar.
// â€”â€”â€”â€”â€” POC line
bool dvDiv  = (dvPlus and barDn) or (dvMinus and barUp)
bool dtDiv  = (dtPlus and barDn) or (dtMinus and barUp)
bool pocDiv = (pocHigher and cl < op) or (pocLower and cl > op) or (i_pocDivAddDv and ((pocHigher and dvMinus) or (pocLower and dvPlus)))
color c_poc = pocHigher ? i_showPocDiv and pocDiv ? i_c_pocDiv : i_c_pocBull : pocLower ? i_showPocDiv and pocDiv ? i_c_pocDiv : i_c_pocBear : i_c_pocNeutral
if i_showPoc
    var line rtPoc = line.new(na, na, na, na, width = i_pocLineWidth)
    line.set_xy1(rtPoc, bar_index - 1, poc)
    line.set_xy2(rtPoc, bar_index, poc)
    line.set_color(rtPoc, c_poc)

// â€”â€”â€”â€”â€” Label above bar (DT).
var string SEPARATOR = "â¸º\n"
var string sepBeforeTotalTicks = i_showDt and i_showTotalTicks and i_showDtValueSeps ? SEPARATOR : ""
var string sepBeforeDtPercent  = i_showDt and i_showTotalTicks and i_showDtPercent and i_showDtValueSeps ? "=\n" : ""
string dtText          = i_showDt ? tostring(deltaTicks) + (i_showDtVolRises ? dtHigher ? "â–²" : dtLower ? "â–¼" : "" : "") + "\n" : ""
string totalTicksText  = i_showTotalTicks ? sepBeforeTotalTicks + tostring(totalTicks) + (i_showTotTicksRises and totTicksRises ? barUp ? "â–²" : "â–¼" : "") + "\n" : ""
string dtPctText       = i_showDtPercent ? sepBeforeDtPercent + tostring(dtPercent, "#") + "%" + (i_showDtPctRises and dtPctRises ? barUp ? "â–²" : "â–¼" : "") : ""
string labelTextAbove  = dtText + totalTicksText + dtPctText
color  c_labelAbove    = i_showDtDiv and dtDiv ? i_c_dtDiv : dtPlus ? i_c_dtBull : dtMinus ? i_c_dtBear : na
var label rtLabelAbove = label.new(bar_index, na, labelTextAbove, style = label.style_label_down, color = color(na), textcolor = c_labelAbove, size = i_dtTextSize)
label.set_xy(rtLabelAbove, bar_index, hi)
label.set_text(rtLabelAbove, labelTextAbove)
label.set_textcolor(rtLabelAbove, c_labelAbove)

// â€”â€”â€”â€”â€” Label below bar (DV).
var string sepBeforeTotalVolume = i_showDv and i_showTotalVolume and i_showDvValueSeps ? SEPARATOR : ""
var string sepBeforeDvPercent   = i_showDv and i_showTotalVolume and i_showDvPercent and i_showDvValueSeps ? "=\n" : ""
var string dvPrecision = "0" + (i_showDVPrec == 0 ? "" : ".") + f_stringOf(i_showDVPrec, "0")
string dvText          = i_showDv ? tostring(deltaVolume, dvPrecision) + (i_showDvVolRises ? dvHigher ? "â–²" : dvLower ? "â–¼" : "" : "") + "\n" : ""
string totalVolumeText = i_showTotalVolume ? sepBeforeTotalVolume + tostring(totalVolume, dvPrecision) + (i_showTotVolRises and totVolRises ? barUp ? "â–²" : "â–¼" : "") + "\n" : ""
string dvPctText       = i_showDvPercent ? sepBeforeDvPercent + tostring(dvPercent, "#") + "%" + (i_showDvPctRises and dvPctRises ? barUp ? "â–²" : "â–¼" : "") + "\n" : ""
string labelTextBelow  = dvText + totalVolumeText + dvPctText
color  c_labelBelow    = i_showDvDiv and dvDiv ? i_c_dvDiv : dvPlus ? i_c_dvBull : dvMinus ? i_c_dvBear : na
var label rtLabelBelow = label.new(bar_index, na, labelTextBelow, style = label.style_label_up, color = color(na), textcolor = c_labelBelow, size = i_dvTextSize)
label.set_xy(rtLabelBelow, bar_index, lo)
label.set_text(rtLabelBelow, labelTextBelow)
label.set_textcolor(rtLabelBelow, c_labelBelow)


// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Realtime bar closes; create final POC and labels for elapsed realtime bars, showing only as many as user has chosen.
if barstate.isrealtime and barstate.isconfirmed
    var label[] dvLabels = array.new_label(i_dvQtyOfValues)
    var label[] dtLabels = array.new_label(i_dtQtyOfValues)
    var line[]  pocLines = array.new_line( i_pocQtyOfLines)
    // Draw above/below bar labels.
    labelTextAbove := (alertDn ? labelMsgDn + "\n\n" : "") + labelTextAbove
    c_labelAbove   := alertDn ? i_c_markerDn : c_labelAbove
    label.delete(f_qDq(dtLabels, label.new(bar_index, hi, labelTextAbove, style = label.style_label_down, color = color(na), textcolor = c_labelAbove, size = i_dtTextSize)))
    labelTextBelow += alertUp ? "\n" + labelMsgUp : ""
    c_labelBelow   := alertUp ? i_c_markerUp : c_labelBelow
    label.delete(f_qDq(dvLabels,  label.new(bar_index, lo, labelTextBelow, style = label.style_label_up,   color = color(na), textcolor = c_labelBelow, size = i_dvTextSize)))
    // Display elapsed POCs.
    line.delete(f_qDq(pocLines, line.new(bar_index - 1, poc, bar_index, poc, color = c_poc, width = i_pocLineWidth)))


// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Data Window.
float dvPctSigned = dvPercent * sign(deltaVolume)
float dtPctSigned = dtPercent * sign(deltaTicks)
plotchar(barstate.isrealtime ? deltaVolume : na, "DV",           "", location.top, c_labelBelow)
plotchar(barstate.isrealtime ? volume      : na, "Total Volume", "", location.top, c_labelBelow)
plotchar(barstate.isrealtime ? dvPctSigned : na, "DV% +/âˆ’",      "", location.top, c_labelBelow)
plotchar(barstate.isrealtime ? poc         : na, "POC",          "", location.top, c_poc)
plotchar(barstate.isrealtime ? dtPctSigned : na, "DT% +/âˆ’",      "", location.top, c_labelAbove)

// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” Candles.
// â€”â€”â€”â€”â€” Body-less â”´ and â”¬ formations for top/bottom of candle.
float topHi = hi
float topLo = max(op, cl)
float botHi = min(op, cl)
float botLo = lo
color c_outlines = barUp ? i_c_bodyBull : i_c_bodyBear
plotcandle(topLo, topHi, topLo, topLo, "Open",  color = c_outlines, wickcolor = c_outlines, bordercolor = c_outlines)
plotcandle(botHi, botHi, botLo, botHi, "Close", color = c_outlines, wickcolor = c_outlines, bordercolor = c_outlines)

// â€”â€”â€”â€”â€” Body containing color indicating DV polarity.
float dvTransp = 100 - dvPercent
color c_candleBody = dvDiv ? color.new(i_c_bodyDiv, dvTransp) : dvPlus ? color.new(i_c_bodyBull, dvTransp) : dvMinus ? color.new(i_c_bodyBear, dvTransp) : na
color c_strongBarBorder = f_markerState(7, conditionsUp, markerConditionsMap) ? i_c_strongBarBull : f_markerState(7, conditionsDn, markerConditionsMap) ? i_c_strongBarBear : na
plotcandle(botHi, topLo, botHi, topLo, "Body",  c_candleBody, wickcolor = na, bordercolor = c_strongBarBorder)

// â€”â€”â€”â€”â€” Level of highest volume tick.
color c_maxVolume = maxVolume > 0  ? i_c_maxVolUp : i_c_maxVolDn
plotchar(i_showMaxVol ? priceOfMaxVolume : na, "Price Mark for Highest Volume", i_maxVolChar, location.absolute, c_maxVolume, size = size.tiny)
plotchar(priceOfMaxVolume, "Price of Highest Volume", "", location.top, c_maxVolume, size = size.tiny)
plotchar(maxVolume, "Highest Volume", "", location.top, c_maxVolume, size = size.tiny)
// }