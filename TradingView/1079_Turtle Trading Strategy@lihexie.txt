// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © 李和邪
// 本脚本所有内容只适用于交流学习，不构成投资建议，所有后果自行承担。
//@version=5
strategy(title='Turtle Trading Strategy@lihexie',
   shorttitle='OKX-海龟交易系统@李和邪',
   overlay=true,
   pyramiding=4,
   initial_capital = 1000,
   default_qty_type = strategy.percent_of_equity,
   default_qty_value=100,
   slippage = 0,
   commission_type = strategy.commission.percent,
   commission_value = 0.05,
   calc_on_every_tick=false,
   process_orders_on_close=true)

// 输入参数
from_date = input.time(timestamp("2013-01-01T00:00:00+08:00"), "From Date/开始日期")
end_date = input.time(timestamp("2024-08-01T00:00:00+08:00"), "To Date/结束日期")
valid_date() => time >= from_date and time <= end_date
current_mode = input.string("Mode 1", "Enter Mode/进场系统",['Mode 1','Mode 2'])
// mode 1
entry_length = input.int(20, 'Entry Length/系统1进场长度', minval=1)  // 进场长度
exit_length = input.int(10, 'Exit Length/系统2出场长度', minval=1)  // 出场长度
// mode 2
entry_length_mode2 = input.int(55, 'Mode2 Entry Length/系统2进场长度', minval=1)  // 进场长度
exit_length_mode2 = input.int(20, 'Mode2 Exit Length/系统2出场长度', minval=1)
atr_period = input.int(14, "ATR Period/计算ATR的周期", minval=1)  // ATR周期
risk_per_trade = input.float(0.02, "Risk Per Trade/每笔交易的风险，0.02就是2%", minval=0.001, maxval=1)  // 每笔交易的风险
initial_stop_atr_multiple = input.float(2, "Initial Stop ATR Multiple/止损使用的ATR倍数", minval=0.1, maxval=10)  // 初始止损ATR倍数
pyramid_atr_multiple = input.float(0.5, "Pyramid ATR Multiple/加仓使用的ATR倍数", minval=0.1, maxval=10)  // 加仓ATR倍数
max_units = input.int(4, "Max Units/最大头寸单位数", minval=1, maxval=10)  // 最大头寸单位数

highlighting = input(title='Highlighter On/Off ?/是否高亮显示', defval=true)  // 是否高亮显示


// 初始化变量
var int units = 0
var float trailing_stop_long = na
var float trailing_stop_short = na
var float real_entry_price_long = na
var float real_entry_price_short = na
var float add_unit_price_long = na
var float add_unit_price_short = na
var bool last_trade_win = false
// 计算ATR
atr = ta.atr(atr_period)

// 计算单位大小
unit_size = (strategy.equity * risk_per_trade) / (initial_stop_atr_multiple * atr)

// 切换模式
mode_signal = current_mode == "Mode 1" ? (last_trade_win==false?true:false) : true

float entry_price_long = na
float entry_price_short = na
float exit_price_long = na
float exit_price_short = na
// 计算进场和出场价格
if current_mode == "Mode 1"
    entry_price_long := ta.highest(entry_length)
    entry_price_short := ta.lowest(entry_length)
    exit_price_long := ta.lowest(exit_length)
    exit_price_short := ta.highest(exit_length)
else
    entry_price_long := ta.highest(entry_length_mode2)
    entry_price_short := ta.lowest(entry_length_mode2)
    exit_price_long := ta.lowest(exit_length_mode2)
    exit_price_short := ta.highest(exit_length_mode2)

// 计算止损价格
stop_price_long = entry_price_long - (initial_stop_atr_multiple * atr)
stop_price_short = entry_price_short + (initial_stop_atr_multiple * atr)

// 交易逻辑
// 生成买入和卖出信号
long_signal = ta.crossover(close, entry_price_long[1]) and strategy.position_size==0 and valid_date()
short_signal = ta.crossunder(close, entry_price_short[1]) and strategy.position_size==0 and valid_date()
// 生成出场信号
exit_long_signal = ta.crossunder(close, exit_price_long[1]) and strategy.position_size > 0 and valid_date()
exit_short_signal = ta.crossover(close, exit_price_short[1]) and strategy.position_size < 0 and valid_date()

if long_signal
    if mode_signal
        strategy.entry("Long", strategy.long, qty=unit_size, stop=stop_price_long)
        units := 1
        trailing_stop_long := stop_price_long
        real_entry_price_long := close
        add_unit_price_long := real_entry_price_long+pyramid_atr_multiple*atr
    else
        last_trade_win:=false
if short_signal
    if mode_signal
        strategy.entry("Short", strategy.short, qty=unit_size, stop=stop_price_short)
        units := 1
        trailing_stop_short := stop_price_short
        real_entry_price_short := close
        add_unit_price_short := real_entry_price_short-pyramid_atr_multiple*atr
    else
        last_trade_win:=false
// 出场逻辑
if exit_long_signal
    last_trade_win := strategy.position_avg_price<close?true:false
    strategy.close_all("SL")
    units := 0
    real_entry_price_long := na
    add_unit_price_long := na
    trailing_stop_long := na
if exit_short_signal
    last_trade_win := strategy.position_avg_price>close?true:false
    strategy.close_all("SS")
    units := 0
    real_entry_price_short := na
    add_unit_price_short := na
    trailing_stop_short := na

// 生成加仓信号
add_unit_signal = (close > add_unit_price_long or close < add_unit_price_short) and units[1] < max_units and valid_date()
// 加仓逻辑
if add_unit_signal
    if strategy.position_size > 0
        strategy.entry("AL", strategy.long, qty=unit_size)
        real_entry_price_long := close
        add_unit_price_long := real_entry_price_long+pyramid_atr_multiple*atr
        trailing_stop_long := real_entry_price_long - (initial_stop_atr_multiple * atr)
    if strategy.position_size < 0
        strategy.entry("AS", strategy.short, qty=unit_size)
        real_entry_price_short := close
        add_unit_price_short := real_entry_price_short-pyramid_atr_multiple*atr
        trailing_stop_short := real_entry_price_short + (initial_stop_atr_multiple * atr)
    units := units + 1

// 移动止损逻辑
trailing_stop_long_signal = ta.crossunder(close, trailing_stop_long) and strategy.position_size > 0 and valid_date()
trailing_stop_short_signal = ta.crossover(close, trailing_stop_short) and strategy.position_size < 0 and valid_date()

if trailing_stop_long_signal
    last_trade_win := strategy.position_avg_price<close?true:false
    strategy.close_all("TSL")
    units := 0
    real_entry_price_long := na
    add_unit_price_long := na
    trailing_stop_long := na
if trailing_stop_short_signal
    last_trade_win := strategy.position_avg_price>close?true:false
    strategy.close_all("TSS")
    units := 0
    real_entry_price_short := na
    add_unit_price_short := na
    trailing_stop_short := na

// 美化图表
plot_entry_lowest = plot(entry_price_short, 'Lower', color=color.new(#0094FF, 0))  // 绘制进场最低线
plot_entry_highest = plot(entry_price_long, 'Upper', color=color.new(#0094FF, 0))  // 绘制进场最高线
entry_line = ta.barssince(short_signal) <= ta.barssince(long_signal) ? entry_price_short : entry_price_long  // 进场线
exit_line = ta.barssince(short_signal) <= ta.barssince(long_signal) ? exit_price_short : exit_price_long  // 出场线
plot(entry_line, title='Trend Line', color=color.new(#ff52f1, 0), linewidth=2)  // 绘制趋势线
plot_exit = plot(exit_line, title='Exit Line', color=color.new(color.blue, 0), linewidth=1, style=plot.style_circles)  // 绘制出场线

entry_long_color = highlighting and strategy.position_size>0 ? color.new(color.green, transp = 88) : na
entry_short_color = highlighting and strategy.position_size<0 ? color.new(color.red, transp = 88) : na
fill(plot_entry_highest, plot_exit, color=entry_long_color, title='Background') // 高亮多头趋势
fill(plot_entry_lowest, plot_exit, color=entry_short_color, title='Background') // 高亮空头趋势