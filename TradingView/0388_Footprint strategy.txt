//@version=5
strategy("Footprint strategy", overlay=true,commission_value = 0.03,default_qty_value = 20,default_qty_type= strategy.percent_of_equity,pyramiding = 26,max_labels_count = 500)
import dboichenko/footprint_type/1
import dboichenko/footprint_logic/5
//Inputs{
var show_bar = input.int(5,"Count show bars",minval =1,inline = "1",group = "Display")
all_show_bar = input.bool(true,"Display all available bars",inline = "1",group = "Display",tooltip = "Number of bars from rt bar to history for calculate,a certain amount or all")
tick_per_row = input.int(40,"Ticks Per Row",minval =0,inline = "2",group = "Row size")
auto_tick_per_row = input.bool(true,"Auto",inline = "2",group = "Row size")
max_label_in_row = input.int(7,"Max row",inline = "2",minval =1,maxval = 100,group = "Row size",tooltip = 'Sets the price step, calculated by multiplying the entered value by syminfo.mintick, or auto mod - sets the acceptable number of rows within a bar. The automatic "Ticks Per Row" calculation is based on the first available bar and applied to subsequent bars.')
inbalance_percent = input.int(300,"Imbalance Percent",minval =0,inline = "3",group = "Imbalance")
stacked_input = input.int(4,"Stacked levels",minval =1,inline = "3",group = "Imbalance",tooltip = "A percentage coefficient to determine the Imbalance of price levels. And minimum number of consecutive Imbalance levels required to draw extended lines.")

stop_loss_pr = input.float(0.01,"Stop loss",step = 0.1,inline = "strop_loss")
enable_stopp_loss = input.bool(false,"Enable stop loss",inline = "strop_loss")
take_profit_pr = input.float(0.003,"Take Profit",step = 0.1)
calc_tf = input.timeframe("1S","Calculation timeframe",group = "timeframe")
trend_tf = input.timeframe("1D","Trend timeframe",group = "timeframe",inline = "trend")
use_trend = input.bool(true,"Enable trend",group = "timeframe",inline = "trend")
//}

// Support function {
get_auto_tick_per_row()=>
    temp_tick_per_row =1
    temp_row_size = temp_tick_per_row * syminfo.mintick
    while low + max_label_in_row*temp_row_size <= high
        temp_tick_per_row +=1
        temp_row_size:=temp_tick_per_row * syminfo.mintick
    temp_row_size
//}

//variable {
[detail_open, detail_high, detail_low, detail_close, detail_vol] = request.security_lower_tf("",calc_tf,[open,high,low,close,volume])
previos_detail_close = detail_close[1]
var isBuyVolume = true

na_cond = not na(previos_detail_close) and not na(detail_close)
size_cond = na_cond ? detail_close.size() != 0 and previos_detail_close.size() == 0 :false
show_bar:= all_show_bar ? na_cond ? size_cond ? last_bar_index - bar_index : show_bar : show_bar : show_bar
show_cond = (bar_index > last_bar_index - show_bar)
bar_index_show_condition = show_cond and na_cond ? true : false

//Calculation row_size
var row_size = tick_per_row * syminfo.mintick
if auto_tick_per_row
    if bar_index == (last_bar_index - show_bar+1) and not na(previos_detail_close)
        if previos_detail_close.size() != 0
            row_size := get_auto_tick_per_row()


//}
//object_creating{
var var_info = footprint_type.Footprint_info_var_object.new(cum_info = table.new(position = position.bottom_right, columns = 3, rows = 4, border_width = 1,frame_width = 1, border_color = chart.fg_color,frame_color = chart.fg_color))
var var_imba_line = footprint_type.Imbalance_line_var_object.new(array.new<line>(),array.new<line>())
foot_bar = footprint_type.Footprint_bar.new(
     foot_rows = array.new<footprint_type.Footprint_row>(),
     imba_line = footprint_type.Imbalance_line.new(
         buy_price_line = array.new<float>(),
         sell_price_line = array.new<float>(),
         var_imba_line = var_imba_line
         ),
     info = footprint_type.Footprint_info.new(var_info = var_info),
     row_size = row_size,
     calc_data = footprint_type.Calculation_data.new(
         detail_open = detail_open,
         detail_high = detail_high,
         detail_low = detail_low,
         detail_close = detail_close,
         detail_vol = detail_vol,
         previos_detail_close = previos_detail_close,
         isBuyVolume = isBuyVolume
         ),
     foot_max_price_vol = map.new<float,float>()
     )
sup = footprint_type.Support_objects.new(
     inp = footprint_type.Inputs.new(
         inbalance_percent = inbalance_percent,
         stacked_input = stacked_input
         ),
     bar_index_show_condition = bar_index_show_condition
     )
//}

day_trend()=>
    bool res = true
    trend = request.security("",trend_tf,ta.rising(close,1))
    if use_trend and not trend
        res := false
    res

method foot_trade(footprint_type.Footprint_bar foot_bar)=>
    imba_buy_count = 0
    buy_price = array.new<float>()
    imba_sell_count = 0
    sell_price = array.new<float>()
    for row in foot_bar.foot_rows
        if row.imbalance_buy
            imba_buy_count += 1
            buy_price.push(row.price)
        if row.imbalance_sell
            imba_sell_count += 1
            sell_price.push(row.price)

    if imba_buy_count > imba_sell_count and close < open and day_trend()
        price_ = buy_price.max()
        stop_loss = price_ * (1-stop_loss_pr)
        profit = price_ * (take_profit_pr + 1)
        strategy.entry("reversal", strategy.long,limit = price_)
        strategy.exit("exit reversal","reversal",limit = profit,comment_profit = "profit reversal",stop = enable_stopp_loss ? stop_loss : na, comment_loss= enable_stopp_loss ? "loss reversal" : na )
        label.new(bar_index,close,str.format("Reversal\nprofit: {0}\nlimit: {1}\nstop_loss: {2}",profit,price_, enable_stopp_loss ? stop_loss : na),yloc = yloc.belowbar,color = na)
        alert(str.format("Reversal\nprofit: {0}\nlimit: {1}\nstop_loss: {2}",profit,price_, enable_stopp_loss ? stop_loss : na), alert.freq_all)
    if foot_bar.foot_buy_vol > foot_bar.foot_sell_vol and foot_bar.imba_line.buy_price_line.size()>0
        price_ = foot_bar.imba_line.buy_price_line.max()
        stop_loss = price_ * (1-stop_loss_pr)
        profit = price_ * (take_profit_pr + 1)
        strategy.entry("trend", strategy.long,limit = price_)
        strategy.exit("exit trend","trend",profit = profit,comment_profit = "profit trend",loss = enable_stopp_loss ? stop_loss : na, comment_loss= enable_stopp_loss ? "loss trend" : na )
        label.new(bar_index,close,str.format("Trend\nprofit: {0}\nlimit: {1}\nstop_loss: {2}",profit,price_, enable_stopp_loss ? stop_loss : na),yloc = yloc.belowbar,color = na)
        alert(str.format("Trend\nprofit: {0}\nlimit: {1}\nstop_loss: {2}",profit,price_, enable_stopp_loss ? stop_loss : na), alert.freq_all)
method local_fill_footprint_object(footprint_type.Footprint_bar foot_bar,footprint_type.Support_objects sup)=>
    foot_bar.fil_price_rows()
    foot_bar.fill_footprint_type(sup)
    foot_bar.imba_line.fill_imba_line(foot_bar,sup)

start(footprint_type.Footprint_bar foot_bar,footprint_type.Support_objects sup)=>
    if sup.bar_index_show_condition
        foot_bar.local_fill_footprint_object(sup)
        foot_bar.foot_trade()
start(foot_bar,sup)