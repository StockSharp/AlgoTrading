//@version=6
strategy(title="PVSRA  v5", shorttitle="PVSRA_VS_Combo_Strategy", overlay=false, pyramiding=0)
// Description: This block sets the version and strategy configuration, such as the title, short title, overlay option, and pyramiding limits.

// --- INPUTS ---
// Basic settings
bool overridesym       = input(title="Override chart symbol?", defval=false)
string pvsra_sym       = input.symbol(title="Symbol", defval="INDEX:BTCUSD")
bool setcandlecolors   = input(title="Set PVSRA candle colors?", defval=true)

// Trade management settings (for normal trades)
float stopLossBufferPct   = input.float(1.25, title="Normal Stop Loss Buffer (%)", step=0.1, minval=0.0)
float takeProfitBufferPct = input.float(7.0, title="Normal Take Profit Buffer (%)", step=0.1, minval=0.0)

// Reversal trade settings
bool enableReversal   = input.bool(true, title="Enable Reversal Trade Taking?")
int reversalLookback  = input.int(1, title="Reversal Lookback Period (bars)", minval=1)

// Core trade logic lookback setting
int coreLookback      = input.int(5, title="Core Trade Lookback Period (bars)", minval=1)
// Description: The INPUTS section defines user-configurable parameters for symbol override, candle coloring, trade management, reversal settings, and the lookback period for core trade logic.

// --- DAILY BOLLINGER BAND (Logic Only) ---
// Calculate the daily 89-period VWMA and standard deviation on daily resolution
daily_vwma   = request.security(syminfo.tickerid, "D", ta.vwma(close, 89), barmerge.gaps_off, barmerge.lookahead_off)
daily_std    = request.security(syminfo.tickerid, "D", ta.stdev(close, 89), barmerge.gaps_off, barmerge.lookahead_off)
daily_upper  = daily_vwma + 1.3 * daily_std
daily_lower  = daily_vwma - 1.3 * daily_std
daily_close  = request.security(syminfo.tickerid, "D", close, barmerge.gaps_off, barmerge.lookahead_off)
// Description: This section calculates the daily volume-weighted moving average (VWMA) and standard deviation for an 89-period on daily charts, then derives upper and lower Bollinger band levels as well as the daily closing price.

// --- CUSTOM SUM FUNCTION ---
// Used to count reversal signals over a custom lookback period.
f_sum(src, len) =>
    s = 0.0
    for i = 0 to len - 1
        s := s + src[i]
    s
// Description: A custom function is defined here to compute the sum of a given series over a specified number of bars. This is primarily used for counting reversal signals.

// --- SECURITY FUNCTION ---
pvsra_security(sresolution, sseries) =>
    request.security(overridesym ? pvsra_sym : syminfo.tickerid, sresolution, sseries[barstate.isrealtime ? 1 : 0], barmerge.gaps_off, barmerge.lookahead_off)

pvsra_volume = overridesym ? pvsra_security('', volume) : volume
pvsra_high   = overridesym ? pvsra_security('', high)   : high
pvsra_low    = overridesym ? pvsra_security('', low)    : low
pvsra_close  = overridesym ? pvsra_security('', close)  : close
pvsra_open   = overridesym ? pvsra_security('', open)   : open
// Description: This section creates a wrapper function to fetch data from a specified symbol if the override is enabled. It then sets up series variables (volume, high, low, close, open) to either use the alternate symbol or the current chart’s data.

// --- CALCULATIONS ---
sum_1    = math.sum(pvsra_volume, 10)
sum_2    = math.sum(volume, 10)
av       = overridesym ? sum_1 / 10 : sum_2 / 10
value2   = overridesym ? pvsra_volume * (pvsra_high - pvsra_low) : volume * (high - low)
hivalue2 = ta.highest(value2, 10)
// Description: Here, the code calculates sums and averages of volume over 10 bars, computes a value based on volume and price range, and identifies the highest such value in the period. These calculations are fundamental for later volume-based analysis.

// --- VOLUME ANALYSIS (VA) ---
iff_1 = pvsra_volume >= av * 1.5 ? 2 : 0
iff_2 = pvsra_volume >= av * 2 or value2 >= hivalue2 ? 1 : iff_1
iff_3 = volume >= av * 1.5 ? 2 : 0
iff_4 = volume >= av * 2 or value2 >= hivalue2 ? 1 : iff_3
va    = overridesym ? iff_2 : iff_4
// Description: This section uses conditional logic to assign volume analysis values (VA) based on whether the current volume is significantly above the average, and comparing the calculated value with its highest level over 10 bars. It accounts for both the override symbol and the chart’s native data.

// --- CANDLE COLORING ---
isBull = overridesym ? pvsra_close > pvsra_open : close > open

CUColor = color.lime
CDColor = color.red
AUColor = color.blue
ADColor = color.fuchsia
NUColor = #999999
NDColor = #4d4d4d

iff_5 = va == 2 ? AUColor : NUColor
iff_6 = va == 1 ? CUColor : iff_5
iff_7 = va == 2 ? ADColor : NDColor
iff_8 = va == 1 ? CDColor : iff_7
candleColor = isBull ? iff_6 : iff_8

barcolor(setcandlecolors ? candleColor : na)
plot(pvsra_volume, style=plot.style_columns, linewidth=1, color=candleColor)
// Description: This block determines the candle color based on whether the bar is bullish and the volume analysis signals. Colors are assigned for various conditions, and the script then colors the chart’s bars and plots the volume accordingly.

// --- DYNAMIC AVERAGE DAILY VOLUME CALCULATION ---
adv = ta.ema(request.security(syminfo.tickerid, "D", volume), 365)
calculate_abnormal_threshold(adv, interval_minutes) =>
    k = 2.26 + 0.34 * math.log(adv)
    per_interval_volume = adv / (1440 / interval_minutes)
    k * per_interval_volume

interval_minutes   = timeframe.in_seconds() / 60
abnormal_threshold = calculate_abnormal_threshold(adv, interval_minutes)
adjusted_threshold = math.max(abnormal_threshold, 1)
plot(adjusted_threshold, title="Abnormal Threshold", color=color.red, linewidth=2)
// Description: This section calculates the average daily volume (ADV) using an exponential moving average on daily volume data over 365 days. It then computes an abnormal volume threshold dynamically based on the ADV and current timeframe, ensuring the threshold is at least 1, and plots it for visual reference.

// --- SIGNAL DEFINITIONS ---
// The trigger is now taken from coreLookback bars ago:
bool triggeredRed   = bar_index >= coreLookback and (volume[coreLookback] > adjusted_threshold[coreLookback]) and (close[coreLookback] < open[coreLookback])
bool triggeredGreen = bar_index >= coreLookback and (volume[coreLookback] > adjusted_threshold[coreLookback]) and (close[coreLookback] > open[coreLookback])
// Description: Signal definitions are established here for red (bearish) and green (bullish) triggers based on volume and price action from a specified number of bars ago (coreLookback). These conditions will be used to initiate trades.

// --- REVERSAL CONDITIONS ---
// Count reversal signals over the reversalLookback period using the core conditions:
float redCount   = f_sum((bar_index >= coreLookback and (volume[coreLookback] > adjusted_threshold[coreLookback]) and (close[coreLookback] < open[coreLookback])) ? 1.0 : 0.0, reversalLookback)
float greenCount = f_sum((bar_index >= coreLookback and (volume[coreLookback] > adjusted_threshold[coreLookback]) and (close[coreLookback] > open[coreLookback])) ? 1.0 : 0.0, reversalLookback)

bool reversalRed   = enableReversal and (redCount >= 2)
bool reversalGreen = enableReversal and (greenCount >= 2)
// Description: This block counts the number of reversal signals (red and green) over a user-defined lookback period using the custom sum function. It then sets flags for reversal trades if the counts meet the threshold and if reversal trading is enabled.

// --- STRATEGY LOGIC ---
// Entry conditions include the daily Bollinger band filter for entry only.
if barstate.isconfirmed and strategy.position_size == 0
    // --- REVERSAL TRADE LOGIC (Entry Filter Only) ---
    if reversalRed and daily_close < daily_lower
        // Reversal: red signals normally trigger long, so reversal trade is a SHORT trade.
        float reversalEntryPrice = close
        float reversalTP  = reversalEntryPrice * 0.90    // 10% below entry
        float reversalSL  = reversalEntryPrice * 1.015   // 1.5% above entry
        strategy.entry("Reversal Short", strategy.short)
        strategy.exit("Reversal Short Exit", "Reversal Short", stop=reversalSL, limit=reversalTP)
    else if reversalGreen and daily_close > daily_upper
        // Reversal: green signals normally trigger short, so reversal trade is a LONG trade.
        float reversalEntryPrice = close
        float reversalTP  = reversalEntryPrice * 1.10    // 10% above entry
        float reversalSL  = reversalEntryPrice * 0.985   // 1.5% below entry
        strategy.entry("Reversal Long", strategy.long)
        strategy.exit("Reversal Long Exit", "Reversal Long", stop=reversalSL, limit=reversalTP)
    // --- NORMAL TRADE LOGIC (Entry Filter Only) ---
    else
        if triggeredRed and daily_close > daily_upper
            float stopLossPrice = low[coreLookback] * (1 - stopLossBufferPct / 100)
            float takeProfitPrice = high[coreLookback] * (1 + takeProfitBufferPct / 100)
            strategy.entry("Long Entry", strategy.long)
            strategy.exit("Long Exit", "Long Entry", stop=stopLossPrice, limit=takeProfitPrice)
        if triggeredGreen and daily_close < daily_lower
            float stopLossPrice = high[coreLookback] * (1 + stopLossBufferPct / 100)
            float takeProfitPrice = low[coreLookback] * (1 - takeProfitBufferPct / 100)
            strategy.entry("Short Entry", strategy.short)
            strategy.exit("Short Exit", "Short Entry", stop=stopLossPrice, limit=takeProfitPrice)
// (Additional exit conditions based on daily Bollinger bands have been removed.)
// Description: The final section implements the core strategy logic. It first checks if the bar is confirmed and there is no open position. Depending on reversal conditions and daily Bollinger band thresholds, it places reversal trades (short when red reversal signals occur under a lower band and long when green reversal signals occur above an upper band). If no reversal conditions are met, it then checks for normal trade entries (long or short) with corresponding stop loss and take profit settings based on historical coreLookback bars.