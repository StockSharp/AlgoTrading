// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © RicardoSantos

//@version=6

// @description Augmented Dickey-Fuller test (ADF), The ADF test is a statistical method used to assess whether a time series is stationary – meaning its statistical properties (like mean and variance) do not change over time. A time series with a unit root is considered non-stationary and often exhibits non-mean-reverting behavior, which is a key concept in technical analysis.
// Reference:
// - https://www.tradingview.com/script/KjD8ByIQ-Augmented-Dickey-Fuller-ADF-mean-reversion-test/
// - https://rtmath.net/assets/docs/finmath/html/93a7b7b9-e3c3-4f19-8a57-49c3938d607d.htm
// - https://en.wikipedia.org/wiki/Augmented_Dickey%E2%80%93Fuller_test
library("FunctionADF")

// @function: Augmented Dickey-Fuller test for stationarity.
// @param    data    Data series.
// @param    n_lag    Maximum lag.
// @param    conf    Confidence Probability level used to test for critical value, (`90%`, `95%`, `99%`).
// @returns
// `adf`    The test statistic. \
// `crit`    Critical value for the test statistic at the 10 % levels. \
// `nobs`    Number of observations used for the ADF regression and calculation of the critical values.
export adftest (float[] data, int n_lag, string conf) =>
    //
    if n_lag >= array.size(data) / 2 - 2
        runtime.error("Maximum lag must be less than half the `data`'s length minus two!")
    //
    // @variable Number of observations.
    int _nobs = array.size(data) - n_lag - 1
    // @variable Difference values.
    float[]  _y = array.new_float(_nobs, na)
    // @variable Actual next value.
    float[]  _x = array.new_float(_nobs, na)
    // @variable Mean of the data series.
    float _meanX = 0.0
    // @variable Components matrix.
    matrix<float> _X = matrix.new<float>(_nobs, 2, 1.0) // initiated values for the predictor layer(1).
    // Initiate matrix and array values:
    for _i = 0 to _nobs - 1
        float _v0 = data.get(_i)
        float _v1 = data.get(_i + 1)
        _meanX += _v1
        // Current difference, dependent variable.
        _y.set(_i, _v0 - _v1)
        // Store the previous-bar predictor value (related to tauADF).
        _x.set(_i, _v1)
        _X.set(_i, 0, _v1)
    _meanX /= _nobs
    //
    // Introduce lags:
    int _M = 2 + math.max(0, n_lag)
    if n_lag > 0
        for _n = 1 to n_lag
            float[] _xl = array.new_float(na)
            for _i = 0 to _nobs - 1
                // lag-n difference, predictor.
                _xl.push(array.get(data, _i + _n) - array.get(data, _i + _n + 1))
            _X.add_col(_n, _xl)
    //
    // Regression:
    matrix<float> _c = _X.pinv()
    float[] _coeff   = matrix.mult(_c, _y)
    //
    // Standard error:
    float[]    _Yhat   = matrix.mult(_X, _coeff)
    // @variable Mean square error (MSE) of regression.
    float   _sum1   = 0.0
    float   _sum2   = 0.0
    for _i = 0 to _nobs - 1
        _sum1 += math.pow(array.get(_y, _i) - array.get(_Yhat, _i), 2)
        _sum2 += math.pow(array.get(_x, _i) - _meanX, 2)
    _sum1 /= (_nobs - _M)
    float _SE = math.sqrt(_sum1 / _sum2)
    //
    // @variable The ADF test statistic.
    float  _adf = array.get(_coeff, 0) / _SE
    //
    // Critical value of the ADF test statistic (90%, model1: constant, no trend)
    // MacKinnon, J.G. 2010. “Critical Values for Cointegration Tests.” Queen”s University, Dept of Economics, Working Papers.
    // @variable Square of observations.
    float _nobs_sq = _nobs * _nobs
    // @variable Cube of observations.
    float _nobs_cu = math.pow(_nobs, 3)
    // @variable Critical value.
    float _crit  = switch
        conf == "90%" => -2.56677 - 1.5384 / _nobs -  2.809 / _nobs_sq
        conf == "95%" => -2.86154 - 2.8903 / _nobs -  4.234 / _nobs_sq - 40.040 / _nobs_cu
        conf == "99%" => -3.43035 - 6.5393 / _nobs - 16.786 / _nobs_sq - 79.433 / _nobs_cu
    //
    // output
    [_adf, _crit, _nobs]

// --- main ---


src       = input.source(title='Source',            defval=close)
lookback  = input.int(title='Length',               defval=100, minval = 2, tooltip = 'The test is applied in a moving window. Length defines the number of points in the sample.')
n_lag      = input.int(title='Maximum lag',          defval=0,   minval = 0, tooltip = 'Maximum lag which is included in test. Generally, lags allow taking into account serial correlation of price changes.')
conf      = input.string(title='Confidence Level',  defval="90%", options = ['90%', '95%', '99%'], tooltip = 'Defines at which confidence level the critical value of the ADF test statistic is calculated. If the test statistic is below the critical value, the time series sample is concluded to be mean-reverting.')
isInfobox = input.bool(title='Show infobox',        defval=true)

// load data from a moving window into an array
float[] a = array.new_float(na)
for i = 0 to lookback-1
    array.push(a,src[i])

// perform the ADF test
[tauADF, crit, nobs] = adftest(a, n_lag, conf)

// plot
color    tauColor =  switch
    tauADF < crit => #7AF54D
    tauADF > crit => color.from_gradient(math.abs(tauADF), 0.0, math.abs(crit), color.white, #F5DF4D)//#939597, #F5DF4D)

bgcolor(#64416b)
plot(0.0,    color = #939597,   title = "Zero")
plot(crit,   color = #c84df5,   title = "Critical value")
plot(tauADF, color = tauColor,  title = "Test statistic",     style = plot.style_cross, linewidth = 2)



if barstate.islast and isInfobox
    infobox = table.new("bottom_left", 2, 3, bgcolor = #faedf5, frame_color = (tauADF < crit)?#7AF54D:#C84DF5, frame_width = 1)
    table.cell(infobox, 0, 0, text = "Test Statistic",   text_color = color.black, text_size = size.small)
    table.cell(infobox, 0, 1, text = conf+" Critical Value",    text_color = color.black, text_size = size.small)
    table.cell(infobox, 0, 2, text = "Mean Reverting?",   text_color = color.black, text_size = size.small)
    table.cell(infobox, 1, 0, text = str.format("{0, number, #.####}",tauADF),   text_color = color.black, text_size = size.small)
    table.cell(infobox, 1, 1, text = str.format("{0, number, #.####}",crit),     text_color = color.black, text_size = size.small)
    table.cell(infobox, 1, 2, text = (tauADF < crit)?"Yes":"No",   text_color = color.black, text_size = size.small)