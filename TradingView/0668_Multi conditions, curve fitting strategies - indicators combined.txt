// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © sleptongems

pyramiding = 0

// var float pseudoRandomNumber = na
// var float germinate = na
// germinate := 3.1415926536 * ohlc4 * timenow
// pseudoRandomNumber := 173.0 * nz(pseudoRandomNumber[1], germinate[1]) % 30323.0
// randomFlag = math.round(pseudoRandomNumber / 30323.0)
randomFlag = math.floor(math.random(0, 1, timenow) + 0.5)
// log.info('Random: ' + str.tostring(math.random(0, 1, timenow)))

//@version=5
strategy("Multi conditions, curve fitting strategies", overlay = true,
   initial_capital = 500,
   default_qty_value = 80,
   default_qty_type = strategy.percent_of_equity,
   pyramiding = pyramiding,
   max_labels_count=500)

import sleptongems/moving_poc/1
import sleptongems/multi_conditions_matrices/2

weekChange = false
var bool weekChangeTrigger = false
weekly = request.security("", "1W", close)
if weekly != weekly[1]
    weekChangeTrigger := true

if weekChangeTrigger == true and dayofweek(time) == dayofweek.monday
    weekChange := true
    weekChangeTrigger := false

// -------------------------
// Global settings
from = input(close, "Source", group = "Global settings")

// Disabled for now.
devPoC = close //input.source(close, "Choose PoC (Point of Control)", group = "Global settings")
devVAH = close //input.source(close, "Choose PoC VAH (Value area high)", group = "Global settings")
devVAL = close //input.source(close, "Choose PoC VAL (value area low)", group = "Global settings")

int risingLength = input(1, "Number of bars for rising triggers", group = "Global settings")
int fallingLength = input(1, "Number of bars for falling triggers", group = "Global settings")

bool enterTradesRandomly = input(false, "Skip random trades", group = "Global settings")
bool weekStartOnly = input(false, "Only enter on week start", group = "Global settings")
bool weekStartOnlyExit = input(false, "Only exit on week start", group = "Global settings")
bool ignoreWeekends = input(false, "Skip trading on the weekends", group = "Global settings")
bool skipNightSignals = input(false, "Skip night signals", group = "Global settings")

bool validRandom = not enterTradesRandomly or randomFlag == 1

bool skip = false
if ignoreWeekends and multi_conditions_matrices.isWeekend()
    skip := true
if skipNightSignals and multi_conditions_matrices.isNightSignal()
    skip := true

// Weekly variables

weeklyClose = request.security("", "1W", close, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)
weeklyOpen = request.security("", "1W", open, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)
weeklyHigh = request.security("", "1W", high, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)
weeklyLow = request.security("", "1W", low, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)

// Weekly balance of power:
var series float weeklyBoP = na
weeklyBoP := (weeklyClose-weeklyOpen) / (weeklyHigh - weeklyLow)

// ------------------------
// IBS

ibs = (close - low) / (high - low)
weeklyIBS = (weeklyOpen-weeklyLow)/(weeklyHigh/weeklyLow)
ibsBuySignal = input(0.25, "IBS buy signal", group = "Intra Bar Strength")
ibsSellSignal = input(0.8, "IBS sell signal", group = "Intra Bar Strength")

// ------------------------
// Accumulation / disttribution

var cumVol = 0.
cumVol += nz(volume)
if barstate.islast and cumVol == 0
    runtime.error("No volume is provided by the data vendor.")
previousAd = ta.cum(from[1]==high[1] and from[1]==low[1] or high[1]==low[1] ? 0 : ((2*from[1]-low[1]-high[1])/(high[1]-low[1]))*volume[1])
ad = ta.cum(from==high and from==low or high==low ? 0 : ((2*from-low-high)/(high-low))*volume)

plot(previousAd, title = "Accumulation/Distribution", color=#999915, display = display.none)
plot(ad, title = "Accumulation/Distribution", color=#999915, display = display.none)

bool bearishAcFlag = ad > previousAd and open < close[1]
bool bearishAcSignal = bearishAcFlag and close < open
plotshape(bearishAcFlag, title = "Bearish ACC/Dist flag", style=shape.flag, location=location.bottom, color=color.orange, size=size.auto, display=display.none)
plotshape(bearishAcSignal, title = "Bearish ACC/Dist signal", style=shape.arrowdown, location=location.top, color=color.red, size=size.auto, display=display.none)

bool bearishObvFlag = ta.obv > ta.obv[1] and open < close[1]
bool bearishObvSignal = bearishObvFlag and close < open
plotshape(bearishObvFlag, title = "Bearish OBV flag", style=shape.flag, location=location.bottom, color=color.blue, size=size.small, display=display.none)
plotshape(bearishObvSignal, title = "Bearish OBV signal", style=shape.xcross, location=location.bottom, color=color.navy, size=size.huge, display=display.none)

// ------------------------
// Fisher Transform

fisherLength = input.int(9, title = "Fisher length", minval=1, group="Fisher transform")
triggerGap = input.float(1, title = "Gap with trigger to provide signal", group="Fisher transform")
fisherTop = input.float(1.5, title = "Fisher top line", minval=-5.0, maxval=5.0, group="Fisher transform")
fisherBottom = input.float(-1.5, title = "Fisher bottom line", minval=-5.0, maxval=5.0, group="Fisher transform")

high_ = ta.highest(hl2, fisherLength)
low_ = ta.lowest(hl2, fisherLength)
round_(val) => val > .99 ? .999 : val < -.99 ? -.999 : val
value = 0.0
value := round_(.66 * ((hl2 - low_) / (high_ - low_) - .5) + .67 * nz(value[1]))
fisher = 0.0
fisher := .5 * math.log((1 + value) / (1 - value)) + .5 * nz(fisher[1])
fisherTrigger = fisher[1]

plot(fisher, "Fisher transform", color = color.orange, display = display.none)
plot(fisherTrigger, "Fisher trigger", color = color.blue, display = display.none)

// ------------------------
// RSI

rsiLength = input(14, "RSI length", group = "RSI")
rsiOverbought = input(95, "RSI overbought", group = "RSI")
rsiOversold = input(5, "RSI oversold", group = "RSI")
rsi = ta.rsi(from, rsiLength)
plot(rsi, "RSI", display = display.none)

// ------------------------
// High minus low

hmlMaLength = input(25, "HML moving average length", group = "HML")
var series float hml = na
hml := high - low
plot(hml, title = "HML (High Minus Low)", color = color.blue, display = display.none)
hmlMa = ta.sma(hml, hmlMaLength)
plot(hmlMa, title = "HML moving average", color = color.orange, display = display.none)

// ------------------------
// SMA

fastSmaLength = input(10, "Fast SMA length", group = "SMA")
simpleSmaLength = input(25, "SMA length", group = "SMA")
fastSMA = ta.ema(from, fastSmaLength)
simpleSMA = ta.ema(from, simpleSmaLength)
plot(fastSMA, title = "Fast SMA", color = color.rgb(52, 93, 228, 5), linewidth = 2, display = display.none)
plot(simpleSMA, title = "Simple SMA", color = color.rgb(245, 157, 85, 5), linewidth = 2, display = display.none)

// ------------------------
// EMA

fastEmaLength = input(10, "Fast EMA length", group = "EMA")
simpleEmaLength = input(25, "Simple EMA length", group = "EMA")
gapAbove = input(0.0, "Percentage gap to trigger 'above' conditions", group = "EMA")
gapBelow = input(0.0, "Percentage gap to trigger 'below' conditions", group = "EMA")
fastEMA = ta.ema(from, fastEmaLength)
simpleEMA = ta.ema(from, simpleEmaLength)
plot(fastEMA, title = "Fast EMA", color = color.rgb(52, 93, 228, 5), linewidth = 2, display = display.none)
plot(simpleEMA, title = "Simple EMA", color = color.rgb(245, 157, 85, 5), linewidth = 2, display = display.none)

// -------------------------
// RSI

bool useHtfTicker = input.bool(false, "Use another ticker for HTF", group = "Higher timeframe")
string htfTicker = input.symbol("", "HTF symbol", group = "Higher timeframe")
string higherTimeframe = input.timeframe("W", "Higher timeframe", group = "Higher timeframe")
if not useHtfTicker or htfTicker == ""
    htfTicker := syminfo.tickerid
float htfPrice = request.security(htfTicker, higherTimeframe, from, lookahead = barmerge.lookahead_off)

htfRsiLength = input(15, "HTF RSI length", group = "Higher timeframe")
htfRsi = ta.rsi(htfPrice, htfRsiLength)
htfRsiMa = ta.sma(htfRsi, htfRsiLength)
plot(htfRsi, title = "HTF RSI", color = color.aqua, display = display.none)
plot(htfRsiMa, title = "HTF RSI MA", color = color.red, display = display.none)

var bool htfRsiUp = na
var bool htfRsiDown = na

if htfRsi == htfRsiMa
    if htfRsiUp
        htfRsiUp := true
        htfRsiDown := false
    else
        htfRsiUp := false
        htfRsiDown := true
else if htfRsi > htfRsiMa
    htfRsiUp := true
    htfRsiDown := false
else if htfRsi < htfRsiMa
    htfRsiUp := false
    htfRsiDown := true

plotshape(htfRsiUp, title = "HTF RSI up", style = shape.arrowup, location = location.bottom, color = color.green, size = size.normal, display = display.none)
plotshape(htfRsiDown, title = "HTF RSI down", style = shape.arrowdown, location = location.bottom, color = color.red, size = size.normal, display = display.none)

// -------------------------
// Full stochastic Indicator

lookback_period = input.int(14, title = "loopback", minval=1, group = "Stochastic")
m1 = input.int(3, minval=1, group = "Stochastic")
m2 = input.int(3, minval=1, group = "Stochastic")

stochK = ta.sma(ta.stoch(from, high, low, lookback_period), m1)
stochD = ta.sma(stochK, m2)
plot(stochK, title="Stochastic oscillator K", color=color.black, display=display.none)
plot(stochD, title="Stochastic oscillator D", color=color.red, display=display.none)
h0 = hline(80, display=display.none)
h1 = hline(20, display=display.none)

// -------------------------
// Point of control moving average

var averagePriceByVolumeHistory = array.new<float>()

nbBarsToLookback = input.int(10, 'Number of bars to calculate PoC moving average', minval = 0, group = "Point of control")
pocLookbackPrecision = input.timeframe("60", "Lookback precision", group = "Point of control")
entryGapP = input.float(0.1, "Crossup percent gap ", group = "Point of control")
exitGapP = input.float(0.1, "Crossdown percent gap ", group = "Point of control")
pocMovingAverageLength = input(30, "PoC sma length", group = "Point of control")

bullishGapSignals = input.float(4.0, "Percentage gap for bullish weekly sentiment", minval = 0, group = "Weekly PoC")
bearishGapSignals = input.float(-4.0, "Percentage gap for bearish weekly sentiment", maxval = 0, group = "Weekly PoC")
bopBullishTrigger = input.float(0.5, "Minimum weekly BoP bullish triggers", minval = 0, maxval = 1, group = "Weekly PoC")
bopBearishTrigger = input.float(-0.5, "Maximum weekly BoP for bearish triggers", minval = -1, maxval = 0, group = "Weekly PoC")
wPocLookbackNbBars = input.int(0, "Nb bars for weekly PoC conditions", minval = 0, group = "Weekly PoC")

ltfVolume = request.security_lower_tf(syminfo.tickerid, pocLookbackPrecision, volume)
ltfPrice = request.security_lower_tf(syminfo.tickerid, pocLookbackPrecision, from)

movingPoc = averagePriceByVolumeHistory.getMovingPoc(ltfVolume, ltfPrice, nbBarsToLookback)
movingPocSma = ta.sma(movingPoc, pocMovingAverageLength)

plot(movingPoc, "Moving point of control", color = color.rgb(49, 98, 233), linewidth = 2, display = display.none)
plot(movingPocSma, "Moving point of control SMA", color = color.rgb(245, 157, 85, 5), linewidth = 1, display = display.none)

// The latest weekly PoC from last sunday.
var series float weeklyPocRef = na
var series float weeklyVAHRef = na
var series float weeklyVALRef = na
var float newBuildingPoC = na
var float newBuildingVAH = na
var float newBuildingVAL = na

bool wPocSentimentIsBullish = false
bool wPocSentimentIsBearish = false
bool wPocSentimentIsInVAH = false
bool wPocSentimentIsInVAL = false

// if syminfo.type == 'stock' and dayofweek(time) == dayofweek.friday or
//  syminfo.type == 'crypto' and dayofweek(time) == dayofweek.sunday
if weeklyClose != weeklyClose[1]
    newBuildingPoC := devPoC
    newBuildingVAH := devVAH
    newBuildingVAL := devVAL

signalWeekChange = false

weeklyPocSentimentIsBullish(lookback = 0) =>
//    weeklyClose[lookback] > weeklyPocRef[lookback] * ((100+bullishGapSignals)/100) and (bopBullishTrigger == 0 or weeklyBoP[lookback] >= bopBullishTrigger)
   //  close > weeklyVAHRef[lookback]
   close > devVAH

weeklyPocSentimentIsBearish(lookback = 0) =>
//    weeklyCloseweeklyVAHRef[lookback] < weeklyPocRef[lookback] * ((100+bearishGapSignals)/100) and (bopBearishTrigger == 0 or weeklyBoP[lookback] <= bopBearishTrigger)
   //  close < weeklyVALRef[lookback]
   close < devVAL

weeklyPocSentimentIsInVAL(lookback = 0) =>
   // close < weeklyPocRef[lookback] and close > weeklyVALRef[lookback]
   close < devPoC and close > devVAL

weeklyPocSentimentIsInVAH(lookback = 0) =>
   // close > weeklyPocRef[lookback] and close < weeklyVAHRef
   close > devPoC and close < devVAH

if (dayofweek(time) == dayofweek.monday or (dayofweek(time) == dayofweek.tuesday) and weeklyPocRef != newBuildingPoC)
    signalWeekChange := true
    weeklyPocRef := newBuildingPoC
    weeklyVAHRef := newBuildingVAH
    weeklyVALRef := newBuildingVAL
    //  log.info('Weekly close: ' + str.tostring(weeklyClose))
    //  log.info('Weekly PoC: ' + str.tostring(weeklyPocRef))
    //  log.info('Weekly BoP: ' + str.tostring(weeklyBoP))
    if weeklyPocSentimentIsBullish()
        wPocSentimentIsBullish := true
        wPocSentimentIsBearish := false
        wPocSentimentIsInVAH := false
        wPocSentimentIsInVAL := false
    else if weeklyPocSentimentIsBearish()
        wPocSentimentIsBearish := true
        wPocSentimentIsBullish := false
        wPocSentimentIsInVAH := false
        wPocSentimentIsInVAL := false
    else if weeklyPocSentimentIsInVAH()
        wPocSentimentIsInVAH := true
        wPocSentimentIsInVAL := false
        wPocSentimentIsBearish := false
        wPocSentimentIsBullish := false
    else if weeklyPocSentimentIsInVAL()
        wPocSentimentIsInVAL := true
        wPocSentimentIsInVAH := false
        wPocSentimentIsBearish := false
        wPocSentimentIsBullish := false
    else
        wPocSentimentIsInVAH := false
        wPocSentimentIsInVAL := false
        wPocSentimentIsBearish := false
        wPocSentimentIsBullish := false
else
    weeklyPocRef := weeklyPocRef[1]

// @todo,

// Use month period in PVP settings, track price crossovers:

// Add aggressive sell and bettter cancel order conditions based on value area
// Use retracements to PoC from exit points

// Set conditions based on monday open or close ? (in conjunction to tuesday open or close for validation ???):
//    1. Position relative to value area : above VAH, below VAL, above PoC, below PoC (4 possibilities)
//    2. Assert next week sentiment on divergences from monday expected direction to friday's close
// Depending on conditions, take one of those actions:
//    a. Retracement to VAH / VAL / PoC (using a percentage ?)
//    b. TP / SL at a percentage

// Detect trend sentiment based on monday price position compared to weekly PoC 2 weeks before (previous blue line),
// Evaluate order differently based on previous trend assertion,
// Ex:
// 1. on a ranging sentiment for the week ahead, put a buy limit on closest support level and sell at weekly PoC if above.
// 2. on a bull trend, use a specific TP

// Record weekly PoC unfilled retracements lines and
// If exited on a new all time high, don't enter until retracement to support level
// Take decision according to proximity of unfilled support resistance lines

// Try to add entry signals on monday with neutral following neutral or bullish weekly PoC sentiment OR
// bullish following neutral or bullish sentiment

// Use weeklyPocRef - weeklyPocRef[1] delta as potent information

// Test if always better to buy the dip / bottom of a bowl instead of peaks ?

// Re-evaluate SL, TP, limit buy at every week start depending on levels and market sentiment
// Try limits orders to retracements with different TP percentage depending on bearish or bullish sentiment
//     -> limit buy on support levels with percentage gap
//     -> limit sell on resistance levels with percentage gap or TP at specific percentage up from
// Look into weeklyPocRef history to use retracements on previous highs (as a percent gap from it)
// Track 3 types of signals: trends start, ongoing and reversals
// Try signals from price crossing weeklyPocRef
// Make different decisions upon weekly bar strength and direction
// Look for forming gap between previous n weekly PoC to guess the trend, during bullrun each week the gap is much higher
// Sum up the count of sentiment for n previous weekly bars in order to get the correct current weekly sentiment ?
// Take into account weekly bar intrabar strength
// X Verify if last week 1D bar direction is telling something usefull about next week sentiment

plot(devPoC, title = "Developping PoC", color = color.rgb(155, 39, 176, 56), style = plot.style_stepline, linewidth = 2)
plot(devVAH, title = "Developping VAH", color = color.rgb(33, 149, 243, 51), style = plot.style_stepline, linewidth = 2)
plot(devVAL, title = "Developping VAL", color = color.rgb(255, 153, 0, 54), style = plot.style_stepline, linewidth = 2)

plotshape(wPocSentimentIsBullish, "Week change signal", text = "Bullish", textcolor = color.white, size = size.large, style = shape.labeldown, color = #4caf4f56)
plotshape(wPocSentimentIsBearish, "Week change signal", text = "Bearish", textcolor = color.white, size = size.large, style = shape.labeldown, color = #ff52522f)
plotshape(wPocSentimentIsInVAH, "Week change signal", text = "VAH", textcolor = color.white, size = size.large, style = shape.labeldown, color = #ff990077)
plotshape(wPocSentimentIsInVAL, "Week change signal", text = "VAL", textcolor = color.white, size = size.large, style = shape.labeldown, color = #2195f365)

plot(weeklyPocRef, color = #a621f3d3, title = "Previous weekly PoC", linewidth = 3, display = display.none)

// -------------------------

var long = false

// Orders

float limitBuy = na
float stopBuy = na

var float entryRef = na
var float exitRef = na

var float stopLoss = na
var float takeProfit = na

// Lagging open trades counter to detect and process on entry bars (see last script line)
var int openTrades = 0

// log.info(str.tostring(strategy.opentrades) + ' open trade(s) around ' + str.tostring(close))
// No opened position(s):
if strategy.opentrades <= 0
    long := false
// Active position(s):
if strategy.opentrades > pyramiding
    long := true
    limitBuy := na
    stopBuy := na

// -------------------------
// Entry

bool withANDEntryConditions = input(true, "Use AND conditions", group = "Entry conditions")

entryConditions = matrix.new<bool>()

entryConditions.addConditions(array.from(
   input(true, "Higher time frame (htf) RSI is bullish", group = "Entry conditions"),
   htfRsiUp))
entryConditions.addConditions(array.from(
   input(false, "Use stochastic oscillator", group = "Entry conditions"),
   stochK > stochD))
// entryConditions.addConditions(array.from(
//    input(true, "[Weelkly PoC] Weekly PoC sentiment is bullish", group = "Entry conditions"),
//    wPocSentimentIsBullish))
// entryConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] price source above", group = "Entry conditions"),
//    from > weeklyPocRef[wPocLookbackNbBars]))
// entryConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] 2 (previous) weeks positive delta", group = "Entry conditions"),
//    weeklyPocRef - weeklyPocRef[5] > 0 ))
// entryConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] moving up", group = "Entry conditions"),
//    weeklyPocRef[5] > weeklyPocRef[9] ))
// entryConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] price above n-1 week PoC", group = "Entry conditions"),
//    from > weeklyPocRef[5] ))
// entryConditions.addConditions(array.from(
//    input(false, "[Moving PoC] crossing up PoC", group = "Entry conditions"),
      //  close > movingPoc * (1 + (entryGapP / 100)) and open <= movingPoc * (1 + (entryGapP / 100))))
// entryConditions.addConditions(array.from(
//    input(false, "[Moving PoC] below moving PoC moving average", group = "Entry conditions"),
//    movingPoc < movingPocSma ))
entryConditions.addConditions(array.from(
   input(false, "[Moving PoC] moving average rising", group = "Entry conditions"),
   ta.rising(movingPoc, risingLength)))
entryConditions.addConditions(array.from(
   input(false, "[SMA] Open above", group = "Entry conditions"),
   open > simpleSMA))
entryConditions.addConditions(array.from(
   input(false, "[SMA] Close above", group = "Entry conditions"),
   close > simpleSMA))
entryConditions.addConditions(array.from(
   input(false, "[SMA] fast above regular", group = "Entry conditions"),
   fastSMA > simpleSMA))
entryConditions.addConditions(array.from(
   input(false, "[EMA] Uptrending", group = "Entry conditions"),
   ta.rising(fastEMA, risingLength) ))
entryConditions.addConditions(array.from(
   input(false, "[EMA] fast above regular", group = "Entry conditions"),
   fastEMA > simpleEMA))
entryConditions.addConditions(array.from(
   input(false, "[EMA] Simple EMA has not been trending down for specified number of bars", group = "Entry conditions"),
   not ta.falling(simpleEMA, fallingLength)))
entryConditions.addConditions(array.from(
   input(false, "[Price] is rising", group = "Entry conditions"),
   ta.rising(from, risingLength)))
entryConditions.addConditions(array.from(
   input(false, "[Price] Buy the dip (falling bars length)", group = "Entry conditions"),
   ta.falling(close, fallingLength)))
entryConditions.addConditions(array.from(
   input(false, "[Timing] Today is monday", group = "Entry conditions"),
   dayofweek(time) == dayofweek.monday))
entryConditions.addConditions(array.from(
   input(false, "[Timing] Today is monday or tuesday", group = "Entry conditions"),
   dayofweek(time) == dayofweek.tuesday or dayofweek(time) == dayofweek.monday))
entryConditions.addConditions(array.from(
   input(false, "[Timing] Today is monday or friday", group = "Entry conditions"),
   dayofweek(time) == dayofweek.monday or dayofweek(time) == dayofweek.friday))
entryConditions.addConditions(array.from(
   input(false, "[Timing] Second day in a row with lower close", group = "Entry conditions"),
   close[0] < close[1] and close[1] < close[2]))
entryConditions.addConditions(array.from(
   input(false, "[Timing] New five days low", group = "Entry conditions"),
   ta.lowest(close, 6) == close))
entryConditions.addConditions(array.from(
   input(false, "[Timing] Today high lower than previous ten days high", group = "Entry conditions"),
   ta.lowest(high, 11) == high ))
entryConditions.addConditions(array.from(
   input(false, "[IBS] Intrabar strength is lower than set value", group = "Entry conditions"),
   ibs < ibsBuySignal ))
entryConditions.addConditions(array.from(
   input(false, "[RSI] Oversold", group = "Entry conditions"),
   rsi <= rsiOversold))
entryConditions.addConditions(array.from(
   input(false, "[Fisher] Trigger above trigger", group = "Entry conditions"),
   fisher > (fisherTrigger + triggerGap)))
entryConditions.addConditions(array.from(
   input(false, "[Fisher] Fisher below bottom line", group = "Entry conditions"),
   fisher < fisherBottom))
entryConditions.addConditions(array.from(
   input(false, "[HML] HML is the lowest of previous 6 trading days", group = "Entry conditions"),
   ta.lowest(hml, 7) == hml))
entryConditions.addConditions(array.from(
   input(false, "[HML] HML is below moving average", group = "Entry conditions"),
   hml < hmlMa))

potentialEntry = entryConditions.check(withANDEntryConditions) and not long and not skip and (not weekStartOnly or weekChange) and validRandom

buyLimitRefPercentage = input.float(-0.5, "Buy limit order percentage from entry point", maxval = 0.0, group = "Buy orders")
buyStopRefPercentage = input.float(0.0, "Buy stop order percentage from entry point", minval = 0.0, group = "Buy orders")
entryRefSource = input.string("Price", "Entry price reference", options = ["Price", "PoC moving average", 'Fast SMA', 'Fast EMA'], group = "Buy orders")
barsFromEntryRef = input.int(0, "Nb of bars behind entry point of reference", minval = 0, group = "Buy orders")
buyImmediately = input(false, "Buy with market order", "Buy orders")

entryTakeProfitPercentage = input.float(0.0, "Entry take profit percentage", minval = 0, group = "Entry SL & TP")
entryStopLossPercentage = input.float(-0.0, "Entry stop loss percentage", maxval = 0, group = "Entry SL & TP")

plotshape(potentialEntry, "Potential entry", location = location.belowbar, style = shape.labelup, color = color.green)

assignPriceReference (source, nbBars) =>
    switch source
        'Price' =>
            if nbBars == 0 and strategy.opentrades > 0 and entryStopLossPercentage != 0
                strategy.opentrades.entry_price(strategy.opentrades - 1)
            else
                from[nbBars]
        'PoC' =>
            movingPoc[nbBars]
        'PoC moving average' =>
            movingPocSma[nbBars]
        'Weekly PoC' =>
            weeklyPocRef[nbBars]
        'Fast SMA' =>
            ta.sma(from[nbBars], fastSmaLength)
        'Fast EMA' =>
            ta.ema(from[nbBars], fastEmaLength)
        'High' =>
            ta.highest(high, nbBars)
        'Low' =>
            ta.lowest(low, nbBars)

potentialEntryPrice = assignPriceReference(entryRefSource, barsFromEntryRef)

if potentialEntry

    entryRef := potentialEntryPrice

    log.info('Potential entry price ' + str.tostring((potentialEntryPrice)))

    stopRef = entryRef * (1+(buyStopRefPercentage/100))
    limitRef = entryRef * (1+(buyLimitRefPercentage/100))

    buyComment = ''
    if stopRef != entryRef and close <= stopRef
        stopBuy := stopRef
        buyComment += "Stop buy " + str.tostring(stopBuy)
    else if limitRef != entryRef and close > limitRef
        if open <= limitRef
            stopBuy := limitRef
            buyComment += "Stop limit buy " + str.tostring(stopBuy)
        else
            limitBuy := limitRef
            buyComment += "Limit buy " + str.tostring(limitBuy)

    strategy.cancel_all()

    if buyImmediately
        strategy.cancel('Buy order')
        strategy.entry("Buy order", strategy.long)
        log.info('Market order buy')
    else if not na(limitBuy) or not na(stopBuy)
        log.info(str.tostring(buyComment) + ".\nPrice ref "  + str.tostring(entryRef))
        strategy.order("Buy order", strategy.long, na, limitBuy, stopBuy, comment = buyComment)
        label.new(bar_index, high, style = label.style_label_down, tooltip = buyComment, color = color.green, size = size.large)
        alert(buyComment, alert.freq_once_per_bar_close)

// Must be triggererd only once from the first potentialEntry trigger before actual entry:
if openTrades < strategy.opentrades

    exitRef := strategy.opentrades.entry_price(strategy.opentrades - 1)

    takeProfit := entryTakeProfitPercentage != 0 ? exitRef * (1+(entryTakeProfitPercentage/100)) : na
    stopLoss := entryStopLossPercentage != 0 ? exitRef * (1+(entryStopLossPercentage/100)) : na

    log.info(str.tostring('Initial SL ' + str.tostring(stopLoss)) + ', exit ref ' + str.tostring(exitRef) )

    initialExitComment = ''
    if not na(stopLoss)
        initialExitComment := initialExitComment + 'SL ' + str.tostring(stopLoss)
    if not na(takeProfit)
        initialExitComment := initialExitComment + 'TP ' + str.tostring(takeProfit)

    if not na(stopLoss) or not na(takeProfit)
        log.info(initialExitComment)
        label.new(bar_index, high, style = label.style_label_down, tooltip = initialExitComment, color = color.orange, size = size.large)
        strategy.exit("Initial sell", "Buy order",
           limit = takeProfit,
           stop = stopLoss,
           comment_profit = 'Initial TP @ ' + str.tostring(takeProfit),
           comment_loss = 'Initial SL @ ' + str.tostring(stopLoss))
        alert(initialExitComment)

// -------------------------
// Exit

bool withANDExitConditions = input(true, "Use AND conditions", group = "Exit conditions")

exitConditions = matrix.new<bool>()

exitConditions.addConditions(array.from(
   input(true, "Higher time frame (htf) RSI is bearish", group = "Exit conditions"),
   htfRsiDown))
exitConditions.addConditions(array.from(
   input(false, "Use stochastic oscillator", group = "Exit conditions"),
   stochD > stochK))
// exitConditions.addConditions(array.from(
//    input(true, "[Weelkly PoC] Weekly PoC sentiment is bearish", group = "Exit conditions"),
//    wPocSentimentIsBearish))
// exitConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] price source below", group = "Exit conditions"),
//    from < weeklyPocRef[wPocLookbackNbBars]))
// exitConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] price below n-1 week PoC", group = "Exit conditions"),
//    from < weeklyPocRef[5] ))
// exitConditions.addConditions(array.from(
//    input(false, "[Moving PoC] moving average above price close", group = "Exit conditions"),
//    close < movingPoc  * (1 - (exitGapP/100)) and open > movingPoc  * (1 - (exitGapP/100))))
// exitConditions.addConditions(array.from(
//    input(false, "[Moving PoC] - crossing up PoC moving average", group = "Exit conditions"),
//    movingPoc > movingPocSma))
// exitConditions.addConditions(array.from(
//    input(false, "[Moving PoC] - moving average falling", group = "Exit conditions"),
//    ta.falling(movingPoc, fallingLength)))
exitConditions.addConditions(array.from(
   input(false, "[SMA] Price open below", group = "Exit conditions"),
   open < simpleSMA))
exitConditions.addConditions(array.from(
   input(false, "[SMA] Price close below", group = "Exit conditions"),
   close < simpleSMA))
exitConditions.addConditions(array.from(
   input(false, "[SMA] fast below regular", group = "Exit conditions"),
   fastSMA < simpleSMA))
exitConditions.addConditions(array.from(
   input(false, "[EMA] Close below", group = "Exit conditions"),
   close < (simpleEMA*(1+gapBelow/100)) ))
exitConditions.addConditions(array.from(
   input(false, "[EMA] Open below", group = "Exit conditions"),
   open < (simpleEMA*(1+gapBelow/100)) ))
exitConditions.addConditions(array.from(
   input(false, "[EMA] fast below regular", group = "Exit conditions"),
   fastEMA < simpleEMA))
exitConditions.addConditions(array.from(
   input(false, "[Price] - is falling", group = "Exit conditions"),
   ta.falling(close, fallingLength)))
exitConditions.addConditions(array.from(
   input(false, "[Timing] Close is higher than yesterday's high", group = "Exit conditions"),
   close[0] > high[1] ))
exitConditions.addConditions(array.from(
   input(false, "[IBS] Closes above given value", group = "Exit conditions"),
   ibs > ibsSellSignal ))
exitConditions.addConditions(array.from(
   input(false, "[RSI] Overbought", group = "Exit conditions"),
   rsi >= rsiOverbought))
exitConditions.addConditions(array.from(
   input(false, "[Fisher] Trigger above line", group = "Exit conditions"),
   fisherTrigger > (fisher + triggerGap)))
exitConditions.addConditions(array.from(
   input(false, "[Fisher] Trigger above fisherTop", group = "Exit conditions"),
   fisherTrigger > fisherTop))
exitConditions.addConditions(array.from(
   input(false, "[Acc / Dist] bearish divergence", group = "Exit conditions"),
   bearishAcSignal ))
exitConditions.addConditions(array.from(
   input(false, "[Acc / Dist] bearish OBV divergence", group = "Exit conditions"),
   bearishObvSignal ))
exitConditions.addConditions(array.from(
   input(false, "[Timing] Today is friday", group = "Exit conditions"),
   dayofweek(time) == dayofweek.friday))
exitConditions.addConditions(array.from(
   input(false, "[Timing] Today is monday or friday", group = "Exit conditions"),
   dayofweek(time) == dayofweek.monday or dayofweek(time) == dayofweek.friday))

potentialExit = exitConditions.check(withANDExitConditions) and long and not skip and (not weekStartOnlyExit or weekChange)

exitRefSource = input.string("Price", "Exit price reference", options = ["Price", "PoC moving average", 'Fast SMA', 'Fast EMA'], group = "Sell orders")
barsFromExitRef = input(1, "Nb of bars behind exit reference point", group = "Sell orders")

takeProfitPercentage = input.float(5.0, "Take profit percentage", minval = 0, group = "Exit TP & SL")
stopLossPercetenage = input.float(-5.0, "Stop loss percentage", maxval = 0, group = "Exit TP & SL")

tpOnlyFromExitSignalIfHigherThanEntryTp = input.bool(false, "Only take profit from exit signal if higher than entry TP", group = "Exit TP & SL")

potentialExitRef = assignPriceReference(exitRefSource, barsFromExitRef)

maxExitSignals = input.int(0, "Put a limit to the number of exit signals", minval = 0, group = "Exit TP  & SL")
maxBarsInTrade = input.int(0, "Always trigger exit signal after n bars", minval = 0, group = "Exit TP  & SL")

var int countExitSignals = 0
var int nbBarsInOpenTrade = 0

// Reset exit signals counter
if strategy.opentrades == 0
    countExitSignals := 0
    nbBarsInOpenTrade := 0
else
    nbBarsInOpenTrade += 1

if maxBarsInTrade != 0 and nbBarsInOpenTrade >= maxBarsInTrade
    potentialExit := true

if maxExitSignals > 0 and countExitSignals >= maxExitSignals
    potentialExit := false

plotshape(potentialExit, "Potential exit", location = location.abovebar, style = shape.labeldown, color = color.red)

if potentialExit

    log.info('potential exit')

    exitRef := potentialExitRef

    exitTp = takeProfitPercentage != 0 ? exitRef * (1+(takeProfitPercentage/100)) : takeProfit
    stopLoss := stopLossPercetenage != 0 ? exitRef * (1+(stopLossPercetenage/100)) : stopLoss
    if tpOnlyFromExitSignalIfHigherThanEntryTp and exitTp < takeProfit
        exitTp := takeProfit
        log.info('tpOnlyFromExitSignalIfHigherThanEntryTp')

    potentialExitText = 'Exit @'
    potentialExitText += ' TP: ' + (na(exitTp) ? 'X' : str.tostring(exitTp))
    potentialExitText += ' SL: ' + (na(stopLoss) ? 'X' : str.tostring(stopLoss))
    potentialExitText += '\nPrice ref: ' + str.tostring(exitRef)

    strategy.cancel_all()
    strategy.exit("Buy order", limit = exitTp, stop = stopLoss,
       comment_profit = 'TP @ ' + str.tostring(exitTp),
       comment_loss = 'SL @ ' + str.tostring(stopLoss))

    if maxExitSignals >= 0
        countExitSignals += 1

    label.new(
       bar_index,
       low,
       style = label.style_label_up,
       tooltip = potentialExitText,
       color = color.red,
       size = size.large)
    log.info(potentialExitText)
    alert(potentialExitText, alert.freq_once_per_bar_close)

// Cancel orders conditions

// @todo aggressive sell option after n sell signals.

// bool withANDResetConditions = input(false, "Use AND reset conditions", group = "Cancel buy orders conditions")

// resetBuyOrdersConditions = matrix.new<bool>()

// resetBuyOrdersConditions.addConditions(array.from(
//    input(false, "[Weekly PoC] price below", group = "Cancel buy orders conditions"),
//    from < weeklyPocRef[wPocLookbackNbBars] ))

// cancelPendingBuyOrders = resetBuyOrdersConditions.check(withANDResetConditions)

// if cancelPendingBuyOrders and strategy.opentrades == 0
//     strategy.cancel_all()

// if strategy.opentrades > 0 and openTrades == 0
//     limitBuy := na
//     stopBuy := na
//     stopLoss := na
//     takeProfit := na

var float entryPrice = na
var int nbBarsBelowEntry = 0

if openTrades < strategy.opentrades
    log.info('New buy order, open trades from ' + str.tostring(openTrades) + ' to ' + str.tostring(strategy.opentrades))
    entryPrice := open

if openTrades > strategy.opentrades
    log.info('New sell order, open trades from ' + str.tostring(openTrades) + ' to ' + str.tostring(strategy.opentrades))
    openTrades -= 1
    nbBarsBelowEntry := 0

if open < entryPrice and openTrades > 0
    nbBarsBelowEntry += 1
else
    nbBarsBelowEntry := 0

acceptBarsBelowPrice = input.int(0, "Number of bars below entry price before automatic exit", group = "Orders cancellation")

if acceptBarsBelowPrice != 0 and nbBarsBelowEntry > acceptBarsBelowPrice
    strategy.cancel_all()
    string buyComment = 'TP: ' + str.tostring(entryPrice) + '\nSL: ' + str.tostring(devVAL)
    strategy.exit("Failed entry", "", stop = devVAL, limit = entryPrice)
    label.new(bar_index, high, style = label.style_label_down, tooltip = buyComment, color = color.rgb(241, 201, 22), size = size.large)

if strategy.opentrades != openTrades
    openTrades := strategy.opentrades