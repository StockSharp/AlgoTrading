// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © PineCoders

//@version=6
library("Time", true)

// Time Library
// v5, 2025.03.26

// This code was written using the recommendations from the Pine Script® User Manual's Style Guide:
//   https://www.tradingview.com/pine-script-docs/writing/style-guide/



//#region ———————————————————— Library functions


// @function            Measures the number of seconds for which a realtime condition remains `true`.
// @param cond          (series bool) A "bool" value representing the condition to time.
// @param resetCond     (series bool) Optional. When `true`, the timer resets. The default is `barstate.isnew`.
// @returns             (int) The duration, in seconds, for which `cond` is continuously `true`.
export secondsSince(series bool cond, series bool resetCond = barstate.isnew) =>
    varip int timeBegin = na
    varip bool lastCond = false
    if resetCond
        timeBegin := cond ? timenow : na
    else if cond
        if not lastCond
            timeBegin := timenow
    else
        timeBegin := na
    lastCond := cond
    int result = (timenow - timeBegin) / 1000


// @function            Calculates a millisecond time offset from a specified positive or negative number of time units,
//                      then applies the offset to the UNIX timestamp of the bar's opening time, closing time, or the
//                      time of the latest script execution.
// @param qty           (series int) The number of specified `units` in the time offset. If the value is positive, the
//                      timestamp is offset into the future. Otherwise, it is offset into the past.
// @param units         (series string) A "string" specifying one of the following time units:
//                      "chart" (for chart timeframes), "seconds", "minutes", "hours", "days", "months", "years".
//                      Note that "chart" option is not usable on tick charts.
// @param from          (series string) Optional. Determines which UNIX timestamp the function applies the offset to.
//                      Possible values:
//                       - "bar" to apply the offset to the bar's opening timestamp.
//                       - "close" to apply the offset to the bar's closing timestamp.
//                       - "now" to apply the offset to timestamp of the script's latest execution.
//                      The default is "bar".
// @returns             (int) The millisecond UNIX timestamp of the offset time.
export timeFrom(series int qty, series string units, series string from = "bar") =>
    var string unitsVal = ""
    var string unit     = ""
    if unitsVal != units
        unit     := str.match(units, "^(?:chart|(?:second|minute|hour|day|month|year)s?)\\z")
        unitsVal := units
    if unit == ""
        runtime.error(
             "Invalid `units` string ('" + unit + "'). The value must be one of the following:
             'chart', 'seconds', 'minutes', 'hours', 'days', 'months', or 'years'"
         )
    int t = switch from
        "bar"   => time
        "close" => time_close
        "now"   => timenow
        => runtime.error(
             "Invalid `from` string ('" + from + "'). The value must be one of the following: 'bar', 'close', or 'now'"
         ), na
    int result = if units == "chart"
        int(t + (timeframe.in_seconds("") * 1000 * qty))
    else
        int y    = year(t)       + (unit == "years"   ? qty : 0)
        int m    = month(t)      + (unit == "months"  ? qty : 0)
        int d    = dayofmonth(t) + (unit == "days"    ? qty : 0)
        int hr   = hour(t)       + (unit == "hours"   ? qty : 0)
        int min  = minute(t)     + (unit == "minutes" ? qty : 0)
        int sec  = second(t)     + (unit == "seconds" ? qty : 0)
        timestamp(y, m, d, hr, min, sec)


// @function            Estimates the number of specified calendar units covered by a millisecond time difference, then
//                      formats the result into a "string" value.
// @param ms            (series int) The millisecond time difference to express in calendar units.
// @param unit          (series string) Optional. A "string" specifying the calendar units used in the conversion.
//                      Possible values: "seconds", "minutes", "hours", "days", "weeks", or "months". If not specified
//                      or an empty "string", the function automatically selects the unit based on the `ms` value. The
//                      default is `na`.
// @returns             (string) A formatted "string" representing the calendar units covered by the `ms` time span.
export formattedNoOfPeriods(series int ms, series string unit = na) =>
    [tf, denominator] = if na(unit)
        switch
            ms < 60000      => ["seconds", 1000      ]
            ms < 3600000    => ["minutes", 60000     ]
            ms < 86400000   => ["hours",   3600000   ]
            ms < 604800000  => ["days",    86400000  ]
            ms < 2628003000 => ["weeks",   604800000 ]
            =>                 ["months",  2628003000]
    else
        switch unit
            "seconds" => [unit, 1000      ]
            "minutes" => [unit, 60000     ]
            "hours"   => [unit, 3600000   ]
            "days"    => [unit, 86400000  ]
            "weeks"   => [unit, 604800000 ]
            "months"  => [unit, 2628003000]
            => runtime.error(
                 "Invalid `unit` string ('" + unit + "'). When specified, the value must be one of the following:
                 'seconds', 'minutes', 'hours', 'days', 'weeks', or 'months'"
             ), [na, na]
    float  qty = math.round(ms / denominator, 2)
    string unitString = qty != 1 ? tf : str.replace(tf, "s", "", 1)
    string result = str.tostring(qty) + " " + unitString
//#endregion



//#region ———————————————————— Example Code


// —————————— Constants

string SI1      = "tiny",    string TP1 = "top"
string SI2      = "small",   string TP2 = "middle"
string SI3      = "normal",  string TP3 = "bottom"
string SI4      = "large",   string TP4 = "left"
string SI5      = "huge",    string TP5 = "center"
string SI6      = "auto",    string TP6 = "right"
string TU1      = "chart",   string OF1 = "Bar's Open Time"
string TU2      = "seconds", string OF2 = "Bar's Close Time"
string TU3      = "minutes", string OF3 = "Last Execution Time"
string TU4      = "hours",   string TU5 = "days"
string TU6      = "weeks",   string TU7 = "months"
string TU8      = "years",

string N_TT     = "Number of specified time units for the time offset of the line's ending point."
string UNITS_TT = "Time unit for the offset calculation. For example, if the value is 'chart' and the previous input's
                     value is 2, the time offset equals two chart timeframes."
string FROM_TT = "Specifies the starting time from which to calculate the line ending times."

string TICKS_TT = "The tick distance between the open and the high required to trigger the alert.
     The bar's timer starts when the range reaches this distance."
string SEC_TT   = "Number of seconds for which the condition must remain active before the alert triggers."
string RESET_TT = "When enabled, the timer resets at the start of every realtime bar."

string INPUT_TT = "When enabled, the script expresses each line's duration in the time unit specified below.
     Otherwise, it automatically selects the time unit."
string TIME_TT  = "Custom unit for expressing the line's time span."

string MULT_TT  = "Multiplier for the timeframe string calculation. The script multiplies the charts timeframe's seconds
                   by this value, then determines the valid timeframe closest to that number of seconds."
string SIZE_TT  = "Changes the size of the display table."
string POS_TT   = "Changes the position of the display table in the pane."

// Define the number of bars before and after a bar required to confirm pivot points.
int LEFT_BARS   = 20
int RIGHT_BARS  = 20


// ——————————  Inputs

string GRP1           = "══════════ Seconds since ══════════"
int    ticksInput     = input.int(0,            "Number Of Ticks From Open",    group = GRP1, tooltip = TICKS_TT)
float  secondsInput   = input.int(20,           "Seconds condition must last",  group = GRP1, tooltip = SEC_TT,   minval = 1)
bool   resetInput     = input.bool(true,        "Reset timing on new bar",      group = GRP1, tooltip = RESET_TT)

string GRP2           = "═══════════   Time from   ═══════════"
int    nInput         = input.int(20,           "Lines End At Offset n (+/-)", group = GRP2, tooltip = N_TT)
string unitsInput     = input.string(TU1,       "Offset Units",                group = GRP2, tooltip = UNITS_TT, options = [TU1, TU2, TU3, TU4, TU5, TU7, TU8])
string fromInput      = input.string(OF1,       "Calculated from",             group = GRP2, tooltip = FROM_TT,  options = [OF1, OF2, OF3])

string GRP3           = "══════ Formatted number of periods ══════"
bool   useTimeInput   = input.bool(false,       "Use Input Time",               group = GRP3, tooltip = INPUT_TT)
string timeInput      = input.string("seconds", "Time Unit",                    group = GRP3, tooltip = TIME_TT,  options = [TU2, TU3, TU4, TU5, TU6, TU7])

string GRP4           = "═════════   Seconds to string   ═════════"
float  tfMultInput    = input.float(1.0,        "Timeframe Multiplier",         group = GRP4, tooltip = MULT_TT)
string textSizeInput  = input.string("large",   "Text size",                    group = GRP4, tooltip = SIZE_TT,  options = [SI1, SI2, SI3, SI4, SI5, SI6])
string tableYposInput = input.string("bottom",  "Position  ",                   group = GRP4, tooltip = POS_TT,   options = [TP1, TP2, TP3], inline = "41")
string tableXposInput = input.string("right",   "",                             group = GRP4,                     options = [TP4, TP5, TP6], inline = "41")


// ——————————  Calculations and display

// Conditions triggering new line drawings.
float pivotHi = ta.pivothigh(LEFT_BARS, RIGHT_BARS)
float pivotLo = ta.pivotlow(LEFT_BARS,  RIGHT_BARS)

// @variable The "string" to use as the `from` argument in the `timeFrom()` call.
string from = switch fromInput
    OF1 => "bar"
    OF2 => "close"
    =>     "now"

// @variable The offset time from the current bar's opening or closing time, or the time of the latest execution.
int timeTo = timeFrom(nInput, unitsInput, from)

// Get the `time` and `timeTo` values from `RIGHT_BARS` back for the line's starting and ending timestamps.
int pivotTime  = time[RIGHT_BARS]
int offsetTime = timeTo[RIGHT_BARS]

// @variable A "string" specifying the time unit used in the `formattedNoOfPeriods()` calculation.
string timeUnit = useTimeInput ? timeInput : na

if not na(pivotHi)
    // Draw a horizontal line at the `pivotHi` from the `pivotTime` to the `offsetTime`.
    line.new(
         pivotTime,  pivotHi, offsetTime, pivotHi, xloc.bar_time, color = color.fuchsia,
         style = line.style_arrow_right, width = 2
     )
    // Draw a label at the `pivotTime` showing a formatted date and time in the exchange time zone.
    label.new(
         pivotTime, pivotHi, str.format_time(pivotTime, "EEEE, MMMM dd, yyyy"), xloc.bar_time,
         color = color.new(color.gray, 85), style = label.style_label_down, textcolor = color.lime
     )
    // Draw a label at the current bar's `time` showing the number of periods covered by the line's time range.
    label.new(
         time, pivotHi, formattedNoOfPeriods(offsetTime - pivotTime, timeUnit), xloc.bar_time, color = color(na),
         style = label.style_label_up, textcolor = color.fuchsia, size = size.small
     )

if not na(pivotLo)
    // Draw a horizontal line at the `pivotLo` from the `pivotTime` to the `offsetTime`.
    line.new(
         pivotTime, pivotLo, offsetTime, pivotLo, xloc.bar_time, color = color.gray,
         style = line.style_arrow_right, width = 2
     )
    // Draw a label at the `pivotTime` showing a formatted date and time in the exchange time zone.
    label.new(
         pivotTime, pivotLo, str.format_time(pivotTime, "yyyy.MM.dd G 'at' hh:mm:ss z"), xloc.bar_time,
         color = color.new(color.gray, 85), style = label.style_label_up, textcolor = color.fuchsia
     )
    // Draw a label at the current bar's `time` showing the number of periods covered by the line's time range.
    label.new(
         time, pivotLo, formattedNoOfPeriods(offsetTime - pivotTime, timeUnit), xloc.bar_time, color = color(na),
         style = label.style_label_down, textcolor = color.gray, size = size.small
     )


// @variable Is `true` if the distance from the `open` to the `high` exceeds `ticksInput` ticks, `false` otherwise.
bool cond = high - open > syminfo.mintick * ticksInput
// @variable The number of seconds that the `cond` value has remained `true` since the last reset.
int secFromOpen = secondsSince(cond, resetInput and barstate.isnew)
// @variable `true` if the `secFromOpen` duration is greater than the `secondsInput` value, `false` otherwise.
bool timeAlert = secFromOpen > secondsInput
// @variable A formatted "string" containing the minutes and seconds covered by `secFromOpen` for the timer label.
string alertTime = str.format("{0,number,00}:{1,number,00}", int(secFromOpen / 60), secFromOpen % 60)

// @variable A "string" containing the text to display in the alert timer label.
string alertString = switch
    timeAlert => "Timed Alert Triggered\n\n" + alertTime
    cond      => "Condition Detected...\n\nTimer count\n" + alertTime
    =>           "Waiting for condition..."

if barstate.islast
    // @variable A label to display the `alertString` on the last bar.
    var label condTime  = label.new(
         na, na, yloc = yloc.abovebar, style = label.style_label_lower_left, textcolor = color.white
     )
    // Update the `x`, `text`, and `color` properties of the `condTime` label on the latest bar.
    label.set_x(condTime, bar_index)
    label.set_text(condTime, alertString)
    label.set_color(condTime,
         timeAlert ? color.new(color.green, 50) : cond ? color.new(color.orange, 0) : color.new(color.red, 50)
     )

if barstate.islastconfirmedhistory
    // @variable A table created on the last historical bar that shows the multiplied timeframe's closest "string".
    var table tfDisplay = table.new(tableYposInput + "_" + tableXposInput, 1, 1)
    // Initialize the table's cell.
    table.cell(
         tfDisplay, 0, 0, timeframe.from_seconds(int(timeframe.in_seconds() * tfMultInput)), bgcolor = color.yellow,
         text_color = color.black, text_size = textSizeInput
     )
//#endregion