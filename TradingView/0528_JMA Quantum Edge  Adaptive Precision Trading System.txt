//@version=5
// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © MaximusGains (Enhanced by Custom User)
// License: MIT License
//
// JMA Quantum Edge: Adaptive Precision Trading System (Enhanced Visuals & Risk Management)
// Release Notes:
// – Integrated partial exit (scaling out) support.
// – Added option for Kelly criterion–based dynamic position sizing.
// – Implemented extra error handling for low volume/gap conditions.
// – Added refresh frequency options for tables and dynamic labels.
// – Refactored common code and enhanced documentation for open-source users.
// - (NEW) Fixed JMA line display issue and alert system.
// - (NEW) Added performance optimizations for high-frequency charts.
// - (NEW) Improved alert system with option to only alert on order fills.

/////////////////////////////////////////////////////////////////
// SECTION 1: INPUTS & UI CUSTOMIZATION
/////////////////////////////////////////////////////////////////
// Group: Risk Management & Trade Settings
recalc_on_tick_input         = input.bool(true, "Recalculate on Every Tick", group="Risk Management", tooltip="Recalculate on every tick for greater precision on fast charts.")
initialCapital               = input.float(10000, "Initial Capital ($)", group="Risk Management", minval=1, step=100, tooltip="Capital available for backtesting; affects position sizing and performance.")
commissionValue_input        = input.float(0.1, "Commission (%)", group="Risk Management", minval=0.0, maxval=5.0, step=0.01, tooltip="Commission per trade (typically between 0 and 5%).")
positionSize_input           = input.float(100, "Position Size", group="Risk Management", minval=1, step=1, tooltip="For 'Fixed', represents units; for 'Percent', the percentage of equity.")
qtyTypeStr_input             = input.string("Fixed", "Quantity Type", options=["Fixed", "Percent"], group="Risk Management", tooltip="Select 'Fixed' for a fixed unit amount or 'Percent' for a percentage of equity.")
order_comment                = input.string("JMA Quantum Edge", "Order Comment", group="Risk Management", tooltip="Comment appended to orders.")
reverseOrders                = input.bool(false, "Allow Reverse Orders", group="Risk Management", tooltip="Allow reverse orders instead of explicitly closing opposing positions.")
enableDynamicPositionSizing  = input.bool(false, "Enable Dynamic Position Sizing", group="Risk Management", tooltip="Enable volatility-based dynamic position sizing for adaptive capital allocation.")
auto_optimize                = input.bool(false, "Auto-Optimize Parameters", group="Risk Management", tooltip="Enable auto-optimization of key JMA parameters based on volatility (experimental).")

// >>> NEW: Performance Optimization
enableLightweightMode = input.bool(false, "Enable Lightweight Mode", group="Performance Optimization", tooltip="Disable non-essential visuals for better performance on slower devices.")
optimizeForHighFrequencyCharts = input.bool(false, "Optimize for High Frequency Charts", group="Performance Optimization", tooltip="Reduces computation intensity on high frequency charts (1min or below).")

// >>> NEW: Partial Exit Inputs
enablePartialExits           = input.bool(false, "Enable Partial Exits", group="Risk Management", tooltip="Enable scaling out positions on profit target.")
partialExitProfitPct         = input.float(2.0, "Partial Exit Profit (%)", group="Risk Management", minval=0.1, step=0.1, tooltip="Profit percentage to trigger a partial exit.")
partialExitPercentage        = input.float(50, "Partial Exit Percentage", group="Risk Management", minval=1, maxval=100, step=1, tooltip="Percentage of the position to exit when profit target is hit.")

// >>> NEW: Kelly Criterion Option
useKelly                     = input.bool(false, "Use Kelly Criterion for Position Sizing", group="Risk Management", tooltip="If enabled, position sizing is adjusted using the Kelly Criterion based on historical performance metrics.")

// >>> NEW: Market Condition Filters
minimumVolume                = input.float(0, "Minimum Volume", group="Risk Management", tooltip="Minimum volume required for trade execution. Set to 0 to disable filter.")
maxGapPct                    = input.float(5.0, "Maximum Gap (%)", group="Risk Management", minval=0, step=0.1, tooltip="Maximum allowed gap percentage between previous close and current open for trade execution.")

// Group: JMA Settings
jma_source                   = input.source(close, title="Price Source", group="JMA Settings", tooltip="Select the price source (typically close) for the JMA calculation.")
jma_length                   = input.int(33, "JMA Length", group="JMA Settings", minval=5, maxval=200, step=1, tooltip="Smoothing period for the JMA. Lower values yield more sensitivity; higher values yield smoother output.")
jma_phase                    = input.int(63, "JMA Phase", group="JMA Settings", minval=-100, maxval=100, step=1, tooltip="Controls the responsiveness of the JMA. Extreme values may reduce reliability.")
jma_power                    = input.int(3, "JMA Power", group="JMA Settings", minval=1, maxval=10, step=1, tooltip="Exponent that adjusts smoothing intensity based on recent volatility.")

// Group: Visual Settings & Style
show_jma_line                = input.bool(true, "Show JMA Line", group="Visual Settings", tooltip="Toggle display of the computed JMA line on the chart.")
show_pivot_lines             = input.bool(true, "Show Pivot Lines", group="Visual Settings", tooltip="Toggle horizontal pivot lines when signals occur.")
show_pivot_labels            = input.bool(true, "Show Pivot Labels", group="Visual Settings", tooltip="Toggle pivot markers (buy/sell labels) on the chart.")
pivot_history                = input.int(10, "Pivot History Count", group="Visual Settings", minval=1, maxval=50, step=1, tooltip="Maximum number of historical pivot markers to retain.")
up_color                     = input.color(color.new(#00e677, 40), "Up Move Neon Color", group="Visual Settings", tooltip="Neon color for upward (buy) signals.")
dn_color                     = input.color(color.new(#df40fb, 30), "Down Move Neon Color", group="Visual Settings", tooltip="Neon color for downward (sell) signals.")
pivot_marker_style           = input.string("Default", "Pivot Marker Style", options=["Default", "Circle", "Square"], group="Marker & Line Customization", tooltip="Marker style for pivots. 'Default' centers the label; 'Circle' or 'Square' may enhance clarity.")
pivot_line_thickness         = input.int(2, "Pivot Line Thickness", group="Marker & Line Customization", minval=1, maxval=5, step=1, tooltip="Thickness for pivot lines.")
pivot_line_style_input       = input.string("Solid", "Pivot Line Style", options=["Solid", "Dotted", "Dashed"], group="Marker & Line Customization", tooltip="Select the style for pivot lines.")
show_stats                   = input.bool(true, "Show Stats Panel", group="Visual Settings", tooltip="Toggle display of the stats panel.")

// Group: Dynamic Background & Visual Enhancements
animate_background           = input.bool(true, "Animate Background", group="Visual Enhancements", tooltip="Toggle animated background color transitions based on momentum.")
show_trend_channels          = input.bool(true, "Show Trend Channels", group="Visual Enhancements", tooltip="Toggle trend channel display.")
show_volume_zones            = input.bool(true, "Show Volume Zones", group="Visual Enhancements", tooltip="Toggle volume/volatility zone display.")
show_data_labels             = input.bool(true, "Show Data-Rich Labels", group="Visual Enhancements", tooltip="Toggle dynamic data-rich labels display.")
highVolThreshold             = input.float(1.5, "High Volatility Threshold", group="Visual Enhancements", tooltip="Multiplier threshold for high volatility zone")

// Group: Multi-Timeframe Settings
higher_tf                    = input.timeframe("D", "Higher Timeframe", group="Multi-Timeframe Settings", tooltip="Select a higher timeframe for trend confirmation. Examples: 'D', 'W'.")
show_htf_zone                = input.bool(true, "Show HTF Trend Zone", group="Multi-Timeframe Settings", tooltip="Display a semi-transparent band indicating the higher timeframe trend zone.")
htf_zone_opacity             = input.int(85, "HTF Zone Opacity", group="Multi-Timeframe Settings", minval=0, maxval=100, step=1, tooltip="Opacity for the HTF trend zone fill (0=opaque, 100=fully transparent).")

// Group: Trailing Stop Settings
trailFactor                  = input.float(1.5, "Trailing Stop ATR Factor", group="Trailing Stop Settings", minval=0.5, maxval=5.0, step=0.1, tooltip="ATR multiplier for the trailing stop distance.")
trailOffsetMultiplier        = input.float(0.5, "Trailing Stop Offset Multiplier", group="Trailing Stop Settings", minval=0.1, maxval=2.0, step=0.1, tooltip="Multiplier for the trailing stop offset (applied to ATR-based trail stop)")

// Group: Alerts & Notifications (enhanced)
alertEnabled                 = input.bool(true, "Enable Alerts", group="Alerts & Notifications", tooltip="Master switch to enable/disable all alerts.")
alertOnlyOnOrderFills        = input.bool(true, "Alert Only on Order Fills", group="Alerts & Notifications", tooltip="Send alerts only when orders are filled (reduces fake alerts).")
alert_on_pivot               = input.bool(true, "Alert on Pivot Formation", group="Alerts & Notifications", tooltip="Enable alert when a pivot is formed.")
alert_on_jma_cross           = input.bool(true, "Alert on JMA Crossover", group="Alerts & Notifications", tooltip="Enable alert when JMA crosses the higher timeframe JMA.")
alert_dynamic_threshold      = input.float(2.0, "Dynamic Power Threshold", group="Alerts & Notifications", minval=0.1, maxval=5.0, step=0.1, tooltip="Threshold for dynamic power alerts.")
alert_message_prefix         = input.string("JMA Quantum Edge: ", "Alert Message Prefix", group="Alerts & Notifications", tooltip="Text to prepend to all alert messages for easier identification.")

// Group: Static Stop Loss / Take Profit
static_stop_loss             = input.float(0.0, "Static Stop Loss (%)", group="Risk Management", minval=0.0, maxval=100.0, step=0.1, tooltip="Static stop loss percentage (0 to disable).")
static_take_profit           = input.float(0.0, "Static Take Profit (%)", group="Risk Management", minval=0.0, maxval=100.0, step=0.1, tooltip="Static take profit percentage (0 to disable).")

// Group: Advanced Settings
atr_length                   = input.int(14, "ATR Length", group="Advanced Settings", minval=5, step=1, tooltip="Period used for the ATR calculation, influencing risk and trailing stops.")

// Group: Optimization Feedback & Enhanced Error Analysis
errorMetricLength            = input.int(20, "Error Metric Length", group="Optimization Feedback", tooltip="Period for calculating error metrics (average, stdev, skew, kurtosis) between JMA and price.")
errorThresholdPct            = input.float(5.0, "Error Threshold (%)", group="Optimization Feedback", minval=0.1, maxval=20.0, step=0.1, tooltip="Threshold for error percentage to trigger alert coloring in tables.")

// Group: UI - User-Driven Tweaking & Table Customization
showTweakerPanel             = input.bool(true, "Show Parameter Tweaker Panel", group="UI Customization", tooltip="Display a panel with current parameters and error metrics.")
debugTablePosition           = input.string("top_right", "Debug Table Position", options=["top_left", "top_center", "top_right", "bottom_left", "bottom_center", "bottom_right"], group="UI Customization", tooltip="Choose the position for the debug table.")
debugTableBgColor            = input.color(color.black, "Debug Table Background", group="UI Customization", tooltip="Background color for the debug table.")
perfTablePosition            = input.string("bottom_left", "Performance Table Position", options=["top_left", "top_center", "top_right", "bottom_left", "bottom_center", "bottom_right"], group="UI Customization", tooltip="Position for the performance analytics table.")
perfTableBgColor             = input.color(color.new(color.blue, 80), "Performance Table Background", group="UI Customization", tooltip="Background color for the performance analytics table.")

// >>> NEW: Refresh Frequency Options
tableRefreshInterval         = input.int(1, "Table Refresh Interval", group="UI Customization", minval=1, tooltip="Number of bars between table updates. Use a higher value for high-frequency charts.")
labelRefreshInterval         = input.int(1, "Label Refresh Interval", group="UI Customization", minval=1, tooltip="Number of bars between dynamic label updates.")

// Map position strings to Pine positions using if/else chain
f_mapPosition(posStr) =>
    if posStr == "top_left"
        position.top_left
    else if posStr == "top_center"
        position.top_center
    else if posStr == "top_right"
        position.top_right
    else if posStr == "bottom_left"
        position.bottom_left
    else if posStr == "bottom_center"
        position.bottom_center
    else
        position.bottom_right

_debugPos = f_mapPosition(debugTablePosition)
_perfPos  = f_mapPosition(perfTablePosition)

strategy("JMA Quantum Edge: Adaptive Precision Trading System - Enhanced Visuals & Risk Management",
     overlay=true,
     max_labels_count=100,
     calc_on_every_tick=true,
     commission_value=0.1,
     default_qty_value=100,
     default_qty_type=strategy.fixed)

// Determine if we're on a high frequency chart
isHighFrequencyChart = timeframe.isdaily == false and timeframe.isdwm == false and timeframe.ismonthly == false and timeframe.isweekly == false and timeframe.isseconds == false and (timeframe.multiplier <= 1)

// Apply performance optimizations conditionally
performOptimizedCalculations = optimizeForHighFrequencyCharts and isHighFrequencyChart

/////////////////////////////////////////////////////////////////
// SECTION 2: CUSTOM FUNCTIONS
/////////////////////////////////////////////////////////////////
// Custom linear interpolation function
f_lerp(a, b, t) =>
    a + (b - a) * t

/////////////////////////////////////////////////////////////////
// SECTION 3: CORE CALCULATIONS & UTILITY FUNCTIONS
/////////////////////////////////////////////////////////////////
fixnan(val) => na(val) ? nz(val[1]) : val

// Determine label style based on pivot marker style input
var label_style = label.style_label_center
if pivot_marker_style == "Circle"
    label_style := label.style_label_down
else if pivot_marker_style == "Square"
    label_style := label.style_label_left

// Set pivot line style based on user selection
var pivot_line_style = line.style_solid
if pivot_line_style_input == "Dotted"
    pivot_line_style := line.style_dotted
else if pivot_line_style_input == "Dashed"
    pivot_line_style := line.style_dashed

// ATR & Volatility Calculations
vol       = ta.atr(atr_length)
avgVol    = ta.sma(vol, atr_length)
volFactor = avgVol != 0 ? vol / avgVol : 1.0

// Custom color lerp function for blue→red interpolation with fixed transparency (50)
f_color_lerp(_t) =>
    r = math.round(f_lerp(0, 255, _t))
    b = math.round(f_lerp(255, 0, _t))
    color.rgb(r, 0, b, 50)

t_val       = math.min(math.max((volFactor - 1) / (highVolThreshold - 1), 0), 1)
baseBgColor = f_color_lerp(t_val)

momentum     = ta.roc(close, 14)
normMomentum = math.min(math.max((momentum + 10) / 20, 0), 1)
bullishColor = color.new(color.green, 80)
bearishColor = color.new(color.red, 80)
f_color_lerp_custom(_t) =>
    r = math.round(f_lerp(255, 0, _t))
    g = math.round(f_lerp(0, 255, _t))
    color.rgb(r, g, 0, 80)
animatedBgColor = f_color_lerp_custom(normMomentum)
bgColorToUse    = (not enableLightweightMode) and animate_background ? animatedBgColor : baseBgColor
bgcolor(bgColorToUse)

/////////////////////////////////////////////////////////////////
// AUTO-OPTIMIZATION LOGIC
/////////////////////////////////////////////////////////////////
opt_jma_length = auto_optimize ? math.max(10, math.min(100, int(math.round(jma_length * (2 - volFactor))))) : jma_length
opt_jma_phase  = auto_optimize ? math.max(-100, math.min(100, int(math.round(jma_phase * volFactor)))) : jma_phase
opt_jma_power  = auto_optimize ? math.max(1, jma_power * volFactor) : jma_power

used_jma_length = na(opt_jma_length) ? jma_length : opt_jma_length
used_jma_phase  = na(opt_jma_phase)  ? jma_phase  : opt_jma_phase
used_jma_power  = na(opt_jma_power)  ? jma_power  : opt_jma_power

// Apply optimizations for high-frequency charts if enabled
used_jma_length := performOptimizedCalculations ? math.max(5, int(used_jma_length * 0.75)) : used_jma_length
used_jma_power := performOptimizedCalculations ? math.max(1, used_jma_power * 0.75) : used_jma_power

calcDynamicPower   = used_jma_power * volFactor
betaForStats       = 0.45 * (used_jma_length - 1) / (0.45 * (used_jma_length - 1) + 2)
phaseRatioForStats = used_jma_phase < -100 ? 0.5 : (used_jma_phase > 100 ? 2.5 : (used_jma_phase / 100 + 1.5))

// Updated JMA function with corrected logic
jma(_src, _length, _phase, _power, _volFactor) =>
    phaseRatio = _phase < -100 ? 0.5 : _phase > 100 ? 2.5 : (_phase / 100 + 1.5)
    beta = 0.45 * (_length - 1) / (0.45 * (_length - 1) + 2)
    dynamicPower = _power * _volFactor
    alpha = math.pow(beta, dynamicPower)
    var float jma = 0.0
    var float e0 = 0.0
    e0 := (1 - alpha) * _src + alpha * nz(e0[1])
    var float e1 = 0.0
    e1 := (_src - e0) * (1 - beta) + beta * nz(e1[1])
    var float e2 = 0.0
    e2 := (e0 + phaseRatio * e1 - nz(jma[1])) * math.pow(1 - alpha, 2) + math.pow(alpha, 2) * nz(e2[1])
    jma := e2 + nz(jma[1])
    jma

// Declare the JMA outputs used in signals
jma_price  = jma(jma_source, used_jma_length, used_jma_phase, used_jma_power, volFactor)
jma_higher = request.security(syminfo.tickerid, higher_tf, jma(jma_source, used_jma_length, used_jma_phase, used_jma_power, volFactor))

/////////////////////////////////////////////////////////////////
// CHANNEL CALCULATIONS (moved before plot calls)
/////////////////////////////////////////////////////////////////
regLength    = input.int(20, "Trend Channel Length", group="Visual Enhancements", tooltip="Lookback period for trend channel calculation")
regLine      = ta.linreg(close, regLength, 0)
channelOffset = ta.atr(atr_length)
upperChannel = regLine + channelOffset
lowerChannel = regLine - channelOffset

/////////////////////////////////////////////////////////////////
// SIGNALS, PIVOT & TRADE CONDITIONS
/////////////////////////////////////////////////////////////////
turn_down   = ta.rising(jma_price[1], 1) and not ta.rising(jma_price, 1)
turn_up     = ta.falling(jma_price[1], 1) and not ta.falling(jma_price, 1)
longSignal  = turn_up and (jma_price > jma_higher)
shortSignal = turn_down and (jma_price < jma_higher)

pivot_window = input.int(5, "Pivot Lookback Period", group="Visual Enhancements", minval=3, tooltip="Period for pivot detection.")
float highest_val = ta.highest(high, pivot_window)
float lowest_val  = ta.lowest(low, pivot_window)
float pivot_val   = na
pivot_val := turn_down ? highest_val : turn_up ? lowest_val : na
pivot_fixed = fixnan(pivot_val)

/////////////////////////////////////////////////////////////////
// PIVOT DRAWING FUNCTION
/////////////////////////////////////////////////////////////////
drawPivot(isHigh, pivotValue, idx) =>
    lColor = isHigh ? color.new(dn_color, 20) : color.new(up_color, 20)
    span = isHigh ? 8 : 5
    var line newLine = na
    var label newLabel = na
    if show_pivot_lines and (not enableLightweightMode)
        newLine := line.new(idx, pivotValue, idx - span, pivotValue, width=pivot_line_thickness, color=lColor, style=pivot_line_style)
    if show_pivot_labels and (not enableLightweightMode)
        mText = isHigh ? "sell" : "buy"
        newLabel := label.new(idx, pivotValue, mText, style=label_style, color=lColor, textcolor=color.white, size=size.tiny)
    [newLine, newLabel]

/////////////////////////////////////////////////////////////////
// ENHANCED PIVOT VISUALS
/////////////////////////////////////////////////////////////////
var label[] pivotHighLabels = array.new_label()
var label[] pivotLowLabels  = array.new_label()
if turn_down and (not enableLightweightMode)
    [_, pLabel] = drawPivot(true, pivot_fixed, bar_index)
    if not na(pLabel)
        array.push(pivotHighLabels, pLabel)
        if array.size(pivotHighLabels) > pivot_history
            label.delete(array.shift(pivotHighLabels))
if turn_up and (not enableLightweightMode)
    [_, pLabel] = drawPivot(false, pivot_fixed, bar_index)
    if not na(pLabel)
        array.push(pivotLowLabels, pLabel)
        if array.size(pivotLowLabels) > pivot_history
            label.delete(array.shift(pivotLowLabels))

/////////////////////////////////////////////////////////////////
// SECTION 4: REFINED & ENHANCED ERROR METRICS (with Skewness & Kurtosis)
/////////////////////////////////////////////////////////////////
f_computeJMAError() =>
    absError    = math.abs(jma_price - jma_source)
    avgError    = ta.sma(absError, errorMetricLength)
    errorPct    = jma_source != 0 ? (avgError / jma_source * 100) : na
    errorStd    = ta.stdev(absError, errorMetricLength)
    errorStdPct = jma_source != 0 ? (errorStd / jma_source * 100) : na
    [errorPct, errorStdPct]

f_computeErrorStats(_src, _jma, _length) =>
    absError  = math.abs(_jma - _src)
    meanErr   = ta.sma(absError, _length)
    stdevErr  = ta.stdev(absError, _length)
    skew      = 0.0
    kurt      = 0.0
    for i = 0 to _length - 1
        diff = absError[i] - meanErr[i]
        skew += math.pow(diff, 3)
        kurt += math.pow(diff, 4)
    skew := stdevErr != 0 ? (skew / _length) / math.pow(stdevErr, 3) : na
    kurt := stdevErr != 0 ? (kurt / _length) / math.pow(stdevErr, 4) - 3 : na
    [skew, kurt]

[errorPct, errorStdPct] = f_computeJMAError()
[errorSkew, errorKurt]   = f_computeErrorStats(jma_source, jma_price, errorMetricLength)

/////////////////////////////////////////////////////////////////
// SECTION 5: ADVANCED BACKTEST ANALYTICS (Modularized)
/////////////////////////////////////////////////////////////////
f_computePerformanceAnalytics() =>
    totalTrades = strategy.closedtrades
    winCount    = 0
    sumProfit   = 0.0
    sumLoss     = 0.0
    sumPnL      = 0.0
    for i = 0 to totalTrades - 1
        pnl = strategy.closedtrades.profit(i)
        sumPnL += pnl
        if pnl > 0
            winCount += 1
            sumProfit += pnl
        else
            sumLoss += pnl
    winRate = totalTrades > 0 ? (winCount / totalTrades * 100) : na
    profitFactor = sumLoss != 0 ? sumProfit / math.abs(sumLoss) : na
    expectancy   = totalTrades > 0 ? sumPnL / totalTrades : na
    riskAdjustedReturn = strategy.max_drawdown != 0 ? strategy.netprofit / math.abs(strategy.max_drawdown) : strategy.netprofit
    [totalTrades, winRate, sumPnL, strategy.max_drawdown, profitFactor, expectancy, riskAdjustedReturn]

[totalTrades, winRate, netProfit, maxDrawdown, profitFactor, expectancy, riskAdjustedReturn] = f_computePerformanceAnalytics()

// >>> NEW: Kelly Criterion Calculation
kellyFraction = 0.0
if useKelly and not na(winRate) and not na(profitFactor) and profitFactor != 0
    kellyFraction := math.max(0, math.min(1, winRate / 100 - (1 - winRate / 100) / profitFactor))
else
    kellyFraction := 0.0

// >>> NEW: Dynamic Position Sizing Functions
f_dynamicPortfolioAdjustment() =>
    multiplier = 1 / volFactor
    math.max(0.5, math.min(1.5, multiplier))

f_calculateDynamicPositionSize() =>
    multiplier = f_dynamicPortfolioAdjustment()
    positionSize_input * multiplier

// >>> UPDATED: Dynamic Position Sizing using either volatility or Kelly criterion
entryQty = useKelly ? (positionSize_input * (1 + kellyFraction)) : (enableDynamicPositionSizing ? f_calculateDynamicPositionSize() : positionSize_input)

/////////////////////////////////////////////////////////////////
// Compute performance curve for plotting
/////////////////////////////////////////////////////////////////
performanceCurve = strategy.equity - initialCapital
pc_color = performanceCurve >= nz(performanceCurve[1]) ? color.green : color.red
plot(show_trend_channels and (not enableLightweightMode) ? upperChannel : na, title="Upper Trend Channel", color=color.blue, linewidth=1)
plot(show_trend_channels and (not enableLightweightMode) ? lowerChannel : na, title="Lower Trend Channel", color=color.blue, linewidth=1)
pc_plot  = plot(performanceCurve, title="Performance Curve", color=pc_color, linewidth=2)
base_plot = plot(0, title="Baseline", display=display.none)
fill(pc_plot, base_plot, color=performanceCurve >= nz(performanceCurve[1]) ? color.new(color.green, 80) : color.new(color.red, 80))

// Add missing plot for JMA line
plot(show_jma_line ? jma_price : na, title="JMA Line", color=color.rgb(255, 255, 255), linewidth=2)

/////////////////////////////////////////////////////////////////
// SECTION 6: ADVANCED RISK MODULES & DYNAMIC POSITION SIZING
/////////////////////////////////////////////////////////////////
f_calcTrailingStop() =>
    trailStop   = trailFactor * vol
    trailOffset = trailStop * trailOffsetMultiplier
    [trailStop, trailOffset]

f_calcStaticStops() =>
    long_stop  = static_stop_loss > 0 ? strategy.position_avg_price * (1 - static_stop_loss / 100) : na
    long_limit = static_take_profit > 0 ? strategy.position_avg_price * (1 + static_take_profit / 100) : na
    short_stop = static_stop_loss > 0 ? strategy.position_avg_price * (1 + static_stop_loss / 100) : na
    short_limit = static_take_profit > 0 ? strategy.position_avg_price * (1 - static_take_profit / 100) : na
    [long_stop, long_limit, short_stop, short_limit]

f_manageRisk() =>
    [trailStop, trailOffset] = f_calcTrailingStop()
    [long_stop, long_limit, short_stop, short_limit] = f_calcStaticStops()
    if strategy.position_size > 0
        strategy.exit("Exit Long", from_entry="Buy", stop=long_stop, limit=long_limit, trail_points=trailStop, trail_offset=trailOffset, comment=order_comment)
    if strategy.position_size < 0
        strategy.exit("Exit Short", from_entry="Sell", stop=short_stop, limit=short_limit, trail_points=trailStop, trail_offset=trailOffset, comment=order_comment)

    // >>> NEW: Partial Exit Logic
    if enablePartialExits
        if strategy.position_size > 0 and close >= strategy.position_avg_price * (1 + partialExitProfitPct / 100)
            strategy.exit("Partial Exit Long", qty_percent=partialExitPercentage, limit=close, from_entry="Buy", comment="Partial Exit Long")
        if strategy.position_size < 0 and close <= strategy.position_avg_price * (1 - partialExitProfitPct / 100)
            strategy.exit("Partial Exit Short", qty_percent=partialExitPercentage, limit=close, from_entry="Sell", comment="Partial Exit Short")

f_manageRisk()

/////////////////////////////////////////////////////////////////
// SECTION 7: TRADE EXECUTION & PIVOT DRAWING
/////////////////////////////////////////////////////////////////
// >>> NEW: Market Condition Checks - Skip trade execution if conditions are atypical.
validMarketConditions = true
if minimumVolume > 0 and volume < minimumVolume
    validMarketConditions := false
if not na(close[1]) and math.abs(open - close[1]) / close[1] * 100 > maxGapPct
    validMarketConditions := false

if validMarketConditions
    if longSignal
        if not reverseOrders
            if strategy.position_size < 0
                strategy.close("Sell")
            if strategy.position_size <= 0
                strategy.entry("Buy", strategy.long, qty=entryQty, comment=order_comment)
        else
            strategy.entry("Buy", strategy.long, qty=entryQty, comment=order_comment)

    if shortSignal
        if not reverseOrders
            if strategy.position_size > 0
                strategy.close("Buy")
            if strategy.position_size >= 0
                strategy.entry("Sell", strategy.short, qty=entryQty, comment=order_comment)
        else
            strategy.entry("Sell", strategy.short, qty=entryQty, comment=order_comment)

/////////////////////////////////////////////////////////////////
// SECTION 8: DYNAMIC VISUAL ENHANCEMENTS
/////////////////////////////////////////////////////////////////
// Box for volume zones – convert x coordinates to integers
if show_volume_zones and (not enableLightweightMode) and (vol > highVolThreshold * avgVol)
    box.new(int(math.round(bar_index - 1)), high, int(math.round(bar_index)), low, xloc=xloc.bar_index, border_width=1, border_color=color.orange, bgcolor=color.new(color.orange, 80))

// >>> UPDATED: Update dynamic data label only at specified refresh intervals
var label dataLabel = na
if show_data_labels and (not enableLightweightMode)
    if na(dataLabel)
        dataLabel := label.new(bar_index, high, "", style=label.style_label_left, textcolor=color.white, color=color.new(color.black, 80), size=size.normal)

    // Apply optimized refresh rate
    labelRefreshRate = performOptimizedCalculations ? labelRefreshInterval * 5 : labelRefreshInterval

    if (bar_index % labelRefreshRate == 0)
        label.set_xy(dataLabel, bar_index, high)
        label.set_text(dataLabel, "Vol: " + str.tostring(vol, "#.##") + "\nPivot: " + str.tostring(pivot_fixed, "#.##") + "\nError: " + str.tostring(errorPct, "#.##") + "%" + "\nMomentum: " + str.tostring(momentum, "#.##"))

/////////////////////////////////////////////////////////////////
// SECTION 9: VISUALIZATION: DEBUG, STATS & PERFORMANCE PANELS
/////////////////////////////////////////////////////////////////
f_fillCell(_table, _col, _row, _text, _bgcolor, _textColor, _alignH, _alignV, _textSize) =>
    table.cell(_table, _col, _row, _text, bgcolor=_bgcolor, text_color=_textColor, text_halign=_alignH, text_valign=_alignV, text_size=_textSize)

f_altRowColor(row) =>
    row % 2 == 0 ? color.new(#40485e, 30) : color.new(#384b5e, 10)

// Apply optimized refresh rate for tables
tableRefreshRate = performOptimizedCalculations ? tableRefreshInterval * 5 : tableRefreshInterval

if (bar_index % tableRefreshRate == 0) and barstate.islast and show_stats and (not enableLightweightMode)
    var table statsTable = table.new(position.top_center, 7, 4, border_width=2, frame_color=color.rgb(66,123,133,32), frame_width=2)
    var table tradeTable = table.new(position.bottom_right, 5, 6, border_width=2, frame_color=color.rgb(255,255,255,90), frame_width=1)
    var table debugTable = table.new(_debugPos, 2, 11, border_width=1, frame_color=debugTableBgColor, frame_width=1)
    var table perfTable  = table.new(_perfPos, 2, 8, border_width=1, frame_color=perfTableBgColor, frame_width=1)

    debugErrBgColor       = errorPct > errorThresholdPct ? color.red : color.green
    debugErrorSkBgColor   = errorSkew > 0.5 ? color.red : color.green
    debugErrorKurtBgColor = errorKurt > 1.0 ? color.red : color.green

    headerNames = array.from("ATR", "Vol Factor", "Dyn Power", "Alpha", "Beta", "Phase Ratio", "Pivot")
    for col = 0 to array.size(headerNames) - 1
        f_fillCell(statsTable, col, 0, array.get(headerNames, col), color.rgb(66,123,133,32), color.white, "center", "center", size.normal)
    f_fillCell(statsTable, 0, 1, str.tostring(vol, "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 1, 1, str.tostring(volFactor, "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 2, 1, str.tostring(calcDynamicPower, "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 3, 1, str.tostring(math.pow(betaForStats, calcDynamicPower), "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 4, 1, str.tostring(betaForStats, "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 5, 1, str.tostring(phaseRatioForStats, "#.##"), f_altRowColor(1), color.white, "center", "center", size.small)
    f_fillCell(statsTable, 6, 1, not na(pivot_fixed) ? str.tostring(pivot_fixed, "#.##") : "NA", f_altRowColor(1), color.white, "center", "center", size.small)
    autoOptStr = auto_optimize ? "Auto-Optimize: ON" : "Auto-Optimize: OFF"
    f_fillCell(statsTable, 0, 2, autoOptStr, color.rgb(60,99,89), color.yellow, "left", "center", size.small)
    for col = 1 to 6
        f_fillCell(statsTable, col, 2, "", color.black, color.white, "center", "center", size.tiny)
    if auto_optimize
        f_fillCell(statsTable, 0, 3, "Opt Length: " + str.tostring(used_jma_length), f_altRowColor(3), color.white, "left", "center", size.tiny)
        f_fillCell(statsTable, 1, 3, "Opt Phase: " + str.tostring(used_jma_phase), f_altRowColor(3), color.white, "center", "center", size.tiny)
        f_fillCell(statsTable, 2, 3, "Opt Power: " + str.tostring(used_jma_power, "#.##"), f_altRowColor(3), color.white, "center", "center", size.tiny)
        for col = 3 to 6
            f_fillCell(statsTable, col, 3, "", f_altRowColor(3), color.white, "center", "center", size.tiny)
    table.cell(debugTable, 0, 0, "Parameter", text_color=color.white, bgcolor=color.gray)
    table.cell(debugTable, 1, 0, "Value", text_color=color.white, bgcolor=color.gray)
    table.cell(debugTable, 0, 1, "ATR", text_color=color.white)
    table.cell(debugTable, 1, 1, str.tostring(vol, "#.##"), text_color=color.white)
    table.cell(debugTable, 0, 2, "Vol Factor", text_color=color.white)
    table.cell(debugTable, 1, 2, str.tostring(volFactor, "#.##"), text_color=color.white)
    table.cell(debugTable, 0, 3, "Opt Length", text_color=color.white)
    table.cell(debugTable, 1, 3, str.tostring(used_jma_length), text_color=color.white)
    table.cell(debugTable, 0, 4, "Opt Phase", text_color=color.white)
    table.cell(debugTable, 1, 4, str.tostring(used_jma_phase), text_color=color.white)
    table.cell(debugTable, 0, 5, "Opt Power", text_color=color.white)
    table.cell(debugTable, 1, 5, str.tostring(used_jma_power), text_color=color.white)
    table.cell(debugTable, 0, 6, "Avg JMA Error %", text_color=color.white)
    table.cell(debugTable, 1, 6, str.tostring(errorPct, "#.##") + "%", text_color=color.white, bgcolor=debugErrBgColor)
    table.cell(debugTable, 0, 7, "JMA Error Std %", text_color=color.white)
    table.cell(debugTable, 1, 7, str.tostring(errorStdPct, "#.##") + "%", text_color=color.white)
    table.cell(debugTable, 0, 8, "Error Skew", text_color=color.white)
    table.cell(debugTable, 1, 8, str.tostring(errorSkew, "#.##"), text_color=color.white, bgcolor=debugErrorSkBgColor)
    table.cell(debugTable, 0, 9, "Error Kurtosis", text_color=color.white)
    table.cell(debugTable, 1, 9, str.tostring(errorKurt, "#.##"), text_color=color.white, bgcolor=debugErrorKurtBgColor)

    table.cell(perfTable, 0, 0, "Metric", text_color=color.white, bgcolor=color.gray)
    table.cell(perfTable, 1, 0, "Value", text_color=color.white, bgcolor=color.gray)
    table.cell(perfTable, 0, 1, "Total Trades", text_color=color.white)
    table.cell(perfTable, 1, 1, str.tostring(totalTrades), text_color=color.white)
    table.cell(perfTable, 0, 2, "Win Rate (%)", text_color=color.white)
    table.cell(perfTable, 1, 2, totalTrades > 0 ? str.tostring(winRate, "#.##") : "NA", text_color=color.white)
    table.cell(perfTable, 0, 3, "Net Profit", text_color=color.white)
    table.cell(perfTable, 1, 3, str.tostring(netProfit, "#.##"), text_color=color.white)
    table.cell(perfTable, 0, 4, "Max Drawdown", text_color=color.white)
    table.cell(perfTable, 1, 4, str.tostring(maxDrawdown, "#.##"), text_color=color.white)
    table.cell(perfTable, 0, 5, "Profit Factor", text_color=color.white)
    table.cell(perfTable, 1, 5, (not na(profitFactor) ? str.tostring(profitFactor, "#.##") : "NA"), text_color=color.white)
    table.cell(perfTable, 0, 6, "Expectancy", text_color=color.white)
    table.cell(perfTable, 1, 6, totalTrades > 0 ? str.tostring(expectancy, "#.##") : "NA", text_color=color.white)
    table.cell(perfTable, 0, 7, "Risk-Adj Return", text_color=color.white)
    table.cell(perfTable, 1, 7, str.tostring(riskAdjustedReturn, "#.##"), text_color=color.white)

    var label tweakerLabel = na
    if showTweakerPanel and (not enableLightweightMode)
        if na(tweakerLabel)
            tweakerLabel := label.new(bar_index, high, "", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=color.new(color.white,80), textcolor=color.black, size=size.normal)
        // Calculate label refresh rate based on optimization settings
        var int labelRefreshRate = labelRefreshInterval
        labelRefreshRate := optimizeForHighFrequencyCharts and isHighFrequencyChart ? labelRefreshInterval * 5 : labelRefreshInterval
        if (bar_index % labelRefreshRate == 0)
            label.set_xy(tweakerLabel, bar_index, high)
            label.set_text(tweakerLabel, "Tweaker Panel:\nJMA Length: " + str.tostring(used_jma_length) + "\nJMA Phase: " + str.tostring(used_jma_phase) + "\nJMA Power: " + str.tostring(used_jma_power) + "\nAvg Error: " + str.tostring(errorPct, "#.##") + "%" + "\nError Skew: " + str.tostring(errorSkew, "#.##") + "\nError Kurtosis: " + str.tostring(errorKurt, "#.##"))
    else
        if not na(tweakerLabel)
            label.delete(tweakerLabel)
            tweakerLabel := na

    if barstate.islast
        // Determine trade type from the size of the most recent closed trade
        currentSize = strategy.closedtrades.size(0)
        currentStatus = currentSize > 0 ? "Long" : currentSize < 0 ? "Short" : "None"
        table.cell(tradeTable, 0, 0, "Current Trade: " + currentStatus, text_color=color.yellow, bgcolor=color.gray)
        table.cell(tradeTable, 0, 1, "Trade", text_color=color.white, bgcolor=color.blue)
        table.cell(tradeTable, 1, 1, "Type", text_color=color.white, bgcolor=color.blue)
        table.cell(tradeTable, 2, 1, "Entry", text_color=color.white, bgcolor=color.blue)
        table.cell(tradeTable, 3, 1, "Exit", text_color=color.white, bgcolor=color.blue)
        table.cell(tradeTable, 4, 1, "PnL", text_color=color.white, bgcolor=color.blue)
        closedTradesCount = strategy.closedtrades
        startIdx = math.max(0, closedTradesCount - 4)
        rowIndex = 2
        for i = startIdx to closedTradesCount - 1
            tradeNum = str.tostring(i + 1)
            tradeSize = strategy.closedtrades.size(i)
            tradeType = tradeSize > 0 ? "Long" : tradeSize < 0 ? "Short" : "NA"
            entryP = str.tostring(strategy.closedtrades.entry_price(i), "#.##")
            exitP  = str.tostring(strategy.closedtrades.exit_price(i), "#.##")
            pnlVal = str.tostring(strategy.closedtrades.profit(i), "#.##")
            table.cell(tradeTable, 0, rowIndex, tradeNum, text_color=color.white)
            table.cell(tradeTable, 1, rowIndex, tradeType, text_color=color.white)
            table.cell(tradeTable, 2, rowIndex, entryP, text_color=color.white)
            table.cell(tradeTable, 3, rowIndex, exitP, text_color=color.white)
            table.cell(tradeTable, 4, rowIndex, pnlVal, text_color=color.white)
            rowIndex += 1

/////////////////////////////////////////////////////////////////
// SECTION 10: ALERTS & NOTIFICATIONS
/////////////////////////////////////////////////////////////////
if alertEnabled
    // Track order fills by comparing current position size to previous bar
    longOrderFilled = strategy.position_size > strategy.position_size[1]
    shortOrderFilled = strategy.position_size < strategy.position_size[1]
    closedPosition = strategy.position_size == 0 and strategy.position_size[1] != 0

    // Create alert messages
    longAlertMsg = alert_message_prefix + "Long Entry at " + str.tostring(close)
    shortAlertMsg = alert_message_prefix + "Short Entry at " + str.tostring(close)
    closedAlertMsg = alert_message_prefix + "Position Closed at " + str.tostring(close)
    pivotAlertMsg = alert_message_prefix + "Pivot Formed at " + str.tostring(pivot_fixed)
    jmaCrossAlertMsg = alert_message_prefix + "JMA Cross at " + str.tostring(close)

    // Handle order fill alerts
    if alertOnlyOnOrderFills
        if longOrderFilled
            alert(longAlertMsg, alert.freq_once_per_bar)
        if shortOrderFilled
            alert(shortAlertMsg, alert.freq_once_per_bar)
        if closedPosition
            alert(closedAlertMsg, alert.freq_once_per_bar)
    else
        // Handle signal-based alerts (may trigger even if no order is filled)
        if longSignal and alert_on_jma_cross
            alert(longAlertMsg, alert.freq_once_per_bar)
        if shortSignal and alert_on_jma_cross
            alert(shortAlertMsg, alert.freq_once_per_bar)

    // Pivot alerts (independent of order fills option)
    if alert_on_pivot
        if turn_up
            alert(pivotAlertMsg + " (UP)", alert.freq_once_per_bar)
        if turn_down
            alert(pivotAlertMsg + " (DOWN)", alert.freq_once_per_bar)

    // Dynamic power threshold alerts
    if calcDynamicPower > alert_dynamic_threshold
        alert(alert_message_prefix + "Dynamic Power Above Threshold: " + str.tostring(calcDynamicPower, "#.##"), alert.freq_once_per_bar_close)

/////////////////////////////////////////////////////////////////
// END OF SCRIPT
/////////////////////////////////////////////////////////////////