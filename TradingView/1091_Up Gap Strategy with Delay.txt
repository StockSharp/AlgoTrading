//@version=6
strategy("Up Gap Strategy with Delay", overlay=true, pyramiding=0)  // Enable pyramiding for multiple positions

// === Inputs ===
gapThreshold = input.float(1, title="Gap Size Threshold in %", minval=0.1, step = 0.1)  // Minimum gap size in percentage
delayPeriods = input.int(0, title="Delay Periods After Gap", minval=0)  // Number of periods after the gap before entry
holdingPeriods = input.int(7, title="Holding Periods", minval=1)  // Number of periods for which the position is held

// === Gap Calculation ===
gapSize = (open - close[1]) / close[1] * 100  // Calculate the gap size in percentage

// === Up Gap Condition ===
upGapCondition = gapSize >= gapThreshold  // Condition for an up gap if gap size is >= threshold

// === Long Entry Condition with Delay ===
var float entryBar = na
longCondition = upGapCondition and (na(entryBar) or bar_index > entryBar + delayPeriods)  // Enter after gap or delay
entryDelayCondition = not na(entryBar) and bar_index >= entryBar + delayPeriods  // Delay after the gap

// === Entry Trigger ===
if longCondition
    entryBar := bar_index  // Store the bar index after the gap
    strategy.entry("Long", strategy.long)  // Enter long position

// === Exit Trigger after Holding Period ===
if (not na(entryBar) and bar_index >= entryBar + delayPeriods + holdingPeriods)
    strategy.close("Long")  // Close the position after holding period

// === Plot Up Gaps ===
plotshape(upGapCondition, location=location.belowbar, color=color.green, style=shape.labelup, title="Up Gap", text="Up Gap")

// === Optional: Change background color when Up Gap occurs ===
bgcolor(upGapCondition ? color.new(color.green, 90) : na)

// === Display Gap Size as Label on the Chart ===
if upGapCondition
    label.new(bar_index, low, text=str.tostring(gapSize, "#.##") + "%", color=color.green, style=label.style_label_up, yloc=yloc.belowbar)