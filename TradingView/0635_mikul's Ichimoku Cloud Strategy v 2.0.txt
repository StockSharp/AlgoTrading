// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© mikul_se
//@version=5
strategy("mikul's Ichimoku Cloud Strategy v 2.0", shorttitle="mikul's Ichi strat", overlay=true, initial_capital=10000, default_qty_type = strategy.percent_of_equity, default_qty_value = 10, commission_type=strategy.commission.percent, commission_value=0.075)

// Strategy settings
strategySettingsGroup = "Strategy settings"
trailSource         = input.string(title="Exit source", defval="Lows/Highs", options=["Lows/Highs", "Close", "Open"], confirm=true, group=strategySettingsGroup)
trailMethod         = input.string(title="Exit method", defval="ATR", options=["ATR", "Percent", "Ichi exit"], confirm=true, tooltip="Ichi rules means it follows the rules of the Ichimoku cloud for exiting the trade.", group=strategySettingsGroup)
trailPercent        = input.float(title="Trailing percent", defval=10, minval=0.1, confirm=true, group=strategySettingsGroup)
swingLookback       = input.int(title="Lookback", defval=7, confirm=true, group=strategySettingsGroup)
atrPeriod           = input.int(title="ATR period", defval=14, confirm=true, group=strategySettingsGroup)
atrMultiplier       = input.float(title="ATR multiplier", defval=1.0, confirm=true, group=strategySettingsGroup)
addIchiExit         = input.bool(false, "Add ichimoku exit", "You can use this to add Ichimoku cloud exit signals on top of Percent or ATR", group=strategySettingsGroup)
useTakeProfit       = input.bool(false, "Use take profit", confirm=true, group=strategySettingsGroup)
takeProfitPercent   = input.float(title="Take profit percentage", defval=25, minval=0.1, confirm=true, group=strategySettingsGroup)


// Moving Average Filter settings
maFilterSettingsGroup = "MA Filter settings"
useMAFilter    = input.bool(false, title="Use moving average filter", group=maFilterSettingsGroup)
maType         = input.string(title="Moving average type", defval="EMA", options=['EMA', 'SMA', 'WMA', 'HMA', 'VWMA', 'VWAP'], group=maFilterSettingsGroup)
maLength       = input.int(title="Moving average length", defval=200, minval=1, group=maFilterSettingsGroup)


getMA(simple int length, string maType) =>
    switch maType
        "EMA" => ta.ema(close, length)
        "SMA" => ta.sma(close, length)
        "HMA" => ta.hma(close, length)
        "WMA" => ta.wma(close, length)
        "VWMA" => ta.vwma(close, length)
        "VWAP" => ta.vwap
        =>
            e1 = ta.ema(close, length)
            e2 = ta.ema(e1, length)
            2 * e1 - e2

// Calculate Moving Average if filter is enabled
maFilter = useMAFilter ? getMA(maLength, maType) : na

// Plot Moving Average if filter is enabled
plot(useMAFilter ? maFilter : na, title="MA Filter", color=color.rgb(255, 255, 255))


// Ichimoku settings
ichimokuSettingsGroup = "Ichimoku settings"
conversionPeriods       = input.int(9, minval=1, title="Conversion line length", group=ichimokuSettingsGroup)
basePeriods             = input.int(26, minval=1, title="Base line length", group=ichimokuSettingsGroup)
laggingSpan2Periods     = input.int(52, minval=1, title="Leading span B length", group=ichimokuSettingsGroup)
displacement            = input.int(26, minval=1, title="Lagging span", group=ichimokuSettingsGroup)
delta                   = input.int(26, minval=1, title="Delta", group=ichimokuSettingsGroup)

donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
conversionLine = donchian(conversionPeriods)
baseLine       = donchian(basePeriods)
leadLine1      = math.avg(conversionLine, baseLine)
leadLine2      = donchian(laggingSpan2Periods)

uppercloud     = leadLine1[displacement-1]
bottomcloud    = leadLine2[displacement-1]

// Ichi exit variables and calculations
delta2 = delta-3
average(len) => math.avg(ta.lowest(len), ta.highest(len))

conversion_line = average(conversionPeriods)
base_line       = average(basePeriods)
lead_line_a     = math.avg(conversion_line, base_line)
lead_line_b     = average(laggingSpan2Periods)
lagging_span    = close
lead_line_a_delta = lead_line_a[delta]
lead_line_b_delta = lead_line_b[delta]
lagging_span_delta = lagging_span[delta]
prisgris = hlc3[delta]
prisgris2 = hlc3[delta2]

// Declare trailing price variable (stores our trail stop value)
var float trailPrice    = na
float next_trailPrice   = na

// Get required trailing stop variables
atrValue       = ta.atr(atrPeriod) * atrMultiplier
swingLow       = ta.lowest(low, swingLookback)
swingHigh      = ta.highest(high, swingLookback)

// Ichi plotting
plot(conversionLine, color=#2962FF, title="Conversion line")
plot(baseLine, color=#B71C1C, title="Base line")
plot(close, offset=-displacement + 1, color=#43A047, title="Lagging span")
p1 = plot(leadLine1, offset=displacement - 1, color=#A5D6A7, title="Leading span A")
p2 = plot(leadLine2, offset=displacement - 1, color=#EF9A9A, title="Leading span B")
fill(p1, p2, color=leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90))

// Plotting ichi crossover signals
ichiup = ta.crossover(conversionLine, baseLine)
ichidown = ta.crossover(baseLine, conversionLine)

plotshape(ichiup ? conversionLine : na, 'Ichi long 1', style=shape.circle, location=location.absolute, offset=0, color=#00ff00b0, size=size.tiny, display=display.pane)
plotshape(ichidown ? conversionLine : na, 'Ichi short 1', style=shape.circle, location=location.absolute, offset=0, color=#ff1100c7, size=size.tiny, display=display.pane)

// Pamp signal
signal5 = close > bottomcloud[displacement] and close > uppercloud[displacement] and close > high[displacement]
signal5b = close[1] <= bottomcloud[displacement+1] or close[1] <= uppercloud[displacement+1] or close <= high[displacement+1]
signal6 = close > bottomcloud and close > uppercloud and close > open
signal6b = close[1] <= bottomcloud[1] or close[1] <= uppercloud[1]
signal7 = leadLine1 > leadLine2
signal7b = leadLine1[1] <= leadLine2[1]
signal8 = conversionLine > baseLine

// Trend signal
nsignal5 = close > close[displacement]
nsignal6 = close > bottomcloud and close > uppercloud and close > open
nsignal8 = ta.crossover(conversionLine, baseLine) and conversionLine > bottomcloud and conversionLine > uppercloud and baseLine > bottomcloud and baseLine > uppercloud


// Signal conditions
// ...
pamp = signal5 and signal6 and signal7 and signal8 and strategy.position_size == 0 and (signal5b or signal6b or signal7b) and (not useMAFilter or close > maFilter)
trend = nsignal5 and nsignal6 and nsignal8 and (not useMAFilter or close > maFilter) and strategy.position_size == 0
// ...


plotshape(trend, style=shape.triangleup, location=location.belowbar, color=color.green)

if (trend or pamp)
    trailPrice := na
    strategy.entry(trend ? "Trend" : "Pamp", direction = strategy.long)

// Get trailing stop price
if trailMethod == "ATR"
    next_trailPrice := switch trailSource
        "Close" => strategy.position_size > 0 ? close - atrValue : close + atrValue
        "Open" => strategy.position_size > 0 ? open - atrValue : open + atrValue
        => strategy.position_size > 0 ? swingLow - atrValue : swingHigh + atrValue
else if trailMethod == "Percent"
    float percentMulti = strategy.position_size > 0 ? (100 - trailPercent) / 100 : (100 + trailPercent) / 100
    next_trailPrice := switch trailSource
        "Close" => close * percentMulti
        "Open" => open * percentMulti
        => strategy.position_size > 0 ? swingLow * percentMulti : swingHigh * percentMulti
else
    short_signal = (ta.crossunder(lagging_span, prisgris)) or ta.crossover(base_line, conversion_line) and ((close)) < ((lead_line_a)) or ta.crossunder(lagging_span, prisgris) or (ta.crossover(base_line, conversion_line) and ((lagging_span) < (lead_line_a)) and ((lagging_span) < (lead_line_b)))

    if short_signal
        strategy.close("Trend", "Ichi trend over")
        strategy.close("Pamp", "Ichi pamp over")
        alert("Sell")

if (addIchiExit)
    short_signal = (ta.crossunder(lagging_span, prisgris)) or ta.crossover(base_line, conversion_line) and ((close)) < ((lead_line_a)) or ta.crossunder(lagging_span, prisgris) or (ta.crossover(base_line, conversion_line) and ((lagging_span) < (lead_line_a)) and ((lagging_span) < (lead_line_b)))

    if short_signal
        strategy.close("Trend", "Ichi trend over")
        strategy.close("Pamp", "Ichi pamp over")
        alert("Sell")

// Check for trailing stop update
if strategy.position_size != 0 and barstate.isconfirmed
    if (next_trailPrice > trailPrice or na(trailPrice)) and strategy.position_size > 0
        trailPrice := next_trailPrice
        alert(message="Trailing Stop updated for " + syminfo.tickerid + ": " + str.tostring(trailPrice, "#.#####"), freq=alert.freq_once_per_bar_close)

    if (next_trailPrice < trailPrice or na(trailPrice)) and strategy.position_size < 0
        trailPrice := next_trailPrice
        alert(message="Trailing Stop updated for " + syminfo.tickerid + ": " + str.tostring(trailPrice, "#.#####"), freq=alert.freq_once_per_bar_close)

// Draw data to chart
plot(strategy.position_size != 0 ? trailPrice : na, color=color.red, title="Trailing Stop")

// Take Profit
float profitTarget = strategy.position_avg_price * (1 + takeProfitPercent / 100)

// Exit trade if stop is hit
strategy.exit(id="trend Exit", from_entry="Trend", stop=trailPrice, limit=useTakeProfit ? profitTarget : na)
strategy.exit(id="pamp Exit", from_entry="Pamp", stop=trailPrice, limit=useTakeProfit ? profitTarget : na)

if strategy.position_size == 0
    trailPrice = 0