// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © PresentTrading


//@version=6
strategy("Strategy Stats [presentTrading]", overlay=true,
 precision=3, commission_value= 0.1, commission_type=strategy.commission.percent, slippage= 1, currency=currency.USD, default_qty_type = strategy.percent_of_equity,
 default_qty_value = 10, initial_capital= 10000)


// Input settings allow the user to customize the strategy's parameters.
tradeDirectionChoice = input.string(title="Trade Direction", defval="Both", options=["Long", "Short", "Both"]) // Option to select the trading direction

// Settings for the first Vegas SuperTrend
atrPeriod1 = input(10, "ATR Period for SuperTrend 1") // Length of the ATR for volatility measurement
vegasWindow1 = input(100, "Vegas Window Length 1") // Length of the moving average for the Vegas Channel
superTrendMultiplier1 = input.float(3.5, "SuperTrend Multiplier Base 1") // Base multiplier for the SuperTrend calculation
volatilityAdjustment1 = input.float(5, "Volatility Adjustment Factor 1") // Factor to adjust the SuperTrend sensitivity to the Vegas Channel width

// Settings for the second Vegas SuperTrend
atrPeriod2 = input(5, "ATR Period for SuperTrend 2") // Length of the ATR for volatility measurement
vegasWindow2 = input(200, "Vegas Window Length 2") // Length of the moving average for the Vegas Channel
superTrendMultiplier2 = input.float(4.0, "SuperTrend Multiplier Base 2") // Base multiplier for the SuperTrend calculation
volatilityAdjustment2 = input.float(7, "Volatility Adjustment Factor 2") // Factor to adjust the SuperTrend sensitivity to the Vegas Channel width

// Settings for Hold Days and TPSL Conditions
useHoldDays = input.bool(true, title="Use Hold Days")
holdDays = input.int(5, title="Hold Days", minval=1, maxval=60, step=1)
TPSLCondition = input.string("Both", "TPSL Condition", options=["TP", "SL", "Both", "None"])
stopLossPerc = input(20.0, title="Stop Loss (%)")

// Multi-Step Take Profit Settings
tp_direction = input.string(title="Take Profit Direction", defval="Both", options=["Long", "Short", "Both"], group="Take Profit Settings")
atrLengthTP = input.int(14, title="ATR Length for Take Profit", group="Take Profit Settings")

// ATR-based Take Profit Steps
atrMultiplierTP1 = input.float(2.618, title="ATR Multiplier for TP 1", group="Take Profit Settings")
atrMultiplierTP2 = input.float(5.0, title="ATR Multiplier for TP 2", group="Take Profit Settings")
atrMultiplierTP3 = input.float(10.0, title="ATR Multiplier for TP 3", group="Take Profit Settings")

// Short Position Multiplier for Take Profit Percentages
shortTPMultiplier = input.float(1.5, title="Short TP Percent Multiplier", group="Take Profit Settings")

// Percentage-based Take Profit Steps
tp_level_percent1 = input.float(title="Take Profit Level 1 (%)", defval=3.0, group="Take Profit Settings")
tp_level_percent2 = input.float(title="Take Profit Level 2 (%)", defval=8.0, group="Take Profit Settings")
tp_level_percent3 = input.float(title="Take Profit Level 3 (%)", defval=17.0, group="Take Profit Settings")

// Percentage-based Take Profit Allocation
tp_percent1 = input.float(title="Take Profit Percent 1 (%)", defval=12.0, group="Take Profit Settings")
tp_percent2 = input.float(title="Take Profit Percent 2 (%)", defval=8.0, group="Take Profit Settings")
tp_percent3 = input.float(title="Take Profit Percent 3 (%)", defval=10.0, group="Take Profit Settings")

// ATR-based Take Profit Percent Allocation
tp_percentATR1 = input.float(title="ATR TP Percent 1 (%)", defval=10.0, group="Take Profit Settings")
tp_percentATR2 = input.float(title="ATR TP Percent 2 (%)", defval=10.0, group="Take Profit Settings")
tp_percentATR3 = input.float(title="ATR TP Percent 3 (%)", defval=10.0, group="Take Profit Settings")

// Short position percentage allocations using the multiplier
tp_percent1_short = tp_percent1 * shortTPMultiplier
tp_percent2_short = tp_percent2 * shortTPMultiplier
tp_percent3_short = tp_percent3 * shortTPMultiplier

tp_percentATR1_short = tp_percentATR1 * shortTPMultiplier
tp_percentATR2_short = tp_percentATR2 * shortTPMultiplier
tp_percentATR3_short = tp_percentATR3 * shortTPMultiplier

// Calculate the first Vegas Channel using a simple moving average and standard deviation.
vegasMovingAverage1 = ta.sma(close, vegasWindow1)
vegasChannelStdDev1 = ta.stdev(close, vegasWindow1)
vegasChannelUpper1 = vegasMovingAverage1 + vegasChannelStdDev1
vegasChannelLower1 = vegasMovingAverage1 - vegasChannelStdDev1

// Adjust the first SuperTrend multiplier based on the width of the Vegas Channel.
channelVolatilityWidth1 = vegasChannelUpper1 - vegasChannelLower1
adjustedMultiplier1 = superTrendMultiplier1 + volatilityAdjustment1 * (channelVolatilityWidth1 / vegasMovingAverage1)

// Calculate the first SuperTrend indicator values.
averageTrueRange1 = ta.atr(atrPeriod1)
superTrendUpper1 = hlc3 - (adjustedMultiplier1 * averageTrueRange1)
superTrendLower1 = hlc3 + (adjustedMultiplier1 * averageTrueRange1)
var float superTrendPrevUpper1 = na
var float superTrendPrevLower1 = na
var int marketTrend1 = 1

// Update SuperTrend values and determine the current trend direction for the first SuperTrend.
superTrendPrevUpper1 := nz(superTrendPrevUpper1[1], superTrendUpper1)
superTrendPrevLower1 := nz(superTrendPrevLower1[1], superTrendLower1)
marketTrend1 := close > superTrendPrevLower1 ? 1 : close < superTrendPrevUpper1 ? -1 : nz(marketTrend1[1], 1)
superTrendUpper1 := marketTrend1 == 1 ? math.max(superTrendUpper1, superTrendPrevUpper1) : superTrendUpper1
superTrendLower1 := marketTrend1 == -1 ? math.min(superTrendLower1, superTrendPrevLower1) : superTrendLower1
superTrendPrevUpper1 := superTrendUpper1
superTrendPrevLower1 := superTrendLower1

// Calculate the second Vegas Channel using a simple moving average and standard deviation.
vegasMovingAverage2 = ta.sma(close, vegasWindow2)
vegasChannelStdDev2 = ta.stdev(close, vegasWindow2)
vegasChannelUpper2 = vegasMovingAverage2 + vegasChannelStdDev2
vegasChannelLower2 = vegasMovingAverage2 - vegasChannelStdDev2

// Adjust the second SuperTrend multiplier based on the width of the Vegas Channel.
channelVolatilityWidth2 = vegasChannelUpper2 - vegasChannelLower2
adjustedMultiplier2 = superTrendMultiplier2 + volatilityAdjustment2 * (channelVolatilityWidth2 / vegasMovingAverage2)

// Calculate the second SuperTrend indicator values.
averageTrueRange2 = ta.atr(atrPeriod2)
superTrendUpper2 = hlc3 - (adjustedMultiplier2 * averageTrueRange2)
superTrendLower2 = hlc3 + (adjustedMultiplier2 * averageTrueRange2)
var float superTrendPrevUpper2 = na
var float superTrendPrevLower2 = na
var int marketTrend2 = 1

// Update SuperTrend values and determine the current trend direction for the second SuperTrend.
superTrendPrevUpper2 := nz(superTrendPrevUpper2[1], superTrendUpper2)
superTrendPrevLower2 := nz(superTrendPrevLower2[1], superTrendLower2)
marketTrend2 := close > superTrendPrevLower2 ? 1 : close < superTrendPrevUpper2 ? -1 : nz(marketTrend2[1], 1)
superTrendUpper2 := marketTrend2 == 1 ? math.max(superTrendUpper2, superTrendPrevUpper2) : superTrendUpper2
superTrendLower2 := marketTrend2 == -1 ? math.min(superTrendLower2, superTrendPrevLower2) : superTrendLower2
superTrendPrevUpper2 := superTrendUpper2
superTrendPrevLower2 := superTrendLower2

// Enhanced Visualization
// Plot the SuperTrend and Vegas Channel for visual analysis for both lengths.
plot(marketTrend1 == 1 ? superTrendUpper1 : na, "SuperTrend Upper 1", color=color.green, linewidth=2)
plot(marketTrend1 == -1 ? superTrendLower1 : na, "SuperTrend Lower 1", color=color.red, linewidth=2)

plot(marketTrend2 == 1 ? superTrendUpper2 : na, "SuperTrend Upper 2", color=color.rgb(31, 119, 130), linewidth=2)
plot(marketTrend2 == -1 ? superTrendLower2 : na, "SuperTrend Lower 2", color=color.rgb(120, 42, 26), linewidth=2)

// Detect trend direction changes and plot entry/exit signals for both lengths.
trendShiftToBullish1 = marketTrend1 == 1 and marketTrend1[1] == -1
trendShiftToBearish1 = marketTrend1 == -1 and marketTrend1[1] == 1

trendShiftToBullish2 = marketTrend2 == 1 and marketTrend2[1] == -1
trendShiftToBearish2 = marketTrend2 == -1 and marketTrend2[1] == 1

// Define conditions for entering long or short positions, and execute trades based on these conditions for both lengths.
enterLongCondition1 = marketTrend1 == 1
enterShortCondition1 = marketTrend1 == -1

enterLongCondition2 = marketTrend2 == 1
enterShortCondition2 = marketTrend2 == -1

// Entry conditions: Both conditions must be met for a trade to be executed.
enterLongCondition = enterLongCondition1 and enterLongCondition2 and not na(superTrendPrevUpper1[1]) and not na(superTrendPrevUpper2[1])
enterShortCondition = enterShortCondition1 and enterShortCondition2 and not na(superTrendPrevLower1[1]) and not na(superTrendPrevLower2[1])

// Variables to track entry times
var float longEntryTime = na
var float shortEntryTime = na

// Variables to track whether we have recently exited a trade to prevent re-entry in the same trend
var bool recentlyExitedLong = false
var bool recentlyExitedShort = false

// Check trade direction choice before executing trade entries.
if (enterLongCondition and (tradeDirectionChoice == "Long" or tradeDirectionChoice == "Both"))
    if (strategy.position_size < 0)
        strategy.close("Short Position")
    strategy.entry("Long Position", strategy.long)
    longEntryTime := time
    recentlyExitedLong := false
    recentlyExitedShort := false

if (enterShortCondition and (tradeDirectionChoice == "Short" or tradeDirectionChoice == "Both"))
    if (strategy.position_size > 0)
        strategy.close("Long Position")
    strategy.entry("Short Position", strategy.short)
    shortEntryTime := time
    recentlyExitedShort := false
    recentlyExitedLong := false

// Exit conditions: Either condition being met will trigger an exit.
exitLongCondition = marketTrend1 == -1 or marketTrend2 == -1
exitShortCondition = marketTrend1 == 1 or marketTrend2 == 1

// Close positions based on exit conditions or hold days.
if (useHoldDays and not na(longEntryTime) and (time >= longEntryTime + holdDays * 86400000) and strategy.position_size > 0)
    strategy.close("Long Position")
    longEntryTime := na
    recentlyExitedLong := true

if (useHoldDays and not na(shortEntryTime) and (time >= shortEntryTime + holdDays * 86400000) and strategy.position_size < 0)
    strategy.close("Short Position")
    shortEntryTime := na
    recentlyExitedShort := true

if (not useHoldDays and exitLongCondition and strategy.position_size > 0)
    strategy.close("Long Position")
    longEntryTime := na
    recentlyExitedLong := true

if (not useHoldDays and exitShortCondition and strategy.position_size < 0)
    strategy.close("Short Position")
    shortEntryTime := na
    recentlyExitedShort := true

// Reset recently exited flags on trend change to allow re-entry on a new trend
if (trendShiftToBullish1 or trendShiftToBullish2)
    recentlyExitedLong := false

if (trendShiftToBearish1 or trendShiftToBearish2)
    recentlyExitedShort := false

if (TPSLCondition == "TP" or TPSLCondition == "Both")
    // Calculate ATR for volatility-based take profit levels
    float atrValue = ta.atr(atrLengthTP)

    // For long positions
    if strategy.position_size > 0 and (tp_direction == "Long" or tp_direction == "Both")
        // ATR-based Take Profit (Long)
        float tp_priceATR1_long = strategy.position_avg_price + atrMultiplierTP1 * atrValue
        float tp_priceATR2_long = strategy.position_avg_price + atrMultiplierTP2 * atrValue
        float tp_priceATR3_long = strategy.position_avg_price + atrMultiplierTP3 * atrValue

        // Percentage-based Take Profit (Long)
        float tp_pricePercent1_long = strategy.position_avg_price * (1 + tp_level_percent1 / 100)
        float tp_pricePercent2_long = strategy.position_avg_price * (1 + tp_level_percent2 / 100)
        float tp_pricePercent3_long = strategy.position_avg_price * (1 + tp_level_percent3 / 100)

        // Execute ATR-based exits for Long
        strategy.exit("TP ATR 1 Long", from_entry="Long Position", qty_percent=tp_percentATR1, limit=tp_priceATR1_long)
        strategy.exit("TP ATR 2 Long", from_entry="Long Position", qty_percent=tp_percentATR2, limit=tp_priceATR2_long)
        strategy.exit("TP ATR 3 Long", from_entry="Long Position", qty_percent=tp_percentATR3, limit=tp_priceATR3_long)

        // Execute Percentage-based exits for Long
        strategy.exit("TP Percent 1 Long", from_entry="Long Position", qty_percent=tp_percent1, limit=tp_pricePercent1_long)
        strategy.exit("TP Percent 2 Long", from_entry="Long Position", qty_percent=tp_percent2, limit=tp_pricePercent2_long)
        strategy.exit("TP Percent 3 Long", from_entry="Long Position", qty_percent=tp_percent3, limit=tp_pricePercent3_long)

    // For short positions
    if strategy.position_size < 0 and (tp_direction == "Short" or tp_direction == "Both")
        // ATR-based Take Profit (Short)
        float tp_priceATR1_short = strategy.position_avg_price - atrMultiplierTP1 * atrValue
        float tp_priceATR2_short = strategy.position_avg_price - atrMultiplierTP2 * atrValue
        float tp_priceATR3_short = strategy.position_avg_price - atrMultiplierTP3 * atrValue

        // Percentage-based Take Profit (Short) - with more aggressive percentages using multiplier
        float tp_pricePercent1_short = strategy.position_avg_price * (1 - tp_level_percent1 / 100)
        float tp_pricePercent2_short = strategy.position_avg_price * (1 - tp_level_percent2 / 100)
        float tp_pricePercent3_short = strategy.position_avg_price * (1 - tp_level_percent3 / 100)

        // Execute ATR-based exits for Short
        strategy.exit("TP ATR 1 Short", from_entry="Short Position", qty_percent=tp_percentATR1_short, limit=tp_priceATR1_short)
        strategy.exit("TP ATR 2 Short", from_entry="Short Position", qty_percent=tp_percentATR2_short, limit=tp_priceATR2_short)
        strategy.exit("TP ATR 3 Short", from_entry="Short Position", qty_percent=tp_percentATR3_short, limit=tp_priceATR3_short)

        // Execute Percentage-based exits for Short
        strategy.exit("TP Percent 1 Short", from_entry="Short Position", qty_percent=tp_percent1_short, limit=tp_pricePercent1_short)
        strategy.exit("TP Percent 2 Short", from_entry="Short Position", qty_percent=tp_percent2_short, limit=tp_pricePercent2_short)
        strategy.exit("TP Percent 3 Short", from_entry="Short Position", qty_percent=tp_percent3_short, limit=tp_pricePercent3_short)

if (TPSLCondition == "SL" or TPSLCondition == "Both")
    // Apply stop loss conditions
    strategy.exit("StopLoss_Long", "Long Position", stop=close * (1 - stopLossPerc / 100))
    strategy.exit("StopLoss_Short", "Short Position", stop=close * (1 + stopLossPerc / 100))

// Ensure that new entry signals can override the hold days condition
if (enterLongCondition and (tradeDirectionChoice == "Long" or tradeDirectionChoice == "Both"))
    if (strategy.position_size < 0)
        strategy.close("Short Position")
    strategy.entry("Long Position", strategy.long)
    longEntryTime := time
    recentlyExitedLong := false
    recentlyExitedShort := false

if (enterShortCondition and (tradeDirectionChoice == "Short" or tradeDirectionChoice == "Both"))
    if (strategy.position_size > 0)
        strategy.close("Long Position")
    strategy.entry("Short Position", strategy.short)
    shortEntryTime := time
    recentlyExitedShort := false
    recentlyExitedLong := false

// =============================
// Performance Tracking & Visualization
// =============================
// Store historical equity values and trade info
var equityHistory = array.new_float(0)
var tradeHistory = array.new_float(0)  // Store profit/loss of each trade
var priceHistory = array.new_float(0)  // Store historical prices for pair performance tracking

var float maxEquity = strategy.initial_capital
var float maxDrawdown = 0.0
var label debugLabel = na

// Track the starting bar time and price for total return calculation
var float startPrice = na
var int startTime = na

// Initialize on the first bar
if bar_index == 0 or na(startPrice)
    startPrice := open
    startTime := time

// Arrays for tracking IC calculation
var predictionSignals = array.new_float(0)  // Store prediction signals (1 for long, -1 for short)
var actualReturns = array.new_float(0)      // Store corresponding actual returns
var periodReturnsArray = array.new_float(0) // Store returns for Sortino calculation

// Revised function to calculate Sortino Ratio
calcSortinoRatio(returns, riskFreeRate=0.0) =>
    int returnsSize = array.size(returns)
    if returnsSize < 2
        na
    else
        // Calculate average return
        float sumReturns = 0.0
        for i = 0 to returnsSize - 1
            sumReturns += array.get(returns, i)
        float avgReturn = sumReturns / returnsSize

        // Calculate downside deviation (only negative returns)
        float sumSquaredDownside = 0.0
        int downsideCount = 0
        for i = 0 to returnsSize - 1
            float ret = array.get(returns, i)
            // Changed condition to focus on negative returns only
            if ret < 0
                sumSquaredDownside += math.pow(ret, 2)
                downsideCount += 1

        // Calculate downside deviation
        float downsideDeviation = downsideCount > 0 ? math.sqrt(sumSquaredDownside / downsideCount) : 0.0

        // Return Sortino Ratio
        downsideDeviation > 0 ? (avgReturn) / downsideDeviation : na

// Calculate bars for different time periods based on chart timeframe - Optimized for Crypto
estimateBarsPerDay() =>
    float barsPerDay = 0.0
    if timeframe.isintraday
        barsPerDay := 24 * 60 / math.max(1, (timeframe.in_seconds() / 60))  // Ensure no division by zero
    else if timeframe.isdaily
        barsPerDay := 1
    else if timeframe.isweekly
        barsPerDay := 1/7
    else if timeframe.ismonthly
        barsPerDay := 1/30
    math.max(0.01, barsPerDay)  // Ensure positive value

float barsPerDay = estimateBarsPerDay()
// Revised time periods: 30D, 90D, 180D, 360D
int bars_30d = math.max(1, math.round(30 * barsPerDay))
int bars_90d = math.max(1, math.round(90 * barsPerDay))
int bars_180d = math.max(1, math.round(180 * barsPerDay))
int bars_360d = math.max(1, math.round(360 * barsPerDay))

// Add current equity to history array
array.push(equityHistory, strategy.equity)

// Track price history for the current pair
array.push(priceHistory, close)

// Keep array sizes manageable by removing old values - updated for longer periods
if array.size(equityHistory) > bars_360d + 100
    array.shift(equityHistory)
if array.size(priceHistory) > bars_360d + 100
    array.shift(priceHistory)

// Track max equity and calculate drawdown
if strategy.equity > maxEquity
    maxEquity := strategy.equity
float currentDrawdown = strategy.equity < maxEquity ? (maxEquity - strategy.equity) / maxEquity * 100 : 0.0
if currentDrawdown > maxDrawdown
    maxDrawdown := currentDrawdown

// In the tracking closed trades section
if strategy.closedtrades > 0 and strategy.closedtrades != strategy.closedtrades[1]
    // Safely get the index of the last trade
    int tradeIndex = strategy.closedtrades - 1

    // Safety check to ensure the trade index is valid
    if tradeIndex >= 0
        float tradePnL = strategy.closedtrades.profit(tradeIndex)
        array.push(tradeHistory, tradePnL)

        float tradeReturn = strategy.closedtrades.profit_percent(tradeIndex)

        // Explicitly determine if it was a long or short trade based on entry/exit times and prices
        bool isLong = true
        float entryPrice = strategy.closedtrades.entry_price(tradeIndex)
        float exitPrice = strategy.closedtrades.exit_price(tradeIndex)

        // For accurate direction detection
        if strategy.closedtrades.entry_id(tradeIndex) == "Short"
            isLong := false

        int tradeType = isLong ? 1 : -1  // 1 for long, -1 for short

        // Store prediction signal (trade direction)
        array.push(predictionSignals, tradeType)

        // Adjust return based on direction for proper IC calculation
        float adjustedReturn = tradeType * tradeReturn
        array.push(actualReturns, adjustedReturn)

// Function to calculate correlation (Pearson correlation coefficient) with error handling
calcCorrelation(array1, array2) =>
    int size1 = array.size(array1)
    int size2 = array.size(array2)

    if size1 < 3 or size2 < 3  // Need at least 3 data points for meaningful correlation
        na
    else
        int n = math.min(size1, size2)
        float sumX = 0.0
        float sumY = 0.0
        float sumXY = 0.0
        float sumX2 = 0.0
        float sumY2 = 0.0

        bool hasValidData = false

        for i = 0 to n - 1
            if i < size1 and i < size2
                float x = array.get(array1, i)
                float y = array.get(array2, i)

                if not na(x) and not na(y)
                    hasValidData := true
                    sumX += x
                    sumY += y
                    sumXY += x * y
                    sumX2 += x * x
                    sumY2 += y * y

        if not hasValidData
            na
        else
            float numerator = n * sumXY - sumX * sumY
            float denominator = math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY))

            float correlation = denominator != 0.0 ? numerator / denominator : na
            math.min(1.0, math.max(-1.0, correlation))  // Clamp to valid range

// Function to calculate period statistics with better error handling
calcPeriodStats(bars) =>
    float returnValue = na
    float maxDD = na
    float winRate = na
    float avgProfit = na
    float ic = na
    float sortino = na
    int winCount = 0
    int lossCount = 0
    float totalProfit = 0.0
    float maxEq = strategy.initial_capital
    float minDD = 0.0
    int tradeCount = 0

    // Clear returns array for this period
    array.clear(periodReturnsArray)

    // Get starting bar index for period
    int historySize = array.size(equityHistory)
    int startIndex = math.max(0, historySize - bars - 1)

    // Calculate period return
    if historySize > bars and startIndex < historySize
        float startEquity = array.get(equityHistory, startIndex)
        float currentEquity = array.last(equityHistory)
        if startEquity > 0
            returnValue := (currentEquity - startEquity) / startEquity * 100

    // Calculate trade statistics for period
    if strategy.closedtrades > 0 and array.size(tradeHistory) > 0
        // Get the timestamp for the beginning of the period
        int periodStartTime = time[math.min(bars, bar_index)]

        // Arrays for IC calculation within this period
        var periodPredictions = array.new_float(0)
        var periodReturns = array.new_float(0)

        // Clear arrays to reuse
        array.clear(periodPredictions)
        array.clear(periodReturns)

        // Analyze trades in this period
        for i = 0 to strategy.closedtrades - 1
            if strategy.closedtrades.exit_time(i) >= periodStartTime
                float profit = strategy.closedtrades.profit(i)
                totalProfit += profit
                if profit >= 0
                    winCount += 1
                else
                    lossCount += 1
                tradeCount += 1

                // Store data for IC calculation for this period
                float tradeReturn = strategy.closedtrades.profit_percent(i)

                // Add return for Sortino calculation
                array.push(periodReturnsArray, tradeReturn)

                // Determine trade direction safely
                float entryPrice = strategy.closedtrades.entry_price(i)
                float exitPrice = strategy.closedtrades.exit_price(i)

                if entryPrice > 0 and exitPrice > 0
                    int tradeType = strategy.closedtrades.size(i) > 0 ? 1 : -1  // 1 for long, -1 for short

                    array.push(periodPredictions, tradeType)

                    // Adjust return based on direction for proper IC calculation (FIX)
                    float adjustedReturn = tradeType * tradeReturn
                    array.push(periodReturns, adjustedReturn)

        // Calculate win rate and average profit
        if tradeCount > 0
            winRate := (winCount / tradeCount) * 100
            avgProfit := totalProfit / tradeCount

        // Calculate IC for this period
        if array.size(periodPredictions) > 2 and array.size(periodReturns) > 2
            ic := calcCorrelation(periodPredictions, periodReturns)

        // Calculate Sortino Ratio
        if array.size(periodReturnsArray) >= 2
            sortino := calcSortinoRatio(periodReturnsArray)

        // Calculate max drawdown for period with safety checks
        if startIndex < historySize
            float highEquity = array.get(equityHistory, startIndex)

            for j = startIndex to historySize - 1
                if j < historySize
                    float equity = array.get(equityHistory, j)
                    highEquity := math.max(highEquity, equity)
                    if highEquity > 0
                        float dd = (highEquity - equity) / highEquity * 100
                        minDD := math.max(minDD, dd)

            maxDD := minDD

    [returnValue, winRate, avgProfit, maxDD, ic, tradeCount, sortino]

// Function to calculate pair-specific performance
calcPairPerformance(bars) =>
    float pairReturn = na
    float pairMaxDD = 0.0  // Initialize to zero

    // Get starting bar index for period
    int historySize = array.size(priceHistory)
    int startIndex = math.max(0, historySize - bars - 1)

    // Calculate period return based on price change
    if historySize > bars and startIndex < historySize
        float startPrice = array.get(priceHistory, startIndex)
        float currentPrice = array.last(priceHistory)
        if startPrice > 0
            pairReturn := (currentPrice - startPrice) / startPrice * 100

        // Better way to calculate max drawdown for price
        float highWatermark = startPrice

        for i = startIndex to historySize - 1
            if i < historySize
                float price = array.get(priceHistory, i)

                // Update high watermark
                if price > highWatermark
                    highWatermark := price

                // Calculate drawdown if we have a high watermark
                if highWatermark > 0
                    float dd = (highWatermark - price) / highWatermark * 100
                    if dd > pairMaxDD
                        pairMaxDD := dd

    [pairReturn, pairMaxDD]

// Calculate total returns from the beginning of the backtest
calcTotalReturns() =>
    float strategyReturn = ((strategy.equity - strategy.initial_capital) / strategy.initial_capital) * 100
    float pairReturn = not na(startPrice) and startPrice > 0 ? ((close - startPrice) / startPrice) * 100 : na

    // Calculate maximum price drawdown since start
    float pairMaxDD = 0.0  // Initialize to zero

    if array.size(priceHistory) > 0 and not na(startPrice)
        float highWatermark = startPrice

        for i = 0 to array.size(priceHistory) - 1
            float price = array.get(priceHistory, i)

            // Update high watermark
            if price > highWatermark
                highWatermark := price

            // Calculate drawdown from highest
            if highWatermark > 0
                float dd = (highWatermark - price) / highWatermark * 100
                if dd > pairMaxDD
                    pairMaxDD := dd

    [strategyReturn, pairReturn, pairMaxDD]

// Calculate current position profit/loss percentage
calcPositionPnL() =>
    float positionPnL = na
    if strategy.position_size != 0
        // For long positions
        if strategy.position_size > 0
            positionPnL := (close - strategy.position_avg_price) / strategy.position_avg_price * 100
        // For short positions
        else if strategy.position_size < 0
            positionPnL := (strategy.position_avg_price - close) / strategy.position_avg_price * 100
    positionPnL

// Calculate overall IC and Sortino
calcOverallMetrics() =>
    float overallIC = na
    float overallSortino = na

    // Calculate overall IC
    if array.size(predictionSignals) > 2 and array.size(actualReturns) > 2
        overallIC := calcCorrelation(predictionSignals, actualReturns)

    // Calculate overall Sortino - use all trade returns
    var allReturns = array.new_float(0)
    array.clear(allReturns)

    for i = 0 to strategy.closedtrades - 1
        array.push(allReturns, strategy.closedtrades.profit_percent(i))

    if array.size(allReturns) >= 2
        overallSortino := calcSortinoRatio(allReturns)

    [overallIC, overallSortino]



// Create a single combined performance table
var table combinedTable = na

// Update the table on the last confirmed bar
if barstate.islastconfirmedhistory
    // Calculate pair-specific performance for different periods
    [pairReturn_30d, pairMaxDD_30d] = calcPairPerformance(bars_30d)
    [pairReturn_90d, pairMaxDD_90d] = calcPairPerformance(bars_90d)
    [pairReturn_180d, pairMaxDD_180d] = calcPairPerformance(bars_180d)
    [pairReturn_360d, pairMaxDD_360d] = calcPairPerformance(bars_360d)

    // Calculate statistics for different periods
    [return_30d, winRate_30d, avgProfit_30d, maxDD_30d, ic_30d, trades_30d, sortino_30d] = calcPeriodStats(bars_30d)
    [return_90d, winRate_90d, avgProfit_90d, maxDD_90d, ic_90d, trades_90d, sortino_90d] = calcPeriodStats(bars_90d)
    [return_180d, winRate_180d, avgProfit_180d, maxDD_180d, ic_180d, trades_180d, sortino_180d] = calcPeriodStats(bars_180d)
    [return_360d, winRate_360d, avgProfit_360d, maxDD_360d, ic_360d, trades_360d, sortino_360d] = calcPeriodStats(bars_360d)

    // Calculate current position PnL
    float positionPnL = calcPositionPnL()

    // Calculate total returns
    [totalStrategyReturn, totalPairReturn, totalPairMaxDD] = calcTotalReturns()

    // Calculate overall IC and Sortino ratio
    [overallIC, overallSortino] = calcOverallMetrics()

    // Create or update the combined table
    if na(combinedTable)
        combinedTable := table.new(position.top_right, 7, 8, border_width=1, border_color=color.new(color.gray, 50))

    // Set table headers
    table.cell(combinedTable, 0, 0, syminfo.ticker, bgcolor=color.new(#162330, 0), text_color=color.white, text_size=size.normal)
    table.cell(combinedTable, 1, 0, "Current", bgcolor=color.new(#162330, 5), text_color=color.white)
    table.cell(combinedTable, 2, 0, "30D" + (trades_30d > 0 ? "(" + str.tostring(trades_30d) + ")" : ""), bgcolor=color.new(#162330, 5), text_color=color.white)
    table.cell(combinedTable, 3, 0, "90D" + (trades_90d > 0 ? "(" + str.tostring(trades_90d) + ")" : ""), bgcolor=color.new(#162330, 5), text_color=color.white)
    table.cell(combinedTable, 4, 0, "180D" + (trades_180d > 0 ? "(" + str.tostring(trades_180d) + ")" : ""), bgcolor=color.new(#162330, 5), text_color=color.white)
    table.cell(combinedTable, 5, 0, "360D" + (trades_360d > 0 ? "(" + str.tostring(trades_360d) + ")" : ""), bgcolor=color.new(#162330, 5), text_color=color.white)
    table.cell(combinedTable, 6, 0, "Total", bgcolor=color.new(#162330, 5), text_color=color.white)

    // Row labels
    table.cell(combinedTable, 0, 1, "Strategy Return", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 0, 2, "Win%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 0, 3, "Strategy MaxDD", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 0, 4, "Pair Return", bgcolor=color.new(color.blue, 70), text_color=color.white)
    table.cell(combinedTable, 0, 5, "Pair MaxDD", bgcolor=color.new(color.blue, 70), text_color=color.white)
    table.cell(combinedTable, 0, 6, "IC", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 0, 7, "Sortino", bgcolor=color.new(#162330, 10), text_color=color.white)

    // Current position cell
    table.cell(combinedTable, 1, 1, na(positionPnL) ? "None" : str.tostring(positionPnL, "#.##") + "%", bgcolor=color.new(#162330, 0), text_color=not na(positionPnL) ? (positionPnL >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 1, 2, "N/A", bgcolor=color.new(#162330, 0), text_color=color.white)
    table.cell(combinedTable, 1, 3, "N/A", bgcolor=color.new(#162330, 0), text_color=color.white)
    table.cell(combinedTable, 1, 4, "Current", bgcolor=color.new(#162330, 0), text_color=color.white)
    table.cell(combinedTable, 1, 5, "N/A", bgcolor=color.new(#162330, 0), text_color=color.white)
    table.cell(combinedTable, 1, 6, "N/A", bgcolor=color.new(#162330, 0), text_color=color.white)
    table.cell(combinedTable, 1, 7, "N/A", bgcolor=color.new(#162330, 0), text_color=color.white)

    // 30-day statistics
    table.cell(combinedTable, 2, 1, na(return_30d) ? "N/A" : str.tostring(return_30d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(return_30d) ? (return_30d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 2, 2, na(winRate_30d) ? "N/A" : str.tostring(winRate_30d, "#.#") + "%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 2, 3, na(maxDD_30d) ? "N/A" : str.tostring(maxDD_30d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 2, 4, na(pairReturn_30d) ? "N/A" : str.tostring(pairReturn_30d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(pairReturn_30d) ? (pairReturn_30d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 2, 5, na(pairMaxDD_30d) ? "N/A" : str.tostring(pairMaxDD_30d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 2, 6, na(ic_30d) ? "N/A" : str.tostring(ic_30d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(ic_30d) ? (ic_30d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 2, 7, na(sortino_30d) ? "N/A" : str.tostring(sortino_30d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(sortino_30d) ? (sortino_30d >= 0 ? color.green : color.red) : color.white)

    // 90-day statistics
    table.cell(combinedTable, 3, 1, na(return_90d) ? "N/A" : str.tostring(return_90d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(return_90d) ? (return_90d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 3, 2, na(winRate_90d) ? "N/A" : str.tostring(winRate_90d, "#.#") + "%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 3, 3, na(maxDD_90d) ? "N/A" : str.tostring(maxDD_90d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 3, 4, na(pairReturn_90d) ? "N/A" : str.tostring(pairReturn_90d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(pairReturn_90d) ? (pairReturn_90d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 3, 5, na(pairMaxDD_90d) ? "N/A" : str.tostring(pairMaxDD_90d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 3, 6, na(ic_90d) ? "N/A" : str.tostring(ic_90d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(ic_90d) ? (ic_90d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 3, 7, na(sortino_90d) ? "N/A" : str.tostring(sortino_90d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(sortino_90d) ? (sortino_90d >= 0 ? color.green : color.red) : color.white)

    // 180-day statistics
    table.cell(combinedTable, 4, 1, na(return_180d) ? "N/A" : str.tostring(return_180d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(return_180d) ? (return_180d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 4, 2, na(winRate_180d) ? "N/A" : str.tostring(winRate_180d, "#.#") + "%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 4, 3, na(maxDD_180d) ? "N/A" : str.tostring(maxDD_180d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 4, 4, na(pairReturn_180d) ? "N/A" : str.tostring(pairReturn_180d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(pairReturn_180d) ? (pairReturn_180d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 4, 5, na(pairMaxDD_180d) ? "N/A" : str.tostring(pairMaxDD_180d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 4, 6, na(ic_180d) ? "N/A" : str.tostring(ic_180d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(ic_180d) ? (ic_180d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 4, 7, na(sortino_180d) ? "N/A" : str.tostring(sortino_180d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(sortino_180d) ? (sortino_180d >= 0 ? color.green : color.red) : color.white)

    // 360-day statistics
    table.cell(combinedTable, 5, 1, na(return_360d) ? "N/A" : str.tostring(return_360d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(return_360d) ? (return_360d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 5, 2, na(winRate_360d) ? "N/A" : str.tostring(winRate_360d, "#.#") + "%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 5, 3, na(maxDD_360d) ? "N/A" : str.tostring(maxDD_360d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 5, 4, na(pairReturn_360d) ? "N/A" : str.tostring(pairReturn_360d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(pairReturn_360d) ? (pairReturn_360d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 5, 5, na(pairMaxDD_360d) ? "N/A" : str.tostring(pairMaxDD_360d, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 5, 6, na(ic_360d) ? "N/A" : str.tostring(ic_360d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(ic_360d) ? (ic_360d >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 5, 7, na(sortino_360d) ? "N/A" : str.tostring(sortino_360d, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(sortino_360d) ? (sortino_360d >= 0 ? color.green : color.red) : color.white)

    // Total statistics (from beginning of backtest)
    table.cell(combinedTable, 6, 1, str.tostring(totalStrategyReturn, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=totalStrategyReturn >= 0 ? color.green : color.red)
    float totalWinRate = strategy.wintrades > 0 ? (strategy.wintrades / math.max(1, strategy.closedtrades)) * 100 : na
    table.cell(combinedTable, 6, 2, na(totalWinRate) ? "N/A" : str.tostring(totalWinRate, "#.#") + "%", bgcolor=color.new(#162330, 10), text_color=color.white)
    table.cell(combinedTable, 6, 3, str.tostring(maxDrawdown, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 6, 4, na(totalPairReturn) ? "N/A" : str.tostring(totalPairReturn, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=not na(totalPairReturn) ? (totalPairReturn >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 6, 5, na(totalPairMaxDD) ? "N/A" : str.tostring(totalPairMaxDD, "#.##") + "%", bgcolor=color.new(#162330, 10), text_color=color.red)
    table.cell(combinedTable, 6, 6, na(overallIC) ? "N/A" : str.tostring(overallIC, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(overallIC) ? (overallIC >= 0 ? color.green : color.red) : color.white)
    table.cell(combinedTable, 6, 7, na(overallSortino) ? "N/A" : str.tostring(overallSortino, "#.##"), bgcolor=color.new(#162330, 10), text_color=not na(overallSortino) ? (overallSortino >= 0 ? color.green : color.red) : color.white)

    // Add a label with pair info
    label.new(bar_index, high, syminfo.ticker + " Performance", color=color.new(color.blue, 80), textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar)