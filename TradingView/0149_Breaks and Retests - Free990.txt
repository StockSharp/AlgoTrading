// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Free990
// Thanks to HoanGhetti for the indicator.
//@version=5
strategy("Breaks and Retests - Free990", shorttitle = "BnR Free990", overlay = true)

g_sr = 'Support and Resistance'
g_c  = 'Conditions'
g_st = 'Styling'
t_r  = 'Bar Confirmation: Generates alerts when candle closes. (1 Candle Later) \n\nHigh & Low: By default, the Break & Retest system uses the current close value to determine a condition, selecting High & Low will make the script utilize these two values instead of the close value. In return, the script won\'t repaint and will yield different results.'
t_rv = 'Whenever a potential retest is detected, the indicator knows that a retest is about to happen. In that given situation, this input grants the ability to raise the limit on how many bars are allowed to be actively checked while a potential retest event is active.\n\nExample, if you see the potential retest label, how many bars do you want that potential retest label to be active for to eventually confirm a retest? This system was implemented to prevent retest alerts from going off 10+ bars later from the potential retest point leading to inaccurate results.'

input_lookback  = input.int(defval = 20, title = 'Lookback Range', minval = 1, tooltip = 'How many bars for a pivot event to occur.', group = g_sr)
input_retSince  = input.int(defval = 2, title = 'Bars Since Breakout', minval = 1, tooltip = 'How many bars since breakout in order to detect a retest.', group = g_sr)
input_retValid  = input.int(defval = 2, title = 'Retest Detection Limiter', minval = 1, tooltip = t_rv, group = g_sr)
input_breakout  = input.bool(defval = true, title = 'Breakouts', group = g_c)
input_retest    = input.bool(defval = true, title = 'Retests', group = g_c)
input_repType   = input.string(defval = 'On', title = 'Repainting', options = ['On', 'Off: Candle Confirmation', 'Off: High & Low'], tooltip = t_r, group = g_c)
input_outL      = input.string(defval = line.style_dotted, title = 'Outline', group = g_st, options = [line.style_dotted, line.style_dashed, line.style_solid])
input_extend    = input.string(defval = extend.none, title = 'Extend', group = g_st, options = [extend.none, extend.right, extend.left, extend.both])
input_labelType = input.string(defval = 'Full', title = 'Label Type', options = ['Full', 'Simple'], group = g_st)
input_labelSize = input.string(defval = size.small, title = 'Label Size', options = [size.tiny, size.small, size.normal, size.large, size.huge], group = g_st)
input_plColor   = input.color(defval = color.red, title = 'Support', inline = 'Color', group = g_st)
input_phColor   = input.color(defval = #089981, title = 'Resistance', inline = 'Color', group = g_st)
input_override  = input.bool(defval = false, title = 'Override Text Color ', inline = 'Override', group = g_st)
input_textColor = input.color(defval = color.white, title = '', inline = 'Override', group = g_st)
bb              = input_lookback

// New inputs for trailing stop logic
profit_threshold_percent = input.float(5.0, title="Profit Threshold (%)", step=0.1)
trailing_stop_gap_percent = input.float(1.0, title="Trailing Stop Gap (%)", step=0.1)
stop_loss_percent = input.float(2.0, title="Initial Stop Loss (%)", step=0.1)

// Input for trade direction
trade_direction = input.string("Both", title="Trade Direction", options=["Long Only", "Short Only", "Both"])

rTon            = input_repType == 'On'
rTcc            = input_repType == 'Off: Candle Confirmation'
rThv            = input_repType == 'Off: High & Low'
breakText       = input_labelType == 'Simple' ? 'Br' : 'Break'

// Pivot Instance
pl = fixnan(ta.pivotlow(low, bb, bb))
ph = fixnan(ta.pivothigh(high, bb, bb))

// Box Height
s_yLoc = low[bb + 1] > low[bb - 1] ? low[bb - 1] : low[bb + 1]
r_yLoc = high[bb + 1] > high[bb - 1] ? high[bb + 1] : high[bb - 1]

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------
drawBox(condition, y1, y2, color) =>
    var box drawBox = na
    if condition
        box.set_right(drawBox, bar_index - bb)
        drawBox.set_extend(extend.none)
        drawBox := box.new(bar_index - bb, y1, bar_index, y2, color, bgcolor = color.new(color, 90), border_style = input_outL, extend = input_extend)
    [drawBox]

updateBox(box) =>
    if barstate.isconfirmed
        box.set_right(box, bar_index + 5)

breakLabel(y, color, style, textform) => label.new(bar_index, y, textform, textcolor = input_override ? input_textColor : color, style = style, color = color.new(color, 50), size = input_labelSize)
retestCondition(breakout, condition) => ta.barssince(na(breakout)) > input_retSince and condition
repaint(c1, c2, c3) => rTon ? c1 : rThv ? c2 : rTcc ? c3 : na

//-----------------------------------------------------------------------------
// Draw and Update Boxes
//-----------------------------------------------------------------------------
[sBox] = drawBox(ta.change(pl), s_yLoc, pl, input_plColor)
[rBox] = drawBox(ta.change(ph), ph, r_yLoc, input_phColor)
sTop = box.get_top(sBox), rTop = box.get_top(rBox)
sBot = box.get_bottom(sBox), rBot = box.get_bottom(rBox)

updateBox(sBox), updateBox(rBox)

//-----------------------------------------------------------------------------
// Breakout Event
//-----------------------------------------------------------------------------
var bool sBreak = na
var bool rBreak = na
cu = repaint(ta.crossunder(close, box.get_bottom(sBox)), ta.crossunder(low, box.get_bottom(sBox)), ta.crossunder(close, box.get_bottom(sBox)) and barstate.isconfirmed)
co = repaint(ta.crossover(close, box.get_top(rBox)), ta.crossover(high, box.get_top(rBox)), ta.crossover(close, box.get_top(rBox)) and barstate.isconfirmed)

switch
    cu and na(sBreak) =>
        sBreak := true
        if input_breakout
            breakLabel(sBot, input_plColor, label.style_label_upper_right, breakText)
    co and na(rBreak) =>
        rBreak := true
        if input_breakout
            breakLabel(rTop, input_phColor, label.style_label_lower_right, breakText)

if ta.change(pl)
    if na(sBreak)
        box.delete(sBox[1])
    sBreak := na
if ta.change(ph)
    if na(rBreak)
        box.delete(rBox[1])
    rBreak := na

//-----------------------------------------------------------------------------
// Retest Event
//-----------------------------------------------------------------------------
s1 = retestCondition(sBreak, high >= sTop and close <= sBot)                                            // High is GOET top sBox value and the close price is LOET the bottom sBox value.
s2 = retestCondition(sBreak, high >= sTop and close >= sBot and close <= sTop)                          // High is GOET top sBox value and close is GOET the bottom sBox value and closing price is LOET the top sBox value.
s3 = retestCondition(sBreak, high >= sBot and high <= sTop)                                             // High is in between the sBox.
s4 = retestCondition(sBreak, high >= sBot and high <= sTop and close < sBot)                            // High is in between the sBox, and the closing price is below.

r1 = retestCondition(rBreak, low <= rBot and close >= rTop)                                             // Low is LOET bottom rBox value and close is GOET the top sBox value
r2 = retestCondition(rBreak, low <= rBot and close <= rTop and close >= rBot)                           // Low is LOET bottom rBox value and close is LOET the top sBox value and closing price is GOET the bottom rBox value.
r3 = retestCondition(rBreak, low <= rTop and low >= rBot)                                               // Low is in between the rBox.
r4 = retestCondition(rBreak, low <= rTop and low >= rBot and close > rTop)                              // Low is in between the rBox, and the closing price is above.

retestEvent(c1, c2, c3, c4, y1, y2, col, style, pType) =>
    if input_retest
        var bool retOccurred = na
        retActive   = c1 or c2 or c3 or c4
        retEvent    = retActive and not retActive[1]
        retValue    = ta.valuewhen(retEvent, y1, 0)

        if pType == 'ph' ? y2 < ta.valuewhen(retEvent, y2, 0) : y2 > ta.valuewhen(retEvent, y2, 0)
            retEvent := retActive

        // Must be reassigned here just in case the above if statement triggers.
        retValue := ta.valuewhen(retEvent, y1, 0)

        retSince = ta.barssince(retEvent)
        var retLabel = array.new<label>()

        if retEvent
            retOccurred := na
            array.push(retLabel, label.new(bar_index - retSince, y2[retSince], text = input_labelType == 'Simple' ? 'P. Re' : 'Potential Retest', color = color.new(col, 50), style = style, textcolor = input_override ? input_textColor : col, size = input_labelSize))

        if array.size(retLabel) == 2
            label.delete(array.first(retLabel))
            array.shift(retLabel)

        retConditions = pType == 'ph' ? repaint(close >= retValue, high >= retValue, close >= retValue and barstate.isconfirmed) : repaint(close <= retValue, low <= retValue, close <= retValue and barstate.isconfirmed)
        retValid = ta.barssince(retEvent) > 0 and ta.barssince(retEvent) <= input_retValid and retConditions and not retOccurred

        if retValid
            label.new(bar_index - retSince, y2[retSince], text = input_labelType == 'Simple' ? 'Re' : 'Retest', color = color.new(col, 50), style = style, textcolor = input_override ? input_textColor : col, size = input_labelSize)
            retOccurred := true

        if retValid or ta.barssince(retEvent) > input_retValid
            label.delete(array.first(retLabel))

        if pType == 'ph' and ta.change(ph) and retOccurred
            box.set_right(rBox[1], bar_index - retSince)
            retOccurred := na

        if pType == 'pl' and ta.change(pl) and retOccurred
            box.set_right(sBox[1], bar_index - retSince)
            retOccurred := na
        [retValid, retEvent, retValue]

[rRetValid, rRetEvent] = retestEvent(r1, r2, r3, r4, high, low, input_phColor, label.style_label_upper_left, 'ph')
[sRetValid, sRetEvent] = retestEvent(s1, s2, s3, s4, low, high, input_plColor, label.style_label_lower_left, 'pl')

// Conditions for buy and sell
buy_condition = ((ta.barssince(na(rBreak)) == 1 or rRetValid) and (trade_direction == "Long Only" or trade_direction == "Both"))
sell_condition = ((ta.barssince(na(sBreak)) == 1 or sRetValid) and (trade_direction == "Short Only" or trade_direction == "Both"))

// Variables for trailing stop logic
var bool trailing_stop_active = false
var float stop_loss_price = na
var float highest_price_since_trailing = na
var float lowest_price_since_trailing = na

// Entry strategy
if (buy_condition and strategy.position_size == 0)
    strategy.entry("Buy", strategy.long)
if (sell_condition and strategy.position_size == 0)
    strategy.entry("Sell", strategy.short)


// Stop loss and trailing stop logic
if (strategy.position_size > 0)  // If a long position is open
    // Calculate profit percent
    profit_percent = ((close - strategy.position_avg_price) / strategy.position_avg_price) * 100

    // Activate trailing stop if profit threshold is reached
    if not trailing_stop_active and profit_percent >= profit_threshold_percent
        trailing_stop_active := true
        highest_price_since_trailing := close

    // Update highest price and adjust stop loss
    if trailing_stop_active
        highest_price_since_trailing := math.max(highest_price_since_trailing, close)
        stop_loss_price := highest_price_since_trailing * (1 - trailing_stop_gap_percent / 100)
    else
        // Initial stop loss before trailing stop is activated
        stop_loss_price := strategy.position_avg_price * (1 - stop_loss_percent / 100)

    // Exit for long positions
    strategy.exit("Exit Long", from_entry="Buy", stop=stop_loss_price)

else if (strategy.position_size < 0)  // If a short position is open
    // Calculate profit percent
    profit_percent = ((strategy.position_avg_price - close) / strategy.position_avg_price) * 100

    // Activate trailing stop if profit threshold is reached
    if not trailing_stop_active and profit_percent >= profit_threshold_percent
        trailing_stop_active := true
        lowest_price_since_trailing := close

    // Update lowest price and adjust stop loss
    if trailing_stop_active
        lowest_price_since_trailing := math.min(lowest_price_since_trailing, close)
        stop_loss_price := lowest_price_since_trailing * (1 + trailing_stop_gap_percent / 100)
    else
        // Initial stop loss before trailing stop is activated
        stop_loss_price := strategy.position_avg_price * (1 + stop_loss_percent / 100)

    // Exit for short positions
    strategy.exit("Exit Short", from_entry="Sell", stop=stop_loss_price)

else  // No position
    // Reset variables when not in a position
    trailing_stop_active := false
    highest_price_since_trailing := na
    lowest_price_since_trailing := na

// --- Plot Stop Loss Level ---
plot(not na(stop_loss_price) ? stop_loss_price : na, title="Stop Loss", color=color.red, linewidth=2, style=plot.style_line)


//-----------------------------------------------------------------------------
// Alerts
//-----------------------------------------------------------------------------
alertcondition(ta.change(pl), 'New Support Level')
alertcondition(ta.change(ph), 'New Resistance Level')
alertcondition(ta.barssince(na(sBreak)) == 1, 'Support Breakout')
alertcondition(ta.barssince(na(rBreak)) == 1, 'Resistance Breakout')
alertcondition(sRetValid, 'Support Retest')
alertcondition(sRetEvent, 'Potential Support Retest')
alertcondition(rRetValid, 'Resistance Retest')
alertcondition(rRetEvent, 'Potential Resistance Retest')

AllAlerts(condition, message) =>
    if condition
        alert(message)

AllAlerts(ta.change(pl), 'New Support Level')
AllAlerts(ta.change(ph), 'New Resistance Level')
AllAlerts(ta.barssince(na(sBreak)) == 1, 'Support Breakout')
AllAlerts(ta.barssince(na(rBreak)) == 1, 'Resistance Breakout')
AllAlerts(sRetValid, 'Support Retest')
AllAlerts(sRetEvent, 'Potential Support Retest')
AllAlerts(rRetValid, 'Resistance Retest')
AllAlerts(rRetEvent, 'Potential Resistance Retest')


// Daily P&L Performance Script
show_performance = input.bool(true, 'Show Daily Performance ?', group='Daily Performance')

dash_loc_mp = input.string("Bottom Right", "Location", options=["Top Right", "Bottom Right", "Top Left", "Bottom Left", "Middle Right", "Bottom Center"], group='Daily Performance', inline="performance")

text_size_mp = input.string('Small', "Size", options=["Tiny", "Small", "Normal", "Large"], group='Daily Performance', inline="performance")

bg_c = input.color(color.new(color.rgb(7, 226, 242), 38), "Background Color", group='Daily Performance')

text_head_color = input.color(color.rgb(0, 0, 0), "Heading Color", group='Daily Performance')

tab_text_c = input.color(color.white, "Data Text Color", group='Daily Performance')

border_c = input.color(color.white, "Table Border Color", group='Daily Performance')

// Table settings
var table_position_mp = dash_loc_mp == 'Top Left' ? position.top_left :
     dash_loc_mp == 'Bottom Left' ? position.bottom_left :
     dash_loc_mp == 'Middle Right' ? position.middle_right :
     dash_loc_mp == 'Bottom Center' ? position.bottom_center :
     dash_loc_mp == 'Top Right' ? position.top_right : position.bottom_right

var table_text_size_mp = text_size_mp == 'Tiny' ? size.tiny :
     text_size_mp == 'Small' ? size.small :
     text_size_mp == 'Normal' ? size.normal : size.large

// Initialize variables
new_day = ta.change(dayofmonth(time)) or ta.change(month(time)) or ta.change(year(time))
newest_day = new_day and strategy.closedtrades >= 1

only_profit = strategy.netprofit
initial_balance = strategy.initial_capital

// Arrays to store daily P&L and corresponding dates
var float net_profit_start_of_day = strategy.initial_capital
var float[] daily_pnl_array = array.new_float()
var int[] day_time_array = array.new_int()

if new_day and barstate.isconfirmed
    prev_day_pnl = only_profit - net_profit_start_of_day
    array.push(daily_pnl_array, prev_day_pnl)

    // Correctly capturing the date using day, month, and year functions
    curr_day = dayofmonth(time)
    curr_month = month(time)
    curr_year = year(time)
    correct_timestamp = timestamp(curr_year, curr_month, curr_day, 0, 0)
    array.push(day_time_array, correct_timestamp)

    net_profit_start_of_day := only_profit

// Current day's P&L
curr_d_pnl = only_profit - net_profit_start_of_day

// Table creation
var int N = 30  // Number of days to display
var table testTable = table.new(position=table_position_mp, columns=N + 1, rows=4, bgcolor=bg_c, border_color=border_c, border_width=1)

if barstate.islastconfirmedhistory and show_performance
    // Set table headers (first row)
    table.cell(table_id=testTable, column=0, row=0, text="Date", text_color=text_head_color, text_size=table_text_size_mp)
    table.cell(table_id=testTable, column=0, row=1, text="P&L", text_color=text_head_color, text_size=table_text_size_mp)
    table.cell(table_id=testTable, column=0, row=2, text="P&L %", text_color=text_head_color, text_size=table_text_size_mp)
    table.cell(table_id=testTable, column=0, row=3, text="Total P&L", text_color=text_head_color, text_size=table_text_size_mp)

    // Loop over the daily P&L data in reverse
    int num_days = array.size(daily_pnl_array)
    int column_counter = 1
    float total_pnl = 0.0
    for i = 0 to math.min(N - 1, num_days - 1)
        if column_counter < N + 1  // Ensure the column does not exceed table bounds
            int index = num_days - 1 - i  // Access elements from the end
            float daily_pnl = array.get(daily_pnl_array, index)
            total_pnl += daily_pnl
            int date_time = array.get(day_time_array, index)
            string date_str = str.format("{0,date,yyyy-MM-dd}", date_time)
            string pnl_str = str.tostring(daily_pnl, "#.##")
            string pnl_pct_str = str.tostring(daily_pnl * 100 / initial_balance, "#.##") + " %"
            color bgcolor = daily_pnl > 0 ? color.new(color.green, 0) : daily_pnl < 0 ? color.new(color.red, 0) : color.new(color.gray, 0)

            // Fill in the table cells horizontally
            table.cell(table_id=testTable, column=column_counter, row=0, text=date_str, text_color=tab_text_c, text_size=table_text_size_mp)
            table.cell(table_id=testTable, column=column_counter, row=1, text=pnl_str, text_color=tab_text_c, bgcolor=bgcolor, text_size=table_text_size_mp)
            table.cell(table_id=testTable, column=column_counter, row=2, text=pnl_pct_str, text_color=tab_text_c, text_size=table_text_size_mp)
            column_counter += 1

    // Add current day's data only if column_counter is within bounds
    if column_counter < N + 1
        float daily_pnl = curr_d_pnl
        total_pnl += daily_pnl
        curr_day = dayofmonth(time)
        curr_month = month(time)
        curr_year = year(time)
        correct_timestamp = timestamp(curr_year, curr_month, curr_day, 0, 0)
        string date_str = str.format("{0,date,yyyy-MM-dd}", correct_timestamp)
        string pnl_str = str.tostring(daily_pnl, "#.##")
        string pnl_pct_str = str.tostring(daily_pnl * 100 / initial_balance, "#.##") + " %"
        color bgcolor = daily_pnl > 0 ? color.new(color.green, 0) : daily_pnl < 0 ? color.new(color.red, 0) : color.new(color.gray, 0)

        // Fill in the table cells horizontally
        table.cell(table_id=testTable, column=column_counter, row=0, text=date_str, text_color=tab_text_c, text_size=table_text_size_mp)
        table.cell(table_id=testTable, column=column_counter, row=1, text=pnl_str, text_color=tab_text_c, bgcolor=bgcolor, text_size=table_text_size_mp)
        table.cell(table_id=testTable, column=column_counter, row=2, text=pnl_pct_str, text_color=tab_text_c, text_size=table_text_size_mp)

    // Display total P&L
    string total_pnl_str = str.tostring(total_pnl, "#.##")
    table.cell(table_id=testTable, column=1, row=3, text=total_pnl_str, text_color=tab_text_c, text_size=table_text_size_mp)


// DATA WINDOW
var T_dataWindow = table.new(position.top_right, 2, 13, color.rgb(255, 255, 255, 55), border_width = 1)
if barstate.islast or barstate.islastconfirmedhistory
    table.cell(T_dataWindow, 0, 0, 'Info', text_size = size.auto, text_color = color.white, bgcolor = color.gray, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 1, 'Initial Capital', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 2, 'Equity', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 3, 'Net Profit', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 4, 'Open Profit', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 5, 'Gross Profit', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 6, 'Gross Loss', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 7, 'Open Trades', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 8, 'Closed Trades', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 9, 'Winning Trades', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 10, 'Losing Trades', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 0, 11, 'Break Even Trades', text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)


    table.cell(T_dataWindow, 1, 0, 'Value', text_size = size.auto, text_color = color.white, bgcolor = color.gray, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 1, str.tostring(strategy.initial_capital, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 2, str.tostring(strategy.equity, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 3, str.tostring(strategy.netprofit, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 4, str.tostring(strategy.openprofit, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 5, str.tostring(strategy.grossprofit, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 6, str.tostring(strategy.grossloss, '#.##'), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 7, str.tostring(strategy.opentrades), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 8, str.tostring(strategy.closedtrades), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 9, str.tostring(strategy.wintrades), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 10, str.tostring(strategy.losstrades), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)
    table.cell(T_dataWindow, 1, 11, str.tostring(strategy.eventrades), text_size = size.auto, text_color = color.white, bgcolor = color.black, text_halign = text.align_left)