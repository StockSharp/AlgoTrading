// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © palitoj_endthen

// Indicator/Strategy        : Trend Cycle Switch - Linear Regression Slope
// Author/Maintainer        : palitoj_endthen
// Language                    : TradingView's Pine Script™ v5
// Status                    : Version 1.00


//@version=5
strategy(title = 'strategy test - trend switch slope'
         , shorttitle = 'trend_switch'
         , overlay = true
         , calc_on_every_tick = true
         , initial_capital = 10000
         , currency = currency.USDT
         , commission_type = strategy.commission.percent
         , commission_value = .1
         , pyramiding = 0
         , slippage = 2
         , margin_long = 10
         , margin_short = 10
         , calc_on_every_tick = true
         , calc_on_order_fills = false
         )



// Input
src = input.source(defval = ohlc4, title = "Source", group = 'Options', tooltip = 'Choose source of input data default to ohlc4')
length = input.int(defval = 10, title = 'Length', group = 'Options', tooltip = 'Determines lookback period to compute linear regression slope, default to 10')
threshold = input.int(defval = 10, title = 'Threshold', group = 'Options', minval = 1, maxval = 100, step = 1, tooltip = '')
fast_limit = input.float(defval = .5, title = 'Fast Limit', group = 'Options', tooltip = 'MESA Adaptive moving average fast limit')
slow_limit = input.float(defval = .05, title = 'Slow Limit', group = 'Options', tooltip = 'MESA adaptive moving average slow limit')
percent_sl = input.float(defval = 3, title = 'Stop Loss', group = 'Options', tooltip = 'Determines the stop-loss percentage')
_strategy = input.string(defval = 'Long-Short', title = 'Strategy Direction', group = 'Options', options = ['Long-Short', 'Long', 'Short'], tooltip = 'Determines whether to apply Long/Short only strategy, or both directions')
show_pma = input.bool(defval = true, title = 'Show PMA', group = 'Toogle',  tooltip = 'Determines whether to display predictive moving average', inline = 'f')
show_mama = input.bool(defval = true, title = 'Show MAMA', group = 'Toogle', tooltip = 'Determines whether to display MESA adaptive moving average', inline = 'f')

// Backtest input
from_day   = input.int(defval = 1,    title = "From Day", group = 'Backtest Period')
from_month = input.int(defval = 1,  title = "From Month", group = 'Backtest Period')
from_year  = input.int(defval = 2022, title = "From Year", group = 'Backtest Period')
to_day = input.int(defval = 1, title = 'To Day', group = 'Backtest Period')
to_month   = input.int(defval = 1, title = 'To Month', group = 'Backtest Period')
to_year  = input.int(defval = 2112, title = "To Year", group = 'Backtest Period')

_start_date = timestamp(from_year, from_month, from_day, 00, 00)
_end_date = timestamp(to_year, to_month, to_day, 23, 59)
window()=>
    time >= _start_date and time <= _end_date ? true : false


// Compute linear regression slope
// linear regression slope assume can identify strong of the trend,
// not limited to its direction, if trend is strong will have a greater value if compare to ranging market,
// by determining if the slope value within a threshold assume there is no clear direction/strong trend identified,
// and if it above or below the threshold assume there is a clear direction/strong trend identified
calc_slope(float _src, int _length) =>
    sum_x = .00
    sum_y = .00
    sum_x_sqr = .00
    sum_xy = .00
    _slope = .00
    for i = 0 to _length - 1 by 1
        val = _src[i]
        per = i + 1.0
        sum_x += per
        sum_y += val
        sum_x_sqr += per * per
        sum_xy += val * per
        _slope := (_length * sum_xy - sum_x * sum_y) / (_length * sum_x_sqr - sum_x * sum_x)
        _slope*-1

slope = calc_slope(src, length)
slope_highest = ta.max(slope)
slope_lowest = ta.min(slope)
_range = slope_highest-slope_lowest
threshold_up = _range/threshold
threshold_down = threshold_up*-1


// Compute Ehlers - MESA adaptive moving average
// if mama > fama consider to indication of an uptrend and given a buy/long signal
// otherwise an indication of a downtrend, given sell/short signal
// use as a relatively longer trend period
// variable
sp = 0.00
dt = 0.00
q1 = 0.00
i1 = 0.00
jI = 0.00
jq = 0.00
i2_ = 0.00
q2 = 0.00
i2 = 0.00
q2_ = 0.00
re_ = 0.00
im_ = 0.00
re = 0.00
im = 0.00
p1 = 0.00
p2 = 0.00
p3 = 0.00
p = 0.00
spp = 0.00
phase = 0.00
dphase_ = 0.00
dphase = 0.00
alpha_ = 0.00
alpha = 0.00
mama = 0.00
fama = 0.00

sp := (4*src + 3*src[1] + 2*src[2] + src[3]) / 10.0
dt := (.0962*sp + .5769*nz(sp[2]) - .5769*nz(sp[4])- .0962*nz(sp[6]))*(.075*nz(p[1]) + .54)
q1 := (.0962*dt + .5769*nz(dt[2]) - .5769*nz(dt[4])- .0962*nz(dt[6]))*(.075*nz(p[1]) + .54)
i1 := nz(dt[3])
jI := (.0962*i1 + .5769*nz(i1[2]) - .5769*nz(i1[4])- .0962*nz(i1[6]))*(.075*nz(p[1]) + .54)
jq := (.0962*q1 + .5769*nz(q1[2]) - .5769*nz(q1[4])- .0962*nz(q1[6]))*(.075*nz(p[1]) + .54)
i2_ := i1 - jq
q2_ := q1 + jI
i2 := .2*i2_ + .8*nz(i2[1])
q2 := .2*q2_ + .8*nz(q2[1])
re_ := i2*nz(i2[1]) + q2*nz(q2[1])
im_ := i2*nz(q2[1]) - q2*nz(i2[1])
re := .2*re_ + .8*nz(re[1])
im := .2*im_ + .8*nz(im[1])

p1 := im != 0 and re != 0 ? 360/math.atan(im/re) : nz(p[1])
p2 := p1 > 1.5*nz(p1[1]) ? 1.5*nz(p1[1]) : p1 < 0.67*nz(p1[1]) ? .67*nz(p1[1]) : p1
p3 := p2 < 6 ? 6 : p2 > 50 ? 50 : p2
p := .2*p3 + .8*nz(p3[1])
spp := .33*p + .67*nz(spp[1])

phase := math.atan(q1 / i1)
dphase_ := nz(phase[1]) - phase
dphase := dphase_ < 1 ? 1 : dphase_
alpha_ := fast_limit/dphase
alpha := alpha_ < slow_limit ? slow_limit : alpha_ > fast_limit ? fast_limit : alpha_

mama := alpha*src+(1-alpha)*nz(mama[1])
fama := .5*alpha*mama+(1-.5*alpha)*nz(fama[1])


// Compute Ehlers - Predictive moving average
// a short period of weighted moving average crossing
// if predict > trigger given a buy signal while predict < trigger given a sell signal
// use as a relatively shorter trend period
wma1 = 0.00
wma2 = 0.00
predict = 0.00
trigger = 0.00

wma1 := (7*src+6*src[1]+5*src[2]+4*src[3]+3*src[4]+2*src[5]+src[6])/28
wma2 := (7*wma1+6*wma1[1]+5*wma1[2]+4*wma1[3]+3*wma1[4]+2*wma1[5]+wma1[6])/28
predict := (2*wma1)-wma2
trigger := (4*predict+3*predict[1]+2*predict[2]+predict)/10
_series = predict > trigger ? predict : trigger


// visualize
// display on user preferences of the shorter/longer trend
color_con_mama = mama > fama ? color.green : color.red
_color_con_mama = mama > fama

color_con_pma = predict > trigger ? color.blue : color.purple
_color_con_pma = predict > trigger

plot(show_mama ? mama : na, title = 'mama', color = color.red, linewidth = 1)
plot(show_mama ? fama : na, title = 'fama', color = color.green, linewidth = 1)
plot(show_pma ? _series : na, color = color_con_pma, style = plot.style_line, linewidth = 3)


// strategy test
// applied strategy backtest on user time window preferences
// could be applied to long/short only strategy, or combination to long-short strategy
bool long_condition = na
bool short_condition = na

if (slope >= threshold_down and slope <= threshold_up)
    long_condition := _color_con_pma and window()
    short_condition := not _color_con_pma and window()
else
    long_condition := _color_con_mama and window()
    short_condition := not _color_con_mama and window()

// long stop-loss
long_sl = 0.00
long_sl := long_condition ? src*(1-percent_sl/100) : nz(long_sl[1])

// long take profit
// long_tp = 0.00
// long_tp := long_condition ? src*(1+percent_sl/100) : nz(long_tp[1])

// short stop loss
short_sl = 0.00
short_sl := short_condition ? src*(1+percent_sl/100) : nz(short_sl[1])

// short take profit
// short_tp = 0.00
// short_tp := short_condition ? src*(1-percent_sl/100) : nz(short_tp[1])

if _strategy == 'Long'
    if long_condition
        strategy.entry(id = 'long', direction = strategy.long)
    if short_condition
        strategy.exit(id = 'exit-long', from_entry = 'long', stop = long_sl)
if _strategy == 'Short'
    if short_condition
        strategy.entry(id = 'short', direction = strategy.short)
    if long_condition
        strategy.exit(id = 'exit-short', from_entry = 'short', stop = short_sl)
if _strategy == 'Long-Short'
    if long_condition
        strategy.entry(id = 'long', direction = strategy.long)
    if short_condition
        strategy.entry(id = 'Short', direction = strategy.short)