// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © aybarsm

//@version=6
strategy("Trend Trader-Remastered Strategy", shorttitle = 'TTR-Strategy', overlay=true, process_orders_on_close = true, calc_on_every_tick = true, default_qty_type = strategy.percent_of_equity, initial_capital = 10000, default_qty_value = 10, currency = currency.USD, commission_value = 0.05, commission_type = strategy.commission.percent)
import aybarsm/ToolsFluent/6 as ToolsFluent
import aybarsm/ToolsPos/10 as ToolsPos
import aybarsm/tac/21 as Tac

// Inputs
string posDir = input.string(title = 'Direction', defval = 'Buy & Sell', options = ['Buy & Sell', 'Buy Only', 'Sell Only'], group = 'Position', inline = 'position')
bool showEntryBuy = input.bool(title = 'Buy: Entry', defval = true, group = 'Show Signals', inline = 'signalsBuy')
bool showTpBuy = input.bool(title = 'Buy: TP', defval = true, group = 'Show Signals', inline = 'signalsBuy')
bool showReBuy = input.bool(title = 'Buy: RE', defval = true, group = 'Show Signals', inline = 'signalsBuy')
bool showExitBuy = input.bool(title = 'Buy: Exit', defval = false, group = 'Show Signals', inline = 'signalsBuy')
bool showEntrySell = input.bool(title = 'Sell: Entry', defval = true, group = 'Show Signals', inline = 'signalsSell')
bool showTpSell = input.bool(title = 'Sell: TP', defval = true, group = 'Show Signals', inline = 'signalsSell')
bool showReSell = input.bool(title = 'Sell: RE', defval = true, group = 'Show Signals', inline = 'signalsSell')
bool showExitSell = input.bool(title = 'Sell: Exit', defval = false, group = 'Show Signals', inline = 'signalsSell')
float psarStart = input.float(title = 'Start', minval = 0.001, defval = 0.02, group = 'PSAR', inline = 'psar')
float psarIncrement = input.float(title = 'Inc', minval = 0.001, defval = 0.02, group = 'PSAR', inline = 'psar')
float psarMax = input.float(title = 'Max', minval = 0.0001, defval = 0.025, group = 'PSAR', inline = 'psar')
float fracSrcHigh = input.source(title = 'High Source', defval = high, group = 'BW Fractals', tooltip = 'Important: This setting affects take profit and re-entry signals. It determines the source of high mark BW fractals.')
float fracSrcLow = input.source(title = 'Low Source', defval = low, group = 'BW Fractals', tooltip = 'Important: This setting affects take profit and re-entry signals. It determines the source of high mark BW fractals.')
int fracLbHigh = input.int(title = 'High Lookback', defval = 2, group = 'BW Fractals', tooltip = 'Important: This setting affects take profit and re-entry signals. It determines the amount of lookback higher high BW fractals breakout.')
int fracLbLow = input.int(title = 'Low Lookback', defval = 2, group = 'BW Fractals', tooltip = 'Important: This setting affects take profit and re-entry signals. It determines the amount of lookback lower low BW fractals breakout.')
float sigReMinProximity = input.float(defval = 0, minval = 0, step = 0.01, maxval = 99.99, title = 'Minimum Re-Entry Proximity Ratio', group = 'Signal Fine-Tuning: Re Proximity', tooltip = 'Important: This setting affects re-entry signals. Minimum required proximity ratio to PSAR for re-entry signal')
bool sigReBuyNoTp = input.bool(title = 'For Buy', defval = false, group = 'Signal Fine-Tuning: Allow Re-Entry Without TP', inline = 'AllowReNoTp', tooltip = 'Important: This setting affects re-entry signals. It allows BUY re-entry signals even if there hasn\'t been a take profit signal. (This setting does not affect minimum required proximity setting.)')
bool sigReSellNoTp = input.bool(title = 'For Sell', defval = false, group = 'Signal Fine-Tuning: Allow Re-Entry Without TP', inline = 'AllowReNoTp', tooltip = 'Important: This setting affects re-entry signals. It allows SELL re-entry signals even if there hasn\'t been a take profit signal. (This setting does not affect minimum required proximity setting.)')

bool showPsar = input.bool(title = 'PSAR', defval = false, group = 'Show Informative', inline = 'informative')
bool showPsarLagging = input.bool(title = 'Lagging PSAR', defval = true, group = 'Show Informative', inline = 'informative')
bool showStrategyAvgPrice = input.bool(title = 'Strategy Avg Price', defval = false, group = 'Show Informative', inline = 'informative')

int sFrom = input.time(title="From", defval=timestamp("01 Jan 2000 00:00"), group = 'Strategy')
int sTo = input.time(title="To", defval=timestamp("31 Dec 2050 23:59"), group = 'Strategy')

float tpReductionRate = input.float(title = 'TP Reduce', minval = 0.00, defval = 10, maxval = 100, group = 'Strategy', tooltip = 'The percentage of progressive reduction on active position size for take profit signals.\n\nExample:\nTP Reduce: 10%\nEntry Position Size: 100\nTP1: 100-10=90\nTP2: 90-9=81')
float reWhenRate = input.float(title = 'RE When', minval = 0.00, defval = 50, maxval = 100, group = 'Strategy', tooltip = 'The percentage of position size on initial entry of the signal to determine re-entry.\n\nExample:\nRE When: 50%\nEntry Position Size: 100\nRe-Entry Condition: Active Position Size < 50')
float reFillRate = input.float(title = 'RE Fill', minval = 0.00, defval = 75, maxval = 100, group = 'Strategy', inline = 'signal', tooltip = 'The percentage of position size on initial entry of the signal to be completed.\n\nExample:\nRE Fill: 75%\nEntry Position Size: 100\nActive Position Size: 50\nRe Order Size: 25\nFinal Active Position Size:75\n\nImportant: Even RE When condition is met, the active position size required to drop below RE Fill rate to trigger re-entry order.')

// One-time Variables
var ToolsPos.PosInfo pos = ToolsPos.PosInfo.new()
var Tac.BWFractals fracs = Tac.BWFractals.new()
var array<int> marksTP = na
var array<int> marksRE = na

// Each bar Variables
[psar, psar_lagging, psar_fast] = Tac.sar(psarStart, psarIncrement,  psarMax)
float psarProximity = math.round(math.abs(close - psar_lagging) / psar_lagging * 100, 2)
bool psarCrossHigh = ta.crossover(high, psar_lagging)
bool psarCrossLow = ta.crossunder(low, psar_lagging)
int psarLagCross = psar_lagging[1] > high[1] and psarCrossHigh ? 1 : (psar_lagging[1] < low[1] and psarCrossLow ? -1 : 0)
Tac.BWFractal posActionFrac = na
bool posAllowBuy = posDir == 'Buy & Sell' or posDir == 'Buy Only'
bool posAllowSell = posDir == 'Buy & Sell' or posDir == 'Sell Only'
string posEnter = posAllowBuy and psarLagCross == 1 ? 'buy' : (posAllowSell and psarLagCross == -1 ? 'sell' : na)
string posExit = not na(pos.state) and pos.state == ToolsPos.PosState.buy and psarLagCross == -1 ? 'buy' : (not na(pos.state) and pos.state == ToolsPos.PosState.sell and psarLagCross == 1 ? 'sell' : na)
string posSide = na(posEnter) and na(posExit) and not na(pos.state) ? (pos.state == ToolsPos.PosState.buy ? 'buy' : 'sell') : na
string posTP = na
string posRE = na
ToolsPos.PosActionType posAction = na
ToolsPos.PosAction posLastTP = na
ToolsPos.PosAction posLastRE = na
bool upBoEligible = close[1] > open[1] and close <= open
bool downBoEligible = close[1] < open[1] and close >= open

if not na(posExit)
    pos.exit()
    marksTP := na
    marksRE := na

if not na(posEnter)
    pos.enter(posEnter == 'buy' ? ToolsPos.PosState.buy : ToolsPos.PosState.sell, psar_lagging)
    marksTP := array.new<int>()
    marksRE := array.new<int>()

// Eval Fractals
fracs.eval(fracSrcHigh, fracSrcLow, fracLbHigh, fracLbLow, not na(pos.when) ? pos.when : time, not na(pos.when) ? pos.when : time)

if not na(posSide)
    posLastTP := array.size(pos.tp) > 0 ? array.last(pos.tp) : na
    posLastRE := array.size(pos.re) > 0 ? array.last(pos.re) : na

    if array.size(fracs.hh) > 0 and upBoEligible and (posSide == 'buy' or (posSide == 'sell' and (sigReSellNoTp or not na(posLastTP))))
        int fracHHFrom = math.max(0, array.size(fracs.hh) - fracLbHigh)
        int fracHHTo = array.size(fracs.hh) - 1
        for i = fracHHFrom to fracHHTo by 1
            Tac.BWFractal fracHH = fracs.hh.get(i)
            if na(fracHH.boPrice) or fracHH.boTime < pos.when
                continue

            posTP := posSide == 'buy' and close > pos.price and marksTP.binary_search(fracHH.when) == -1 and (na(posLastTP) or close > posLastTP.price) ? 'buy' : na
            posRE := posSide == 'sell' and psarProximity > sigReMinProximity and marksRE.binary_search(fracHH.when) == -1 and (not na(posLastTP) or sigReSellNoTp) and (na(posLastRE) or close > posLastRE.price) ? 'sell' : na
            if posTP == 'buy' or posRE == 'sell'
                posActionFrac := fracHH
                break

    if array.size(fracs.ll) > 0 and downBoEligible and (posSide == 'sell' or (posSide == 'buy' and (sigReBuyNoTp or not na(posLastTP))))
        int fracLLFrom = math.max(0, array.size(fracs.ll) - fracLbLow)
        int fracLLTo = array.size(fracs.ll) - 1
        for i = fracLLFrom to fracLLTo by 1
            Tac.BWFractal fracLL = array.get(fracs.ll, i)
            if na(fracLL.boPrice) or fracLL.boTime < pos.when
                continue

            posTP := posSide == 'sell' and close < pos.price and marksTP.binary_search(fracLL.when) == -1 and (na(posLastTP) or close < posLastTP.price) ? 'sell' : na
            posRE := posSide == 'buy' and psarProximity > sigReMinProximity and marksRE.binary_search(fracLL.when) == -1 and (not na(posLastTP) or sigReSellNoTp) and (na(posLastRE) or close < posLastRE.price) ? 'buy' : na
            if posTP == 'sell' or posRE == 'buy'
                posActionFrac := fracLL
                break

if not na(posTP) or not na(posRE)
    posAction := na(posTP) ? ToolsPos.PosActionType.re : ToolsPos.PosActionType.tp
    pos.action(posAction, close, time, bar_index, posActionFrac.price, posActionFrac.when, posActionFrac.index)

    if posAction == ToolsPos.PosActionType.tp
        marksTP.push(posActionFrac.when)

    if posAction == ToolsPos.PosActionType.re
        marksRE.push(posActionFrac.when)

// Strategy One-time Variables
var float sInitSize = na
var string sInitId = na
var string sExitId = na
var float sReTrigger = na

// Strategy each-bar variables & settings
bool isInTimeRange = time >= sFrom and time <= sTo
bool prepEnterBuy = isInTimeRange and psar_lagging[1] > high[1] and posAllowBuy
bool prepEnterSell = isInTimeRange and psar_lagging[1] < low[1] and posAllowSell
float sSize = math.abs(strategy.position_size)

if prepEnterBuy or prepEnterSell
    strategy.entry(prepEnterBuy ? 'Long' : 'Short', prepEnterBuy ? strategy.long : strategy.short, stop = psar_fast)

if strategy.opentrades > 0 and strategy.opentrades.entry_time(strategy.opentrades - 1) == time
    sInitSize := math.abs(strategy.position_size)
    sInitId := strategy.opentrades.entry_id(strategy.opentrades - 1)
    sExitId := sInitId == 'Long' ? 'Short' : 'Long'
    sReTrigger := reWhenRate > 0 and reFillRate > 0 ? (reWhenRate == 100 ? sInitSize : ((sInitSize / 100) * reWhenRate)) : na

if strategy.opentrades > 0 and barstate.isconfirmed
    if not na(posTP) and tpReductionRate > 0
        strategy.close(sInitId, comment = 'TP', qty = ((sSize / 100) * tpReductionRate), immediately = true)
    else if not na(posRE) and not na(sReTrigger) and sSize < sReTrigger and sSize < ((sInitSize / 100) * reFillRate)
        float sReQty = reFillRate == 100 ? sInitSize : ((sInitSize / 100) * reFillRate) - sSize
        strategy.order('RE-' + sInitId, comment = 'RE', direction = (sInitId == 'Long' ? strategy.long : strategy.short), stop = close, qty = sReQty)

if strategy.opentrades > 0 and strategy.opentrades.entry_time(strategy.opentrades - 1) < time and posDir != 'Buy & Sell'
    strategy.exit('Exit-' + sInitId, from_entry = sInitId, stop = psar_fast, qty = sSize)

plotshape(showEntryBuy and posEnter == 'buy', style = shape.labelup, location = location.belowbar, color = color.green, size = size.tiny, title = 'BUY', text = 'BUY', textcolor = color.white, force_overlay = true)
plotshape(showExitBuy and posExit == 'buy', style = shape.labelup, location = location.belowbar, color = color.green, size = size.tiny, title = 'EXIT BUY', text = 'EXIT BUY', textcolor = color.white, force_overlay = true)
plotshape(showTpBuy and posTP == 'buy', style = shape.labeldown, location = location.abovebar, color = color.teal, size = size.tiny, title = 'BUY TP', text = 'TP', textcolor = color.white, force_overlay = true)
plotshape(showReBuy and posRE == 'buy', style = shape.labelup, location = location.belowbar, color = color.olive, size = size.tiny, title = 'BUY RE', text = 'RE', textcolor = color.white, force_overlay = true)

plotshape(showEntrySell and posEnter == 'sell', style = shape.labeldown, location = location.abovebar, color = color.red, size = size.tiny, title = 'SELL', text = 'SELL', textcolor = color.white, force_overlay = true)
plotshape(showExitSell and posExit == 'sell', style = shape.labeldown, location = location.abovebar, color = color.red, size = size.tiny, title = 'EXIT SELL', text = 'EXIT SELL', textcolor = color.white, force_overlay = true)
plotshape(showTpSell and posTP == 'sell', style = shape.labelup, location = location.belowbar, color = color.maroon, size = size.tiny, title = 'SELL TP', text = 'TP', textcolor = color.white, force_overlay = true)
plotshape(showReSell and posRE == 'sell', style = shape.labeldown, location = location.abovebar, color = color.purple, size = size.tiny, title = 'SELL RE', text = 'RE', textcolor = color.white, force_overlay = true)

plot(showPsar ? psar : na, title = 'PSAR', style = plot.style_line, color = psar < low ? color.lime : color.red)
plot(showPsarLagging ? psar_lagging : na, title = 'Lagging PSAR', color = psar_lagging < low ? color.yellow : color.fuchsia, style = plot.style_line)
plot(showStrategyAvgPrice ? strategy.position_avg_price : na, title = 'Strategy Avg Price', color = color.white, style = plot.style_line)