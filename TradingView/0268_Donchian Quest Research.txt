//@version=5
strategy(title='Donchian Quest Research', overlay=true, pyramiding=0,
     initial_capital=1000, commission_type=strategy.commission.percent,
     commission_value=0.055, slippage=0)

// =============================================================================
// VARIABLES
// =============================================================================

donch_string_st = 'Number of candles for two channels:\nFirst channel for trades opening, second channel for trades closing.'
permit_stop_st = 'Using stoploss:\
 \n\n- No stop:\nNo stop.\
 \n\n- Fixed:\nSet stop one time and never change it.\
 \n\n- Breakeven:\nInitial stop = fixed stop. If profit > risk: move stop to entry price.\
 \n\n- Trailing:\nInitial stop = fixed stop. If profit > risk: move stop to entry price. If channel border cross entry price: move stop to channel border.'
orders_number_st = 'Use single order or divide it to several orders. If several orders - each order changes average entry price.'
use_add_orders_theory_st = 'If theory qty > position qty: \nUse additional orders to increase position size.\n Theory qty = calculated on every candle Close price.'
use_add_orders_cost_st = 'If cost usd < pnl usd: \nUse additional orders to increase position size.\nCost usd = size * entry price.'
permit_long_st = 'Direction of trading.'
permit_short_st = 'Direction of trading.'
risk_percent_st = 'Maximal stoploss for trade in percents of Equity.'
atr_mult_st = 'This multiplier moves stoploss up or down.\n\nBig multiplier = small size of order, small profit, stoploss far from entry, low chance of stoploss.\
 \n\nSmall multiplier = big size of order, big profit, stoploss near entry, high chance of stoploss.'
atr_len_st = 'Number of candles to calculate ATR indicator. It used for order size and stoploss.'
close_in_end_st = 'Close active trade in the end (and don`t trade anymore) or leave it open. You can see difference in Strategy Tester.'
show_info_label_st = 'Show informational label with calculations: ATR, order size, prices.'

donch_string = input.string(title= 'Length (open/close)', options = ['10/5', '10/10', '20/10', '20/20', '50/20', '50/50', '100/50', '100/100'], defval='50/50', tooltip = donch_string_st)
permit_stop  = input.string(title = 'Permit stoploss', options = ['No stop', 'Fixed', 'Breakeven', 'Trailing'], defval='No stop', tooltip = permit_stop_st)
orders_number  = input.int(title = 'Orders number', defval = 1, display = display.none, tooltip = orders_number_st)
use_add_orders_theory = input.bool(title = 'Additional theory orders ?', defval = false, tooltip = use_add_orders_theory_st)
use_add_orders_cost = input.bool(title = 'Additional cost orders?', defval = false, tooltip = use_add_orders_cost_st)
permit_long  = input.bool(title = 'Permit Long', defval = true, tooltip = permit_long_st)
permit_short  = input.bool(title = 'Permit Short', defval = true, tooltip = permit_short_st)
risk_percent = input.float(title = 'Risk % of Equity', defval = 0.5, step = 0.1, display = display.none, tooltip = risk_percent_st)
atr_mult = input.float(title ='ATR multiplier', defval = 2.0, step = 0.5, display = display.none, tooltip = atr_mult_st)
atr_len = input.int(title = 'ATR length', defval = 20, display = display.none, tooltip = atr_len_st)
close_in_end  = input.bool(title = 'Close in end', defval = false, tooltip = close_in_end_st)
show_info_label = input.bool(title = 'Show Info Label', defval = false, tooltip = show_info_label_st)
backtestStartDate = input.time(timestamp("1 Jan 2000"), title="Backtest Start Date")

// =============================================================================
// CALCULATIONS
// =============================================================================

donch_len_big =
 donch_string == '10/5' ? 10 :
 donch_string == '10/10' ? 10 :
 donch_string == '20/10' ? 20 :
 donch_string == '20/20' ? 20 :
 donch_string == '50/20' ? 50 :
 donch_string == '50/50' ? 50 :
 donch_string == '100/50' ? 100 :
 donch_string == '100/100' ? 100 :
 na
donch_len_small =
 donch_string == '10/5' ? 5 :
 donch_string == '10/10' ? 10 :
 donch_string == '20/10' ? 10 :
 donch_string == '20/20' ? 20 :
 donch_string == '50/20' ? 20 :
 donch_string == '50/50' ? 50 :
 donch_string == '100/50' ? 50 :
 donch_string == '100/100' ? 100 :
 na

big_maxclose = ta.highest(close, donch_len_big)
big_minclose = ta.lowest(close, donch_len_big)
small_maxclose = ta.highest(close, donch_len_small)
small_minclose = ta.lowest(close, donch_len_small)

atr_value = donch_len_big <= 10 ? ta.atr(10) : ta.atr(atr_len)

trade_window  = time <= timenow - (timeframe.in_seconds() * 1000 * 3)
permit_new_trades = not close_in_end or (close_in_end and trade_window)
backtest_window =  time >= backtestStartDate

// =============================================================================
// NOTOPEN QTY
// =============================================================================

risk_usd = (risk_percent / 100) * strategy.equity
atr_currency = atr_value * syminfo.pointvalue
qty = risk_usd / (atr_mult * atr_currency)

notopen_qty =
 str.contains(syminfo.description, 'Crypto Total') ? 0.001 :
 qty <= 0 ? 0 : // liquidation
 qty > 1000000000 ? 1000000000 : // maximal
 qty / orders_number

// =============================================================================
// LONG STOP
// =============================================================================

long_stop_price_fixed = 0.0
long_stop_price_fixed :=
 strategy.position_size > 0 and na(long_stop_price_fixed[1]) ? strategy.position_avg_price - atr_mult * atr_currency : // first
 strategy.position_size > 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price - atr_mult * atr_currency > long_stop_price_fixed[1] ? strategy.position_avg_price - atr_mult * atr_currency : // add order
 strategy.position_size > 0 ? long_stop_price_fixed[1] : // no changes
 na

long_stop_price_be = 0.0
long_stop_price_be :=
 strategy.position_size > 0 and na(long_stop_price_be[1]) ? strategy.position_avg_price - atr_mult * atr_currency : // first
 strategy.position_size > 0 and strategy.openprofit > risk_usd ? strategy.position_avg_price: // breakeven
 strategy.position_size > 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price - atr_mult * atr_currency > long_stop_price_be[1] ? strategy.position_avg_price - atr_mult * atr_currency : // add order
 strategy.position_size > 0 ? long_stop_price_be[1] : // no changes
 na

long_stop_price_trail = 0.0
long_stop_price_trail :=
 strategy.position_size > 0 and na(long_stop_price_trail[1]) ? strategy.position_avg_price - atr_mult * atr_currency : // first
 strategy.position_size > 0 and strategy.openprofit > risk_usd and long_stop_price_trail[1] < strategy.position_avg_price ? strategy.position_avg_price: // breakeven
 strategy.position_size > 0 and small_minclose > strategy.position_avg_price ? small_minclose : // trailing
 strategy.position_size > 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price - atr_mult * atr_currency > long_stop_price_trail[1] ? strategy.position_avg_price - atr_mult * atr_currency : // add order
 strategy.position_size > 0 ? long_stop_price_trail[1] : // no changes
 na

long_stop_price =
 permit_stop == 'Fixed' ? long_stop_price_fixed :
 permit_stop == 'Breakeven' ? long_stop_price_be :
 permit_stop == 'Trailing' ? long_stop_price_trail :
 na

// =============================================================================
// SHORT STOP
// =============================================================================

short_stop_price_fixed = 0.0
short_stop_price_fixed :=
 strategy.position_size < 0 and na(short_stop_price_fixed[1]) ? strategy.position_avg_price + atr_mult * atr_currency : // first
 strategy.position_size < 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price + atr_mult * atr_currency < short_stop_price_fixed[1]? strategy.position_avg_price + atr_mult * atr_currency : // add order
 strategy.position_size < 0 ? short_stop_price_fixed[1] : // no changes
 na

short_stop_price_be = 0.0
short_stop_price_be :=
 strategy.position_size < 0 and na(short_stop_price_be[1]) ? strategy.position_avg_price + atr_mult * atr_currency : // first
 strategy.position_size < 0 and strategy.openprofit > risk_usd ? strategy.position_avg_price : // breakeven
 strategy.position_size < 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price + atr_mult * atr_currency < short_stop_price_be[1]? strategy.position_avg_price + atr_mult * atr_currency : // add order
 strategy.position_size < 0 ? short_stop_price_be[1] : // no changes
 na

short_stop_price_trail = 0.0
short_stop_price_trail :=
 strategy.position_size < 0 and na(short_stop_price_trail[1]) ? strategy.position_avg_price + atr_mult * atr_currency : // first
 strategy.position_size < 0 and strategy.openprofit > risk_usd and short_stop_price_trail[1] > strategy.position_avg_price ? strategy.position_avg_price: // breakeven
 strategy.position_size < 0 and small_maxclose < strategy.position_avg_price ? small_maxclose : // trailing
 strategy.position_size < 0 and strategy.position_size != strategy.position_size[1] and strategy.position_avg_price + atr_mult * atr_currency < short_stop_price_trail[1]? strategy.position_avg_price + atr_mult * atr_currency : // add order
 strategy.position_size < 0 ? short_stop_price_trail[1] : // no changes
 na

short_stop_price =
 permit_stop == 'Fixed' ? short_stop_price_fixed :
 permit_stop == 'Breakeven' ? short_stop_price_be :
 permit_stop == 'Trailing' ? short_stop_price_trail :
 na

// =============================================================================
// PLOT VERTICAL COLOR BAR
// =============================================================================

cross_up = strategy.position_size <= 0 and close == big_maxclose and close >= syminfo.mintick and permit_long
cross_dn = strategy.position_size >= 0 and close == big_minclose and close >= syminfo.mintick and permit_short
bg_color = close_in_end and not trade_window ? color.gray : cross_up ? color.green : cross_dn ? color.red : na
bg_color := color.new(bg_color, 70)
bgcolor(bg_color)

// =============================================================================
// PLOT DONCHIAN LINES
// =============================================================================

s1 = big_maxclose
s2 = big_minclose
s3 = cross_up ? na : cross_dn ? na : strategy.position_size != 0 ? strategy.position_avg_price : na
s4 = cross_up ? na : cross_dn ? na : strategy.position_size > 0 ? small_minclose : strategy.position_size < 0 ? small_maxclose : na
s5 = cross_up ? na : cross_dn ? na : permit_stop == 'No stop' ? na : strategy.position_size > 0 ? long_stop_price : strategy.position_size < 0 ? short_stop_price : na

plot(series=s1, style=plot.style_linebr, color=color.black, linewidth=1, title='Donch Big Maxclose - Black')
plot(series=s2, style=plot.style_linebr, color=color.black, linewidth=1, title='Donch Big Minclose - Black')
plot(series=s3, style=plot.style_linebr, color=color.yellow, linewidth=2, title='Entry - Yellow')
plot(series=s4, style=plot.style_linebr, color=color.red, linewidth=1, title='Donch Small - Red')
plot(series=s5, style=plot.style_linebr, color=color.fuchsia, linewidth=2, title='Stop - Fuchsia')

// =============================================================================
// END LABEL
// =============================================================================

var label myLabel = label.new(bar_index, high, yloc= yloc.belowbar, style=label.style_label_up)

if not trade_window and close_in_end
    label.set_text(myLabel, text='Close in end\nBars on\nthe chart:\n' + str.tostring(bar_index + 2))
    label.set_x(myLabel, bar_index)

// =============================================================================
// INFO LABEL
// =============================================================================

if show_info_label
    var label info_label = na
    if cross_up or cross_dn
        txt = 'Info:\nEquity = ' + str.tostring(strategy.equity, '#.##') + '\nAtr = ' + str.tostring(atr_currency,  format.mintick) +
         '\nAtr/2 = ' + str.tostring(atr_currency/2,  format.mintick) + '\nQty = ' + str.tostring(notopen_qty, '#.######')
        for i = 1 to orders_number
            op =
             cross_up ? close + atr_value / 2 * (i - 1) :
             cross_dn ? close - atr_value / 2 * (i - 1) :
             na
            txt := txt + '\nOrder' + str.tostring(i) + ' = ' + str.tostring(op,  format.mintick)
        info_label := label.new(bar_index, cross_up ? high : low, txt, xloc.bar_index, yloc.price, color.silver, cross_up ? label.style_label_down : label.style_label_up,  color.black)

// =============================================================================
// CANCEL ALL IF WAS STOP
// =============================================================================

if strategy.position_size == 0
    strategy.cancel_all()

// =============================================================================
// EXIT CHANNEL
// =============================================================================

if strategy.position_size > 0 and close == small_minclose
    strategy.cancel_all()
    strategy.close_all('Close Long')

if strategy.position_size < 0 and close == small_maxclose
    strategy.cancel_all()
    strategy.close_all('Close Short')

// =============================================================================
// STOP ORDER
// =============================================================================

if strategy.position_size > 0 and permit_stop != 'No stop'
    strategy.exit(id='Stop Long', stop=long_stop_price)

if strategy.position_size < 0 and permit_stop != 'No stop'
    strategy.exit(id='Stop Short', stop=short_stop_price)

// =============================================================================
// CLOSE IN END
// =============================================================================

if close_in_end
    if not trade_window
        strategy.close_all('End')

// =============================================================================
// ENTRY ORDERS
// =============================================================================

if strategy.position_size <= 0 and close == big_maxclose and close >= syminfo.mintick and permit_new_trades and permit_long and backtest_window
    for i = 1 to orders_number
        st = 'Long' + str.tostring(i)
        op = close + atr_value / 2 * (i - 1)
        strategy.entry(st, strategy.long, qty=notopen_qty, stop=op)

if strategy.position_size >= 0 and close == big_minclose and close >= syminfo.mintick and permit_new_trades and permit_short and backtest_window
    for i = 1 to orders_number
        st = 'Short' + str.tostring(i)
        op = close - atr_value / 2 * (i - 1)
        strategy.entry(st, strategy.short, qty=notopen_qty, stop=op)

// =============================================================================
// ADDITIONAL ENTRY ORDERS - THEORY
// =============================================================================

if use_add_orders_theory

    diff_qty = 0.0
    min_order_usd = 10

    theory_qty = risk_usd / (atr_mult * atr_currency)
    diff_qty := theory_qty - math.abs(strategy.position_size)

    if strategy.openprofit > 0
        if strategy.opentrades >= orders_number
            if diff_qty * close >= min_order_usd

                if strategy.position_size > 0
                    strategy.order( 'Long', strategy.long, qty=diff_qty)

                if strategy.position_size < 0
                    strategy.order('Short', strategy.short, qty=diff_qty)

// =============================================================================
// ADDITIONAL ENTRY ORDERS - COST
// =============================================================================

if use_add_orders_cost

    max_cost_percent = risk_percent * 10
    diff_qty = 0.0
    min_order_usd = 10

    for i = 0.0 to max_cost_percent by 0.1

        usd_cost = math.abs(strategy.position_size) * strategy.position_avg_price
        usd_theory = strategy.equity / 100 * i
        usd_diff = usd_theory - usd_cost
        diff_qty := usd_diff / close

        if usd_cost < usd_theory
            if usd_theory < strategy.openprofit
                if usd_diff > min_order_usd

                    if strategy.position_size > 0
                        strategy.order( 'Cost', strategy.long, qty=diff_qty)

                    if strategy.position_size < 0
                        strategy.order('Cost', strategy.short, qty=diff_qty)

// =============================================================================
// END
// =============================================================================