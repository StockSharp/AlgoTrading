//@version=5
strategy("00 Averaging Down Backtest Strategy by RPAlawyer v21", overlay=true, max_bars_back=4900, calc_on_every_tick=false, initial_capital = 10000, margin_long=1000000, margin_short=1000000, default_qty_type=strategy.cash, default_qty_value=100)
strategy.risk.allow_entry_in(strategy.direction.all)

strategy.risk.max_position_size(1000000)

// External signal input
ext_source = input.source(close, "External Source", tooltip="Select your indicator as input source")

// ATR Filter settings
useAtrFilter = input.bool(true, "Use ATR Filter", tooltip="When ATR fitler is enabled, uses ATR-based bands to filter entry signals based on price volatility.")
atr_filter_length = input.int(40, "ATR Filter Length")
atr_filter_mult = input.float(8.0, "ATR Filter Multiplier")

// Core strategy parameters
tpPercent = input.float(3.0, "Take Profit %", step=0.1)
stepScale = input.float(1.5, "Step Scale Multiplier", step=0.1)
initialSize = input.float(100.0, "Initial Position Size")
dcaMultiplier = input.float(1.2, "DCA Size Multiplier")
maxDcaLevels = input.int(20, "Maximum DCA Levels", minval=1, maxval=95)

// ATR Settings for Bands
atr_length = input.int(40, "DCA ATR Length", minval=1)
atr_band_multiplier = input.float(8.0, "DCA ATR Band Multiplier", minval=0.1, step=0.1)

// EMA Settings
ema_length = input.int(200, "EMA Length", minval=1)
ema_value = ta.ema(close, ema_length)

// ATR calculations
atr = ta.atr(atr_filter_length)
entry_filter_upper_band = ema_value + (atr * atr_filter_mult)
entry_filter_lower_band = ema_value - (atr * atr_filter_mult)

// ATR Bands for DCA
dca_atr = ta.atr(atr_length)
dca_upper_band = ema_value + (dca_atr * atr_band_multiplier)
dca_lower_band = ema_value - (dca_atr * atr_band_multiplier)

// Base position statistics tracking
var float totalPnl = 0.0
var float largestPosition = 0.0
var float largestDrawdown = 0.0
var float largestUnrealizedNegativePnl = 0.0
var float currentTradeMaxDip = 0.0
var int maxDcaCount = 0
var int totalTrades = 0
var float totalDuration = 0.0
var int entryTime = 0

var float baseTradeId = 0.0  // Unique identifier for base trade
var bool inDcaMode = false   // Flag to track if we're in DCA mode

var float hedgeTradeId = 0.0  // Unique identifier for hedge trades
var bool isHedgeActive = false
var bool hedge_isOutsideAtrBands = false
var bool hedge_shouldTriggerDCA = false

// Hedge position statistics tracking
var float hedge_totalPnl = 0.0
var float hedge_largestPosition = 0.0
var float hedge_largestDrawdown = 0.0
var float hedge_largestUnrealizedNegativePnl = 0.0
var float hedge_currentTradeMaxDip = 0.0
var int hedge_maxDcaCount = 0
var int hedge_totalTrades = 0
var float hedge_totalDuration = 0.0
var int hedge_entryTime = 0

// Variables for step scale lines
var float baseStepScaleLine = na
var float hedgeStepScaleLine = na

// Variables for next DCA level plotting
var float nextBaseDcaLevel = na
var float nextHedgeDcaLevel = na

var float currentBaseTradeId = 0.0  // Add this with other var declarations

var float hedge_initialSize = 0.0  // Store the initial hedge size when hedge position opens

// Function to calculate time difference in hours
getTimeDiff(startTime) =>
    diff = time - startTime
    hours = math.floor(diff / (1000 * 60 * 60))
    minutes = math.floor((diff - (hours * 1000 * 60 * 60)) / (1000 * 60))
    [hours, minutes]

baseDeviation = input.float(3, "DCA Base Deviation %", step=0.1)

// Array to store DCA thresholds
var float[] dcaThresholds = array.new_float(0)

// Initialize fixed thresholds on first bar
if barstate.isfirst
    // First threshold is always baseDeviation
    array.push(dcaThresholds, baseDeviation)

    // Calculate remaining thresholds
    for i = 1 to maxDcaLevels - 1
        array.push(dcaThresholds, baseDeviation * math.pow(stepScale, i))

// Function to validate step scale for DCA entries
validateStepScale(float currentPrice, float firstEntry, float lastDcaLevel, int dcaLevel, int direction) =>
    float threshold = 0.0
    float lastActualDeviation = 0.0

    if dcaLevel == 0
        threshold := baseDeviation  // First DCA uses base deviation
    else
        // Calculate how far the last DCA actually happened from entry
        lastActualDeviation := direction == 1 ? (firstEntry - lastDcaLevel) / firstEntry * 100 : (lastDcaLevel - firstEntry) / firstEntry * 100

        // Next required move uses the actual last DCA point plus base*stepscale^level
        threshold := lastActualDeviation + (baseDeviation * math.pow(stepScale, dcaLevel))

    float movePercent = direction == 1 ? (firstEntry - currentPrice) / firstEntry * 100 : (currentPrice - firstEntry) / firstEntry * 100

    movePercent >= threshold

// Base position tracking
var float entryPrice = na
var float avgEntryPrice = na
var float totalPositionSize = 0.0
var float totalInvested = 0.0
var int dcaCount = 0
var float lastDcaLevel = 0.0
var int positionDir = 0
var float maxDrawdown = 0.0
var float baseDca1Size = 0.0  // Store DCA1 size for hedge entry
var bool allowHedgeEntry = false

// Hedge position tracking
var float hedge_entryPrice = na
var float hedge_avgEntryPrice = na
var float hedge_totalPositionSize = 0.0
var float hedge_totalInvested = 0.0
var int hedge_dcaCount = 0
var float hedge_lastDcaLevel = 0.0
var int hedge_positionDir = 0
var float hedge_maxDrawdown = 0.0

// Single summary table (created once at the start)
var table statsTable = table.new(position.top_right, 3, 13, bgcolor=color.new(color.white, 70))

if barstate.isfirst
    // Header row
    table.cell(statsTable, 0, 0, "Stats", text_color=color.black, bgcolor=color.new(color.white, 70))
    table.cell(statsTable, 1, 0, "Base", text_color=color.black, bgcolor=color.new(color.white, 70))
    table.cell(statsTable, 2, 0, "Hedge", text_color=color.black, bgcolor=color.new(color.white, 70))

    // Stats rows
    table.cell(statsTable, 0, 1, "Total TPs", text_color=color.black)
    table.cell(statsTable, 1, 1, "-", text_color=color.black)
    table.cell(statsTable, 2, 1, "-", text_color=color.black)

    table.cell(statsTable, 0, 2, "Total PNL", text_color=color.black)
    table.cell(statsTable, 1, 2, "-", text_color=color.black)
    table.cell(statsTable, 2, 2, "-", text_color=color.black)

    table.cell(statsTable, 0, 3, "Largest Position", text_color=color.black)
    table.cell(statsTable, 1, 3, "-", text_color=color.black)
    table.cell(statsTable, 2, 3, "-", text_color=color.black)

    table.cell(statsTable, 0, 4, "Largest Drawdown", text_color=color.black)
    table.cell(statsTable, 1, 4, "-", text_color=color.black)
    table.cell(statsTable, 2, 4, "-", text_color=color.black)

    table.cell(statsTable, 0, 5, "Largest Negative PNL", text_color=color.black)
    table.cell(statsTable, 1, 5, "-", text_color=color.black)
    table.cell(statsTable, 2, 5, "-", text_color=color.black)

    table.cell(statsTable, 0, 6, "Max DCA Count", text_color=color.black)
    table.cell(statsTable, 1, 6, "-", text_color=color.black)
    table.cell(statsTable, 2, 6, "-", text_color=color.black)

    table.cell(statsTable, 0, 7, "Current Direction", text_color=color.black)
    table.cell(statsTable, 1, 7, "-", text_color=color.black)
    table.cell(statsTable, 2, 7, "-", text_color=color.black)

    table.cell(statsTable, 0, 8, "Current PNL", text_color=color.black)
    table.cell(statsTable, 1, 8, "-", text_color=color.black)
    table.cell(statsTable, 2, 8, "-", text_color=color.black)

    table.cell(statsTable, 0, 9, "Current Position", text_color=color.black)
    table.cell(statsTable, 1, 9, "-", text_color=color.black)
    table.cell(statsTable, 2, 9, "-", text_color=color.black)

    table.cell(statsTable, 0, 10, "Current Largest Negative PNL", text_color=color.black)
    table.cell(statsTable, 1, 10, "-", text_color=color.black)
    table.cell(statsTable, 2, 10, "-", text_color=color.black)

    table.cell(statsTable, 0, 11, "Current DCA Count", text_color=color.black)
    table.cell(statsTable, 1, 11, "-", text_color=color.black)
    table.cell(statsTable, 2, 11, "-", text_color=color.black)

    table.cell(statsTable, 0, 12, "Next DCA Distance (%)", text_color=color.black)
    table.cell(statsTable, 1, 12, "-", text_color=color.black)
    table.cell(statsTable, 2, 12, "-", text_color=color.black)

// Entry conditions and logic
isValidLong = useAtrFilter ? (close > entry_filter_upper_band) : true
isValidShort = useAtrFilter ? (close < entry_filter_lower_band) : true

// Base position entry
if positionDir == 0 and not inDcaMode and not (isHedgeActive and ((ext_source == 1 and hedge_positionDir == 1) or (ext_source == -1 and hedge_positionDir == -1)))
    baseSignal = ext_source == 1 ? isValidLong : isValidShort
    if baseSignal
        baseTradeId := baseTradeId + 1
        currentBaseTradeId := baseTradeId  // Store the ID for this trade
        dir = int(ext_source)
        entryPrice := close
        avgEntryPrice := close
        lastDcaLevel := close
        totalInvested := initialSize
        totalPositionSize := initialSize/close
        positionDir := dir
        dcaCount := 0
        maxDrawdown := 0.0
        entryTime := time
        baseDca1Size := 0.0
        inDcaMode := false

        strategy.entry("Base_" + str.tostring(baseTradeId) + "_" + (dir > 0 ? "Long" : "Short"), dir > 0 ? strategy.long : strategy.short, qty=initialSize/close)

// Hedge position entry
// Only enter hedge if:
// 1. Base position exists
// 2. Base has taken at least one DCA
// 3. No current hedge position exists
// 4. Signal is valid in opposite direction of base
// Hedge position entry
if positionDir != 0 and not isHedgeActive and allowHedgeEntry
    hedgeSignal = positionDir == 1 ? (close < entry_filter_lower_band and ext_source == -1) : (close > entry_filter_upper_band and ext_source == 1)
    oppositeDir = -positionDir

    if hedgeSignal and ((oppositeDir == 1 and strategy.position_size <= 0) or (oppositeDir == -1 and strategy.position_size >= 0))
        hedgeTradeId := hedgeTradeId + 1
        hedge_entryPrice := close
        hedge_avgEntryPrice := close
        hedge_lastDcaLevel := close
        hedge_initialSize := baseDca1Size  // Store the initial size when hedge opens
        hedge_totalInvested := hedge_initialSize  // Use hedge_initialSize
        hedge_totalPositionSize := hedge_initialSize/close
        hedge_positionDir := oppositeDir
        hedge_dcaCount := 0
        hedge_maxDrawdown := 0.0
        hedge_entryTime := time
        isHedgeActive := true

        strategy.entry("Hedge_" + str.tostring(hedgeTradeId) + "_" + (oppositeDir > 0 ? "Long" : "Short"), oppositeDir > 0 ? strategy.long : strategy.short, qty=hedge_initialSize/close)  // Use hedge_initialSize

// Hedge position management
if hedge_positionDir != 0
    // Calculate current PNL for hedge position
    float currentPnlHedge = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) * hedge_totalPositionSize : (hedge_avgEntryPrice - close) * hedge_totalPositionSize

    // Calculate current drawdown for hedge
    float hedge_currentDD = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) / hedge_avgEntryPrice * 100 : (hedge_avgEntryPrice - close) / hedge_avgEntryPrice * 100

    // Calculate next DCA distance percentage for hedge
    float nextDcaDistanceHedge = na(nextHedgeDcaLevel) ? 0.0 : math.abs((close - nextHedgeDcaLevel) / close * 100)

    // Update statistics
    hedge_maxDrawdown := math.min(hedge_maxDrawdown, hedge_currentDD)
    hedge_unrealizedPnl = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) * hedge_totalPositionSize : (hedge_avgEntryPrice - close) * hedge_totalPositionSize
    hedge_currentTradeMaxDip := math.min(hedge_currentTradeMaxDip, hedge_unrealizedPnl)
    hedge_largestUnrealizedNegativePnl := math.min(hedge_largestUnrealizedNegativePnl, hedge_currentTradeMaxDip)

    // Update hedge position in stats table
    table.cell(statsTable, 2, 1, str.tostring(hedge_totalTrades), text_color=color.black)
    table.cell(statsTable, 2, 2, str.format("${0}", str.tostring(math.round(hedge_totalPnl))), text_color=color.black)
    table.cell(statsTable, 2, 3, str.format("${0}", str.tostring(math.round(hedge_largestPosition))), text_color=color.black)
    table.cell(statsTable, 2, 4, str.format("{0}%", str.tostring(math.round(math.abs(hedge_largestDrawdown)))), text_color=color.black)
    table.cell(statsTable, 2, 5, str.format("${0}", str.tostring(math.round(math.abs(hedge_largestUnrealizedNegativePnl)))), text_color=color.black)
    table.cell(statsTable, 2, 6, str.tostring(hedge_maxDcaCount), text_color=color.black)

    // Update current trade information
    table.cell(statsTable, 2, 7, hedge_positionDir > 0 ? "LONG" : "SHORT", text_color=color.black)
    table.cell(statsTable, 2, 8, str.format("${0}", str.tostring(math.round(currentPnlHedge))), text_color=color.black)
    table.cell(statsTable, 2, 9, str.format("${0}", str.tostring(math.round(hedge_totalInvested))), text_color=color.black)
    table.cell(statsTable, 2, 10, str.format("${0}", str.tostring(math.round(hedge_currentTradeMaxDip))), text_color=color.black)
    table.cell(statsTable, 2, 11, str.tostring(hedge_dcaCount), text_color=color.black)
    table.cell(statsTable, 2, 12, str.tostring(math.round(nextDcaDistanceHedge, 2)) + "%", text_color=color.black)

// Base position management
if positionDir != 0
    // First calculate current drawdown
    float currentDD = positionDir == 1 ? (close - avgEntryPrice) / avgEntryPrice * 100 : (avgEntryPrice - close) / avgEntryPrice * 100

    // Then calculate PnL and update stats
    unrealizedPnl = positionDir == 1 ? (close - avgEntryPrice) * totalPositionSize : (avgEntryPrice - close) * totalPositionSize
    currentTradeMaxDip := math.min(currentTradeMaxDip, unrealizedPnl)
    largestUnrealizedNegativePnl := math.min(largestUnrealizedNegativePnl, currentTradeMaxDip)
    maxDrawdown := math.min(maxDrawdown, currentDD)

    // Now update the table with the calculated values
    table.cell(statsTable, 1, 7, positionDir > 0 ? "LONG" : "SHORT", text_color=color.black)
    table.cell(statsTable, 1, 8, str.format("${0}", str.tostring(math.round(unrealizedPnl))), text_color=color.black)
    table.cell(statsTable, 1, 9, str.format("${0}", str.tostring(math.round(totalInvested))), text_color=color.black)
    table.cell(statsTable, 1, 10, str.format("${0}", str.tostring(math.round(currentTradeMaxDip))), text_color=color.black)
    table.cell(statsTable, 1, 11, str.tostring(dcaCount), text_color=color.black)
    float nextDcaDistance = na(nextBaseDcaLevel) ? 0.0 : math.abs((close - nextBaseDcaLevel) / close * 100)
    table.cell(statsTable, 1, 12, str.tostring(math.round(nextDcaDistance, 2)) + "%", text_color=color.black)

    // Update drawdown and unrealized PNL
    maxDrawdown := math.min(maxDrawdown, currentDD)

// Hedge DCA Management
if hedge_positionDir != 0
    // Calculate current drawdown for hedge
    float hedge_currentDD = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) / hedge_avgEntryPrice * 100 : (hedge_avgEntryPrice - close) / hedge_avgEntryPrice * 100

    // Update statistics
    hedge_maxDrawdown := math.min(hedge_maxDrawdown, hedge_currentDD)
    hedge_unrealizedPnl = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) * hedge_totalPositionSize : (hedge_avgEntryPrice - close) * hedge_totalPositionSize
    hedge_currentTradeMaxDip := math.min(hedge_currentTradeMaxDip, hedge_unrealizedPnl)

    // For ATR based triggers for hedge
    hedge_isOutsideAtrBands := false
    if hedge_positionDir == 1  // Long hedge position
        hedge_isOutsideAtrBands := close <= dca_lower_band and ext_source == -1  // Signal should be opposite to position direction
    else if hedge_positionDir == -1  // Short hedge position
        hedge_isOutsideAtrBands := close >= dca_upper_band and ext_source == 1  // Signal should be opposite to position direction

    // For deviation based triggers for hedge
    hedge_shouldTriggerDCA := hedge_isOutsideAtrBands

    if hedge_shouldTriggerDCA and hedge_dcaCount < maxDcaLevels and validateStepScale(close, hedge_entryPrice, hedge_lastDcaLevel, hedge_dcaCount, hedge_positionDir)
        float hedge_dcaSize = hedge_initialSize * math.pow(dcaMultiplier, hedge_dcaCount)
        float hedge_newPositionSize = hedge_dcaSize/close

        strategy.order("Hedge_" + str.tostring(hedgeTradeId) + "_" + (hedge_positionDir > 0 ? "Long" : "Short") + "_DCA_" + str.tostring(hedge_dcaCount + 1),
                      hedge_positionDir > 0 ? strategy.long : strategy.short,
                      qty=hedge_newPositionSize)

        hedge_totalInvested := hedge_totalInvested + hedge_dcaSize
        hedge_totalPositionSize := hedge_totalPositionSize + hedge_newPositionSize
        hedge_avgEntryPrice := hedge_totalInvested / hedge_totalPositionSize
        hedge_lastDcaLevel := close
        hedge_dcaCount := hedge_dcaCount + 1

        // Update statistics
        hedge_largestPosition := math.max(hedge_largestPosition, hedge_totalInvested)
        hedge_maxDcaCount := math.max(hedge_maxDcaCount, hedge_dcaCount)

// For ATR based triggers
isOutsideAtrBands = false
if positionDir == 1  // Long position
    isOutsideAtrBands := close <= dca_lower_band and ext_source == 1  // Buy signal required for long DCA
else if positionDir == -1  // Short position
    isOutsideAtrBands := close >= dca_upper_band and ext_source == -1  // Sell signal required for short DCA

// For deviation based triggers
shouldTriggerDCA = isOutsideAtrBands

if shouldTriggerDCA and dcaCount < maxDcaLevels and validateStepScale(close, entryPrice, lastDcaLevel, dcaCount, positionDir)
    float dcaSize = initialSize * math.pow(dcaMultiplier, dcaCount)
    float newPositionSize = dcaSize/close

    inDcaMode := true

    strategy.order("Base_" + str.tostring(currentBaseTradeId) + "_" + (positionDir > 0 ? "Long" : "Short") + "_DCA_" + str.tostring(dcaCount + 1), positionDir > 0 ? strategy.long : strategy.short, qty=newPositionSize)

    // Store DCA1 size for hedge entry
    if dcaCount == 0
        baseDca1Size := initialSize * math.pow(dcaMultiplier, 1)  // Always use DCA2 size
        allowHedgeEntry := true

    totalInvested := totalInvested + dcaSize
    totalPositionSize := totalPositionSize + newPositionSize
    avgEntryPrice := totalInvested / totalPositionSize
    lastDcaLevel := close
    dcaCount := dcaCount + 1

    // Update statistics
    largestPosition := math.max(largestPosition, totalInvested)
    maxDcaCount := math.max(maxDcaCount, dcaCount)

// Take profit logic for base position
if positionDir != 0
    isTP = positionDir == 1 ? close >= avgEntryPrice * (1 + tpPercent/100) : close <= avgEntryPrice * (1 - tpPercent/100)

    if isTP
        float pnlUSD = positionDir == 1 ? (close - avgEntryPrice) * totalPositionSize : (avgEntryPrice - close) * totalPositionSize
        [hours, minutes] = getTimeDiff(entryTime)

        label.new(bar_index, high, text=str.format("#{0}\nPNL: ${1}\n{2} ${3}\nDCA: {4}\nMax DD: {5}%\nMax. Dip: ${6}\nDuration: {7}h {8}m", str.tostring(totalTrades), str.tostring(math.round(math.abs(pnlUSD))), positionDir > 0 ? "LONG" : "SHORT", str.tostring(math.round(totalInvested)), str.tostring(dcaCount), str.tostring(math.round(math.abs(maxDrawdown))), str.tostring(math.round(math.abs(currentTradeMaxDip))), str.tostring(hours), str.tostring(minutes)), color=color.green, textcolor=color.white, style=label.style_label_down)

        // Update base position statistics
        totalTrades := totalTrades + 1
        totalPnl := totalPnl + pnlUSD
        largestDrawdown := math.min(largestDrawdown, maxDrawdown)
        totalDuration := totalDuration + (hours + minutes/60)

        // Update base stats in table
        table.cell(statsTable, 1, 1, str.tostring(totalTrades), text_color=color.black)
        table.cell(statsTable, 1, 2, str.format("${0}", str.tostring(math.round(totalPnl))), text_color=color.black)
        table.cell(statsTable, 1, 3, str.format("${0}", str.tostring(math.round(largestPosition))), text_color=color.black)
        table.cell(statsTable, 1, 4, str.format("{0}%", str.tostring(math.round(math.abs(largestDrawdown)))), text_color=color.black)
        table.cell(statsTable, 1, 5, str.format("${0}", str.tostring(math.round(math.abs(largestUnrealizedNegativePnl)))), text_color=color.black)
        table.cell(statsTable, 1, 6, str.tostring(maxDcaCount), text_color=color.black)

        // Clear current base position info
        table.cell(statsTable, 1, 7, "-", text_color=color.black)
        table.cell(statsTable, 1, 8, "-", text_color=color.black)
        table.cell(statsTable, 1, 9, "-", text_color=color.black)
        table.cell(statsTable, 1, 10, "-", text_color=color.black)
        table.cell(statsTable, 1, 11, "-", text_color=color.black)
        table.cell(statsTable, 1, 12, "-", text_color=color.black)

        // Close base position
        for i = 0 to dcaCount
            if i == 0
                strategy.close("Base_" + str.tostring(currentBaseTradeId) + "_" + (positionDir > 0 ? "Long" : "Short"))
            else
                strategy.close("Base_" + str.tostring(currentBaseTradeId) + "_" + (positionDir > 0 ? "Long" : "Short") + "_DCA_" + str.tostring(i))

        // Reset base position variables
        entryPrice := na
        avgEntryPrice := na
        lastDcaLevel := 0.0
        totalInvested := 0.0
        totalPositionSize := 0.0
        dcaCount := 0
        positionDir := 0
        currentTradeMaxDip := 0.0
        allowHedgeEntry := false
        baseDca1Size := 0.0
        inDcaMode := false
        currentBaseTradeId := 0.0

// Separate take profit logic for hedge position
if hedge_positionDir != 0
    // Calculate hedge take profit threshold
    bool hedge_isTP = hedge_positionDir == 1 ? close >= hedge_avgEntryPrice * (1 + tpPercent/100) : close <= hedge_avgEntryPrice * (1 - tpPercent/100)

    if hedge_isTP
        float hedge_pnlUSD = hedge_positionDir == 1 ? (close - hedge_avgEntryPrice) * hedge_totalPositionSize : (hedge_avgEntryPrice - close) * hedge_totalPositionSize
        [hedge_hours, hedge_minutes] = getTimeDiff(hedge_entryTime)

        // Update hedge statistics
        hedge_totalTrades := hedge_totalTrades + 1
        hedge_totalPnl := hedge_totalPnl + hedge_pnlUSD
        hedge_largestDrawdown := math.min(hedge_largestDrawdown, hedge_maxDrawdown)
        hedge_totalDuration := hedge_totalDuration + (hedge_hours + hedge_minutes/60)

        // Create hedge TP label
        label.new(bar_index, low, text=str.format("HEDGE #{0}\nPNL: ${1}\n{2} ${3}\nDCA: {4}\nMax DD: {5}%\nMax. Dip: ${6}\nDuration: {7}h {8}m", str.tostring(hedge_totalTrades), str.tostring(math.round(math.abs(hedge_pnlUSD))), hedge_positionDir > 0 ? "LONG" : "SHORT", str.tostring(math.round(hedge_totalInvested)), str.tostring(hedge_dcaCount), str.tostring(math.round(math.abs(hedge_maxDrawdown))), str.tostring(math.round(math.abs(hedge_currentTradeMaxDip))), str.tostring(hedge_hours), str.tostring(hedge_minutes)), color=color.red, textcolor=color.white, style=label.style_label_up)

        // Close hedge position
        for i = 0 to hedge_dcaCount
            if i == 0
                strategy.close("Hedge_" + str.tostring(hedgeTradeId) + "_" + (hedge_positionDir > 0 ? "Long" : "Short"))
            else
                strategy.close("Hedge_" + str.tostring(hedgeTradeId) + "_" + (hedge_positionDir > 0 ? "Long" : "Short") + "_DCA_" + str.tostring(i))

        // Reset hedge variables
        hedge_entryPrice := na
        hedge_avgEntryPrice := na
        hedge_lastDcaLevel := 0.0
        hedge_totalInvested := 0.0
        hedge_totalPositionSize := 0.0
        hedge_dcaCount := 0
        hedge_positionDir := 0
        hedge_currentTradeMaxDip := 0.0
        isHedgeActive := false
        hedge_initialSize := 0.0

        // Update hedge stats in table
        table.cell(statsTable, 2, 1, str.tostring(hedge_totalTrades), text_color=color.black)
        table.cell(statsTable, 2, 2, str.format("${0}", str.tostring(math.round(hedge_totalPnl))), text_color=color.black)
        table.cell(statsTable, 2, 3, str.format("${0}", str.tostring(math.round(hedge_largestPosition))), text_color=color.black)
        table.cell(statsTable, 2, 4, str.format("{0}%", str.tostring(math.round(math.abs(hedge_largestDrawdown)))), text_color=color.black)
        table.cell(statsTable, 2, 5, str.format("${0}", str.tostring(math.round(math.abs(hedge_largestUnrealizedNegativePnl)))), text_color=color.black)
        table.cell(statsTable, 2, 6, str.tostring(hedge_maxDcaCount), text_color=color.black)

        // Clear current hedge position info
        table.cell(statsTable, 2, 7, "-", text_color=color.black)
        table.cell(statsTable, 2, 8, "-", text_color=color.black)
        table.cell(statsTable, 2, 9, "-", text_color=color.black)
        table.cell(statsTable, 2, 10, "-", text_color=color.black)
        table.cell(statsTable, 2, 11, "-", text_color=color.black)
        table.cell(statsTable, 2, 12, "-", text_color=color.black)

// Calculate next DCA levels
nextBaseDcaLevel := if positionDir != 0 and dcaCount < maxDcaLevels
    float threshold = 0.0
    float lastActualDeviation = 0.0

    if dcaCount == 0
        threshold := baseDeviation
    else
        // Calculate actual deviation of last DCA
        lastActualDeviation := positionDir == 1 ? (entryPrice - lastDcaLevel) / entryPrice * 100 : (lastDcaLevel - entryPrice) / entryPrice * 100

        // Next threshold is last actual deviation plus scaled base
        threshold := lastActualDeviation + (baseDeviation * math.pow(stepScale, dcaCount))

    if positionDir == 1
        entryPrice * (1 - threshold/100)
    else
        entryPrice * (1 + threshold/100)
else
    na

nextHedgeDcaLevel := if hedge_positionDir != 0 and hedge_dcaCount < maxDcaLevels
    float threshold = 0.0
    float lastActualDeviation = 0.0

    if hedge_dcaCount == 0
        threshold := baseDeviation
    else
        // Calculate actual deviation of last hedge DCA
        lastActualDeviation := hedge_positionDir == 1 ? (hedge_entryPrice - hedge_lastDcaLevel) / hedge_entryPrice * 100 : (hedge_lastDcaLevel - hedge_entryPrice) / hedge_entryPrice * 100

        // Next threshold is last actual deviation plus scaled base
        threshold := lastActualDeviation + (baseDeviation * math.pow(stepScale, hedge_dcaCount))

    if hedge_positionDir == 1
        hedge_entryPrice * (1 - threshold/100)
    else
        hedge_entryPrice * (1 + threshold/100)
else
    na

        // Plot indicators
plot(ema_value, "EMA", color=color.blue, linewidth=2)
plot(dca_upper_band, "DCA Upper Band", color=color.purple, linewidth=1)
plot(dca_lower_band, "DCA Lower Band", color=#9c27b0, linewidth=1)
plot(useAtrFilter ? entry_filter_upper_band : na, "Entry Filter Upper Band", color=color.rgb(255, 165, 0), linewidth=1)
plot(useAtrFilter ? entry_filter_lower_band : na, "Entry Filter Lower Band", color=color.rgb(255, 165, 0), linewidth=1)

// Plot average entry prices with different colors for base and hedge positions
var float basePlotPrice = na
var float hedgePlotPrice = na
basePlotPrice := positionDir != 0 ? avgEntryPrice : na
hedgePlotPrice := hedge_positionDir != 0 ? hedge_avgEntryPrice : na
plot(series=basePlotPrice, title="Base Average Entry", color=positionDir > 0 ? color.green : color.red, linewidth=4, style=plot.style_linebr)
plot(series=hedgePlotPrice, title="Hedge Average Entry", color=hedge_positionDir > 0 ? color.black : color.black, linewidth=4, style=plot.style_linebr)

// Plot next DCA levels as dashed lines
plot(nextBaseDcaLevel, "Next Base DCA Level", color=color.red, linewidth=1, style=plot.style_linebr)
plot(nextHedgeDcaLevel, "Next Hedge DCA Level", color=color.black, linewidth=1, style=plot.style_linebr)