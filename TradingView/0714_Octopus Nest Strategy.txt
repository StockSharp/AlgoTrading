// This work by simwai is licensed under CC BY-NC-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/

//@version=5
strategy('Octopus Nest Strategy', shorttitle='Octo', overlay=true, initial_capital=1000, default_qty_value=25, default_qty_type=strategy.percent_of_equity, calc_on_every_tick=false, process_orders_on_close=true, commission_value=0.075)

// -- Colors --
color rajah = color.rgb(242, 166, 84) // orange
color magicMint = color.rgb(171, 237, 198)
color mediumAquamarine = color.rgb(104, 223, 153)
color carrotOrange = color.rgb(239, 146, 46)

// -- Inputs --
string resolution = input.timeframe(defval='', title='Choose Timeframe', group='General', inline='1')
float src = input.source(close, 'Choose Source', group='General', inline='1')
bool isSignalLabelEnabled = input.bool(title='Show Signal Labels?', defval=true, group='General', inline='2')
bool isPsarAdaptive = input.bool(title='Is PSAR Adaptive?', defval=false, group='General', inline='2')
bool isRepaintingEnabled = input.bool(title='Is Repainting Enabled?', defval=false, group='General', inline='3', tooltip='If repainting is enabled, the strategy uses the current bar to determine the signal. Otherwise, it uses the previous bar.')

float highLowStopLossMultiplier = input.float(defval=0.98,  step=0.01, minval=0, maxval=1, title='Multiplier', group='High Low Stop Loss', inline='1')
float highLowStopLossBackupMultiplier = input.float(defval=0.98, step=0.01, minval=0, maxval=1, title='Backup Multiplier', group='High Low Stop Loss', inline='1')
int highLowStopLossLookback = input.int(defval=20, step=5, minval=1, title='Lookback', group='High Low Stop Loss', inline='2')
float automaticHighLowTakeProfitRatio = input.float(defval=1.125, step=0.1, minval=0, title='Risk Reward Ratio', group='Automatic High Low Take Profit', inline='2')

int emaLength = input.int(100, minval=2, title='Length', group='EMA', inline='1')

int bbLength = input(20, title='BB Length', group='TTM Squeeze/Squeeze Momentum', inline='3')
float multBB = input(2.0, title='BB MultFactor', group='TTM Squeeze/Squeeze Momentum', inline='3')
int lengthKC=input(20, title='KC Length', group='TTM Squeeze/Squeeze Momentum', inline='4')
float multKC = input(1.5, title="KC MultFactor", group='TTM Squeeze/Squeeze Momentum', inline='4')
bool isTrueRangeEnabled = input.bool(title='Use True Range?', defval=true, group='TTM Squeeze/Squeeze Momentum', inline='5')

float psarStart = input.float(0.02, 'Start', step=0.01, minval=0.0, group='PSAR', inline='1')
float psarInc = input.float(0.02, 'Increment', step=0.01, minval=0.01, group='PSAR', inline='1')
float psarMax = input.float(0.2, 'Max', step=0.05, minval=0.0, group='PSAR', inline='2')

float startAFactor = input.float(0.02, 'Starting Acceleration Factor', step = 0.001, group='Adaptive PSAR', inline='1')
float minStep = input.float(0.0, 'Min Step', step = 0.001, group='Adaptive PSAR', inline='1')
float maxStep = input.float(0.02, 'Max Step', step = 0.001, group='Adaptive PSAR', inline='2')
float maxAFactor = input.float(0.2, 'Max Acceleration Factor', step = 0.001, group='Adaptive PSAR', inline='2')

string hiloMode = input.string('On', 'HiLo Mode', options = ['Off', 'On'], group='Adaptive PSAR')
string adaptMode = input.string('Kaufman', 'Adaptive Mode', options = ['Kaufman', 'Ehlers'], group='Adaptive PSAR')
int adaptSmth = input.int(5, 'Adaptive Smoothing Period', minval = 1, group='Adaptive PSAR')
float filt = input.float(0.0, 'Filter in Pips', group='Adaptive PSAR', minval = 0)
float minChng = input.float(0.0, 'Min Change in Pips', group='Adaptive PSAR', minval = 0)
string SignalMode = input.string('Only Stops', 'Signal Mode', options = ['Only Stops', 'Signals & Stops'], group='Adaptive PSAR')

// -- Functions --
tr(_high, _low, _close) => math.max(_high - _low, math.abs(_high - _close[1]), math.abs(_low - _close[1]))

// -- Calculation --
var string lastTrade = 'initial'

int repaint = isRepaintingEnabled ? 0 : 1
[_src, _low, _high, _close] = request.security(syminfo.tickerid, resolution, [src[repaint], low[repaint], high[repaint], close[repaint]], barmerge.gaps_off, isRepaintingEnabled ? barmerge.lookahead_off : barmerge.lookahead_on)

// -- TTM Squeeze/Squeeze Momentum – Credits to @Greeny and @LazyBear --

float osc = ta.linreg(_src - math.avg(math.avg(ta.highest(_high, lengthKC), ta.lowest(_low, lengthKC)), ta.sma(_close, lengthKC)), lengthKC, 0)

[_, _upperBB, _lowerBB] = ta.bb(_src, bbLength, multBB)
[_, _upperKC, _lowerKC] = ta.kc(_src, lengthKC, multKC, isTrueRangeEnabled)
float upperBB = _upperBB[repaint]
float lowerBB = _lowerBB[repaint]
float upperKC = _upperKC[repaint]
float lowerKC = _lowerKC[repaint]

osc_color = osc[1] < osc[0] ? osc[0] >= 0 ? #00ffff : #cc00cc : osc[0] >= 0 ? #009b9b : #ff9bff

// -- Adaptive PSAR – Credits to @loxx --
// Credits to @Bjorgum
calcBaseUnit() =>
    bool  isForexSymbol = syminfo.type     == 'forex'
    bool  isYenPair     = syminfo.currency == 'JPY'
    float result = isForexSymbol ? isYenPair ? 0.01 : 0.0001 : syminfo.mintick

_afact(mode,input, per, smooth) =>
    eff = 0., seff = 0.
    len = 0, sum = 0., max = 0., min = 1000000000.
    len := mode == 'Kaufman' ? math.ceil(per) : math.ceil(math.max(20, 5 * per))
    for i = 0 to len
        if (mode == 'Kaufman')
            sum += math.abs(input[i] - input[i + 1])
        else
            max := input[i] > max ? input[i] : max
            min := input[i] < min ? input[i] : min
    if (mode == 'Kaufman' and sum != 0)
        eff := math.abs(input - input[len]) / sum
    else
        if (mode == 'Ehlers' and (max - min) > 0)
            eff := (input - min) / (max - min)
    seff := ta.ema(eff, smooth)
    seff

baseUnit = calcBaseUnit()

hVal2 = nz(_high[2]), hVal1 = nz(_high[1]), hVal0 = _high
lowVal2 = nz(_low[2]), lowVal1 = nz(_low[1]), lowVal0 = _low
hiprice2 = nz(_high[2]), hiprice1 = nz(_high[1]), hiprice0 = _high
loprice2 = nz(_low[2]), loprice1 = nz(_low[1]), loprice0 = _low

upSig = 0., dnSig = 0.
aFactor = 0., step = 0., trend = 0.
upTrndSAR = 0., dnTrndSAR = 0.
length = (2 / maxAFactor - 1)

if (hiloMode == 'On')
    hiprice0 := _high
    loprice0 := _low
else
    hiprice0 := _src
    loprice0 := hiprice0

if isPsarAdaptive
    if bar_index == 1
        trend := 1
        hVal1 := hiprice1
        hVal0 := math.max(hiprice0, hVal1)
        lowVal1 := loprice1
        lowVal0 := math.min(loprice0, lowVal1)
        aFactor := startAFactor
        upTrndSAR := lowVal0
        dnTrndSAR := 0.
    else
        hVal0 := hVal1
        lowVal0 := lowVal1
        trend := nz(trend[1])
        aFactor := nz(aFactor[1])
        inputs = 0.
        inprice = _src

        if (hiloMode == 'On')
            inprice := _src
        else
            inprice := hiprice0
        if (adaptMode == 'Kaufman')
            inputs := inprice
        else
            if (adaptMode == 'Ehlers')
                if (nz(upTrndSAR[1]) != 0.)
                    inputs := math.abs(inprice - nz(upTrndSAR[1]))
                else
                    if (nz(dnTrndSAR[1]) != 0.)
                        inputs := math.abs(inprice - nz(dnTrndSAR[1]))
        step := minStep + _afact(adaptMode, inputs, length, adaptSmth) * (maxStep - minStep)

        upTrndSAR := 0., dnTrndSAR := 0., upSig := 0., dnSig := 0.

        if (nz(trend[1]) > 0)
            if (nz(trend[1]) == nz(trend[2]))
                aFactor := hVal1 > hVal2 ? nz(aFactor[1]) + step : aFactor
                aFactor := aFactor > maxAFactor ? maxAFactor : aFactor
                aFactor := hVal1 < hVal2 ? startAFactor : aFactor
            else
                aFactor := nz(aFactor[1])

            upTrndSAR := nz(upTrndSAR[1]) + aFactor * (hVal1 - nz(upTrndSAR[1]))
            upTrndSAR := upTrndSAR > loprice1 ? loprice1 : upTrndSAR
            upTrndSAR := upTrndSAR > loprice2 ? loprice2 : upTrndSAR
        else
            if (nz(trend[1]) == nz(trend[2]))
                aFactor := lowVal1 < lowVal2 ? nz(aFactor[1]) + step : aFactor
                aFactor := aFactor > maxAFactor ? maxAFactor : aFactor
                aFactor := lowVal1 > lowVal2 ? startAFactor : aFactor
            else
                aFactor := nz(aFactor[1])

            dnTrndSAR := nz(dnTrndSAR[1]) + aFactor * (lowVal1 - nz(dnTrndSAR[1]))
            dnTrndSAR := dnTrndSAR < hiprice1 ? hiprice1 : dnTrndSAR
            dnTrndSAR := dnTrndSAR < hiprice2 ? hiprice2 : dnTrndSAR

        hVal0 := hiprice0 > hVal0 ? hiprice0 : hVal0
        lowVal0 := loprice0 < lowVal0 ? loprice0 : lowVal0

        if (minChng > 0)
            if (upTrndSAR - nz(upTrndSAR[1]) < minChng * baseUnit and upTrndSAR != 0. and nz(upTrndSAR[1]) != 0.)
                upTrndSAR := nz(upTrndSAR[1])
            if (nz(dnTrndSAR[1]) - dnTrndSAR < minChng * baseUnit and dnTrndSAR != 0. and nz(dnTrndSAR[1]) != 0.)
                dnTrndSAR := nz(dnTrndSAR[1])

        dnTrndSAR := trend < 0 and dnTrndSAR > nz(dnTrndSAR[1]) ? nz(dnTrndSAR[1]) : dnTrndSAR
        upTrndSAR := trend > 0 and upTrndSAR < nz(upTrndSAR[1]) ? nz(upTrndSAR[1]) : upTrndSAR

        if (trend < 0 and hiprice0 >= dnTrndSAR + filt * baseUnit)
            trend := 1
            upTrndSAR := lowVal0
            upSig := SignalMode == 'Signals & Stops' ? lowVal0 : upSig
            dnTrndSAR := 0.
            aFactor := startAFactor
            lowVal0 := loprice0
            hVal0 := hiprice0
        else if (trend > 0 and loprice0 <= upTrndSAR - filt * baseUnit)
            trend := -1
            dnTrndSAR := hVal0
            dnSig := SignalMode == 'Signals & Stops' ? hVal0 : dnSig
            upTrndSAR := 0.
            aFactor := startAFactor
            lowVal0 := loprice0
            hVal0 := hiprice0

psar = upTrndSAR > 0 ? upTrndSAR : dnTrndSAR
psar := isPsarAdaptive ? psar : ta.sar(psarStart, psarInc, psarMax)[repaint]
plot(psar, title='PSAR', color=_src < psar ? rajah : magicMint, style=plot.style_circles)

// -- EMA --
// Auto higher time frame
string aHtf = resolution == '1' ? '5' : resolution == '3' ? '15' : resolution == '5' ? '15' : resolution == '15' ? '60' : resolution == '30' ? '60' : resolution == '45' ? '60' : resolution == '60' ? '240' : resolution == '120' ? '240' : resolution == '180' ? '240' : resolution == '240' ? 'D' : resolution == 'D' ? 'W' : ''

float emaSrc = request.security(syminfo.tickerid, aHtf, _src, barmerge.gaps_off, barmerge.lookahead_on)
float ema = ta.ema(emaSrc, emaLength)
plot(ema, title='EMA', color=osc_color)

// -- Signals --
var string isTradeOpen = ''

bool enterLong = _src > ema and ta.crossover(_src, psar) and ta.crossover(osc, 0) and isTradeOpen == ''
bool enterShort = _src < ema and ta.crossunder(_src, psar) and ta.crossunder(osc, 0) and isTradeOpen == ''

if (isTradeOpen == '')
    if (enterLong)
        isTradeOpen := 'long'
    else if (enterShort)
        isTradeOpen := 'short'
else if (isTradeOpen == 'long')
    if (enterLong)
        enterLong := false
else if (isTradeOpen == 'short')
    if (enterShort)
        enterShort := false

plotshape((isSignalLabelEnabled and enterLong and (isTradeOpen == 'long')) ? ema : na, title='LONG', text='L', style=shape.labelup, color=mediumAquamarine, textcolor=color.white, size=size.tiny, location=location.absolute)
plotshape((isSignalLabelEnabled and enterShort and (isTradeOpen == 'short')) ? ema : na, title='SHORT', text='S', style=shape.labeldown, color=carrotOrange, textcolor=color.white, size=size.tiny, location=location.absolute)

// -- High Low Stop Loss and Take Profit --
bool isHighLowStopLossEnabled = true
bool isAutomaticHighLowTakeProfitEnabled = true
bool recalculateStopLossTakeProfit = false
bool isStrategyEntryEnabled = false
bool isLongEnabled = true
bool isShortEnabled = true
bool isStopLossTakeProfitRecalculationEnabled = true

bool longStopLossTakeProfitRecalculation = isStopLossTakeProfitRecalculationEnabled ? true : (lastTrade == 'short' or lastTrade == 'initial')
bool shortStopLossTakeProfitRecalculation = isStopLossTakeProfitRecalculationEnabled ? true : (lastTrade == 'long' or lastTrade == 'initial')

var float longHighLowStopLoss = 0
var float shortHighLowStopLoss = 0

float highLowStopLossLowest = ta.lowest(_low, highLowStopLossLookback)
float highLowStopLossHighest = ta.highest(_high, highLowStopLossLookback)

if (isHighLowStopLossEnabled)
    if (((enterLong and longStopLossTakeProfitRecalculation) or recalculateStopLossTakeProfit) and (isStrategyEntryEnabled ? isTradeOpen != 'long' : true))
        if (highLowStopLossLowest == _low)
            longHighLowStopLoss := _low * highLowStopLossBackupMultiplier
        else if (highLowStopLossLowest > 0)
            longHighLowStopLoss := highLowStopLossLowest * highLowStopLossMultiplier

    if (((enterShort and shortStopLossTakeProfitRecalculation) or recalculateStopLossTakeProfit) and (isStrategyEntryEnabled ? isTradeOpen != 'short' : true))
        if (highLowStopLossHighest == _high)
            shortHighLowStopLoss := _high * (1 + (1 - highLowStopLossBackupMultiplier))
        else if (highLowStopLossHighest > 0)
            shortHighLowStopLoss := highLowStopLossHighest * (1 + (1 - highLowStopLossMultiplier))

plot((isLongEnabled and isHighLowStopLossEnabled and (isTradeOpen == 'long')) ? longHighLowStopLoss : na, 'Long High Low Stop Loss', color=magicMint, style=plot.style_circles, trackprice=false)
plot((isShortEnabled and isHighLowStopLossEnabled and (isTradeOpen == 'short')) ? shortHighLowStopLoss : na, 'Short High Low Stop Loss ', color=rajah, style=plot.style_circles, trackprice=false)

// -- Automatic High Low Take Profit --
var float longAutomaticHighLowTakeProfit = na
var float shortAutomaticHighLowTakeProfit = na

if (isAutomaticHighLowTakeProfitEnabled)
    if (((enterLong and longStopLossTakeProfitRecalculation) or recalculateStopLossTakeProfit) and (isStrategyEntryEnabled ? isTradeOpen != 'long' : true))
        longHighLowStopLossPercentage = 1 - (longHighLowStopLoss / _close)
        longAutomaticHighLowTakeProfit := _close * (1 + (longHighLowStopLossPercentage  * automaticHighLowTakeProfitRatio))
    if (((enterShort and shortStopLossTakeProfitRecalculation) or recalculateStopLossTakeProfit) and (isStrategyEntryEnabled ? isTradeOpen != 'short' : true))
        shortHighLowStopLossPercentage = 1 - (_close / shortHighLowStopLoss)
        shortAutomaticHighLowTakeProfit := _close * (1 - (shortHighLowStopLossPercentage * automaticHighLowTakeProfitRatio))

plot((isAutomaticHighLowTakeProfitEnabled and isHighLowStopLossEnabled and (isTradeOpen == 'long')) ? longAutomaticHighLowTakeProfit : na, 'Long Automatic High Low Take Profit', color=magicMint, style=plot.style_circles, trackprice=false)
plot((isAutomaticHighLowTakeProfitEnabled and isHighLowStopLossEnabled and (isTradeOpen == 'short')) ? shortAutomaticHighLowTakeProfit : na, 'Short Automatic High Low Take Profit', color=rajah, style=plot.style_circles, trackprice=false)

bool longHighLowStopLossCondition = ta.crossunder(_close, longHighLowStopLoss)
bool shortHighLowStopLossCondition = ta.crossover(_close, shortHighLowStopLoss)

bool longAutomaticHighLowTakeProfitCondition = ta.crossover(_close, longAutomaticHighLowTakeProfit)
bool shortAutomaticHighLowTakeProfitCondition = ta.crossunder(_close, shortAutomaticHighLowTakeProfit)

bool exitLong = (longHighLowStopLossCondition or longAutomaticHighLowTakeProfitCondition) and isTradeOpen == 'long'
bool exitShort = (shortHighLowStopLossCondition or shortAutomaticHighLowTakeProfitCondition) and isTradeOpen == 'short'

plotshape((isSignalLabelEnabled and exitLong and (isTradeOpen == 'long')) ? ema : na, title='LONG EXIT', style=shape.circle, color=magicMint, size=size.tiny, location=location.absolute)
plotshape((isSignalLabelEnabled and exitShort and (isTradeOpen == 'short')) ? ema : na, title='SHORT EXIT', style=shape.circle, color=rajah, size=size.tiny, location=location.absolute)

// Long Exits
if (exitLong)
    strategy.close('long', comment=longAutomaticHighLowTakeProfitCondition ? 'EXIT_LONG_TP' : 'EXIT_LONG_SL')
    isTradeOpen := ''

// Short Exits
if (exitShort)
    strategy.close('short', comment=shortAutomaticHighLowTakeProfitCondition ? 'EXIT_SHORT_TP' : 'EXIT_SHORT_SL')
    isTradeOpen := ''

// Long Entries
if (enterLong)
    strategy.order('long', strategy.long, comment='ENTER_LONG')
    isTradeOpen := 'long'

// Short Entries
if (enterShort)
    strategy.order('short', strategy.short, comment='ENTER_SHORT')
    isTradeOpen := 'short'

// Save last trade state
if (enterLong or exitLong)
    lastTrade := 'long'
if (enterShort or exitShort)
    lastTrade := 'short'

barcolor(color=isTradeOpen == 'long' ? mediumAquamarine : isTradeOpen == 'short' ? carrotOrange : na)