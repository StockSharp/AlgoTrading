//@version=5
strategy("Dubic EMA Strategy", overlay=true,
     default_qty_type=strategy.percent_of_equity,
     default_qty_value=100,
     initial_capital=10000,
     currency=currency.USD,
     commission_value=0.1,
     pyramiding=0,
     calc_on_every_tick=true)

// Inputs
ema_length = input.int(40, "EMA Length")
tp_percent = input.float(2.0, "Take Profit %", step=0.1, minval=0.1) / 100
sl_offset = input.float(0.5, "Stop Loss Offset %", step=0.1, minval=0.1) / 100

// Toggles for SL/TP
use_take_profit = input.bool(true, "Use Take Profit")
use_stop_loss = input.bool(true, "Use Stop Loss")

// Range Detection
range_length = input.int(20, "Range Detection Length", minval=5)
range_threshold = input.float(2.0, "Range Threshold %", step=0.1) / 100
min_range_bars = input.int(3, "Min Range Bars", minval=1)

// Parabolic SAR
use_parabolic_sar = input.bool(true, "Use Parabolic SAR Trailing Stop")
sar_start = input.float(0.02, "SAR Start", step=0.01)
sar_increment = input.float(0.02, "SAR Increment", step=0.01)
sar_max = input.float(0.2, "SAR Maximum", step=0.01)

// ATR Stop Configuration
use_atr_stop = input.bool(true, "Use ATR Stop Instead of Fixed %")
atr_length = input.int(14, "ATR Length")
atr_mult = input.float(1.5, "ATR Multiplier", minval=0.5)

// Volatility Filter
min_atr = input.float(0.5, "Min ATR % for Trading", step=0.1) / 100
use_volatility_filter = input.bool(true, "Enable Volatility Filter")

// Unbroken Range Visualization
show_unbroken_range = input.bool(true, "Show Unbroken Range Visualization", group="Unbroken Range")
unbroken_length = input.int(20, 'Minimum Range Length', minval=2, group="Unbroken Range")
unbroken_mult = input.float(1., 'Range Width', minval=0, step=0.1, group="Unbroken Range")
unbroken_atrLen = input.int(500, 'ATR Length', minval=1, group="Unbroken Range")
upCss = input.color(#089981, 'Broken Upward', group="Unbroken Range")
dnCss = input.color(#f23645, 'Broken Downward', group="Unbroken Range")
unbrokenCss = input.color(#2157f3, 'Unbroken', group="Unbroken Range")

// Calculate Indicators
ema_high = ta.ema(high, ema_length)
ema_low = ta.ema(low, ema_length)
ema_200 = ta.ema(close, 200)
sar = ta.sar(sar_start, sar_increment, sar_max)
atr = ta.atr(atr_length)

// Volatility Filter
atr_percentage = (atr / close) * 100
sufficient_volatility = not use_volatility_filter or (atr_percentage >= min_atr * 100)

// Range Detection Logic
range_high = ta.highest(high, range_length)
range_low = ta.lowest(low, range_length)
range_size = range_high - range_low
range_percentage = (range_size / close) * 100
range_condition = range_percentage <= (range_threshold * 100)

// Consecutive range bars counter
var int range_bars_count = 0
range_bars_count := range_condition ? range_bars_count + 1 : 0
in_range = range_bars_count >= min_range_bars

// Visualize Range
bgcolor(in_range ? color.new(color.purple, 85) : na, title="Range Zone")
plot(in_range ? range_high : na, "Range High", color=color.purple, linewidth=2, style=plot.style_linebr)
plot(in_range ? range_low : na, "Range Low", color=color.purple, linewidth=2, style=plot.style_linebr)

// Trading Conditions
buy_condition = (close > ema_high) and (close > ema_low)
sell_condition = (close < ema_high) and (close < ema_low)

// Apply Filters
buy_signal = buy_condition and not in_range and sufficient_volatility
sell_signal = sell_condition and not in_range and sufficient_volatility

// Trend State Machine
var int currentTrend = 0  // 0=neutral, 1=long, -1=short
var bool showBuy = false
var bool showSell = false

trendChanged = false
if buy_signal and currentTrend != 1
    currentTrend := 1
    trendChanged := true
    showBuy := true
    showSell := false
else if sell_signal and currentTrend != -1
    currentTrend := -1
    trendChanged := true
    showBuy := false
    showSell := true

// Reset signals
showBuy := nz(showBuy[1]) and not trendChanged ? false : showBuy
showSell := nz(showSell[1]) and not trendChanged ? false : showSell

// Plot Indicators
plot(ema_high, "EMA High", color=color.blue, linewidth=2)
plot(ema_low, "EMA Low", color=color.orange, linewidth=2)
plot(ema_200, "200 EMA", color=color.white, linewidth=3)

// Plot SAR with color coding
color sarColor = strategy.position_size > 0 ? color.red :
               strategy.position_size < 0 ? color.green :
               color.gray
plot(use_parabolic_sar ? sar : na, "SAR", style=plot.style_circles, color=sarColor, linewidth=2)

// Plot signals
plotshape(showBuy, title="Buy Signal", text="BUY", style=shape.labelup,
          location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny)
plotshape(showSell, title="Sell Signal", text="SELL", style=shape.labeldown,
          location=location.abovebar, color=color.red, textcolor=color.white, size=size.tiny)

// Strategy Logic
var float long_sl = na
var float long_tp = na
var float short_sl = na
var float short_tp = na
var float long_trail_stop = na
var float short_trail_stop = na

// Position Sizing with Volatility Scaling
position_size = use_volatility_filter ? math.min(100, 100 * (min_atr * 100) / atr_percentage) : 100

// Execute trades
if (showBuy)
    // Calculate stop loss and take profit
    long_sl := use_atr_stop ? close - atr * atr_mult : ema_low * (1 - sl_offset)
    long_tp := close * (1 + tp_percent)
    long_trail_stop := use_parabolic_sar ? sar : na

    strategy.close("Short", comment="Exit Short")
    strategy.entry("Long", strategy.long, qty=position_size)

    // Set exit orders with toggle support
    if use_stop_loss or use_take_profit
        strategy.exit("Long SL/TP", "Long",
             stop=use_stop_loss ? long_sl : na,
             limit=use_take_profit ? long_tp : na)

    if use_parabolic_sar
        strategy.exit("Long SAR", "Long", stop=long_trail_stop)

    alert("BUY: " + syminfo.ticker, alert.freq_once_per_bar)

if (showSell)
    // Calculate stop loss and take profit
    short_sl := use_atr_stop ? close + atr * atr_mult : ema_high * (1 + sl_offset)
    short_tp := close * (1 - tp_percent)
    short_trail_stop := use_parabolic_sar ? sar : na

    strategy.close("Long", comment="Exit Long")
    strategy.entry("Short", strategy.short, qty=position_size)

    // Set exit orders with toggle support
    if use_stop_loss or use_take_profit
        strategy.exit("Short SL/TP", "Short",
             stop=use_stop_loss ? short_sl : na,
             limit=use_take_profit ? short_tp : na)

    if use_parabolic_sar
        strategy.exit("Short SAR", "Short", stop=short_trail_stop)

    alert("SELL: " + syminfo.ticker, alert.freq_once_per_bar)

// Update SAR trailing stops
if barstate.isrealtime and use_parabolic_sar
    if strategy.position_size > 0
        strategy.exit("Long SAR", "Long", stop=long_trail_stop)
    else if strategy.position_size < 0
        strategy.exit("Short SAR", "Short", stop=short_trail_stop)

// Plot SL/TP levels with toggle support
plot(strategy.position_size > 0 and use_stop_loss ? long_sl : na, "Long Stop", color=color.red, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size > 0 and use_take_profit ? long_tp : na, "Long Take Profit", color=color.green, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size < 0 and use_stop_loss ? short_sl : na, "Short Stop", color=color.red, style=plot.style_linebr, linewidth=2)
plot(strategy.position_size < 0 and use_take_profit ? short_tp : na, "Short Take Profit", color=color.green, style=plot.style_linebr, linewidth=2)

// Plot SAR trailing stops
plot(strategy.position_size > 0 and use_parabolic_sar ? long_trail_stop : na,
     "Long Trail Stop", color=color.orange, style=plot.style_circles, linewidth=2)
plot(strategy.position_size < 0 and use_parabolic_sar ? short_trail_stop : na,
     "Short Trail Stop", color=color.orange, style=plot.style_circles, linewidth=2)

// Alerts
alertcondition(showBuy, title="Buy Alert", message="BUY: {{ticker}}")
alertcondition(showSell, title="Sell Alert", message="SELL: {{ticker}}")

// Information Labels
var label range_lbl = na
label.delete(range_lbl)
if in_range
    range_lbl := label.new(bar_index, high, "RANGE\nNO TRADING",
          color=color.purple, textcolor=color.white,
          style=label.style_label_down, yloc=yloc.abovebar)

// Volatility Warning
var label vol_lbl = na
label.delete(vol_lbl)
if not sufficient_volatility
    vol_lbl := label.new(bar_index, low, "LOW VOLATILITY\nNO TRADING",
          color=color.gray, textcolor=color.white,
          style=label.style_label_up, yloc=yloc.belowbar)

// =============================================================================
// Unbroken Range Visualization - FIXED
// =============================================================================
// Initialize persistent variables
var box rangeBox = na
var line rangeLevel = na
var float unbrokenMax = na
var float unbrokenMin = na
var int unbrokenOs = 0
var color unbrokenTopColor = na
var color unbrokenBottomColor = na

// Calculate indicators for range detection
unbrokenAtr = ta.atr(unbroken_atrLen) * unbroken_mult
unbrokenMa = ta.sma(close, unbroken_length)

// Count bars within the range
unbrokenCount = 0
for i = 0 to unbroken_length - 1
    unbrokenCount += math.abs(close[i] - unbrokenMa) > unbrokenAtr ? 1 : 0

// Manage range box and level
if show_unbroken_range
    if unbrokenCount == 0 and unbrokenCount[1] != unbrokenCount
        // Handle overlapping ranges
        if not na(rangeBox) and (bar_index - unbroken_length) <= rangeBox.get_right()
            unbrokenMax := math.max(unbrokenMa + unbrokenAtr, rangeBox.get_top())
            unbrokenMin := math.min(unbrokenMa - unbrokenAtr, rangeBox.get_bottom())

            // Update box coordinates
            rangeBox.set_top(unbrokenMax)
            rangeBox.set_bottom(unbrokenMin)
            rangeBox.set_right(bar_index)
            rangeBox.set_bgcolor(color.new(unbrokenCss, 80))

            // Update level line
            avg = (unbrokenMax + unbrokenMin) / 2
            if na(rangeLevel)
                rangeLevel := line.new(bar_index, avg, bar_index, avg, color=unbrokenCss, style=line.style_dotted)
            else
                rangeLevel.set_y1(avg)
                rangeLevel.set_xy2(bar_index, avg)
                rangeLevel.set_color(unbrokenCss)
        else
            unbrokenMax := unbrokenMa + unbrokenAtr
            unbrokenMin := unbrokenMa - unbrokenAtr

            // Set new box and level
            rangeBox := box.new(bar_index - unbroken_length, unbrokenMax, bar_index, unbrokenMin,
                 bgcolor=color.new(unbrokenCss, 80), border_color=na)

            rangeLevel := line.new(bar_index - unbroken_length, unbrokenMa, bar_index, unbrokenMa,
                 color=unbrokenCss, style=line.style_dotted)

            unbrokenOs := 0

    else if unbrokenCount == 0
        if not na(rangeBox)
            rangeBox.set_right(bar_index)
        if not na(rangeLevel)
            rangeLevel.set_x2(bar_index)

    // Update colors when range is broken
    if not na(rangeBox)
        if close > rangeBox.get_top()
            rangeBox.set_bgcolor(color.new(upCss, 80))
            if not na(rangeLevel)
                rangeLevel.set_color(upCss)
            unbrokenOs := 1
        else if close < rangeBox.get_bottom()
            rangeBox.set_bgcolor(color.new(dnCss, 80))
            if not na(rangeLevel)
                rangeLevel.set_color(dnCss)
            unbrokenOs := -1

    // Set colors for plots
    unbrokenTopColor := unbrokenOs == 0 ? unbrokenCss : unbrokenOs == 1 ? upCss : dnCss
    unbrokenBottomColor := unbrokenTopColor
else
    // Hide visualization when disabled
    if not na(rangeBox)
        box.delete(rangeBox)
    if not na(rangeLevel)
        line.delete(rangeLevel)
    unbrokenMax := na
    unbrokenMin := na
    unbrokenTopColor := na
    unbrokenBottomColor := na

// Plot range boundaries (outside local scope)
plot(show_unbroken_range ? unbrokenMax : na, "Unbroken Range Top",
     color=unbrokenTopColor, linewidth=2, style=plot.style_circles)
plot(show_unbroken_range ? unbrokenMin : na, "Unbroken Range Bottom",
     color=unbrokenBottomColor, linewidth=2, style=plot.style_circles)