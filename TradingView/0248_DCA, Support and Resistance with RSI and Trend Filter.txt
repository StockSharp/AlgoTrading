// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© alescha13
// this script is bases on script from Kieranj https://www.tradingview.com/v/8avMvSbe/

//@version=5
strategy("Support and Resistance with RSI and Trend Filter", overlay=true, default_qty_type = strategy.cash, default_qty_value = 100, initial_capital = 10000, pyramiding = 100)

//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>//

testStartYear = input.int(2023, 'Backtest Start Year', minval=1980)
testStartMonth = input.int(11, 'Backtest Start Month', minval=1, maxval=12)
testStartDay = input.int(1, 'Backtest Start Day', minval=1, maxval=31)
testPeriodStart = timestamp("Etc/UTC", testStartYear, testStartMonth, testStartDay, 0, 0)

testStopYear = input.int(9999, 'Backtest Stop Year', minval=1980)
testStopMonth = input.int(12, 'Backtest Stop Month', minval=1, maxval=12)
testStopDay = input.int(31, 'Backtest Stop Day', minval=1, maxval=31)
testPeriodStop = timestamp("Etc/UTC", testStopYear, testStopMonth, testStopDay, 0, 0)

testPeriod() =>
    time >= testPeriodStart and time <= testPeriodStop ? true : false

start_postion_size = input.float(0, 'Start position size')
start_avg_entry_price = input.float(0, 'Start entry price')


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<//

// === STRATEGY ===
entryEnabled = input(true, title='Enable entries?', group = "General")
closeEnabled = input(true, title='Enable close?', group = "General")

tradeType = input.string('LONG', group = "General", title='What trades should be taken : ', options=['LONG', 'SHORT', 'BOTH', 'NONE'])
switchType_emaLength = input.int(200, title="EMA Period(switch between short and long on both)", minval=1, group = "General")

uha = input(true, title='Use Heikin Ashi Candles', group = "General")
o_rsi = "RSI"
o_mfi = "MFI"
o_crsi = "Connor RSI"
i_osc = input.string(o_rsi, title = "Oscillator Type", options = [o_rsi, o_crsi, o_mfi])

updown(s) =>
    isEqual = s == s[1]
    isGrowing = s > s[1]
    ud = 0.0
    ud := isEqual ? 0 : isGrowing ? (nz(ud[1]) <= 0 ? 1 : nz(ud[1])+1) : (nz(ud[1]) >= 0 ? -1 : nz(ud[1])-1)
    ud
crsi(src, lenrsi) =>
    lenupdown = 2
    lenroc = 100
    rsi = ta.rsi(src, lenrsi)
    updownrsi = ta.rsi(updown(src), lenupdown)
    percentrank = ta.percentrank(ta.roc(src, 1), lenroc)
    crsi = math.avg(rsi, updownrsi, percentrank)
    crsi

f_osc(osc, src, _len) =>
    if osc == o_mfi
        ta.mfi(src, _len)
    else if osc == o_rsi
        ta.rsi(src, _len)
    else
        crsi(src, _len)

f_osc(osc, tickerid, timeframe, src, _len) =>
    request.security(tickerid, timeframe, f_osc(osc, src[1], _len), lookahead = barmerge.lookahead_on)

delayInBars = input.int(12, title="Cooldown(bars)", group = "General")
profitPerc = input.float(0.5, title="Profit %", group = "General")
profitPercTrend = input.float(0.8, title="Profit(full sell) outside trend %", group = "General")
partSellPerc = input.int(20, title="Part. sell %", group = "General")
panicModeEntries = input.int(10, title="Enable panic mode after entries", group = "General")
panicModeProfitPerc = input.float(-1, title="Panic mode profit %", group = "General")
panicModePartSellPerc = input.int(20, title="Panic mode part. sell %", group = "General")


// Use only Heikinashi Candles for all calculations or use Standard Candles for calculations.
tickerid = uha ? ticker.heikinashi(syminfo.tickerid) :  syminfo.tickerid

f_src(tickerid, period, src) =>
    result = request.security(tickerid, period, src)
    result

srcClose = f_src(tickerid, timeframe.period, close)
srcHigh = f_src(tickerid, timeframe.period, high)
srcLow = f_src(tickerid, timeframe.period, low)
//
// BB
useBB = input(false, group = "BB")
bblength = input(50, group = "BB")
bbupmult =input(1.5,title="Multiplier for BB Upper Band", group = "BB")
bblowmult = input(1.5,title="Multiplier for BB Lower Band", group = "BB")

basis =  ta.sma(srcClose,bblength)

devup = bbupmult * ta.stdev(srcClose, bblength)
devlow = bblowmult * ta.stdev(srcClose, bblength)

upper = basis + devup
lower = basis - devlow
plot(basis, color=color.red)
p1 = plot(upper, color=color.blue)
p2 = plot(lower, color=color.blue)
fill(p1, p2)

// Support and Resistance Calculation
useSupportResistence = input(false, title="use S&R?", group = "S&P")
lookbackBars = input(50, title="Lookback Bars", group = "S&P")

highs = ta.highest(high, lookbackBars)
lows = ta.lowest(low, lookbackBars)

supportLevel = ta.valuewhen(low == lows, low, 0)
resistanceLevel = ta.valuewhen(high == highs, high, 0)

plot(supportLevel, color=color.green, linewidth=1, title="Support")
plot(resistanceLevel, color=color.red, linewidth=1, title="Resistance")

// RSI Conditions
rsiLength = input(14, title="RSI Length", group = "RSI")
overboughtThreshold = input(70, title="Overbought Threshold", group = "RSI")
oversoldThreshold = input(40, title="Oversold Threshold", group = "RSI")

rsi = f_osc(i_osc, srcClose, rsiLength)

// Wave trend

useWT = input.bool(title="Use wave trend?", group = "Wave trend", defval=true)
n1 = input.int(title="Channel Length", group = "Wave trend", defval=12) //Channel Length
n2 = input.int(title="Average Length", group = "Wave trend", defval=20) //Average Length
srcWT = input.source(title="Source", group = "Wave trend", defval=hlcc4)
obLevel = input(48, "Overbought Level", group = "Wave trend")
osLevel = input(-48, "Oversold Level", group = "Wave trend")

f_WT(src, n1, n2, obLevel, osLevel) =>
    esa = ta.ema(src, n1)
    d = ta.ema(math.abs(src - esa), n1)
    ci = (src - esa) / (0.015 * d)
    tci = ta.ema(ci, n2)

    wt1 = tci
    wt2 = ta.sma(wt1,4)

    WTBull = ta.crossover(wt1, wt2) and (wt1<osLevel)
    WTBear = ta.crossunder(wt1, wt2) and (wt1>obLevel)
    [WTBull, WTBear, wt1]

ap = request.security(tickerid, timeframe.period, srcWT)
[WTBull, WTBear, WT] = f_WT(ap, n1, n2, obLevel, osLevel)

// Divergence Settings
useDivergences = input.bool(title="Use Divergences?", group="Divergences", defval=false)
srcDivergences = input(title="Source", defval=close, group = "Divergences")
len = input.int(title="RSI Period", minval=1, defval=14)
lbR = input(title="Pivot Lookback Right", defval=5)
lbL = input(title="Pivot Lookback Left", defval=5)
rangeUpper = input(title="Max of Lookback Range", defval=60)
rangeLower = input(title="Min of Lookback Range", defval=5)
_inRange(cond) =>
    bars = ta.barssince(cond)
    rangeLower <= bars and bars <= rangeUpper

f_Divergences(srcDivergences, srcLow, srcHigh) =>
    osc = ta.rsi(srcDivergences, len)
    plFound = not na(ta.pivotlow(osc, lbL, lbR))
    phFound = not na(ta.pivothigh(osc, lbL, lbR))
    // Bullish Divergence
    oscHL = osc[lbR] > ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
    priceLL = srcLow[lbR] < ta.valuewhen(plFound, srcLow[lbR], 1)
    bullCond = priceLL and oscHL and plFound
    // Hidden Bullish Divergence
    oscLL = osc[lbR] < ta.valuewhen(plFound, osc[lbR], 1) and _inRange(plFound[1])
    priceHL = srcLow[lbR] > ta.valuewhen(plFound, srcLow[lbR], 1)
    hiddenBullCond = priceHL and oscLL and plFound
    // Bearish Divergence
    oscLH = osc[lbR] < ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
    priceHH = srcHigh[lbR] > ta.valuewhen(phFound, srcHigh[lbR], 1)
    bearCond = priceHH and oscLH and phFound
    // Hidden Bearish Divergence
    oscHH = osc[lbR] > ta.valuewhen(phFound, osc[lbR], 1) and _inRange(phFound[1])
    priceLH = srcHigh[lbR] < ta.valuewhen(phFound, srcHigh[lbR], 1)
    hiddenBearCond = priceLH and oscHH and phFound
    [bullCond, hiddenBullCond, bearCond, hiddenBearCond]

[bullCond, hiddenBullCond, bearCond, hiddenBearCond] = f_Divergences(srcDivergences, srcLow, srcHigh)

// Volatility Gaussian Bands [BigBeluga]""

useGaussian = input.bool(title="Use Gaussian filter?", group="Volatility Gaussian Bands", defval=false)
//@variable len Length of the Gaussian filter for smoothing (minimum value: 5)
int    gaussian_len         = input.int(20, "Length", group = "Volatility Gaussian Bands", minval = 5)
//@variable mode Select the mode of aggregation to be used: AVG (average), MEADIAN (median), or MODE (mode)
string gaussian_mode        = input.string("AVG", "Type", ["AVG", "MEADIAN", "MODE"], group = "Volatility Gaussian Bands")
//@variable distance Multiplier for calculating the distance between the Gaussian filter and the volatility bands
float  gaussian_distance    = input.float(1, step = 0.1, group = "Volatility Gaussian Bands")

// }

//@function Calculates a Gaussian filter for smoothing the data
//@param src (series float) Source price series
//@param length (int) Length of the filter
//@param sigma (float) Standard deviation for the Gaussian function
//@returns (float) Smoothed value for the current bar
gaussian_filter(src, length, sigma) =>
    var float[] weights = array.new_float(100)  // Create an array to store weights for Gaussian filter
    float total = 0.0                           // Sum of all weights, used for normalization
    float pi = math.pi                          // Define Pi constant

    // Calculate weights for Gaussian filter
    for i = 0 to length - 1
        float weight = math.exp(-0.5 * math.pow((i - length / 2) / sigma, 2.0)) / math.sqrt(sigma * 2.0 * pi)
        weights.set(i, weight)
        total := total + weight

    // Normalize weights
    for i = 0 to length - 1
        weights.set(i, weights.get(i) / total)

    // Apply Gaussian filter to the source series
    float sum = 0.0
    for i = 0 to length - 1
        sum := sum + src[i] * weights.get(i)
    sum

//@function Multi-trend calculation using Gaussian filter
//@param src (series float) Source price series
//@param period (int) Lookback period for trend calculation
//@returns (float[]) Returns score, value, color, trend line, and trend status
multi_trend(src, srcHigh, srcLow,  period) =>
    array<float> g_value     = array.new<float>()       // Array to store Gaussian filtered values
    float        volatility  = ta.sma(srcHigh - srcLow, 100) // Calculate the average true range (ATR) volatility

    var float lower_band = 0.0     // Lower band for trend analysis
    var float upper_band = 0.0    // Upper band for trend analysis
    var float trend_line = 0.0   // Trend line value
    var bool trend = na         // Trend direction status

    // Apply Gaussian filter with a step adjustment to calculate multiple trend lines
    for step = 0 to 20 by 1
        float gaussian_filter = gaussian_filter(src, (period + step), 10)
        g_value.push(gaussian_filter)

    float coeff = 0.05
    float score = 0.0

    // Calculate score based on trend analysis
    for i = 0 to g_value.size() - 1
        float g_f = g_value.get(i)
        if g_f > g_value.first()
            score += coeff

    // Determine value based on user-selected mode (AVG, MEDIAN, MODE)
    float value = switch gaussian_mode
        "AVG"     => g_value.avg()
        "MEADIAN" => g_value.median()
        "MODE"    => g_value.mode()

    lower_band := value - volatility * gaussian_distance   // Calculate lower band based on value and volatility
    upper_band := value + volatility * gaussian_distance  // Calculate upper band based on value and volatility

    // Check crossover and crossunder of price with bands to determine trend
    if ta.crossover(src, upper_band)
        trend := true
    if ta.crossunder(src, lower_band)
        trend := false

    // Set trend line based on trend direction
    trend_line :=
         trend ? lower_band
         : not trend ? upper_band : na

    // Return values: score, trend line, and trend status
    [score, trend_line, trend]

useTSI = input.bool(title="Use TSI trend filter?", group="TSI", defval=false)

//ADX

useADX = input.bool(title="Use ADX trtend filter?", group="ADX", defval=false)
adxlen = input(14, title="ADX Smoothing", group = "ADX")
dilen = input(14, title="DI Length", group = "ADX")

//MACD
useMACDTrend = input.bool(title="Use MACD cloud trend filter?", group="MACD", defval=true)
fast_length = input(title = "Fast Length", group = "MACD", defval = 12)
slow_length = input(title = "Slow Length", group = "MACD", defval = 26)
MACDsrc = input(title = "Source", group = "MACD", defval = close)

signal_length = input.int(title = "Signal Smoothing",  minval = 1, maxval = 50, defval = 9, group = "MACD", display = display.data_window)
sma_source = input.string('EMA', title='Oscillator MA Type', options=["ALMA", "DEMA", "EMA", "LSMA", "RMA", "SMA", "TEMA", "TRIMA", "VWMA", "WMA"], group = "MACD")

alma_offset = input.float(defval=0.85, title="* Arnaud Legoux Moving Average (ALMA) Only - Offset", group = "MACD")
alma_sigma = input.int(defval=6, title="* Arnaud Legoux Moving Average (ALMA) Only - Sigma", group = "MACD")
lsma_offset = input.int(defval=0, title="* Least Squares Moving Average (LSMA) Only - Offset", group = "MACD")

// Calculating

RMA(x, t) =>
    EMA1 = x
    EMA1 := na(EMA1[1]) ? x : (x - nz(EMA1[1])) * (1/t) + nz(EMA1[1])
    EMA1

EMA(x, t) =>
    EMA1 = x
    EMA1 := na(EMA1[1]) ? x : (x - nz(EMA1[1])) * (2 / (t + 1)) + nz(EMA1[1])
    EMA1

ma_variant(type, src, len) =>
    sig = 0.0
    if type == "ALMA"
        sig := ta.alma(src, len, alma_offset, alma_sigma)
    else if type == "SMA"
        sig := ta.sma(src, len)
    else if type == "EMA"
        sig := EMA(src, len)
    else if type == "DEMA"
        sig := 2 * EMA(src, len) - EMA(EMA(src, len), len)
    else if type == "TEMA"
        sig := 3 * (EMA(src, len) - EMA(EMA(src, len), len)) + EMA(EMA(EMA(src, len), len), len)
    else if type == "WMA"
        sig := ta.wma(src, len)
    else if type == "TRIMA"
        sig := ta.sma(ta.sma(src, math.ceil(len / 2)), math.floor(len / 2) + 1)
    else if type == "RMA"
        sig := RMA(src, len)
    else if type == "VWMA"
        sig := ta.vwma(src, len)
    else if type == "LSMA"
        sig := ta.linreg(src, len, lsma_offset)
    sig

f_MACD(MACDsrc, fast_length, slow_length, signal_length, sma_source, sma_signal) =>
    fast_ma = ma_variant(sma_source, MACDsrc, fast_length)
    slow_ma = ma_variant(sma_source, MACDsrc, slow_length)
    macd = fast_ma - slow_ma
    signal = ma_variant(sma_source, macd, signal_length)
    histLine = macd - signal
    histLine

//Schaff Trend Cycle
useSTCTrend = input.bool(title="Use Schaff Trend Cycle trend filter?", group="Schaff Trend Cycle", defval=false)
length = input.int(55, 'Adaptive Logic Length', minval = 1, group = "Schaff Trend Cycle")
lengthInput = input.int(12, 'STC Length', minval = 1, group = "Schaff Trend Cycle")
smoothingFactor = input.float(0.45, 'STC Sensitivity', minval = 0.0001, maxval = 1, group = "Schaff Trend Cycle")
fastLength = input.int(3, 'MACD Fast Length', minval = 1, group = "Schaff Trend Cycle")
slowLength = input.int(10, 'MACD Slow Length', minval = 1, group = "Schaff Trend Cycle")
uptrendThreshold = input.int(-25, 'uptrend threshold value', minval = -50, maxval = 50, group = "Schaff Trend Cycle")
downtrendThreshold = input.int(25, 'downtrend threshold value', minval = -50, maxval = 50, group = "Schaff Trend Cycle")

stc_sma_source = input.string('EMA', title='Oscillator MA Type', options=["ALMA", "DEMA", "EMA", "LSMA", "RMA", "SMA", "TEMA", "TRIMA", "VWMA", "WMA"], group = "Schaff Trend Cycle")

stc_alma_offset = input.float(defval=0.85, title="* Arnaud Legoux Moving Average (ALMA) Only - Offset", group = "Schaff Trend Cycle")
stc_alma_sigma = input.int(defval=6, title="* Arnaud Legoux Moving Average (ALMA) Only - Sigma", group = "Schaff Trend Cycle")
stc_lsma_offset = input.int(defval=0, title="* Least Squares Moving Average (LSMA) Only - Offset", group = "Schaff Trend Cycle")

calculateMACD(source, stc_sma_source, fastLength, slowLength) =>
    fast_MA1 = ma_variant(stc_sma_source, source, fastLength)
    fast_MA2 = ma_variant(stc_sma_source,fast_MA1, fastLength)
    diff_fast = fast_MA1 - fast_MA2
    zlag_fast= fast_MA1 + diff_fast
    slow_MA1 = ma_variant(stc_sma_source, source, slowLength)
    slow_MA2 = ma_variant(stc_sma_source, slow_MA1, slowLength)
    diff_slow = slow_MA1 - slow_MA2
    zlag_slow= slow_MA1 + diff_slow
    macd = 0.0
//    if (m_type == zlagin)
    macd := zlag_fast - zlag_slow
  //  else
  //      macd := fast_MA1 - slow_MA1
    macd

calculateSTC(srcClose, stc_sma_source, lengthInput, fastLength, slowLength) =>
    var normalizedMACD = 0.0
    var smoothedMACD = 0.0
    var smoothedNormalizedMACD = 0.0
    var STCValue = 0.0
    MACDValue = calculateMACD(srcClose, stc_sma_source, fastLength, slowLength)
    lowestMACD = ta.lowest(MACDValue, lengthInput)
    highestMACD = ta.highest(MACDValue, lengthInput) - lowestMACD
    normalizedMACD := highestMACD > 0 ? (MACDValue - lowestMACD) / highestMACD * 100 : nz(normalizedMACD[1])
    smoothedMACD := na(smoothedMACD[1]) ? normalizedMACD : smoothedMACD[1] + smoothingFactor * (normalizedMACD - smoothedMACD[1])
    lowestSmoothedMACD = ta.lowest(smoothedMACD, lengthInput)
    highestSmoothedMACD = ta.highest(smoothedMACD, lengthInput) - lowestSmoothedMACD
    smoothedNormalizedMACD := highestSmoothedMACD > 0 ? (smoothedMACD - lowestSmoothedMACD) / highestSmoothedMACD * 100 : nz(smoothedNormalizedMACD[1])
    STCValue := na(STCValue[1]) ? smoothedNormalizedMACD : STCValue[1] + smoothingFactor * (smoothedNormalizedMACD - STCValue[1])
    [STCValue-50, MACDValue]

//isUptrend = useTrendFilter and request.security(syminfo.tickerid, trendtimeframe, ta.sma(srcClose, 50) > ta.sma(srcClose, 200))
CalcTrend(MACDsrc, srcClose, srcHigh, srcLow, srcBarIndex, rsiLength) =>
    float result = na
    if useTSI
        result := ta.correlation(srcClose, srcBarIndex, rsiLength) > 0 ? 1 : -1
    if useSTCTrend
        [STCValue, MACDValue] = calculateSTC(srcClose, stc_sma_source, lengthInput, fastLength, slowLength)
        result := (na(result) or result > 0) and STCValue[0] >= STCValue[1] and STCValue > uptrendThreshold ? 1 : (na(result) or result < 0) and STCValue[0] <= STCValue[1] and STCValue < downtrendThreshold ? -1 : 0
    if useMACDTrend
        result := (na(result) or result > 0) and f_MACD(MACDsrc, fast_length, slow_length, signal_length, sma_source, sma_source) > 0 ? 1 : (na(result) or result < 0 ? -1 : 0)
    if useADX
        [adx_sig, adx_plus, adx_minus] = ta.dmi(dilen, adxlen)
        result := (na(result) or result > 0) and adx_plus > adx_minus ? 1 : (na(result) or result < 0 ? -1 : 0)
    if useGaussian
        [score, trend_line, trend] = multi_trend(srcClose, srcHigh, srcLow, gaussian_len)
        result := (na(result) or result > 0) and srcClose > trend_line ? (score - 1) * -1 : (na(result) or result < 0 ? ((score - 1) * -1 - 1) : 0)
    result


// Trend Filter
useTrendFilter = input.bool(true, "Use fast trend filter?", group = "Fast trend filter")
fullSellFastTrend = input.bool(true, title="Always full sells on wrong fast trend direction?", group = "Fast trend filter")
fullSellFastTrendSignal = input.bool(false, title="Always full sells on signal?", group = "Fast trend filter")
fast_profitPercSignal = input.float(0.8, title="Profit(full sell) on fast trend signals %", group = "Fast trend filter")
fast_WTobLevel = input(48, "Wavetrend overbought Level", group = "Fast trend filter")
fast_WTosLevel = input(-48, "Wavertrend oversold Level", group = "Fast trend filter")
fast_trendtimeframe = input.timeframe("15", "Fast trend filter timeframe", group = "Fast trend filter")
fast_rsiLength = input(14, title="RSI Length", group = "Fast trend filter")
fast_overboughtThreshold = input(70, title="Overbought Threshold", group = "Fast trend filter")
fast_oversoldThreshold = input(30, title="Oversold Threshold", group = "Fast trend filter")
fast_entrysignalEnabled = input.bool(true, title="Additional entry signal", group = "Fast trend filter")
fast_trendStrengthThreshold = input.int(50, title="Trend strength threshold (enter)", group = "Fast trend filter")
fast_trendStrengthThresholdExit = input.int(50, title="Trend strength threshold (exit)", group = "Fast trend filter")

useTrendFilter2 = input.bool(true, "Use slow trend filter?", group = "Slow trend filter")
fullSellSlowTrend = input.bool(true, title="Always full sells on wrong direction?", group = "Slow trend filter")
fullSellSlowTrendSignal = input.bool(true, title="Always full sells on signal?", group = "Slow trend filter")
slow_profitPercSignal = input.float(0.8, title="Profit(full sell) on slow trend signals %", group = "Slow trend filter")
slow_WTobLevel = input(48, "Wavetrend overbought Level", group = "Slow trend filter")
slow_WTosLevel = input(-48, "Wavertrend oversold Level", group = "Slow trend filter")
slow_thresholdEntries = input.int(1, title="Threshold entries", group = "Slow trend filter")
slow_trendtimeframe = input.timeframe("240", "Slow trend filter timeframe", group = "Slow trend filter")
slow_rsiLength = input(14, title="RSI Length", group = "Slow trend filter")
slow_overboughtThreshold = input(70, title="RSI overbought threshold", group = "Slow trend filter")
slow_oversoldThreshold = input(30, title="RSI oversold threshold", group = "Slow trend filter")
slow_trendStrengthThreshold = input.int(50, title="Trend strength threshold (enter)", group = "Slow trend filter")
slow_trendStrengthThresholdExit = input.int(50, title="Trend strength threshold (exit)", group = "Slow trend filter")

srcMACD = f_src(tickerid, timeframe.period, MACDsrc)

fast_trend = request.security(tickerid, fast_trendtimeframe, CalcTrend(MACDsrc[1], close[1], high[1], low[1], bar_index, fast_rsiLength), lookahead = barmerge.lookahead_on)
slow_trend = request.security(tickerid, slow_trendtimeframe, CalcTrend(MACDsrc[1], close[1], high[1], low[1], bar_index, slow_rsiLength), lookahead = barmerge.lookahead_on)
fast_osc = f_osc(i_osc, tickerid, fast_trendtimeframe, srcClose, fast_rsiLength)
slow_osc = f_osc(i_osc, tickerid, slow_trendtimeframe, srcClose, slow_rsiLength)

isUptrend = useTrendFilter and (fast_trend > 0  or fast_osc < fast_oversoldThreshold and -1 * fast_trend >= fast_trendStrengthThreshold/100. )
isUptrendSlow = useTrendFilter2 and (slow_trend > 0 or slow_osc < slow_oversoldThreshold and -1 * slow_trend >= slow_trendStrengthThreshold/100)
isDowntrend = useTrendFilter and (fast_trend < 0 or fast_osc > fast_overboughtThreshold and fast_trend >= fast_trendStrengthThreshold/100.)
isDowntrendSlow = useTrendFilter2 and (slow_trend < 0 or slow_osc > slow_overboughtThreshold and slow_trend >= slow_trendStrengthThreshold/100.)


//macd = request.security(syminfo.tickerid, trendtimeframe, f_MACD(MACDsrc, fast_length, slow_length, signal_length, sma_source, sma_signal))
//macd = f_MACD(MACDsrc, fast_length, slow_length, signal_length, sma_source, sma_signal)

plotshape(isUptrend or isDowntrend, title='Trend Indicator blocking', location=location.top, color= tradeType == "SHORT" ? (isDowntrend ? color.red : color.black) : isUptrend ? color.green : color.red, style=shape.circle, offset=-1, transp=0)
plotshape(isUptrendSlow or isDowntrendSlow, title='Trend Indicator blocking', location=location.bottom, color= tradeType == "SHORT" ? (isDowntrendSlow? color.red : color.black) : isUptrendSlow ? color.green : color.red, style=shape.circle, offset=-1, transp=0)

[fast_WTBull, fast_WTBear] = request.security(tickerid, fast_trendtimeframe, f_WT(ap[1], n1, n2, fast_WTobLevel, fast_WTosLevel), lookahead = barmerge.lookahead_on)
[slow_WTBull, slow_WTBear] = request.security(tickerid, slow_trendtimeframe, f_WT(ap[1], n1, n2, slow_WTobLevel, slow_WTosLevel), lookahead = barmerge.lookahead_on)

insidePeriod = time >= testPeriodStart and time <= testPeriodStop ? true : false

var fast_lastEntryBar = 0
fast_bar_index = request.security(tickerid, fast_trendtimeframe, bar_index, lookahead = barmerge.lookahead_off)

oversold = not useWT and not useDivergences and ta.crossover(rsi, oversoldThreshold) or  rsi < oversoldThreshold and (useWT and WTBull or useDivergences and (bullCond or hiddenBullCond))
fast_oversold = fast_osc < fast_oversoldThreshold and (useWT and fast_WTBull and fast_entrysignalEnabled) and fast_bar_index != fast_lastEntryBar
// Buy Condition
buyCondition = (oversold or fast_oversold) and (srcClose >= supportLevel or not useSupportResistence) and (not useBB or srcClose < lower) and (isUptrend and useTrendFilter or not useTrendFilter) and (isUptrendSlow and useTrendFilter2 or not useTrendFilter2 or useTrendFilter2 and strategy.opentrades < slow_thresholdEntries or fast_oversold )

overbought = not useWT and not useDivergences and ta.crossunder(rsi, overboughtThreshold) or rsi > overboughtThreshold and ((useWT and WTBear) or (useDivergences and (bearCond or hiddenBearCond)))
fast_overbought = fast_osc > fast_overboughtThreshold and (useWT and fast_WTBear and fast_entrysignalEnabled) and fast_bar_index != fast_lastEntryBar
// Sell Condition
sellCondition = (overbought or fast_overbought) and (srcClose <= resistanceLevel or not useSupportResistence) and (not useBB or srcClose > upper) and (isDowntrend and useTrendFilter or not useTrendFilter) and (isDowntrendSlow and useTrendFilter2 or not useTrendFilter2 or useTrendFilter2 and strategy.opentrades < slow_thresholdEntries or fast_overbought)

slow_emaValue = request.security(tickerid, slow_trendtimeframe, ta.ema(srcClose[1], switchType_emaLength), lookahead = barmerge.lookahead_on)

var int lastEntryBar = 0
var int lastExitBar = 0

var float costs = 0
var float current_position_size = 0

avg_price = current_position_size != 0 ? costs / math.abs(current_position_size) : 0

if closeEnabled and strategy.position_size > 0 and insidePeriod
    if fast_WTBear and useWT and fullSellFastTrendSignal and srcClose > avg_price * (1 + fast_profitPercSignal/100.)
        strategy.close_all(comment = "Full sell long trend fast signal")
        costs := 0
        current_position_size := 0
        lastExitBar := bar_index
    else if slow_WTBear and useWT and fullSellSlowTrendSignal and srcClose > avg_price * (1 + slow_profitPercSignal/100.)
        strategy.close_all(comment = "Full sell long trend slow signal")
        costs := 0
        current_position_size := 0
        lastExitBar := bar_index
    else if overbought
        if (not isUptrend and fullSellFastTrend and useTrendFilter and (not isUptrendSlow or not useTrendFilter2) or not isUptrendSlow and fullSellSlowTrend and useTrendFilter2) and srcClose > avg_price * (1 + profitPercTrend/100.)
            strategy.close_all(comment = "Full sell long trend")
            costs := 0
            current_position_size := 0
            lastExitBar := bar_index
        else
            if (bar_index - lastExitBar) >= delayInBars and math.abs(strategy.position_size) < strategy.default_entry_qty(close) and srcClose > avg_price * (1 + profitPerc/100.)
                strategy.close_all(comment = "Full sell long threshold position size")
                costs := 0
                current_position_size := 0
                lastExitBar := bar_index
            else
                if (fast_trend > 50 and fast_trend < fast_trendStrengthThresholdExit/100. or slow_trend > 50 and slow_trend < slow_trendStrengthThresholdExit /100.) and srcClose > avg_price * (1 + profitPercTrend/100.)
                    strategy.close_all(comment = "Full sell long trend strength")
                    costs := 0
                    current_position_size := 0
                    lastExitBar := bar_index
                else
                    if partSellPerc > 0 and (bar_index - lastExitBar) >= delayInBars and math.abs(strategy.position_size) > strategy.default_entry_qty(close) and srcClose > avg_price * (1 + profitPerc /100.)
                        strategy.close("long", comment = "part. sell long", qty_percent = partSellPerc)
                        lastExitBar := bar_index
                    else
                        qty = strategy.default_entry_qty(close)
                        if partSellPerc > 0 and (bar_index - lastExitBar) >= delayInBars and math.abs(strategy.position_size) > strategy.default_entry_qty(close) and strategy.position_size / qty >= panicModeEntries and srcClose > avg_price * (1 + panicModeProfitPerc /100.)
                            qty := strategy.position_size * ( panicModePartSellPerc /100.)
                            strategy.close("long", comment = "panic sell long", qty = qty)
                            current_position_size -= qty
                            costs -= qty * avg_price
                            lastExitBar := bar_index
if closeEnabled and strategy.position_size < 0 and insidePeriod
    if fast_WTBull and fullSellFastTrendSignal and useWT and srcClose < avg_price * (1 - fast_profitPercSignal/100.)
        strategy.close_all(comment = "Full sell long fast trend signal")
        costs := 0
        current_position_size := 0
        lastExitBar := bar_index
    else if useWT and slow_WTBull and fullSellSlowTrendSignal and srcClose < avg_price * (1 - slow_profitPercSignal/100.)
        strategy.close_all(comment = "Full sell long slow trend signal")
        costs := 0
        current_position_size := 0
        lastExitBar := bar_index
    else if oversold
        if (not isDowntrend and fullSellFastTrend and useTrendFilter or not isDowntrendSlow and fullSellSlowTrend and useTrendFilter2) and srcClose < avg_price * (1 - profitPercTrend/100.)
            strategy.close_all(comment = "Full sell short trend")
            costs := 0
            current_position_size := 0
            lastExitBar := bar_index
        else
            if (bar_index - lastExitBar) >= delayInBars and math.abs(strategy.position_size) < strategy.default_entry_qty(close) and srcClose < avg_price * (1 - profitPerc/100.)
                strategy.close_all(comment = "Full sell short threshold position size")
                current_position_size := 0
                costs := 0
                lastExitBar := bar_index
            else
                if (fast_trend > -1*fast_trendStrengthThresholdExit/100 or slow_trend > -1 * slow_trendStrengthThresholdExit /100) and srcClose < avg_price * (1 - profitPercTrend/100.)
                    strategy.close_all(comment = "Full sell short trend strength")
                    current_position_size := 0
                    costs := 0
                    lastExitBar := bar_index
                else
                    if partSellPerc > 0 and (bar_index - lastExitBar) >= delayInBars and (srcClose < avg_price * (1 - profitPerc/100.) or slow_WTBear and strategy.opentrades >= panicModeEntries  and srcClose < avg_price * (1 - panicModeProfitPerc/100.))  and math.abs(strategy.position_size) > strategy.default_entry_qty(close)
                        strategy.close("short", comment = "Part. sell short", qty_percent = partSellPerc)
                        lastExitBar := bar_index
                    else
                        qty = strategy.default_entry_qty(close)
                        if partSellPerc > 0 and (bar_index - lastExitBar) >= delayInBars and math.abs(strategy.position_size) > strategy.default_entry_qty(close) and math.abs(strategy.position_size) / qty >= panicModeEntries and srcClose < avg_price * (1 - panicModeProfitPerc /100.)
                            qty := math.abs(strategy.position_size) * ( panicModePartSellPerc /100.)
                            strategy.close("long", comment = "panic sell short", qty = qty)
                            current_position_size += qty
                            costs -= qty * avg_price
                            lastExitBar := bar_index

vol_index() =>
    idx = ta.sma(100*math.abs(high-low)/close,20)
    idx

CalcQtyMuliplier(vol_index) =>
    m = 1.
    if vol_index < 3
        m := 2.
    else if vol_index < 7
        m := 0.5
    else
        m := 0.25
    m

vol_index = request.security(tickerid, "D", vol_index(), lookahead = barmerge.lookahead_on)


if entryEnabled and insidePeriod
    if buyCondition and not (slow_WTBear and useWT and fullSellSlowTrendSignal) and (fast_osc < fast_overboughtThreshold and useTrendFilter or not useTrendFilter) and (slow_osc < slow_overboughtThreshold and useTrendFilter2 or not useTrendFilter2) and (bar_index - lastEntryBar) >= delayInBars and lastExitBar != bar_index and strategy.position_size >= 0 and (tradeType == "BOTH" and (srcClose >= slow_emaValue or strategy.position_size > 0) or tradeType == "LONG")
        m = CalcQtyMuliplier(vol_index)
        qty = strategy.default_entry_qty(close)
        current_position_size += qty
        costs += qty * close
        strategy.entry("long", strategy.long, qty = qty)
        lastEntryBar := bar_index
        fast_lastEntryBar := fast_bar_index
    if sellCondition and not (slow_WTBull and useWT and fullSellSlowTrendSignal) and (fast_osc > fast_oversoldThreshold and useTrendFilter or not useTrendFilter) and (slow_osc > slow_oversoldThreshold and useTrendFilter2 or not useTrendFilter2)  and (bar_index - lastEntryBar) >= delayInBars and lastExitBar != bar_index and strategy.position_size <= 0 and (tradeType == "BOTH" and (srcClose <= slow_emaValue or strategy.position_size < 0) or tradeType == "SHORT")
        qty = strategy.default_entry_qty(close)
        current_position_size -= qty
        costs += math.abs(qty) * close
        strategy.entry("short", strategy.short, qty)
        lastEntryBar := bar_index
        fast_lastEntryBar := fast_bar_index

if not insidePeriod and start_postion_size != 0 and current_position_size == 0
    if math.abs(start_avg_entry_price  - close) < close * 0.00025
        strategy.entry(start_postion_size > 0 ? "long" : "short", start_postion_size > 0 ? strategy.long : strategy.short, math.abs(start_postion_size))
        current_position_size += start_postion_size
        costs += math.abs(start_postion_size) * close



// Plotting Buy/Sell Signals
//plotshape(buyCondition, title="Buy Signal", location=location.belowbar, color=color.green, style=shape.labelup, text="BUY")
//plotshape(sellCondition, title="Sell Signal", location=location.abovebar, color=color.red, style=shape.labeldown, text="SELL")

// Plotting RSI
//hline(overboughtThreshold, "Overbought", color=color.red)
//hline(oversoldThreshold, "Oversold", color=color.green)
//plot(rsi, title="RSI", color=color.orange, linewidth=2)