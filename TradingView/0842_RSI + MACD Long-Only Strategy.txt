//@version=6
// Vibe coded by Andrew Grothe 2025-08-08. Adjust the TP/SL on lines 28 & 29 to fine tune the strategy
strategy("RSI + MACD Long-Only Strategy", overlay=true, pyramiding=0, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.0)

// Inputs — RSI
rsiLen  = input.int(14, "RSI Length", minval=1, group="RSI")
rsiOB   = input.int(70, "RSI Overbought", minval=50, maxval=100, group="RSI")
rsiOS   = input.int(30, "RSI Oversold", minval=0,  maxval=50, group="RSI")
rsiMid  = input.int(50, "RSI Midline", minval=0,   maxval=100, group="RSI")

// Inputs — MACD
fastLen = input.int(12, "MACD Fast Length",   minval=1, group="MACD")
slowLen = input.int(26, "MACD Slow Length",   minval=1, group="MACD")
sigLen  = input.int(9,  "MACD Signal Length", minval=1, group="MACD")
requireAboveZero = input.bool(false, "Require MACD > 0 (trend filter)", group="MACD")

// Inputs — Filters & Visuals
useOversoldContext  = input.bool(false, "Entry must be within N bars after RSI < Oversold", group="Signals")
oversoldWindowBars  = input.int(10, "N bars after oversold", minval=1, group="Signals")
useEMATrend         = input.bool(false, "Only Long if price > EMA", group="Signals")
emaLen              = input.int(200, "EMA Length", minval=1, group="Signals")
showMarkers         = input.bool(true, "Plot Entry/Exit Markers", group="Visuals")
colorBars           = input.bool(false, "Color Bars on Signals", group="Visuals")

// Inputs — Risk
// 1 hour = 2.0/1.0, 2 hour = 10.5/2.5
useTPSL             = input.bool(true,  "Use Take Profit / Stop Loss", group="Risk")
tpPerc              = input.float(11.5,  "Take Profit %", minval=0.0, step=0.1, group="Risk")
slPerc              = input.float(2.5,  "Stop Loss %",  minval=0.0, step=0.1, group="Risk")

// Core calculations
rsi = ta.rsi(close, rsiLen)
[macd, macdSignal, macdHist] = ta.macd(close, fastLen, slowLen, sigLen)
emaTrend = ta.ema(close, emaLen)

// Conditions
macdBull = macd > macdSignal and (not requireAboveZero or macd > 0)
rsiBull  = rsi > rsiMid
recentlyOversold = ta.barssince(rsi < rsiOS) <= oversoldWindowBars
trendOk = not useEMATrend or close > emaTrend

// Precompute cross events to avoid conditional execution warnings
rsiCrossUpMid     = ta.crossover(rsi, rsiMid)
macdCrossUp       = ta.crossover(macd, macdSignal)
rsiCrossDownMid   = ta.crossunder(rsi, rsiMid)
macdCrossDown     = ta.crossunder(macd, macdSignal)

// Signals (long-only)
longTrigger = (rsiCrossUpMid and macdBull) or (macdCrossUp and rsi >= rsiMid)
longEntry   = longTrigger and (not useOversoldContext or recentlyOversold) and trendOk
exitSignal  = rsiCrossDownMid or (macdCrossDown and macdHist <= 0)

// Stateful gating so we only get one exit per entry
var bool inLong = false
inLongPrev = barstate.isfirst ? false : inLong[1]
finalLongEntry = longEntry and not inLongPrev
finalExit      = exitSignal and inLongPrev
inLong := (inLongPrev or finalLongEntry) and not finalExit

// Plots
plot(useEMATrend ? emaTrend : na, title="EMA", color=color.orange, linewidth=2)
plotshape(showMarkers and finalLongEntry,  title="Long Entry", style=shape.triangleup,   location=location.belowbar, color=color.lime, size=size.tiny, text="Long")
plotshape(showMarkers and finalExit,       title="Exit",       style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.tiny, text="Exit")
barcolor(colorBars ? (finalLongEntry ? color.lime : finalExit ? color.red : na) : na)

// Debug background to visualize when raw long trigger occurs
bgcolor(longTrigger ? color.new(color.lime, 90) : na)

// Alerts
//alertcondition(finalLongEntry,  title="RSI+MACD Long Entry", message="RSI+MACD Long Entry on {{ticker}} {{interval}} at {{close}}")
//alertcondition(finalExit,       title="RSI+MACD Exit",       message="RSI+MACD Exit on {{ticker}} {{interval}} at {{close}}")

// Strategy Orders — Long only
if finalLongEntry
    strategy.entry("Long", strategy.long)

// Protective exits (TP/SL) while in position
if useTPSL and strategy.position_size > 0
    longSL = strategy.position_avg_price * (1 - slPerc / 100.0)
    longTP = strategy.position_avg_price * (1 + tpPerc / 100.0)
    strategy.exit("Long TP/SL", from_entry="Long", stop=longSL, limit=longTP)

// Signal-based exit
if finalExit and strategy.position_size > 0
    strategy.close("Long", comment="Signal Exit")