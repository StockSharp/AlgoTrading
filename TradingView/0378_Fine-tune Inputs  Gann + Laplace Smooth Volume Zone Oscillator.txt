//@version=5
strategy("Fine-tune GannLSVZO Strategy [Algo Alert]", precision = 2, default_qty_type ="percent_of_equity" , default_qty_value = 15 ,overlay = false)

// Importing required libraries
import TradingView/ta/5
//import AutomatedTradingAlgorithms/math_Fourier_test/12 as math
//import AutomatedTradingAlgorithms/math/4
import AutomatedTradingAlgorithms/math/4 as math
gannvzo = input.bool(true,"Gann vzo",inline = "showF4GannML")
gannentry = input.bool(true,"Gann entry",inline = "showF4GannML")
short = input.bool(false, "if true: short ; else close")
close_all = input.bool(true,"Enable Close all", tooltip=" Position is always 1 or -1 if false, and 1, 0 or -1 if true. 0 Is falling above 0 or rising bellow 0")
Static_laplace = input.bool(true,group = "laplace")

DefaultGannMLSetting = "[Color][ChoCh Gann][ChoCh SGann]"
showF1GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")
showSF1GannML = true // input.bool(true,"F1", group = DefaultGannMLSetting,inline = "showF1GannML")
colorF1GannML = input.color(color.aqua, '', group = DefaultGannMLSetting,inline = "showF1GannML")
showChoChF1GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")
showChoChSF1GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF1GannML")

showF2GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF2GannML")
showSF2GannML = true // input.bool(true,"F2", group = DefaultGannMLSetting,inline = "showF2GannML")
colorF2GannML = input.color(color.yellow, '', group = DefaultGannMLSetting,inline = "showF2GannML")
showChoChF2GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF2GannML")
showChoChSF2GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF2GannML")

showF3GannML = true // input.bool(true,"", group = DefaultGannMLSetting,inline = "showF3GannML")
showSF3GannML = true //
colorF3GannML = input.color(color.purple, '', group = DefaultGannMLSetting,inline = "showF3GannML")
showChoChF3GannML = input.bool(true,"", group = DefaultGannMLSetting,inline = "showF3GannML")
showChoChSF3GannML = false // input.bool(false,"", group = DefaultGannMLSetting,inline = "showF3GannML")


//  Credit to meomeo105 for writing the gann swing part

f_CalculateF0(_pointX,_pointY,arrayX0,arrayY0)=>
    array.unshift(arrayX0,_pointX)
    array.unshift(arrayY0,_pointY)
    [1]

f_CalculateFn1(_pointX,_pointY,arrayXn,arrayYn,arrayXFn1,arrayYFn1)=>
    //_resultdraw 2:Tiếp tục 1:Đảo chiều
    int _resultdraw = 0
    //OSB pha dinh/day
    if((array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and array.get(arrayYn,0) < array.get(arrayYFn1,1)) or (array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and array.get(arrayYn,0) > array.get(arrayYFn1,1)))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    //Dao chieu sang giam
    else if(array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and (array.get(arrayYn,0) < array.get(arrayYn,1) and array.get(arrayYn,0) < array.get(arrayYn,2) and array.get(arrayYn,1) < array.get(arrayYn,3)) and array.get(arrayYn,2) < array.get(arrayYn,3))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    //Dao chieu sang tang
    else if(array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and (array.get(arrayYn,0) > array.get(arrayYn,1) and array.get(arrayYn,0) > array.get(arrayYn,2) and array.get(arrayYn,1) > array.get(arrayYn,3)) and array.get(arrayYn,2) > array.get(arrayYn,3))
        array.unshift(arrayXFn1,_pointX)
        array.unshift(arrayYFn1,_pointY)
        _resultdraw := 1
    else if(array.get(arrayYFn1,0) >= array.get(arrayYFn1,1) and _pointY >= array.get(arrayYFn1,0) and (_pointY >= array.get(arrayYFn1,0) or (array.get(arrayYn,0) > array.get(arrayYn,2) and array.get(arrayYn,2) > array.get(arrayYn,1)) or (array.get(arrayYn,0) > array.get(arrayYn,1) and array.get(arrayYn,1) > array.get(arrayYn,2) and array.get(arrayYn,2) > array.get(arrayYn,3))))
        array.set(arrayXFn1, 0, _pointX)
        array.set(arrayYFn1, 0, _pointY)
        _resultdraw := 2
    else if(array.get(arrayYFn1,0) <= array.get(arrayYFn1,1) and _pointY <= array.get(arrayYFn1,0) and (_pointY <= array.get(arrayYFn1,0) or (array.get(arrayYn,0) < array.get(arrayYn,2) and array.get(arrayYn,2) < array.get(arrayYn,1)) or (array.get(arrayYn,0) < array.get(arrayYn,1) and array.get(arrayYn,1) < array.get(arrayYn,2) and array.get(arrayYn,2) < array.get(arrayYn,3))))
        array.set(arrayXFn1, 0, _pointX)
        array.set(arrayYFn1, 0, _pointY)
        _resultdraw := 2
    [_resultdraw]

f_CalculateSFn1(_pointX,_pointY,_arrayMark,_mIdxMark,arraySXFn1,arraySYFn1)=>
    int _resultdraw = 0
    if(array.get(_arrayMark,_mIdxMark) == 0)
        if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY >= array.get(arraySYFn1,0)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY <= array.get(arraySYFn1,0)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            _resultdraw := 2
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            _resultdraw := 1
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,0) and _pointY > array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,0) and _pointY < array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            array.set(_arrayMark,_mIdxMark,_pointY)
            _resultdraw := 1
    else if(array.get(_arrayMark,_mIdxMark) > 0)
        if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,1)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,1)))
            array.unshift(arraySXFn1,_pointX)
            array.unshift(arraySYFn1,_pointY)
            array.set(_arrayMark,_mIdxMark,0)
            _resultdraw := 1
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY > array.get(arraySYFn1,2)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY < array.get(arraySYFn1,2)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            array.set(_arrayMark,_mIdxMark,0)
            _resultdraw := 2
        else if((array.get(arraySYFn1,0) >= array.get(arraySYFn1,1) and _pointY <= array.get(arraySYFn1,2) and _pointY >= array.get(arraySYFn1,0)) or (array.get(arraySYFn1,0) <= array.get(arraySYFn1,1) and _pointY >= array.get(arraySYFn1,2) and _pointY <= array.get(arraySYFn1,0)))
            array.set(arraySXFn1, 0, _pointX)
            array.set(arraySYFn1, 0, _pointY)
            array.set(_arrayMark,_mIdxMark,_pointY)
            _resultdraw := 2

    [_resultdraw]

f_CalculateRemoveDuplicateLine(arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1)=>
    if(array.size(arrayLineX0) > 1 and array.size(arrayLineSX0) >1)
        if(array.get(arrayLineSY1,1) ==  array.get(arrayLineY1,1) and   array.get(arrayLineSY0,1) ==  array.get(arrayLineY0,1)   and array.get(arrayLineSX1,1) == array.get(arrayLineX1,1) and array.get(arrayLineSX0,1) ==array.get(arrayLineX0,1)     )
        //if(line.get_y1(array.get(arraySLine,1)) == line.get_y1(array.get(arrayLine,1)) and line.get_y2(array.get(arraySLine,1)) == line.get_y2(array.get(arrayLine,1))and line.get_x1(array.get(arraySLine,1)) == line.get_x1(array.get(arrayLine,1)) and line.get_x2(array.get(arraySLine,1)) == line.get_x2(array.get(arrayLine,1)))
            //line.delete(array.get(arrayLine,1))
            array.remove(arrayLineX0,1)
            array.remove(arrayLineY0,1)
            array.remove(arrayLineX1,1)
            array.remove(arrayLineY1,1)


f_CalculateChoCh(arraySXFn1,arraySYFn1) =>
    int _X = 0
    float _Y = 0
    // ChoCh Trường hợp chữ N ngược, chữ N
    if((array.get(arraySYFn1,3) > array.get(arraySYFn1,2) and array.get(arraySYFn1,3) < array.get(arraySYFn1,1) and array.get(arraySYFn1,0) < array.get(arraySYFn1,2)) or (array.get(arraySYFn1,3) < array.get(arraySYFn1,2) and array.get(arraySYFn1,3) > array.get(arraySYFn1,1) and array.get(arraySYFn1,0) > array.get(arraySYFn1,2)))
        _X := array.get(arraySXFn1,2)
        _Y := array.get(arraySYFn1,2)
    [_X,_Y]

f_CalculateDrawF(_drawF,_showSF,arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayX,arrayY,showChoCh,arrayMChoCh,idxChoCh,_color) =>
    if(_drawF > 0)
        if(_drawF == 1)
            array.unshift(arrayLineX0,array.get(arrayX,1))
            array.unshift(arrayLineY0,array.get(arrayY,1))
            array.unshift(arrayLineX1,array.get(arrayX,0))
            array.unshift(arrayLineY1,array.get(arrayY,0))

        else if(_drawF == 2 and array.size(arrayLineX0) >0)
            array.set(arrayLineX0,0,array.get(arrayX,0))
            array.set(arrayLineY0,0,array.get(arrayY,0))

        [XChoCh,YChoCh] = f_CalculateChoCh(arrayX,arrayY)
        if(showChoCh and YChoCh >0 and array.get(arrayMChoCh,idxChoCh) != YChoCh)
            array.set(arrayMChoCh,idxChoCh,YChoCh)
            //line.new(XChoCh,YChoCh,time,YChoCh, color = _color,xloc = xloc.bar_time,width = 1,style = line.style_dotted)

f_CalculateDrawSF(_drawSF,arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1,arraySX,arraySY,showChoCh,arrayMChoCh,idxChoCh,_color) =>
    if(_drawSF > 0)
        if(_drawSF == 1)
            array.unshift(arrayLineSX0,array.get(arraySX,1))
            array.unshift(arrayLineSY0,array.get(arraySY,1))
            array.unshift(arrayLineSX1,array.get(arraySX,0))
            array.unshift(arrayLineSY1,array.get(arraySY,0))
        else if(_drawSF == 2 and array.size(arrayLineSX0) >0)
            array.set(arrayLineSX0,0,array.get(arraySX,0))
            array.set(arrayLineSY0,0,array.get(arraySY,0))
        f_CalculateRemoveDuplicateLine(arrayLineX0,arrayLineY0,arrayLineX1,arrayLineY1,arrayLineSX0,arrayLineSY0,arrayLineSX1,arrayLineSY1)
        [XChoChS,YChoChS] = f_CalculateChoCh(arraySX,arraySY)
        if(showChoCh and YChoChS >0 and array.get(arrayMChoCh,idxChoCh) != YChoChS)
            array.set(arrayMChoCh,idxChoCh,YChoChS)
            //line.new(XChoChS,YChoChS,time,YChoChS, color = _color,xloc = xloc.bar_time,width = 1,style = line.style_dashed)

var arrayMarkGannML = array.new_float(3,0)
var arrayMarkChoChGannML = array.new_float(6,0)
var arrayXF0GannML = array.new_int(5,time)
var arrayYF0GannML = array.new_float(5,close)
var arrayXF1GannML = array.new_int(5,time)
var arrayYF1GannML = array.new_float(5,close)
var arrayLineXF1_0GannML = array.new_int()
var arrayLineYF1_0GannML = array.new_float()
var arrayLineXF1_1GannML = array.new_int()
var arrayLineYF1_1GannML = array.new_float()
var arrayLineF1GannML = array.new_line()
var arraySXF1GannML = array.new_int(5,time)
var arraySYF1GannML = array.new_float(5,close)
var arrayLineSXF1_0GannML = array.new_int()
var arrayLineSYF1_0GannML = array.new_float()
var arrayLineSXF1_1GannML = array.new_int()
var arrayLineSYF1_1GannML = array.new_float()
var arraySLineF1GannML = array.new_line()
var arrayXF2GannML = array.new_int(5,time)
var arrayYF2GannML = array.new_float(5,close)
var arrayLineXF2_0GannML = array.new_int()
var arrayLineYF2_0GannML = array.new_float()
var arrayLineXF2_1GannML = array.new_int()
var arrayLineYF2_1GannML = array.new_float()
var arrayLineF2GannML = array.new_line()
var arraySXF2GannML = array.new_int(5,time)
var arraySYF2GannML = array.new_float(5,close)
var arrayLineSXF2_0GannML = array.new_int()
var arrayLineSYF2_0GannML = array.new_float()
var arrayLineSXF2_1GannML = array.new_int()
var arrayLineSYF2_1GannML = array.new_float()

var arraySLineF2GannML = array.new_line()
var arrayXF3GannML = array.new_int(5,time)
var arrayYF3GannML = array.new_float(5,close)
var arrayLineXF3_0GannML = array.new_int()
var arrayLineYF3_0GannML = array.new_float()
var arrayLineXF3_1GannML = array.new_int()
var arrayLineYF3_1GannML = array.new_float()
var arrayLineF3GannML = array.new_line()
var arraySXF3GannML = array.new_int(5,time)
var arraySYF3GannML = array.new_float(5,close)
var arrayLineSXF3_0GannML = array.new_int()
var arrayLineSYF3_0GannML = array.new_float()
var arrayLineSXF3_1GannML = array.new_int()
var arrayLineSYF3_1GannML = array.new_float()
var arraySLineF3GannML = array.new_line()

f_CalculateAndDrawFn1(_pointX,_pointY) =>
    //F0 : Song cua nen
    array.unshift(arrayXF0GannML,_pointX)
    array.unshift(arrayYF0GannML,_pointY)
    //F1,F2,...: Song cua song theo Gann
    if(showF1GannML or showF2GannML or showF3GannML or showSF1GannML or showSF2GannML or showSF3GannML)
        [drawF1] = f_CalculateFn1(_pointX,_pointY,arrayXF0GannML,arrayYF0GannML,arrayXF1GannML,arrayYF1GannML)
        f_CalculateDrawF(showF1GannML?drawF1:0,showSF1GannML,arrayLineXF1_0GannML,arrayLineYF1_0GannML,arrayLineXF1_1GannML,arrayLineYF1_1GannML ,arrayXF1GannML,arrayYF1GannML,showChoChF1GannML,arrayMarkChoChGannML,0,colorF1GannML)
        if(drawF1 > 0 and (showF2GannML or showF3GannML or showSF1GannML or showSF2GannML or showSF3GannML))
            [drawSF1] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,0,arraySXF1GannML,arraySYF1GannML)
            f_CalculateDrawSF(showSF1GannML?drawSF1:0,arrayLineXF1_0GannML,arrayLineYF1_0GannML,arrayLineXF1_1GannML,arrayLineYF1_1GannML ,arrayLineSXF1_0GannML,arrayLineSYF1_0GannML,arrayLineSXF1_1GannML,arrayLineSYF1_1GannML ,arraySXF1GannML,arraySYF1GannML,showChoChSF1GannML,arrayMarkChoChGannML,1,colorF1GannML)
            if(drawSF1 > 0 and (showF2GannML or showF3GannML or showSF2GannML or showSF3GannML))
                [drawF2] = f_CalculateFn1(_pointX,_pointY,arraySXF1GannML,arraySYF1GannML,arrayXF2GannML,arrayYF2GannML)
                f_CalculateDrawF(showF2GannML?drawF2:0,showSF2GannML,arrayLineXF2_0GannML,arrayLineYF2_0GannML,arrayLineXF2_1GannML,arrayLineYF2_1GannML ,arrayXF2GannML,arrayYF2GannML,showChoChF2GannML,arrayMarkChoChGannML,2,colorF2GannML)
                if(drawF2 > 0 and (showF3GannML or showSF2GannML or showSF3GannML))
                    [drawSF2] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,1,arraySXF2GannML,arraySYF2GannML)
                    f_CalculateDrawSF(showSF2GannML?drawSF2:0,arrayLineXF2_0GannML,arrayLineYF2_0GannML,arrayLineXF2_1GannML,arrayLineYF2_1GannML ,arrayLineSXF2_0GannML,arrayLineSYF2_0GannML,arrayLineSXF2_1GannML,arrayLineSYF2_1GannML ,arraySXF2GannML,arraySYF2GannML,showChoChSF2GannML,arrayMarkChoChGannML,3,colorF2GannML)
                    if(drawSF2 > 0 and (showF3GannML or showSF3GannML))
                        [drawF3] = f_CalculateFn1(_pointX,_pointY,arraySXF2GannML,arraySYF2GannML,arrayXF3GannML,arrayYF3GannML)
                        f_CalculateDrawF(showF3GannML?drawF3:0,showSF3GannML,arrayLineXF3_0GannML,arrayLineYF3_0GannML,arrayLineXF3_1GannML,arrayLineYF3_1GannML,arrayXF3GannML,arrayYF3GannML,showChoChF3GannML,arrayMarkChoChGannML,4,colorF3GannML)
                        if(drawF3 > 0 and (showSF3GannML))
                            [drawSF3] = f_CalculateSFn1(_pointX,_pointY,arrayMarkGannML,2,arraySXF3GannML,arraySYF3GannML)
                            f_CalculateDrawSF(showSF3GannML?drawSF3:0,arrayLineXF3_0GannML,arrayLineYF3_0GannML,arrayLineXF3_1GannML,arrayLineYF3_1GannML,arrayLineSXF3_0GannML,arrayLineSYF3_0GannML,arrayLineSXF3_1GannML,arrayLineSYF3_1GannML,arraySXF3GannML,arraySYF3GannML,showChoChSF3GannML,arrayMarkChoChGannML,5,colorF3GannML)

f_CalculateAndDraw(_pointX,_pointY1,_pointY2) =>
    if((array.get(arrayYF0GannML,0) > _pointY1 and array.get(arrayYF0GannML,0) > _pointY2) or (array.get(arrayYF0GannML,0) < _pointY1 and array.get(arrayYF0GannML,0) < _pointY2))
        f_CalculateAndDrawFn1(time,array.get(arrayYF0GannML,1))
    f_CalculateAndDrawFn1(time,_pointY1)
    f_CalculateAndDrawFn1(time,_pointY2)

highPrev = high
lowPrev = low
if(true)
    if(high > highPrev[1] and low > lowPrev[1])
        f_CalculateAndDraw(time,low,high)
    else if(high < highPrev[1] and low < lowPrev[1])
        f_CalculateAndDraw(time,high,low)
    else if((high >= highPrev[1] and low < lowPrev[1]) or (high > highPrev[1] and low <= lowPrev[1]))
        if(close > open)
            f_CalculateAndDraw(time,low,high)
        else
            f_CalculateAndDraw(time,high,low)
    else if(high[0] <= highPrev[1] and low[0] >= lowPrev[1])
        highPrev := highPrev[1]
        lowPrev := lowPrev[1]
//plot(array.get(arrayMarkChoChGannML,1), color = colorF1GannML)
//plot(array.get(arrayMarkChoChGannML,1)[1], color =colorF1GannML )

//plot(array.get(arrayMarkChoChGannML,2), color = colorF2GannML)
//plot(array.get(arrayMarkChoChGannML,2)[1], color = colorF2GannML)
//plot(array.get(arrayMarkChoChGannML,3), color = colorF3GannML)
//plot(array.get(arrayMarkChoChGannML,3)[1], color =colorF3GannML)
//plot(array.get(arrayMarkChoChGannML,4))
//plot(array.get(arrayMarkChoChGannML,4)[1])



var aaa = true
var bbb = true
var eee = true
var fff = true
var a2 = true
var b2 = true
var a3 = true
var b3 = true


if array.get(arrayMarkChoChGannML,4) < array.get(arrayMarkChoChGannML,4)[1]
    aaa := true
    bbb := false
if array.get(arrayMarkChoChGannML,4) > array.get(arrayMarkChoChGannML,4)[1]
    aaa := false
    bbb := true

if array.get(arrayMarkChoChGannML,1) < array.get(arrayMarkChoChGannML,1)[1]
    eee := true
    fff := false
if array.get(arrayMarkChoChGannML,1) > array.get(arrayMarkChoChGannML,1)[1]
    eee := false
    fff := true

if array.get(arrayMarkChoChGannML,3) < array.get(arrayMarkChoChGannML,3)[1]
    a3 := true
    b3 := false
if array.get(arrayMarkChoChGannML,3) > array.get(arrayMarkChoChGannML,3)[1]
    a3 := false
    b3 := true

if array.get(arrayMarkChoChGannML,2) < array.get(arrayMarkChoChGannML,2)[1]
    a2 := true
    b2 := false
if array.get(arrayMarkChoChGannML,2) > array.get(arrayMarkChoChGannML,2)[1]
    a2 := false
    b2 := true

ccc = array.get(arrayMarkChoChGannML,0) != array.get(arrayMarkChoChGannML,0)[1] and array.get(arrayMarkChoChGannML,0) < high and ( array.get(arrayMarkChoChGannML,0) > close[1] ) and  ( fff or (bbb or b2 or b3)) ? true : false
ddd = array.get(arrayMarkChoChGannML,0) != array.get(arrayMarkChoChGannML,0)[1] and array.get(arrayMarkChoChGannML,0) > low and ( array.get(arrayMarkChoChGannML,0) < close[1] ) and (  eee or (aaa or a2 or a3)) ? true : false

var position_gann = 1
toggle = true //, "Stay in trade for longer.")

if ((ddd[0]   )and short   )
    //strategy.entry("short",strategy.short)
    //strategy.entry("short",strategy.short)
    position_gann := -1
if ((ccc or (((bbb and b2 and b3)) and toggle) ) and not (((ddd[0] and not short) or not (ccc or (((bbb and b2 and b3) and fff) and toggle))))  )
    //strategy.entry("long",strategy.long)
    position_gann := 1





if (((ddd[0] and not short) or not (ccc and not short or (((bbb and b2 and b3) and fff) and toggle))))
    //strategy.entry("short",strategy.short)
    //strategy.close_all()
    position_gann := 0





plot(position_gann , "gann_position" , display=display.status_line)
// Input options for enabling new versions of DFT and whitenoise
version2 = input.bool(title = 'Double Fourier', tooltip="Improved Fourier Transform" ,defval = true, group = "VZO")
version3 = input.bool(title = 'Improved whitenoise', tooltip="Improved Noice Reduction using mathimated price aswell ad close price.", defval = true, group = "VZO")

magic = input.bool(title = 'Magical Wavelet mathimation',tooltip="Uses Wavelet as Main math. instead of Fourier", defval = false, group = "Edition")
xval=close
alpha = input.float(-0.15,"laplace alpha",step = 0.01)
beta = input.float(0.1,"laplace beta",step = 0.01)

N = input(9,"laplace N")
repeat = input(2,"laplace repeat")





// Define the number of closing prices to consider
nnn = input(11,"dinamic laplace" ,group = "laplace")
// Calculate parameters
[a, k, b, l] = math.calculateParameters(n=nnn)

// Plot the calculated parameters
//plot(a, color=color.red, title="a")
//plot(k, color=color.blue, title="k")
//plot(b, color=color.green, title="b")
//plot(l, color=color.yellow, title="l")
//alpha=k
//betta=l

// FAST FOURIER TRANSFORM
// Selecting either DTF32 or FFT based on user preference
//dft = math.N_divLaplaceTransformsum(N=N,a=alpha,b=beta,repeat = repeat)



dft=   math.LaplaceStieltjesTransform(xval = close ,  N = N,  a = Static_laplace? alpha : gannvzo ?  k*position_gann : k , b = Static_laplace ? beta : l, c = gannvzo ? alpha*position_gann : alpha, d = beta, repeat=repeat)

//dft= dft1

// VZO (Volume Zone Oscillator) calculation with EMA smoothing
lengthV = input(10, title='VZO Length', tooltip="I suggest 2 for FAST and 5 or 7 for SLOW. Using FAST setting require averaging more than 1 Timeframe together. ", group = "VZO")
VZO_1 = math.vzo_ema(dft, lengthV)

// NOISE REDUCTION
min_ = input(1, "NoiseR min length", tooltip="Keep it at 1 if you didn't read the code!! it's the range of EMA mathimation of the VZO depending on last 3 close prices." , group = "Noise")
max_ = input(8, "NoiseR max length",tooltip="I suggest 2 for FAST and 7 or 8 for SLOW. Using FAST setting require averaging more than 1 Timeframe together.", group = "Noise")
malen = input(2, title="Smooth Length", tooltip="Insert 1 if you use VZO > VZO[1] and 2 if you use VZO > ta.ema(VZO,2)", group = "Noise")

// Using whitenoise function for noise reduction in VZO
VZO_ = version3 ? math.whitenoise(VZO_1, dft, 10, minEmaLength = min_, maxEmaLength = max_) :
               math.whitenoise(VZO_1, 10, minEmaLength = min_, maxEmaLength = max_)

// PLOTS
nice_chart = input.bool(true, "Nice chart", tooltip="IF (FALSE): Shows the red falling line if VZO falling above 0", group = "Plots")

// Conditions for plotting based on oscillator direction
var greencon = false
var redcon = false

taema = ta.ema(VZO_, malen)

greencon := malen < 2 ? VZO_ > VZO_[1] : (VZO_ > taema)
redcon := malen < 2 ? VZO_ < VZO_[1] : (VZO_ < taema)

leadosc = (VZO_)*0.8

mar = input.int(0,"Vzvo difference",tooltip="bulish_VZO = true  WHEN  { Vzo = bulish AND VZO > this_input } ")

plot(mar , display = display.pane)
plot(-mar,  display = display.pane)


longCondition = greencon and VZO_ >mar
shortCondition =  redcon and VZO_ < -mar
// Strategy execution
var pos = 0
var long = 0

if longCondition
    pos := 1
    long := 1
    strategy.entry("long",strategy.long)

if shortCondition
    pos := -1
    long := -1
    strategy.entry("short",strategy.short)


if not longCondition and not shortCondition and close_all and (position_gann == 0 or not gannentry)
    pos := 0
    strategy.close_all()


// Plotting the indicators and colored zones
mid = plot(0, color=color.new(#ffffff, 71), display = display.pane)
lii = plot(leadosc, color = greencon ? color.rgb(0, 255, 187, math.abs(leadosc)) : color.rgb(255, 17, 0, math.abs(leadosc)), display = display.none)
v3 = plot(VZO_ >= 0 ? math.min(VZO_, taema)*1.1 : math.max(VZO_, taema)*1.1, display = display.none)
v4 = plot(VZO_ >= 0 ? math.min(VZO_, taema)*1: math.max(VZO_, taema)*1, display = display.none)

fill(v3, lii, taema > 0 ? taema : 0, taema > 0 ? 0 : taema, taema > 0 ? color.rgb(9, 232, 173, math.abs(leadosc)) : #0d030300, taema > 0 ? #0b030300 : color.rgb(208, 20, 7, math.abs(leadosc)), display = nice_chart ? display.all : display.none)
fill(v4, lii, taema > 0 ? taema : 0, taema > 0 ? 0 : taema, taema > 0 ? color.rgb(9, 232, 173, math.abs(leadosc)) : #0d030300, taema > 0 ? #0b030300 : color.rgb(208, 20, 7, math.abs(leadosc)), display = not nice_chart ? display.all : display.none)
plot(VZO_, color = greencon ? color.rgb(9, 232, 173, math.abs(leadosc)) : redcon ? color.rgb(255, 17, 0, math.abs(leadosc)) : color.aqua, display = not nice_chart ? display.pane : display.none)

// Plotting additional information on the status line
plot(close, title="ClosePrice", display=display.status_line)
plot(open, title="OpenPrice", display=display.status_line)

plot(pos, color = greencon ? color.rgb(9, 232, 173, 50) : redcon ? color.rgb(255, 17, 0, 50) : color.aqua, title="position", display=display.status_line)

plotchar(longCondition and long[1]==-1 ? -125 : na, char = "▲", color = color.rgb(0, 255, 187,40), location = location.absolute, size = size.tiny,  display = display.pane)
plotchar(shortCondition  and long[1]==1 ? 125 : na, char = "▼", color = color.rgb(255, 17, 0, 40), location = location.absolute, size = size.tiny,  display = display.pane)


//plot(longCondition and not(longCondition[1]) ? 1 :0)
//plot(shortCondition and not(shortCondition[1]) ? 1 :0)
//plot((not longCondition and not shortCondition and close_all )and not(not longCondition[1] and not shortCondition[1] and close_all ) ? 1 :0)
alertcondition(longCondition and not(longCondition[1]),"Long","Go long!")
alertcondition(shortCondition and not(shortCondition[1]),"Short","Go short!")
alertcondition((not longCondition and not shortCondition and close_all )and not(not longCondition[1] and not shortCondition[1] and close_all ) ,"Close","Close position.")