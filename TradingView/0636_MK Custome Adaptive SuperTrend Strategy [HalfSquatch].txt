//@version=5
strategy("Machine Learning Adaptive SuperTrend Strategy [AlgoAlpha]", "AlgoAlpha - ðŸ¤– Adaptive SuperTrend Strategy", overlay = true, max_labels_count = 500, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)

import TradingView/ta/7
atr_len = input.int(10, "ATR Length", group = "SuperTrend Settings")
fact = input.float(3, "SuperTrend Factor", group = "SuperTrend Settings")
training_data_period = input.int(100, "Training Data Length", group = "K-Means Settings")
highvol = input.float(0.75, "Initial High volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'high volatility' area is, a value of 0.75 will take the 75th percentile of the range of ATR values over the training data period")
midvol = input.float(0.5, "Initial Medium volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'medium volatility' area is, a value of 0.5 will take the 50th percentile of the range of ATR values over the training data period")
lowvol = input.float(0.25, "Initial Low volatility Percentile Guess", maxval = 1, group = "K-Means Settings", tooltip = "The initial guess of where the potential 'low volatility' area is, a value of 0.25 will take the 25th percentile of the range of ATR values over the training data period")

pine_supertrend(factor, atr) =>
    src = hl2
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])

    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int _direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr[1])
        _direction := 1






    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand




    if na(atr[1])
        _direction := 1
    else
        if prevSuperTrend == prevUpperBand
            _direction := close > upperBand ? 1 : -1
        else
            _direction := close < lowerBand ? -1 : 1

    superTrend := _direction == 1 ? lowerBand : upperBand
    [superTrend, _direction]


volatility = ta.atr(atr_len)

upper = ta.highest(volatility, training_data_period)
lower = ta.lowest(volatility, training_data_period)

high_volatility = lower + (upper - lower) * highvol
medium_volatility = lower + (upper - lower) * midvol
low_volatility = lower + (upper - lower) * lowvol

iterations = 0

size_a = 0
size_b = 0
size_c = 0

hv = array.new_float()
mv = array.new_float()
lv = array.new_float()
amean = array.new_float(1, high_volatility)
bmean = array.new_float(1, medium_volatility)
cmean = array.new_float(1, low_volatility)

if nz(volatility) > 0 and bar_index >= training_data_period - 1
    while ((amean.size() == 1 ? true : (amean.first() != amean.get(1))) or (bmean.size() == 1 ? true : (bmean.first() != bmean.get(1))) or (cmean.size() == 1 ? true : (cmean.first() != cmean.get(1))))
        hv.clear()
        mv.clear()
        lv.clear()
        for i = training_data_period - 1 to 0
            _1 = math.abs(volatility[i] - amean.first())
            _2 = math.abs(volatility[i] - bmean.first())
            _3 = math.abs(volatility[i] - cmean.first())
            if _1 < _2 and _1 < _3
                hv.unshift(volatility[i])

            if _2 < _1 and _2 < _3
                mv.unshift(volatility[i])

            if _3 < _1 and _3 < _2
                lv.unshift(volatility[i])

        amean.unshift(hv.avg())
        bmean.unshift(mv.avg())
        cmean.unshift(lv.avg())
        size_a := hv.size()
        size_b := mv.size()
        size_c := lv.size()
        iterations := iterations + 1

hv_new = amean.first()
mv_new = bmean.first()
lv_new = cmean.first()
vdist_a = math.abs(volatility - hv_new)
vdist_b = math.abs(volatility - mv_new)
vdist_c = math.abs(volatility - lv_new)

distances = array.new_float()
centroids = array.new_float()

distances.push(vdist_a)
distances.push(vdist_b)
distances.push(vdist_c)

centroids.push(hv_new)
centroids.push(mv_new)
centroids.push(lv_new)

cluster = distances.indexof(distances.min()) // 0 for high, 1 for medium, 2 for low
assigned_centroid = cluster == -1 ? na : centroids.get(cluster)

[ST, dir] = pine_supertrend(fact, assigned_centroid)

// Define entry conditions
long_condition = ta.crossover(dir, 0)
short_condition = ta.crossunder(dir, 0)

// Entry and exit
if (long_condition)
    strategy.entry("Long", strategy.long)

if (short_condition)
    strategy.entry("Short", strategy.short)

if (strategy.position_size > 0 and close < ST)
    strategy.exit("Exit Long", "Long", stop=ST)

if (strategy.position_size < 0 and close > ST)
    strategy.exit("Exit Short", "Short", stop=ST)

upTrend = plot(close > ST ? ST : na, color=color.new(#00ffbb, 0), style=plot.style_linebr)
downTrend = plot(close < ST ? ST : na, color=color.new(#ff1100, 0), style=plot.style_linebr)

// === Input for easy tweaking (optional) ===
exit_pct = input.float(1.5, title="Exit %", minval=0.1) / 100  // 1.5%

// === Calculate target levels ===
long_take_profit  = strategy.position_avg_price * (2 + exit_pct)
long_stop_loss    = strategy.position_avg_price * (1 - exit_pct)
short_take_profit = strategy.position_avg_price * (2 - exit_pct)
short_stop_loss   = strategy.position_avg_price * (1 + exit_pct)

// === Input for Stop Loss % ===
sl_pct = input.float(1.0, title="Stop Loss %", minval=0.1) / 100  // 1% SL

// === Calculate stop loss levels from entry price ===



// === Attach SL to both long and short entries ===
strategy.exit("Stop Long", from_entry="Long", stop=long_stop_loss)
strategy.exit("Stop Short", from_entry="Short", stop=short_stop_loss)


// === Attach exits to both entry types ===
strategy.exit("Exit Long", from_entry="Long", limit=long_take_profit, stop=long_stop_loss)
strategy.exit("Exit Short", from_entry="Short", limit=short_take_profit, stop=short_stop_loss)


plotshape(long_condition, "Bullish Signal", shape.labelup, location.absolute, color.green, text="â–²", size=size.small)
plotshape(short_condition, "Bearish Signal", shape.labeldown, location.absolute, color.red, text="â–¼", size=size.small)

// Alerts
alertcondition(long_condition, "Bullish Trend Shift", "Bullish trend detected.")
alertcondition(short_condition, "Bearish Trend Shift", "Bearish trend detected.")
alertcondition(long_condition, title="Buy Signal", message="BUY")
alertcondition(short_condition, title="Sell Signal", message="SELL")