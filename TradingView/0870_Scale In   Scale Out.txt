// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © colgunn

//@version=5

strategy("Scale In : Scale Out",
  overlay = true,
  currency=currency.USD,
  initial_capital = 1000000.0,
  commission_type = strategy.commission.percent,
  commission_value = 0.0,
  process_orders_on_close = true,
  margin_long = 100,
  margin_short = 100,
  pyramiding = 1000000,
  max_labels_count = 500,
  use_bar_magnifier = true) // premium accounts onlysma50 = ta.sma(close, 50)

// symbol and ticker
var sym_type = syminfo.type
var sym_is_partial_qty = not (sym_type == "stock" or sym_type == "fund")

// timeframe
var tf = "D"
if timeframe.isdaily
    tf := "day"
else if timeframe.isweekly
    tf := "week"
else if timeframe.ismonthly
    tf := "month"
else if timeframe.isminutes
    tf := "minute"
else if timeframe.isseconds
    tf := "second"
var tf_multiplier = timeframe.multiplier

// User input paramters
start_unix_time = input.time(timestamp("2022-01-01T00:00:00"), "Start Date/Time")
finish_unix_time = input.time(timestamp("2024-12-31T23:59:59"), "Finish Date/Time")
initial_capital = input.int(1000000, "Initial Capital", 0, 100000000, 1000,
  "The initial capital (cash) in currency.") * 1.0
buy_scaling_size = input.float(2, "Buy Scaling Size %", 0.1, 100.0, 0.5,
  "The percentage of deployable cash to spend per bar when scaling (averaging) in. For example to scale in over 365 daily bars, percentage = 100/365 = 0.274%. See also Retain Profit Portion %.")
take_profit_level = input.float(50.0, "Take Profit Level %", 1.0, 10000.0, 1.0,
  "The minimum percentage profit level to trigger selling (profit taking).")
take_profit_position_portion = input.float(1.0, "Take Profit Size %", 0.5, 100.0, 0.5,
  "The percentage of current position to sell per bar when taking profits. See also Take Profit Level %.")
retain_profit_portion = input.float(50.0, "Retain Profit Portion %", 0.0, 100.0, 1.0,
  "The portion of realised profit to retain on each sell. The remaining realised profit will be allocated to deployable cash for future buys. See also Buy Scaling Size.") / 100.0
min_position_value = input.int(200000, "Minimum Position Value", 0, 100000000, 100000,
  "The minimum capital at risk in currency. Profit taking will not start if market value of position is below this value.") * 1.0
min_buy_value = input.int(100, "Minimum Buy Value $", 0, 1000000, 10,
  "The minimum value of any buy trade in currency. Should be proprtional to the unit cost of the target asset. For assets which can be bought in partial units (e.g. crypto), this value should be set to ensure impractically small buys do not occur.") * 1.0
annual_interest_rate = input.float(3.5, "Annual Interest Rate %", 0.0, 100.0, 0.5,
  "The annual interest rate which current cash balance earns. Interest earnings will be applied on a daily basis at [annual rate / 365]. If the bar period is less than a day, interest will not be applied.") / 100.0
label_frequency = input.int(20, "Metrics Label Frequency", 0, 1000, 10, "How many bars between metrics labels. A value of 0 means no labels will be shown." )
show_metrics_table = input.bool(true, "Show Metrics Table",
  "Whether to display a table displaying strategy performance metrics.")
debug_verbose = false // input.bool(false, "Verbose Label Metrics", "More details on metrics labels, helps with debugging.")

get_days_in_bar() =>
    base = 0.0
    if tf == "month"
        base := 30.0
    else if tf == "week"
        base := 7.0
    else if tf == "day"
        base := 1.0
    else if tf == "hour"
        base := 1.0 / 24
    else if tf == "minute"
        base := 1.0 / (24 * 60)
    else if tf == "second"
        base := 1.0 / (24 * 60 * 60)
    else
        base := 0.0
    base * tf_multiplier

get_timeframe_desc() =>
    m = str.tostring(tf_multiplier)
    if tf == "month"
        m + "M"
    else if tf == "week"
        m + "W"
    else if tf == "day"
        m + "D"
    else if tf == "hour"
        m + "H"
    else if tf == "minute"
        if tf_multiplier >= 60
            hours = math.round(tf_multiplier / 60)
            str.tostring(hours) + "H"
        else
            m + "m"
    else if tf == "second"
        if tf_multiplier >= 60
            mins = math.round(tf_multiplier / 60)
            str.tostring(mins) + "m"
        else
            m + "s"
    else
        m + "???"


// constant values
var trade_id = "siso"
// var start_bar = 3 * 365 // 365
// var finish_bar = 1 * 365 // 365

// global vars //
var retained_cash = 0.0
var deployable_cash = initial_capital
var min_cash_balance = initial_capital
var last_bar_index_sold = -1
var last_price_sold = 0.0
var index = 0
var entry_count = 0
var trade_count = 0
var total_spend = 0.0
var total_sales = 0.0
var total_interest_earned = 0.0
var first_price = 0.0
var closed_trades_qty = 0.0
var current_buy_quota = -1.0
var current_sell_quota = -1.0

var open_position_ids = array.new_string(0)
var open_position_sizes = array.new_float(0)
var open_position_prices = array.new_float(0)
var closed_position_sizes = array.new_float(0)
var closed_position_prices = array.new_float(0)
var closed_position_values = array.new_float(0)
var closed_position_costs = array.new_float(0)

// A = P (1 + r/n)^(nt)
// Where:
// - A is the amount of money accumulated after n years, including interest.
// - P is the principal amount (the initial amount of money).
// - r is the annual interest rate (in decimal).
// - n is the number of times that interest is compounded per year.
// - t is the time the money is invested for in years.
//
// If compounding daily, n would be 365 (or 366 for a leap year).
// If you're given a daily interest rate and you want to calculate the interest earned on a compounding basis over 30 days, you can use the formula for compound interest:
// A = P (1 + r/n)^(nt)
// In this case, n would be 1 (since the interest is compounded daily), and t would be 30/365 (since you're calculating for 30 days, not a full year).

calc_interest() =>
    days = get_days_in_bar()
    if (days < 1.0 or annual_interest_rate == 0.0)
        0.0
    else
        P = deployable_cash + retained_cash
        A = P * math.pow(1.0 + (annual_interest_rate / 365.0), days)
        A - P

flt2str2(lbl, flt) =>
    lbl + "  " + str.format("{0,number,###,###.##}", flt)

flt2str6(lbl, flt) =>
    lbl + "  " + str.format("{0,number,###,###.######}", flt)

flt2currK(lbl, flt) =>
    lbl + "  " + str.format("{0,number,###,###}", flt)

flt2curr(lbl, flt) =>
    lbl + "  " + str.format("{0,number,###,###.##}", flt)

flt2pc(lbl, flt) =>
    lbl + "  " + str.format("{0,number,#.##}", flt)

get_cash_balance() =>
    retained_cash + deployable_cash

get_cash_profit() =>
    get_cash_balance() - initial_capital

// returns array [size, ave_price, cost, value, profit, profit_percent, entries]
// value is size times current close
// entries is number of individual open position entries
get_open_position_metrics() =>
    size = 0.0
    cost = 0.0
    n = open_position_ids.size()
    if n > 0 // believe it or not the loop will execute if n == 0
        for i = 0 to (n - 1)
            q = open_position_sizes.get(i)
            p = open_position_prices.get(i)
            size += q
            cost += q * p
    ave_price = size == 0.0 ? 0.0 : cost / size
    value = size * close
    profit = value - cost
    profit_pc = (cost == 0.0 ? 0.0 : profit / cost) * 100.0
    array.from(size, ave_price, cost, value, profit, profit_pc, n)

// returns array [size, ave_sell_price, ave_buy_price, value, cost, profit, profit_pc, entries]
// entries is number of individual closed position entries
get_closed_position_metrics() =>
    size = 0.0
    value = 0.0
    cost = 0.0
    n = closed_position_sizes.size()
    if n > 0 // believe it or not the loop will execute if n == 0
        for i = 0 to (n - 1)
            size += closed_position_sizes.get(i)
            value += closed_position_values.get(i)
            cost += closed_position_costs.get(i)
    ave_sell_price = size == 0.0 ? 0.0 : value / size
    ave_buy_price = size == 0.0 ? 0.0 : cost / size
    profit = value - cost
    profit_pc = (cost == 0.0 ? 0.0 : profit / cost) * 100.0
    array.from(size, ave_sell_price, ave_buy_price, value, cost, profit, profit_pc, n)

// buy given qty of contract at current close - in this bar, not open in next
// returns array [qty, cost]
// qty is the number of (possaibly fractional) units bought
// cost is cost of units bought, ignoring commission
buy(id, qty) =>
    id_str = '#' + str.tostring(id)
    price = close
    open_position_ids.push(id_str)
    open_position_sizes.push(qty)
    open_position_prices.push(price)
    strategy.entry(id_str, strategy.long, qty=qty)
    cost = qty * price
    array.from(qty, cost)

// sell qty units starting with first opened positions
// as qty may not exactly match, not all of an opened position may be sold
// returns array [sold_qty, sold_value, sold_cost]
// sold_qty is the number of (possaibly fractional) units sold
// sold_value is the value units sold (less commission paid)
// sold_cost is the cost of the entry trades which were fully or partially exited (including commission)
// commision is the brokerage commission paid on sales
sell(qty, fifo=true) =>
    sold_qty = 0.0
    sold_cost = 0.0
    sold_value = 0.0
    n = open_position_ids.size()
    for i = 0 to (n - 1)
        remaining_qty = qty - sold_qty
        if remaining_qty > 0.0
            if open_position_ids.size() > 0
                id_str = fifo ? open_position_ids.shift() : open_position_ids.pop()
                trade_open_qty = fifo ? open_position_sizes.shift() : open_position_sizes.pop()
                trade_open_price = fifo ? open_position_prices.shift() : open_position_prices.pop()
                trade_qty = math.min(trade_open_qty, remaining_qty)
                if trade_qty < trade_open_qty
                    if fifo
                        open_position_ids.unshift(id_str)
                        open_position_sizes.unshift(trade_open_qty - trade_qty)
                        open_position_prices.unshift(trade_open_price)
                    else
                        open_position_ids.push(id_str)
                        open_position_sizes.unshift(trade_open_qty - trade_qty)
                        open_position_prices.unshift(trade_open_price)
                strategy.close(id_str, na, trade_qty, na, na, true)
                price = close
                sell_value = trade_qty * price
                trade_open_cost = trade_qty * trade_open_price

                sold_qty += trade_qty
                sold_value += sell_value
                sold_cost += trade_open_cost

                closed_position_sizes.push(trade_qty)
                closed_position_prices.push(price)
                closed_position_values.push(sell_value)
                closed_position_costs.push(trade_open_cost)
            else
                log.error("bar_index={0} selling more than we own qty={1}", bar_index, qty)
    array.from(sold_qty, sold_value, sold_cost)

get_label_or_tooltip(which) =>
    tp_level = take_profit_level
    tp_size = take_profit_position_portion
    net_spend = total_spend - total_sales
    current_close = close

    // get_open_position_metrics returns array:
    // [size, ave_price, cost, value, profit, profit_percent, entries]
    open_metrics = get_open_position_metrics()
    open_size = open_metrics.get(0)
    open_ave_price = open_metrics.get(1)
    open_cost = open_metrics.get(2)
    open_value = open_metrics.get(3)
    open_profit = open_metrics.get(4)
    open_profit_pc = open_metrics.get(5)

    // get_closed_position_metrics returns array:
    // [size, ave_sell_price, ave_buy_price, value, cost, profit, profit_pc, entries]
    // entries is number of individual closed position entries
    closed_metrics = get_closed_position_metrics()
    closed_size = closed_metrics.get(0)
    closed_ave_sell_price = closed_metrics.get(1)
    ave_buy_price = closed_metrics.get(2)
    closed_value = closed_metrics.get(3)
    closed_cost = closed_metrics.get(4)
    closed_profit = closed_metrics.get(5)
    closed_profit_pc = closed_metrics.get(6)

    cash_balance = get_cash_balance()
    total_equity= cash_balance + open_value
    total_profit = total_equity - initial_capital
    total_profit_pc = (initial_capital == 0.0 ? 0.0 : total_profit / initial_capital) * 100.0
    bh_profit_pc = ((current_close - first_price) / first_price) * 100.0

    current_capital = cash_balance + open_value

    if which == "label"
        "\n" + "------------------------------" +
          "\n" + flt2currK("Current Capital $", current_capital) +
          "\n" + "------------------------------" +
          "\n" + flt2currK("Realized PL $", closed_profit) +
          "\n" + flt2currK("Open PL $", open_profit) +
          "\n" + flt2currK("Total PL $", total_profit) +
          "\n" + "------------------------------" +
          "\n" + flt2pc("Realized PL %", closed_profit_pc) +
          "\n" + flt2pc("Open PL %", open_profit_pc) +
          "\n" + flt2pc("Total PL %", total_profit_pc) +
          "\n" + "------------------------------" +
          "\n" + flt2pc("Buy & Hold PL %", bh_profit_pc) +
          "\n" + "------------------------------" +
          "\n" + flt2currK("Current Cash $", cash_balance) +
          "\n" + "------------------------------" +
          "\n" + flt2str2("Open Size", open_size) +
          "\n" + flt2curr("Open Ave Price $", open_ave_price) +
          "\n" + flt2currK("Open Value $", open_value)
    else
        "\n" + "------------------------------" +
          "\n" + flt2currK("Current Capital $", current_capital) +
          "\n" + "------------------------------" +
          "\n" + flt2currK("Realized PL $", closed_profit) +
          "\n" + flt2currK("Open PL $", open_profit) +
          "\n" + flt2currK("Total PL $", total_profit) +
          "\n" + "------------------------------" +
          "\n" + flt2pc("Realized PL %", closed_profit_pc) +
          "\n" + flt2pc("Open PL %", open_profit_pc) +
          "\n" + flt2pc("Total PL %", total_profit_pc) +
          "\n" + "------------------------------" +
          "\n" + flt2pc("Buy & Hold PL %", bh_profit_pc) +
          "\n" + "------------------------------" +
          "\n" + flt2str2("Open Size", open_size) +
          "\n" + flt2curr("Open Ave Price $", open_ave_price) +
          "\n" + flt2currK("Open Value $", open_value) +
          "\n" + "------------------------------" +
          "\n" + flt2currK("Current Cash $", cash_balance) +
          "\n" + flt2currK("Retained Cash $", retained_cash) +
          "\n" + flt2currK("Deployable Cash $", deployable_cash) +
          "\n" + flt2currK("Interest Earned $", total_interest_earned) +
          "\n" + "------------------------------" +
          "\n" + flt2currK("Total Spend $", total_spend) +
          "\n" + flt2currK("Total Sales $", total_sales) +
          "\n" + flt2currK("Net Spend $", net_spend) +
          "\n" + flt2currK("Min Cash Balance $", min_cash_balance)

add_status_label() =>
    var table metrics_table = na
    // index_tag = str.upper(tf) + " #" + str.tostring(index)
    index_tag = " #" + str.tostring(index) + " x " + get_timeframe_desc()
    txt = index_tag + get_label_or_tooltip("label")
    tooltip = index_tag + get_label_or_tooltip("tooltip")
    mod = label_frequency
    if index % mod == 0
        if mod > 0
            lbl = label.new(bar_index, high, text=txt, yloc=yloc.abovebar, size=size.small, tooltip=tooltip)
            label.set_color(lbl, color.yellow)
            // label.set_size(lbl, size.large)
    if show_metrics_table and (barstate.islast or barstate.islastconfirmedhistory)
        if na(metrics_table)
            metrics_table := table.new(position.bottom_right, 1, 1, bgcolor = color.black)
        table.set_frame_width(metrics_table, 1)
        table.set_frame_color(metrics_table, color.yellow)
        table.cell(table_id = metrics_table, column = 0, row = 0, text = txt)
        table.cell_set_text_color(metrics_table, 0, 0, color.yellow)
        table.cell_set_text_size(metrics_table, 0, 0, size.normal)
        table.cell_set_tooltip(metrics_table, 0, 0, tooltip)
        true
    else
        table.delete(metrics_table)
        metrics_table := na
        false

if barstate.isnew
    // bars_to_go = last_bar_index - bar_index
    // if (bars_to_go <= start_bar and bars_to_go >= finish_bar)
    bar_time = time(timeframe.period)
    if bar_time >= start_unix_time and bar_time <= finish_unix_time
        index := index + 1
        current_close = close
        if first_price == 0.0
            first_price := current_close

        // get_open_position_metrics returns array:
        // [size, ave_price, cost, value, profit, profit_percent, entries]
        open_metrics = get_open_position_metrics()
        open_size = open_metrics.get(0)
        open_ave_price = open_metrics.get(1)
        open_cost = open_metrics.get(2)
        open_value = open_metrics.get(3)
        open_profit = open_metrics.get(4)
        open_profit_pc = open_metrics.get(5)
        interest = calc_interest()

        total_interest_earned := total_interest_earned + interest
        retained_cash := retained_cash + interest

        if close > 0.00000001
            profit_taken = false
            if open_value >= min_position_value
                tp_level = take_profit_level
                tp_size = take_profit_position_portion
                if open_profit_pc >= tp_level
                    sell_portion = (tp_size / 100.0)
                    if current_sell_quota < 0.0
                        current_sell_quota := open_size * sell_portion
                    qty = current_sell_quota
                    sell_value = qty * current_close
                    if open_value - sell_value >= min_position_value
                        if not sym_is_partial_qty
                            qty := math.floor(qty)
                            if qty == 0.0
                                qty := 1.0
                            sell_value := (qty * current_close)
                        if qty > 0.0
                            trade_count += 1
                            sell_result = sell(qty)
                            // sell result = [sold_qty, sold_value, sold_cost]
                            sold_qty = sell_result.get(0)
                            sold_value = sell_result.get(1)
                            sold_cost = sell_result.get(2)
                            profit_taken := true
                            total_sales += sold_value
                            closed_trades_qty += sold_qty
                            retain = sold_value * retain_profit_portion
                            if (deployable_cash < initial_capital)
                                retain := math.min(retain * 0.5, initial_capital - deployable_cash)
                            retained_cash := retained_cash + retain
                            deploy = sold_value - retain
                            deployable_cash := deployable_cash + deploy
                            last_bar_index_sold := bar_index
                            last_price_sold := current_close
                            current_buy_quota := -1.0
            if not profit_taken // and (last_price_sold == 0.0 or current_close < last_price_sold)
                current_sell_quota := -1.0
                if deployable_cash >= min_buy_value
                    buy_size = buy_scaling_size / 100.0
                    if current_buy_quota < 0.0
                        current_buy_quota := deployable_cash > initial_capital
                          ? deployable_cash * buy_size
                          : math.min(deployable_cash, initial_capital * buy_size)
                    spend = current_buy_quota
                    if spend >= min_buy_value
                        qty = spend / current_close
                        if not sym_is_partial_qty
                            qty := math.floor(qty)
                            if qty == 0.0
                                qty := 1.0
                            spend := qty * current_close
                        if qty > 0.0 and spend <= deployable_cash
                            entry_count += 1
                            trade_count += 1
                            buy_result = buy(entry_count, qty)
                            total_spend := total_spend + spend
                            deployable_cash := deployable_cash - spend

        cash_balance = get_cash_balance()
        if cash_balance < min_cash_balance
            min_cash_balance := cash_balance
        add_status_label()



plot(strategy.position_avg_price, color=color.yellow)