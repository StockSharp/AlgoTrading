// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© RagingRocketBull

//@version=4
// you might want to use max_labels_count=500, max_lines_count=500 to increase the number of objects from default 50
study("Pinescript - Common Label & Line Array Functions Library by RRB", overlay=true)

// Pinescript - Common Label & Line Array Functions Library by RagingRocketBull 2021
// Version 1.0
//
// This script provides a library of common array functions for arrays of label and line objects with live testing of all functions.
// Using this library you can easily create, update, delete, join label/line object arrays, and get/set properties of individual label/line object array items.
// You can find the full list of supported label/line array functions below.
//
// There are several libraries:
// - Common String Functions Library
// - Standard Array Functions Library
// - Common Fixed Type Array Functions Library
// - Common Label & Line Array Functions Library
// - Common Variable Type Array Functions Library
//
// Features:
// - 30 array functions in categories create/update/delete/join/get/set with support for both label/line objects (45+ including all implementations)
// - Create, Update label/line object arrays from list/array params
// - GET/SET properties of individual label/line array items by index
// - Join label/line objects/arrays into a single string for output
// - Supports User Input of x,y coords of 5 different types: abs/rel/rel%/inc/inc% list/array, auto transforms x,y input into list/array based on type, base and xloc, translates rel into abs bar indexes
// - Supports User Input of lists with shortened names of string properties, auto expands all standard string properties to their full names for use in functions
// - Live Output for all/selected functions based on User Input. Test any function for possible errors you may encounter before using in script.
// - Output filters: hide all excluded and show only allowed functions using a list of function names
// - Output Panel customization options: set custom style, color, text size, and line spacing
//
// Usage:
// - select create function - create label/line arrays from lists or arrays (optional). Doesn't affect the update functions. The only change in output should be function name regardless of the selected implementation.
// - specify num_objects [0..7] for both label/line arrays (default is 7)
// - specify common anchor point settings x,y base/type for both label/line arrays and GET/SET items in Common Settings
// - fill lists with items to use as inputs for create label/line array functions in Create Label/Line Arrays section
// - specify label/line array item index and properties to SET in corresponding sections
// - select label/line SET function to see the changes applied live
//
// Code Structure:
// - translate x,y depending on x,y type, base and xloc as specified in UI (required for all functions)
// - expand all shortened standard property names to full names (required for create/update* from arrays and set* functions, not needed for create/update* from lists) to prevent errors in label.new and line.new
// - create param arrays from string lists (required for create/update* from arrays and set* functions, not needed for create/update* from lists)
// - create label/line array from string lists (property names are auto expanded) or param arrays (requires already expanded properties)
// - update entire label/line array or
// - get/set label/line array item properties by index
//
// Transforming/Expanding Input values:
// - for this script to work on any chart regardless of price/scale, all x*,y* are specified as % increase relative to x0,y0 base levels by default, but user can enter abs x,price values specific for that chart if necessary.
// - all lists can be empty, contain 1 or several items, have the same/different lengths. Array Length = min(min(len(list*)), mum_objects) is used to create label/line objects. Missing list items are replaced with default property values.
// - when a list contains only 1 item it is duplicated (label name/tooltip is also auto incremented) to match the calculated Array Length
// - since this script processes user input, all x,y values must be translated to abs bar indexes before passing them to functions. Your script may provide all data internally and doesn't require this step.
// - at first int x, float y arrays are created from user string lists, transformed as described below and returned as x,y arrays.
// - translated x,y arrays can then be passed to create from arrays function or can be converted back to x,y string lists for the create from lists function if necessary.
// - all translation logic is separated from create/update/set functions for the following reasons:
//   - to avoid redundant code/dependency on ext functions/reduce local scopes and to be able to translate everything only once in one place - should be faster
//   - to simplify internal logic of all functions
//   - because your script may provide all data internally without user input and won't need the translation step
// - there are 5 types available for both x,y: abs, rel, rel%, inc, inc%. In addition to that, x can be: bar index or time, y is always price.
//   - abs - absolute bar index/time from start bar0 (x) or price (y) from 0, is >= 0
//   - rel - relative bar index/time from cur bar n (x) or price from y0 base level, is >= 0
//   - rel% - relative % increase of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
//   - inc - relative increment (step) for each new level of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
//   - inc% - relative % increment (% step) for each new level of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
//   - x base level >= 0
//   - y base level can be 0 (empty) or open, close, high, low of cur bar
//   - single item x1_list = "50" translates into:
//     - for x type abs: "50, 50, 50 ..." num_objects times regardless of xloc => x = 50
//     - for x type rel: "50, 50, 50 ... " num_objects times     => x = x_base + 50
//     - for x type rel%: "50%, 50%, 50% ... " num_objects times => x_base * (1 + 0.5)
//     - for x type inc: "0, 50, 100 ... " num_objects times     => x_base + 50 * i
//     - for x type inc%: "0%, 50%, 100% ... " num_objects times => x_base * (1 + 0.5 * i)
//     - when xloc = xloc.bar_index each rel*/inc* value in the above list is then subtracted from n: n - x to convert rel to abs bar index, values of abs type are not affected
//     - x1_list = "0, 50, 100, ..." of type rel is the same as "50" of type inc
//     - x1_list = "50, 50, 50, ..." of type abs/rel/rel% produces a sequence of the same values and can be shortened to just "50"
//   - single item y1_list = "2" translates into (ragardless of yloc):
//     - for y type abs: "2, 2, 2 ..." num_objects times        => y = 2
//     - for y type rel: "2, 2, 2 ... " num_objects times       => y = y_base + 2
//     - for y type rel%: "2%, 2%, 2% ... " num_objects times   => y = y_base * (1 + 0.02)
//     - for y type inc: "0, 2, 4 ... " num_objects times       => y = y_base + 2 * i
//     - for y type inc%: "0%, 2%, 4% ... " num_objects times   => y = y_base * (1 + 0.02 * i)
//     - when yloc != yloc.price all calculated values above are simply ignored
//     - y1_list = "0, 2, 4" of type rel% is the same as "2" with type inc%
//     - y1_list = "2, 2, 2" of type abs/rel/rel% produces a sequence of the same values and can be shortened to just "2"
// - you can enter shortened property names in lists. To lookup supported shortened names use corresponding dropdowns in Set Label/Line Array Item Properties sections
// - all shortened standard property names must be expanded to full names (required for create/update* from arrays and set* functions, not needed for create/update* from lists) to prevent errors in label.new and line.new
//   - examples of shortened property names that can be used in lists: bar_index, large, solid, label_right, white, left, left, price
//   - expanded to their corresponding full names: xloc.bar_index, size.large, line.style_solid, label.style_label_right, color.white, text.align_left, extend.left, yloc.price
// - all expanding logic is separated from create/update* from arrays and set* functions for the same reasons as above, and because param arrays already have different types, implying the use of final values.
// - all expanding logic is included in the create/update* from lists functions because it seemed more natural to process string lists from user input directly inside the function, since they are already strings.
//
// Creating Label/Line Objects:
// - use study max_lines_count and max_labels_count params to increase the max number of label/line objects to 500 (+3) if necessary. Default number of label/line objects is 50 (+3)
// - all functions use standard param sequence from methods in reference, except style always comes before colors.
// - standard label/line.get* functions only return a few properties, you can't read style, color, width etc.
// - label.new(na, na, "") will still create a label with x = n-301, y = NaN, text = "" because max default scope for a var is 300 bars back.
// - there are 2 types of color na, label color requires color(na) instead of color_na to prevent error. text_color and line_color can be color_na
// - for line to be visible both x1, x2 ends must be visible on screen, also when y1 == y2 => abs(x1 - x2) >= 2 bars => line is visible
// - xloc.bar_index line uses abs x1, x2 indexes and can only be within 0 and n ends, where n <= 5000 bars (free accounts) or 10000 bars (paid accounts) limit, can't be plotted into the future
// - xloc.bar_time line uses abs x1, x2 times, can't go past bar0 time but can continue past cur bar time into the future, doesn't have a length limit in bars.
// - xloc.bar_time line with length = exact number of bars can be plotted only within bar0 and cur bar, can't be plotted into the future reliably because of future gaps due to sessions on some charts
// - xloc.bar_index line can't be created on bar 0 with fixed length value because there's only 1 bar of horiz length
//   - it can be created on cur bar using fixed length x < n <= 5000 or
//   - created on bar0 using na and then assigned final x* values on cur bar using set_x*
//   - created on bar0 using n - fixed_length x and then updated on cur bar using set_x*, where n <= 5000
// - default orientation of lines (for style_arrow* and extend) is from left to right (from bar 50 to bar 0), it reverses when x1 and x2 are swapped
// - price is a function, not a line object property

// Variable Type Arrays:
// - you can't create an if/function that returns var type value/array - compiler uses strict types and doesn't allow that
//    - however you can assign array of any type to another array of any type creating an arr pointer of invalid type that must be reassigned to a matching array type before used in any expression to prevent error
//    - create_any_array2 uses this loophole to return an int_arr pointer of a var type array
//    - this works for all array types defined with/without var keyword and doesn't work for string arrays defined with var keyword for some reason
//    - you can't do this with var type vars, only var type arrays because arrays are pointers passed by reference, while vars are actual values passed by value.
// - you can only pass a var type value/array param to a function if all functions inside support every type - otherwise error
//    - alternatively values of every type must be passed simultaneously and processed separately by corresponding if branches/functions supporting these particular types returning a common single type result
//    - get_var_types solves this problem by generating a list of dummy values of every possible type including the source type, tricking the compiler into allowing a single valid branch to execute without error, while ignoring all dummy results

// Notes:
// - uses Pinescript v3 Compatibility Framework
// - uses Common String Functions Library, Common Fixed Type Array Functions Library, Common Variable Type Array Functions Library
// - has to be a separate script to reduce the number of local scopes/compiled file size, can't be merged with another library.
// - lets you live test all label/line array functions for errors. If you see an error - change params in UI
// - if you see "Loop too long" error - hide/unhide or reattach the script
// - if you see "Chart references too many candles" error - change x type or value between abs/rel*. This can happen on charts with 5000+ bars when a rel bar index x is passed to label.new or line.new instead of abs bar index n - x
// - create/update_label/line_array* use string lists, while create/update_label/line_array_from_arrays* use array params to create label/line arrays. "from_lists" is dropped to shorten the names of the most commonly used functions.
// - create_label/line_array2,4 are preferable, 5,6 are listed for pure demonstration purposes only - don't use them, they don't improve anything but dramatically increase local scopes/compiled file size
// - for this reason you would mainly be using create/update_label/line_array2,4 for list params or create/update_label/line_array_from_arrays2 for array params
// - all update functions are executed after each create as proof of work and can be disabled. Only create functions are required. Use update functions when necessary - when list/array params are changed by your script.
// - both lists and array item properties use the same x,y_type, x,y_base from common settings
// - doesn't use pagination, a single str contains all output
// - why is this so complicated? What are all these functions for?
//   - this script merges standard label/line object methods with standard array functions to create a powerful set of label/line object array functions to simplify manipulation of these arrays.
//   - this library also extends the functionality of Common Variable Type Array Functions Library providing support for label/line types in var type array functions (any_to_str6, join_any_array5)
//   - creating arrays from either lists or arrays adds a level of flexibility that comes with complexity. It's very likely that in your script you'd have to deal with both string lists as input, and arrays internally, once everything is converted.
//   - processing user input, allowing customization and targeting for any chart adds a whole new layer of complexity, all inputs must be translated and expanded before used in functions.
//   - different function implementations can increase/reduce local scopes and compiled file size. Select a version that best suits your needs. Creating complex scripts often requires rewriting your code multiple times to fit the limits, every line matters.

// P.S. Don't rely too much on labels, for too often they are fables.

// List of functions*:
// * - functions from other libraries are not listed
//
// 1. Join Functions
//
// Labels
// - join_label_object(label_, d1, d2)
// - join_label_array(arr, d1, d2)
// - join_label_array2(arr, d1, d2, d3)
//
// Lines
// - join_line_object(line_, d1, d2)
// - join_line_array(arr, d1, d2)
// - join_line_array2(arr, d1, d2, d3)
//
// Any Type
// - any_to_str6(arr, index, type)
// - join_any_array4(arr, d1, d2, type)
// - join_any_array5(arr, d, type)
//
// 2. GET/SET Functions
//
// Labels
// - label_array_get_text(arr, index)
// - label_array_get_xy(arr, index)
// - label_array_get_fields(arr, index)
// - label_array_set_text(arr, index, str)
// - label_array_set_xy(arr, index, x, y)
// - label_array_set_fields(arr, index, x, y, str)
// - label_array_set_all_fields(arr, index, x, y, str, xloc, yloc, label_style, label_color, text_color, text_size, text_align, tooltip)
// - label_array_set_all_fields2(arr, index, x, y, str, xloc, yloc, label_style, label_color, text_color, text_size, text_align, tooltip)
//
// Lines
// - line_array_get_price(arr, index, bar)
// - line_array_get_xy(arr, index)
// - line_array_get_fields(arr, index)
// - line_array_set_text(arr, index, width)
// - line_array_set_xy(arr, index, x1, y1, x2, y2)
// - line_array_set_fields(arr, index, x1, y1, x2, y2, width)
// - line_array_set_all_fields(arr, index, x1, y1, x2, y2, xloc, extend, line_style, line_color, width)
// - line_array_set_all_fields2(arr, index, x1, y1, x2, y2, xloc, extend, line_style, line_color, width)
//
// 3. Create/Update/Delete Functions
//
// Labels
// - delete_label_array(label_arr)
// - create_label_array(list1, list2, list3, list4, list5, d)
// - create_label_array2(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - create_label_array3(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - create_label_array4(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - create_label_array5(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - create_label_array6(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - update_label_array2(label_arr, x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - update_label_array4(label_arr, x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d)
// - create_label_array_from_arrays2(x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d)
// - create_label_array_from_arrays4(x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d)
// - update_label_array_from_arrays2(label_arr, x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d)
//
// Lines
// - delete_line_array(line_arr)
// - create_line_array(list1, list2, list3, list4, list5, list6, d)
// - create_line_array2(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - create_line_array3(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - create_line_array4(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - create_line_array5(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - create_line_array6(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - update_line_array2(line_arr, x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - update_line_array4(line_arr, x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d)
// - create_line_array_from_arrays2(x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style_arr, color_arr, width_arr, d)
// - update_line_array_from_arrays2(line_arr, x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style_arr, color_arr, width_arr, d)

// More Scripts:
// https://www.tradingview.com/u/RagingRocketBull/

// ================================================================================================================
// Pinescript v3 Compatibility Framework
// ================================================================================================================

// Input types

// types can't be var names hence _
bool_ = input.bool
integer_ = input.integer
float_ = input.float
color_ = input.color
string_ = input.string

// array na equivalent for use in ifs when functions in if branches return arrays
array_bool_na = array.new_bool(0)
array_int_na = array.new_int(0)
array_float_na = array.new_float(0)
array_color_na = array.new_color(0)
array_string_na = array.new_string(0)
array_label_na = array.new_label(0)
array_line_na = array.new_line(0)

// resolution = input.resolution
// session = input.session
source = input.source
// symbol = input.symbol

// Styles

// plot styles
// line can't be a var name
lines = plot.style_line
linebr = plot.style_linebr
stepline  = plot.style_stepline
histogram = plot.style_histogram
cross = plot.style_cross
area = plot.style_area
areabr = plot.style_areabr
columns = plot.style_columns
circles = plot.style_circles

// Colors
aqua = color.aqua
black = color.black
blue = color.blue
fuchsia = color.fuchsia
gray = color.gray
green = color.green
lime = color.lime
maroon = color.maroon
navy = color.navy
olive = color.olive
orange = color.orange
purple = color.purple
red = color.red
silver = color.silver
teal = color.teal
white = color.white
yellow = color.yellow
color color_na = na
color color_na2 = #000000
color color_na3 = color.new(na, 0)
// don't use, differs from all color_na* above
color color_na4 = color(na)

// Timeframe
interval = timeframe.multiplier
period = timeframe.period
isintraday = timeframe.isintraday
isdaily = timeframe.isdaily
isweekly = timeframe.isweekly
ismonthly = timeframe.ismonthly
// isdwm = timeframe.isdwm

// Ticker
ticker = syminfo.ticker
tickerid = syminfo.tickerid

// Bar index
n = bar_index

// ================================================================================================================
// Const
// ================================================================================================================

digits_str = "0123456789"

colors_str = "aqua,black,blue,fuchsia,gray,green,lime,maroon,navy,olive,orange,purple,red,silver,teal,white,yellow"

types_str = "integer,float,string,color,bool,label,line"

// only ascii chars [32..126] are supported
charset_str = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"


// 0..n-1
chars = str.split(charset_str, "")
num_chars = array.size(chars)

digits = str.split(digits_str, "")
num_digits = array.size(digits)

types = str.split(types_str, ",")
num_types = array.size(types)

color_names = str.split(colors_str, ",")
num_colors = array.size(color_names)

colors = array.new_color(0)

array.push(colors, aqua)
array.push(colors, black)
array.push(colors, blue)
array.push(colors, fuchsia)
array.push(colors, gray)
array.push(colors, green)
array.push(colors, lime)
array.push(colors, maroon)
array.push(colors, navy)
array.push(colors, olive)
array.push(colors, orange)
array.push(colors, purple)
array.push(colors, red)
array.push(colors, silver)
array.push(colors, teal)
array.push(colors, white)
array.push(colors, yellow)

// code_base = 32 // starts from space char

max_length = 4096 // max possible length of a string

// delimiters
s = " "
u = "_"
d = ":" + s
b = ")" + s
c = "," + s
eol = "\n"
eol2 = "\n\n"
divider_line = "-------------------------------------------------------------------------"

// console panel
// native text color: new.color(msg_color, transp)
msg_color = black
transp1 = 100 // 100% visible
transp2 = 0 // 100% invisible

// default panel settings
// var msg_color = black
var panel_style = label.style_none
// label color requires color(na) instead of color_na
var panel_color = color(na)
var panel_text_color = msg_color
var panel_text_size = size.large
var panel_text_align = text.align_left

// default label settings
var def_label_xloc = xloc.bar_index
var def_label_yloc = yloc.price
var def_label_style = label.style_none
var def_text_size = size.large
var def_text_align = text.align_left
var def_label_color = black
var def_text_color = black

// default line settings
var def_line_xloc = xloc.bar_index
var def_line_style = line.style_solid
var def_line_extend = extend.none
var def_line_width = 1
var def_line_color = black

// Define Arrays

// Method 1 - doesn't require var in arr definition, init arrays on each bar
// x1_arr = array.new_int(0)
// x2_arr = array.new_int(0)
// y1_arr = array.new_float(0)
// y2_arr = array.new_float(0)
// width_arr = array.new_int(0)
// color1_arr = array.new_color(0)
// color2_arr = array.new_color(0)
// color3_arr = array.new_color(0)

// xloc_arr = array.new_string(0)
// yloc_arr = array.new_string(0)
// style_arr = array.new_string(0)
// style2_arr = array.new_string(0)
// text_arr = array.new_string(0)
// tooltip_arr = array.new_string(0)
// size_arr = array.new_string(0)
// align_arr = array.new_string(0)
// extend_arr = array.new_string(0)
// exclude_arr = array.new_string(0)
// include_arr = array.new_string(0)

// label_arr = array.new_label(0)
// label_arr2 = array.new_label(0)
// line_arr = array.new_line(0)
// line_arr2 = array.new_line(0)

// Method 2 - init arrays once on startup
var x1_arr = array.new_int(0)
var x2_arr = array.new_int(0)
var y1_arr = array.new_float(0)
var y2_arr = array.new_float(0)
var width_arr = array.new_int(0)
var color1_arr = array.new_color(0)
var color2_arr = array.new_color(0)
var color3_arr = array.new_color(0)

var xloc_arr = array.new_string(0)
var yloc_arr = array.new_string(0)
var style_arr = array.new_string(0)
var style2_arr = array.new_string(0)
var text_arr = array.new_string(0)
var tooltip_arr = array.new_string(0)
var size_arr = array.new_string(0)
var align_arr = array.new_string(0)
var extend_arr = array.new_string(0)
var exclude_arr = array.new_string(0)
var include_arr = array.new_string(0)

var label_arr = array.new_label(0)
var label_arr2 = array.new_label(0)
var line_arr = array.new_line(0)
var line_arr2 = array.new_line(0)

// ================================================================================================================
// Inputs
// ================================================================================================================

// Show/Hide flags
show_panel = input(true, type=bool_, title="Show Info Panel")
show_labels = input(true, type=bool_, title="Show Labels")
show_lines = input(true, type=bool_, title="Show Lines")
show_divider = input(true, type=bool_, title="Group Functions")
show_bar_index = input(false, type=bool_, title="Show Abs Bar Index")

// Function selection
// all functions works, but some are disabled to reduce compiled size
// fc1_str = input("create_label_array2", type=string_, title="Select Label Array Create Function (Lists, Arrays)", options=["create_label_array2", "create_label_array3", "create_label_array4", "create_label_array5", "create_label_array6", "create_label_array_from_arrays2"])
// fc2_str = input("create_line_array2", type=string_, title="Select Line Array Create Function (Lists, Arrays)", options=["create_line_array2", "create_line_array3", "create_line_array4", "create_line_array5", "create_line_array6", "create_line_array_from_arrays2"])
fc1_str = input("create_label_array2", type=string_, title="Select Label Array Create Function (Lists, Arrays)", options=["create_label_array2", "create_label_array4", "create_label_array_from_arrays2"])
fc2_str = input("create_line_array2", type=string_, title="Select Line Array Create Function (Lists, Arrays)", options=["create_line_array2", "create_line_array4", "create_line_array_from_arrays2"])

f1_str = input("all", type=string_, title="Select Label Array Function", options=["all", "none", "join_label_array", "join_label_array2", "label_array_get_text", "label_array_get_xy", "label_array_get_fields"])
f2_str = input("none", type=string_, title="Select Label Array SET Function", options=["none", "label_array_set_text", "label_array_set_xy", "label_array_set_color", "label_array_set_text_color", "label_array_set_fields", "label_array_set_all_fields", "label_array_set_all_fields2"])
f3_str = input("all", type=string_, title="Select Line Array Function", options=["all", "none", "join_line_array", "join_line_array2", "line_array_get_price", "line_array_get_xy", "line_array_get_fields"])
f4_str = input("none", type=string_, title="Select Line Array SET Function", options=["none", "line_array_set_width", "line_array_set_xy", "line_array_set_color", "line_array_set_fields", "line_array_set_all_fields", "line_array_set_all_fields2"])

// Function filters
exclude_str = input("", type=string_, title="Exclude Functions (i.e.join_label_array, ...):")
include_str = input("", type=string_, title="Allow Only Functions (i.e.join_label_array, ...):")

// Inputs

// Common Anchor Point Settings
group0 = "Common Anchor Point Settings"
// Label Array
label_x_base = input(0, type=integer_, title="Label X0 Base", group=group0)
label_y_base_str = input("open", type=string_, title="Label Y0 Base (Empty - 0)", options=["", "open", "high", "low", "close"], group=group0)
label_x_type_str = input("rel", type=string_, title="Label X type", options=["abs", "rel", "rel%", "inc", "inc%"], group=group0)
label_y_type_str = input("inc%", type=string_, title="Label Y type", options=["abs", "rel", "rel%", "inc", "inc%"], group=group0)
// Line Array
line_x_base = input(0, type=integer_, title="Line X0 Base", group=group0)
line_y_base_str = input("open", type=string_, title="Line Y0 Base (Empty - 0)", options=["", "open", "high", "low", "close"], group=group0)
line_x_type_str = input("rel", type=string_, title="Line X* type", options=["abs", "rel", "rel%", "inc", "inc%"], group=group0)
line_y_type_str = input("inc%", type=string_, title="Line Y* type", options=["abs", "rel", "rel%", "inc", "inc%"], group=group0)

// Lists for Create Array Functions
group1 = "Create Label/Line Arrays"

// array length
num_objects = input(7, minval=0, maxval=7, type=integer_, title="Number of Objects/Array Length [0..7]", group=group1)

// label x,y, line x1,y1,x2,y2
// x - bar index/time/% depending on x_type, x_loc; y - price/%
x1_list = input("50, 50, 50, 50, 50, 50, 50", type=string_, title="X1/X Array", group=group1)
y1_list = input("2", type=string_, title="Y1/Y Array", group=group1)
x2_list = input("0, 0, 0, 0, 0, 0, 0", type=string_, title="X2/Length Array", group=group1)
y2_list = input("2", type=string_, title="Y2/Height Array", group=group1)

// line width, extend
width_list = input("1, 2, 3, 4, 5, 6, 7", type=string_, title="Line Width Array", group=group1)
extend_list = input("none", type=string_, title="Line Extend Array", group=group1)

// label/line xloc, yloc
xloc_list = input("bar_index", type=string_, title="Label/Line Xloc Array", group=group1)
yloc_list = input("price", type=string_, title="Label Yloc Array", group=group1)

// label/line style
label_style_list = input("label_right", type=string_, title="Label Style Array", group=group1)
line_style_list = input("solid", type=string_, title="Line Style Array", group=group1)

// label object and text color, line color
color1_list = input("black, orange, red, green, blue, fuchsia, navy", type=string_, title="Label Color Array", group=group1)
color2_list = input("white", type=string_, title="Label Text Color Array", group=group1)
color3_list = input("black, orange, red, green, blue, fuchsia, navy", type=string_, title="Line Color Array", group=group1)

// label text, tooltip
text_list = input("Watermelon, Apple, Orange, Banana, Pineapple, Mango, Kiwi", type=string_, title="Label Text Array", group=group1)
tooltip_list = input("Watermelon, Apple, Orange, Banana, Pineapple, Mango, Kiwi", type=string_, title="Label Tooltip Array", group=group1)

// label text size, align
size_list = input("large", type=string_, title="Label Text Size Array", group=group1)
align_list = input("left", type=string_, title="Label Text Align Array", group=group1)

// // String Array 1
// source1 = input("Watermelon", type=string_, title="Array String 1", group="String Array 1")
// source2 = input("Apple", type=string_, title="Array String 2", group="String Array 1")
// source3 = input("Orange", type=string_, title="Array String 3", group="String Array 1")
// source4 = input("Banana", type=string_, title="Array String 4", group="String Array 1")
// source5 = input("Pineapple", type=string_, title="Array String 5", group="String Array 1")
// source6 = input("Mango", type=string_, title="Array String 6", group="String Array 1")
// source7 = input("Kiwi", type=string_, title="Array String 7", group="String Array 1")

// Properties for SET functions
// label & line colors must be string color names to be visible in function arguments
// Label
group2 = "Set Label Array Item Properties"
label_index = input(0, minval=0, maxval=6, type=integer_, title="Label Array Item Index [0..6]", group=group2)
label_x = input(50, minval=0, type=integer_, title="Label X", group=group2)
label_y = input(2, minval=0.0, type=float_, title="Label Y", group=group2)
label_text_str = input("Label", type=string_, title="Label Text", group=group2)
label_xloc_str = input("bar_index", type=string_, title="Label xloc", options=["bar_index", "bar_time"], group=group2)
label_yloc_str = input("price", type=string_, title="Label yloc", options=["price", "abovebar", "belowbar"], group=group2)
// label.style_none, label.style_xcross, label.style_cross, label.style_triangleup, label.style_triangledown, label.style_flag, label.style_circle, label.style_arrowup, label.style_arrowdown, label.style_label_up, label.style_label_down, label.style_label_left, label.style_label_right, label.style_label_lower_left, label.style_label_lower_right, label.style_label_upper_left, label.style_label_upper_right, label.style_label_center, label.style_square, label.style_diamond
label_style_str = input("label_right", type=string_, title="Label Style", options=["none", "xcross", "cross", "triangleup", "triangledown", "flag", "circle", "arrowup", "arrowdown", "label_up", "label_down", "label_left", "label_right", "label_lower_left", "label_lower_right", "label_upper_left", "label_upper_right", "label_center", "square", "diamond"], group=group2)
label_color_str = input("teal", type=string_, title="Label Color", options=["", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"], group=group2)
text_color_str = input("lime", type=string_, title="Label Text Color", options=["", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"], group=group2)
text_size_str = input("large", type=string_, title="Label Text Size", options=["auto", "tiny", "small", "normal", "large", "huge"], group=group2)
// text.align_left, text.align_center, text.align_right
text_align_str = input("left", type=string_, title="Label Text Align", options=["center", "left", "right"], group=group2)
tooltip_str = input("tooltip", type=string_, title="Tooltip", group=group2)

// Line
group3 = "Set Line Array Item Properties"
line_index = input(0, minval=0, maxval=6, type=integer_, title="Line Array Item Index [0..6]", group=group3)
line_x1 = input(50, minval=0, type=integer_, title="Label X1", group=group3)
line_y1 = input(2, minval=0.0, type=float_, title="Label Y1", group=group3)
line_x2 = input(0, minval=0, type=integer_, title="Label X2", group=group3)
line_y2 = input(2, minval=0.0, type=float_, title="Label Y2", group=group3)
line_width = input(5, minval=0, type=integer_, title="Line Width", group=group3)
line_price_bar = input(0, minval=0, type=integer_, title="Line Price Bar", group=group3)
line_xloc_str = input("bar_index", type=string_, title="Line xloc", options=["bar_index", "bar_time"], group=group3)
// line.style_solid, line.style_dotted, line.style_dashed, line.style_arrow_left, line.style_arrow_right, line.style_arrow_both
line_style_str = input("solid", type=string_, title="Line Style", options=["solid", "dotted", "dashed", "arrow_left", "arrow_right", "arrow_both"], group=group3)
// extend.none, extend.left, extend.right, extend.both
line_extend_str = input("none", type=string_, title="Line Extend", options=["none", "left", "right", "both"], group=group3)
line_color_str = input("teal", type=string_, title="Line Color", options=["", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"], group=group3)

// Formatting
group4 = "Formatting"
del3 = input(",", type=string_, title="List Delimiter", options=[",", ";", " "], group=group4)
format = input("#.##", type=string_, title="Float Value Format", group=group4)
line_spacing = input(0, minval=0, type=integer_, title="Line Spacing", group=group4)

// Panel Customization
group5 = "Customization"
panel_style_str = input("label_lower_left", type=string_, title="Panel Style", options=["none", "xcross", "cross", "triangleup", "triangledown", "flag", "circle", "arrowup", "arrowdown", "label_up", "label_down", "label_left", "label_right", "label_lower_left", "label_lower_right", "label_upper_left", "label_upper_right", "label_center", "square", "diamond"], group=group5)
use_native = input(true, type=bool_, title="Use Native Colors", group=group5)
// msg_color must be const, can't be var/mutable to be used in input.color color.new() - otherwise it doesn't compile
//   - unicode Em-space (wider) is used for padding of inline color fields because the compiler trims all empty space sequences in title
panel_color_native = input(color.new(msg_color, transp1), type=color_, title="Panel Color (Native|String)      ", group=group5, inline="Panel Color")
panel_color_str = input("", type=string_, title="|", options=["", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"], group=group5, inline="Panel Color")
panel_text_color_native = input(color.new(msg_color, transp2), type=color_, title="Panel Text Color (Native|String)    ", group=group5, inline="Panel Text Color")
panel_text_color_str = input("black", type=string_, title="|", options=["", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"], group=group5, inline="Panel Text Color")
// panel_text_transp value must be discrete
// panel_transp = input(transp, type=integer_, minval=0, maxval=100, title="Level Transparency [0..100], step 10", options=[0,10,20,30,40,50,60,70,80,90,100], group=group5)
// panel_text_transp = input(transp, type=integer_, minval=0, maxval=100, title="Level Transparency [0..100], step 10", options=[0,10,20,30,40,50,60,70,80,90,100], group=group5)
// important! v_shift must be explicitly defined as float otherwise v_shift/100 = 0 instead of 0.02
// v_shift = input(2.0, type=float_, title="Panel Vertical Shift, %", group=group5)
panel_text_size_str = input("large", type=string_, title="Panel Text Size", options=["auto", "tiny", "small", "normal", "large", "huge"], group=group5)
panel_text_align_str = input("left", type=string_, title="Panel Text Align", options=["center", "left", "right"], group=group5)


// ================================================================================================================
// Using Common String Functions Library
// ================================================================================================================

// ================================================================================================================
// String Modification Functions
// ================================================================================================================

// repeat str string num times
// str - can be char/string
repeat(str, num) =>
    res = ""
    len = str.length(str)
    if num > 0 and len * num <= max_length
        for i = 1 to num
            res := res + str

    res

// str pre-processing before output
// wraps str in quotes or replaces "" with NaN for output
// quote_str
out_str(str, type) =>
    res = type == "string" ? "\"" + str + "\"" : str == "" ? "NaN" : str

// splits string into substrings using specified separator char, returns array of substrings
// can't use str.split(str, ",") - it doesn't work as expected
// - str.split(str, d) ignores starting d and all d sequences ,,, in the middle, requires other chars between d, only an ending d produces an empty arr item for some reason
// - str.split(str, "") when str = "" => [""] (not na), size = 1 (same as "a"!), str = "a" => ["a"], size = 1 (same as ""!), str = "ab" => ["a", "b"], size = 2 (correct)
str_split(str, d) =>
    // 0..n-1
    arr = str.split(str, "")
    str_arr = array.new_string(0)

    // n
    // can't use array.size: str = "" => len = 1 (min size), always > 0 => len > 0 cond can't be used to filter out str = ""
    // len = array.size(arr)
    len = str.length(str)

    // str != ""
    if len > 0
        res = ""
        char = ""
        for i = 0 to len - 1
            char := array.get(arr, i)

            // end of char sequence
            if char == d
                array.push(str_arr, res)
                res := ""
            else
                res := res + char

        // can't move this inside for - res := res + char must run on the last iteration
        // - when str ends with char != d => push last char sequence
        // - when str ends with d => push empty char as the last arr item
        res := char == d ? "" : res
        array.push(str_arr, res)


    str_arr

// splits string into substrings using specified separator char, returns array of substrings
// fixed str.split using str.split with a 2nd separator
str_split2(str, d) =>
    // wraps d in unique symbols to prevent incorrect result when str = d or contains ddd... sequence or starts with d
    source = str.replace_all(str, d, "#" + d)
    // 0..n-1
    arr = str.split(source, d)

    // remove the only empty "" element
    if str == ""
        array.clear(arr)

    // n
    len1 = array.size(arr)
    len2 = str.length(str)

    if len1 > 0
        for i = 0 to len1 - 1
            item = array.get(arr, i)
            len = str.length(item)
            item_arr = str.split(item, "")
            // item with last char removed
            item_arr2 = array.copy(item_arr)
            last_char = array.pop(item_arr2)
            // strict cond - remove last char of every item (that now ends with # as result of split), except last (doesn't end with #, because # was inserted in front of d, not behind it)
            // array.pop requires len > 0 or item != "" otherwise error - nothing to pop from empty array
            item := item == "#" or item == "" ? "" : i < len1 - 1 ? array.join(item_arr2, "") : item
            // loose cond - item str may contain # char from user input
            // item := item == "#" ? "" : str.replace_all(item, "#", "")
            array.set(arr, i, item)

    arr

// remove the first and the last chars wrapping a string - usually square brackets
remove_end_chars(str) =>
    // 0..n-1
    arr = str.split(str, "")

    // must be 2 separate ifs because str can be empty or a single char => prevents error
    if array.size(arr) > 0
        array.shift(arr)

    if array.size(arr) > 0
        array.pop(arr)

    res = array.join(arr, "")


// ================================================================================================================
// Type Conversion Functions
// ================================================================================================================

// 1. Convert Var Type to String Functions

// convert bool to string
// tostring(flag) works only for internal script vars, flag bool expression can't depend on any inputs of any type
bool_to_str(flag) =>
    // string(na) == ""
    res = na(flag) ? "" : flag ? "true" : "false"

// convert color to string
// tostring(col) doesn't work
color_to_str(col) =>
    // "", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"
    get_color = col == black ? "black" : col == silver ? "silver" : col == gray ? "gray" : col == white ? "white" : col == maroon ? "maroon" : col == red ? "red" :
         col == purple ? "purple" : col == fuchsia ? "fuchsia" : col == green ? "green" : col == lime ? "lime" : col == olive ? "olive" : col == yellow ? "yellow" :
             col == navy ? "navy" : col == blue ? "blue" : col == teal ? "teal" : col == aqua ? "aqua" : col == orange ? "orange" : ""

// get full name of label_style property
label_style_to_str(str) =>
    res = str == "xcross" or str == label.style_xcross ? "label.style_xcross" : str == "cross" or str == label.style_cross ? "label.style_cross" : str == "triangleup" or str == label.style_triangleup ? "label.style_triangleup" :
         str == "triangledown" or str == label.style_triangledown ? "label.style_triangledown" : str ==  "flag" or str == label.style_flag ? "label.style_flag" : str == "circle" or str == label.style_circle ? "label.style_circle" :
             str == "arrowup" or str == label.style_arrowup ? "label.style_arrowup" : str == "arrowdown" or str == label.style_arrowdown ? "label.style_arrowdown" : str == "label_up" or str == label.style_label_up ? "label.style_label_up" :
                 str ==  "label_down" or str == label.style_label_down ? "label.style_label_down" : str == "label_left" or str == label.style_label_left ? "label.style_label_left" : str == "label_right" or str == label.style_label_right ? "label.style_label_right" :
                     str == "label_lower_left" or str == label.style_label_lower_left ? "label.style_label_lower_left" : str == "label_lower_right" or str == label.style_label_lower_right ? "label.style_label_lower_right" :
                         str == "label_upper_left" or str == label.style_label_upper_left ? "label.style_label_upper_left" : str == "label_upper_right" or str == label.style_label_upper_right ? "label.style_label_upper_right" :
                             str == "label_center" or str == label.style_label_center ? "label.style_label_center" : str == "square" or str == label.style_square ? "label.style_square" : str == "diamond" or str == label.style_diamond ? "label.style_diamond" :
                                 str == "none" or str == label.style_none ? "label.style_none" : ""

// get full name of line_style property
line_style_to_str(str) =>
    res = str == "dotted" or str == line.style_dotted ? "line.style_dotted" : str == "dashed" or str == line.style_dashed ? "line.style_dashed" : str == "arrow_left" or str == line.style_arrow_left ? "line.style_arrow_left" :
         str == "arrow_right" or str == line.style_arrow_right ? "line.style_arrow_right" : str == "arrow_both" or str == line.style_arrow_both ? "line.style_arrow_both" : str == "solid" or str == line.style_solid ? "line.style_solid" : ""

// get full name of size property
// both size_str and string constant size.large can be passed
size_to_str(size) =>
    res = size == "tiny" or size == size.tiny ? "size.tiny" : size == "small" or size == size.small ? "size.small" : size == "normal" or size == size.normal ? "size.normal" : size == "large" or size == size.large ? "size.large" :
         size == "huge" or size == size.huge ? "size.huge" : size == "auto" or size == size.auto ? "size.auto" : ""

// get full name of text_align property
text_align_to_str(str) =>
    res = str == "left" or str == text.align_left ? "text.align_left" : str == "right" or str == text.align_right ? "text.align_right" : str == "center" or str == text.align_center ? "text.align_center" : ""

// get full name of line_extend property
line_extend_to_str(str) =>
    res = str == "left" or str == extend.left ? "extend.left" : str == "right" or str == extend.right ? "extend.right" : str == "both" or str == extend.both ? "extend.both" : str == "none" or str == extend.none ? "extend.none" : ""

// get full name of xloc property
xloc_to_str(str) =>
    res = str == "bar_time" or str == xloc.bar_time ? "xloc.bar_time" : str == "bar_index" or str == xloc.bar_index ? "xloc.bar_index" : ""

// get full name of yloc property
yloc_to_str(str) =>
    res = str == "abovebar" or str == yloc.abovebar ? "yloc.abovebar" : str == "belowbar" or str == yloc.belowbar ? "yloc.belowbar" : str == "price" or str == yloc.price ? "yloc.price" : ""

// get full name of any property
property_to_str(str) =>
    res = ""
    res := na(res) ? xloc_to_str(str) : res
    res := na(res) ? yloc_to_str(str) : res
    res := na(res) ? label_style_to_str(str) : res
    res := na(res) ? size_to_str(str) : res
    res := na(res) ? text_align_to_str(str) : res
    res := na(res) ? line_style_to_str(str) : res
    res := na(res) ? line_extend_to_str(str) : res

    res


// 2. Convert String to Var Type Functions

// convert bool_str to bool
// tonumber(bool_str) doesn't work
get_bool(bool_str) =>
    res = bool_str == "true" ? true : bool_str == "false" ? false : bool(na)

// convert color_str to color
// - you can set color from input if you cast str to color first
// - str can't be a color literal (i.e. #CC0000) - can't cast string to a # color literal
// - you can't set color_transp color(red, color_transp) from input (must be const), but you can set plot_transp (can be var)
// - this increases plot outputs 1x color => 2x color because color is the result of a cond
// - there are 2 color na values:
//   - color color_na = na = #000000 = na(color) (without transparency) and
//   - color(na) = #00000000 (with transparency) != color_na
//   - different functions require different types of na color, can't return both
//   - returns color_na
get_color(str) =>
    // "", "black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange"
    get_color = str == "black" ? black : str == "silver" ? silver : str == "gray" ? gray : str == "white" ? white : str == "maroon" ? maroon : str == "red" ? red :
         str == "purple" ? purple : str == "fuchsia" ? fuchsia : str == "green" ? green : str == "lime" ? lime : str == "olive" ? olive : str == "yellow" ? yellow :
             str == "navy" ? navy : str == "blue" ? blue : str == "teal" ? teal : str == "aqua" ? aqua : str == "orange" ? orange : color_na

// extract source from source str
get_src(src_str) =>
    res = src_str == "open" ? open : src_str == "high" ? high : src_str == "low" ? low : src_str == "close" ? close : src_str == "hl2" ? hl2 : src_str == "hlc3" ? hlc3 : src_str == "ohlc4" ? ohlc4 : na

// get full label style property name
get_label_style(str) =>
    res = str == "xcross" ? label.style_xcross : str == "cross" ? label.style_cross : str == "triangleup" ? label.style_triangleup : str == "triangledown" ? label.style_triangledown : str ==  "flag" ? label.style_flag :
         str == "circle" ? label.style_circle : str == "arrowup" ? label.style_arrowup : str == "arrowdown" ? label.style_arrowdown : str == "label_up" ? label.style_label_up : str ==  "label_down" ? label.style_label_down :
             str == "label_left" ? label.style_label_left : str == "label_right" ? label.style_label_right : str == "label_lower_left" ? label.style_label_lower_left : str == "label_lower_right" ? label.style_label_lower_right :
                 str == "label_upper_left" ? label.style_label_upper_left : str == "label_upper_right" ? label.style_label_upper_right : str == "label_center" ? label.style_label_center : str == "square" ? label.style_square :
                     str == "diamond" ? label.style_diamond : label.style_none

// get full line style property name
get_line_style(str) =>
    res = str == "dotted" ? line.style_dotted : str == "dashed" ? line.style_dashed : str == "arrow_left" ? line.style_arrow_left : str == "arrow_right" ? line.style_arrow_right : str == "arrow_both" ? line.style_arrow_both : line.style_solid

// get full text size property name
get_size(size_str) =>
    res = size_str == "tiny" ? size.tiny : size_str == "small" ? size.small : size_str == "normal" ? size.normal : size_str == "large" ? size.large : size_str ==  "huge" ? size.huge : size.auto

// get full text align property name
get_text_align(str) =>
    res = str == "left" ? text.align_left : str == "right" ? text.align_right : text.align_center

// get full line extend property name
get_line_extend(str) =>
    res = str == "left" ? extend.left : str == "right" ? extend.right : str == "both" ? extend.both : extend.none

// get full xloc property name
get_xloc(str) =>
    res = str == "bar_time" ? xloc.bar_time : xloc.bar_index

// get full yloc property name
get_yloc(str) =>
    res = str == "abovebar" ? yloc.abovebar : str == "belowbar" ? yloc.belowbar : yloc.price

// get full name of any string property
get_property_name(str) =>
    res = ""
    res := na(res) ? get_xloc(str) : res
    res := na(res) ? get_yloc(str) : res
    res := na(res) ? get_label_style(str) : res
    res := na(res) ? get_size(str) : res
    res := na(res) ? get_text_align(str) : res
    res := na(res) ? get_line_style(str) : res
    res := na(res) ? get_line_extend(str) : res

    res

// get full name of any string property by type
get_property_name2(str, type) =>
    res = type == "extend" or type == "line_extend" ? get_line_extend(str) : type == "size" or type == "text_size" ? get_size(str) : type == "align" or type == "text_align" ? get_text_align(str) :
         type == "xloc" or type == "label_xloc" or type == "line_xloc" ? get_xloc(str) : type == "yloc" or type == "label_yloc" ? get_yloc(str) : ""

    if type == "style" or type == "label_style" or type == "line_style"
        label_style = get_label_style(str)
        line_style = get_line_style(str)
        res := type == "label_style" ? label_style : type == "line_style" ? line_style : not na(label_style) ? label_style : line_style

    res

// 3. String Expand/Transform Functions

// get x,y type
// there are 5 types available for both x,y: abs, rel, rel%, inc, inc%
//  - abs - absolute bar index/time from start bar0 (x) or price (y) from 0, is >= 0
//  - rel - relative bar index/time from cur bar n (x) or price from y0 base level, is >= 0
//  - rel% - relative % increase of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
//  - inc - relative increment (step) for each new level of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
//  - inc% - relative % increment (% step) for each new level of bar index/time (x) or price (y) from corresponding base level (x0 or y0), can be <=> 0
get_type(str) =>
    res = str == "abs" ? 0 : str == "rel" ? 1 : str == "rel%" ? 2 : str == "inc" ? 3 : str == "inc%" ? 4 : na

// translate x depending on type, base, xloc and array item index
//  - when xloc = xloc.bar_index each rel*/inc* value is subtracted from n: n - x to convert rel to abs bar index, values of abs type are not affected
//  - when xloc = xloc.bar_time there's no rel to abs bar index conversion
//  - x1_list = "0, 50, 100, ..." of type rel is the same as "50" of type inc
//  - x1_list = "50, 50, 50, ..." of type abs/rel/rel% produces a sequence of the same values and can be shortened to just "50"
transform_x(x, x_type, x_base, xloc, index) =>
    x_int = x_type == 1 ? x_base + x : x_type == 2 ? int(x_base * (1 + x / 100.0)) : x_type == 3 ? x_base + x * index : x_type == 4 ? int(x_base * (1 + x * index / 100.0)) : x
    res = xloc == xloc.bar_index and x_type > 0 ? n - x_int : x_int

// translate y depending on type, base and array item index
//  - when yloc != yloc.price all calculated values are simply ignored
//  - y1_list = "0, 2, 4" of type rel% is the same as "2" of type inc%
//  - y1_list = "2, 2, 2" of type abs/rel/rel% produces a sequence of the same values and can be shortened to just "2"
transform_y(y, y_type, y_base, index) =>
    res = y_type == 1 ? y_base + y : y_type == 2 ? y_base * (1 + y / 100.0) : y_type == 3 ? y_base + y * index : y_type == 4 ? y_base * (1 + y * index / 100.0) : y
    // if yloc_str != yloc.price y is simply ignored - no need to check for yloc_str

// translate entire x_arr depending on type, base, xloc and array item index
// requires expanded xloc_arr
transform_x_array(x_arr, x_type, x_base, xloc_arr, max_len) =>

    xt_arr = array.new_int(0)

    len1 = array.size(x_arr)
    len2 = array.size(xloc_arr)

    // max_len can be > 0, while x_arr and x_loc_arr empty => fill xt_arr with na values
    len = max(len1, len2)
    len := max(len, max_len)

    if len > 0
        for i = 0 to len - 1
            x = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : na
            xloc = len2 > 0 ? array.get(xloc_arr, i < len2 ? i : 0) : ""
            xt = transform_x(x, x_type, x_base, xloc, i)
            array.push(xt_arr, xt)

    xt_arr

// translate entire y_arr depending on type, base and array item index
// doesn't need yloc_arr
transform_y_array(y_arr, y_type, y_base, max_len) =>

    yt_arr = array.new_float(0)

    length = array.size(y_arr)

    // max_len can be > 0, while y_arr is empty => fill yt_arr with na values
    len = max(length, max_len)

    if len > 0
        for i = 0 to len - 1
            y = length > 0 ? array.get(y_arr, i < length ? i : 0) : na
            yt = transform_y(y, y_type, y_base, i)
            array.push(yt_arr, yt)

    yt_arr

// 0 - transform x, 1 - transform y
// requires expanded xloc str
transform_coord_array(arr, type, base, xloc, mode) =>

    // float and int arr pointers are interchangeable to some extent and don't produce errors
    res_arr = array.new_float(0)
    if mode == 0
        res_arr := array.new_int(0)

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            val = array.get(arr, i)
            new_val = mode == 0 ? transform_x(val, type, base, xloc, i) : transform_y(val, type, base, i)
            array.push(res_arr, new_val)

    res_arr

// replace all strings in array with their corresponding full property names for use in standard functions
// must assign proper def* values to empty array items, "" - causes error in label.new, line.new
expand_string_array(str_arr, type) =>

    res_arr = array.new_string(0)

    // supports any array type
    len = array.size(str_arr)

    if len > 0
        for i = 0 to len - 1
            str = array.get(str_arr, i)
            name_str = get_property_name2(str, type)
            array.push(res_arr, name_str)

    else
        // get default property name
        name_str = get_property_name2("", type)
        array.push(res_arr, name_str)

    res_arr

// get var type of a string value
typeof(str) =>
    number = tonumber(str)
    is_int = not na(number) and int(number) == number
    is_float = not na(number)
    is_color = get_color(str) != color_na
    is_bool = get_bool(str) != bool(na)

    res = is_int ? "integer" : is_float ? "float" : is_color ? "color" : is_bool ? "bool" :  "string"


// ================================================================================================================
// Using Common Fixed Type Array Functions Library
// ================================================================================================================

// ================================================================================================================
// Fixed Type Array Join Functions
// ================================================================================================================

// convert to string/join array of numbers
// arr - array of int/float numbers
// standard array.join() can only join array of strings, can't join array of numbers, using tostring() instead
// using tostring()
join_number_array(arr, d) =>
    // this doesn't work - internal server error - can't join array of numbers and convert it into string
    // res = array.join(arr, ", ")
    // res = "" + array.join(arr, ", ")
    // this works => "[1, 2,.., 3]"
    // format applies to each array item
    res = tostring(arr, format)
    res := d != ", " ? str.replace_all(res, ", ", d) : res

// convert to string/join array of numbers
// * modified, don't wrap joined arr result in square brackets
join_number_array2(arr, d) =>
    res = ""
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            item = array.get(arr, i)
            item_str = tostring(item, format)
            // minimizes local scopes/function calls
            // str = out_str(item_str, type)
            str = item_str == "" ? "NaN" : item_str
            res := i > 0 ? res + d : res
            res := res + str

        // don't wrap joined arr result in square brackets
        // res := "[" + res + "]"

    res

// convert to string/join array of strings
// arr - array of strings
// always wrap string array items in quotes
// using array.join
join_string_array(arr) =>
    // d* must be const, can't be var/input or depend on cond for array.join to work
    d = "\", \""
    res = "[\"" + array.join(arr, d) + "\"]"

// arr - array of strings
// join array of strings using a custom delimiter with all items wrapped in quotes
// using array.join
join_string_array2(arr, d) =>
    // d* must be const, can't be var/input or depend on cond for array.join to work => must have multiple array.join calls
    d1 = "\", \""
    d2 = "\"; \""
    d3 = "\" \""
    res = d == ", " ? array.join(arr, d1) : d == "; " ? array.join(arr, d2) : d == " " ? array.join(arr, d3) : array.join(arr)
    res := "[\"" + res + "\"]"

// join array of strings using a custom delimiter and wrap all items in quotes based on arr type (for arrays of any type converted to string type)
// using array.join
join_string_array3(arr, d, type) =>
    // d* must be const, can't be var/input or depend on cond for array.join to work
    // doesn't work
    // del = type == "string" ? "\", \"" : ", " // array.join for str_arr only supports const str delimiter
    d1 = "\", \""
    d2 = "\"; \""
    d3 = "\" \""
    d4 = ", "
    d5 = "; "
    d6 = " "
    // wrap str_arr items in quotes
    res1 = d == ", " ? array.join(arr, d1) : d == "; " ? array.join(arr, d2) : d == " " ? array.join(arr, d3) : array.join(arr)
    res1 := "[\"" + res1 + "\"]"

    // omit quotes for all other array types converted to str_arr
    res2 = d == ", " ? array.join(arr, d4) : d == "; " ? array.join(arr, d5) : d == " " ? array.join(arr, d6) : array.join(arr)
    res2 := "[" + res2 + "]"
    // search & replace order is important
    res2 := str.replace_all(res2, "[" + d, "[" + "NaN" + d)
    // 1st pass: for odd d
    res2 := str.replace_all(res2, d + d, d + "NaN" + d)
    // 2nd pass: for even remaining d
    res2 := str.replace_all(res2, d + d, d + "NaN" + d)
    res2 := str.replace_all(res2, d + "]", d + "NaN" + "]")

    res = type == "string" ? res1 : res2

// join array of strings using a custom delimiter and wrap all items in quotes based on arr type (for arrays of any type converted to string type)
join_string_array4(arr, d, type) =>
    res = ""
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            item = array.get(arr, i)
            str = out_str(item, type)
            res := i > 0 ? res + d : res
            res := res + str

        res := "[" + res + "]"

    res

// ================================================================================================================
// Label Object Array Join Functions
// ================================================================================================================

// join all fields of a label object into a single string using custom delimiters
// d1 - field name prefix delimiter
// d2 - field list delimiter
join_label_object(label_, d1, d2) =>
    // this doesn't work => internal server error - can't join label and convert it into string
    // res = array.join(arr, ", ")
    res = ""

    if not na(label_)
        x = label.get_x(label_)
        y = label.get_y(label_)
        str = label.get_text(label_)
        x_str = tostring(x, format)
        y_str = tostring(y, format)
        res := "x" + d1 + x_str + d2 + "y" + d1 + y_str + d2 + "text" + d1 + str

    res := "[" + res + "]"

// join label object array into a single string using custom delimiters
// d1 - field name prefix delimiter
// d2 - field list delimiter
join_label_array(arr, d1, d2) =>
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            label_ = array.get(arr, i)
            res := i > 0 ? res + d2 : res
            res := res + join_label_object(label_, d1, d2)

    res := "[" + res + "]"


// d1 - field name prefix delimiter
// d2 - field list delimiter
// d3 - tuple delimiter (i.e. ","" or ",\n")
join_label_array2(arr, d1, d2, d3) =>
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            label_ = array.get(arr, i)

            label_str = ""

            if not na(label_)
                x = label.get_x(label_)
                y = label.get_y(label_)
                str = label.get_text(label_)
                str := "\"" + str + "\""
                x_str = tostring(x, format)
                y_str = tostring(y, format)
                label_str := "x" + d1 + x_str + d2 + "y" + d1 + y_str + d2 + "text" + d1 + str

            res := i > 0 ? res + d3 : res

            label_str := "[" + label_str + "]"
            res := res + label_str

    res := "[" + res + "]"


// ================================================================================================================
// Line Object Array Join Functions
// ================================================================================================================

// join all fields of a line object into a single string using custom delimiters
// d1 - field name prefix delimiter
// d2 - field list delimiter
join_line_object(line_, d1, d2) =>
    // this doesn't work => internal server error - can't join line and convert it into string
    // res = array.join(arr, ", ")
    res = ""

    if not na(line_)
        x1 = line.get_x1(line_)
        y1 = line.get_y1(line_)
        x2 = line.get_x2(line_)
        y2 = line.get_y2(line_)
        x1_str = tostring(x1, format)
        y1_str = tostring(y1, format)
        x2_str = tostring(x2, format)
        y2_str = tostring(y2, format)

        res := "x1" + d1 + x1_str + d2 + "y1" + d1 + y1_str + d2 + "x2" + d1 + x2_str + d2 + "y2" + d1 + y2_str

    res := "[" + res + "]"

// join line object array into a single string using custom delimiters
// d1 - field name prefix delimiter
// d2 - field list delimiter
join_line_array(arr, d1, d2) =>
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            line_ = array.get(arr, i)
            res := i > 0 ? res + d2 : res
            res := res + join_line_object(line_, d1, d2)

    res := "[" + res + "]"


// d1 - field name prefix delimiter
// d2 - field list delimiter
// d3 - tuple delimiter (i.e. ","" or ",\n")
join_line_array2(arr, d1, d2, d3) =>
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1
            line_ = array.get(arr, i)

            line_str = ""

            if not na(line_)
                x1 = line.get_x1(line_)
                y1 = line.get_y1(line_)
                x2 = line.get_x2(line_)
                y2 = line.get_y2(line_)
                x1_str = tostring(x1, format)
                y1_str = tostring(y1, format)
                x2_str = tostring(x2, format)
                y2_str = tostring(y2, format)

                line_str := "x1" + d1 + x1_str + d2 + "y1" + d1 + y1_str + d2 + "x2" + d1 + x2_str + d2 + "y2" + d1 + y2_str

            res := i > 0 ? res + d3 : res

            line_str := "[" + line_str + "]"
            res := res + line_str

    res := "[" + res + "]"


// ================================================================================================================
// Using Common Variable Type Array Functions Library
// ================================================================================================================

// ================================================================================================================
// Any Type Var Type Conversion Functions
// ================================================================================================================

init_any_var() =>
    val1 = int(na)
    val2 = float(na)
    val3 = string(na)
    val4 = color_na
    val5 = bool(na)
    val6 = label(na)
    val7 = line(na)

    [val1, val2, val3, val4, val5, val6, val7]

// generate a list of every possible arr* type including the source arr type
// arr - array of 1 element, value that is already wrapped in array
// arr is used instead of val to allow arr* pointer assignments of a non matching arr type - otherwise error
get_var_types5(arr, type) =>
    arr1 = array.new_int(0)
    arr2 = array.new_float(0)
    arr3 = array.new_string(0)
    arr4 = array.new_color(0)
    arr5 = array.new_bool(0)
    arr6 = array.new_label(0)
    arr7 = array.new_line(0)

    // doesn't work - incompatible types
    // this produces an error if arr, arr1, val and val1 types don't match
    // if type == "integer"
    //     val1 := val
    //     arr1 := array.new_int(1, val)
    //     array.fill(arr1, val)
    //     array.set(arr1, 0, val)
    //     array.unshift(arr1, val)
    //     array.push(arr1, val)
    //     array.concat(arr1, arr)
    //     val1 := array.shift(arr)

    // doesn't work
    // val1 = iff(type == "integer", val, int(na))

    // this works for local/param var type arr because arr is passed by reference and only 1 branch with arr pointer assignment regardless of type is executed - compiler allows that
    // however just 1 branch returns a valid arr* result matching arr type, the remaining branches return arr* with invalid types that can produce errors later
    // this can't be done for local/param vars because they are passed by value with pre-determined type and since the compiler uses strict types it throws an error
    if type == "integer"
        arr1 := arr

    if type == "float"
        arr2 := arr

    if type == "string"
        arr3 := arr

    if type == "color"
        arr4 := arr

    if type == "bool"
        arr5 := arr

    if type == "label"
        arr6 := arr

    if type == "line"
        arr7 := arr

    // this works without errors because each arr* matches its na type including one arr* that matches the type of an array pointer to arr
    // all arrays are empty except arr, when size > 0 - only 1 if branch is executed
    val1 = array.size(arr1) > 0 ? array.get(arr1, 0) : int(na)
    val2 = array.size(arr2) > 0 ? array.get(arr2, 0) : float(na)
    val3 = array.size(arr3) > 0 ? array.get(arr3, 0) : string(na)
    val4 = array.size(arr4) > 0 ? array.get(arr4, 0) : color_na
    val5 = array.size(arr5) > 0 ? array.get(arr5, 0) : bool(na)
    val6 = array.size(arr6) > 0 ? array.get(arr6, 0) : label(na)
    val7 = array.size(arr7) > 0 ? array.get(arr7, 0) : line(na)


    [val1, val2, val3, val4, val5, val6, val7]


// convert any type value to string
// base version
// arr matches type and arr_val - no errors
// arr_val* - val* wrapped into a single element array of a matching type
// using array.slice
any_to_str5(arr, index, type) =>
    arr_val = array.slice(arr, index, index + 1)
    [val1, val2, val3, val4, val5, val6, val7] = get_var_types5(arr_val, type)
    res = type == "integer" ? tostring(val1, format) : type == "float" ? tostring(val2, format) : type == "string" ? val3 : type == "color" ? color_to_str(val4) : type == "bool" ? bool_to_str(val5) : type == "label" ? "label_" : "line_"

// base version with label/line object support
// uses join_label/line_object, must stay after
any_to_str6(arr, index, type) =>
    arr_val = array.slice(arr, index, index + 1)
    [val1, val2, val3, val4, val5, val6, val7] = get_var_types5(arr_val, type)
    res = type == "integer" ? tostring(val1, format) : type == "float" ? tostring(val2, format) : type == "string" ? val3 : type == "color" ? color_to_str(val4) : type == "bool" ? bool_to_str(val5) : type == "label" ? join_label_object(val6, d, del3) : type == "line" ? join_line_object(val7, d, del3) : ""

// convert string value to any target type
str_to_any2(str, type) =>
    // must init with corresponding value depending on type
    // [val1, val2, val3, val4, val5, val6, val7] = init_any_var()
    [val1_, val2_, val3_, val4_, val5_, val6_, val7_] = init_any_var()

    // reduces local scopes
    val1 = type == "integer" ? int(tonumber(str)) : val1_
    val2 = type == "float" ? tonumber(str) : val2_
    val3 = type == "string" ? str : val3_
    val4 = type == "color" ? get_color(str) : val4_
    val5 = type == "bool" ? get_bool(str) : val5_
    val6 = val6_
    val7 = val7_

    // +5 local scopes
    // if type == "integer"
    //     val1 := int(tonumber(str))

    // if type == "float"
    //     val2 := tonumber(str)

    // if type == "string"
    //     val3 := str

    // if type == "color"
    //     val4 := get_color(str)

    // if type == "bool"
    //     val5 := get_bool(str)

    // if type == "label"
    //     val6 := label.new_label(x, y, color, str)

    // if type == "line"
    //     val6 := label.new_line(x1, y1, x2, y2, color)

    [val1, val2, val3, val4, val5, val6, val7]


// ================================================================================================================
// Any Type Array Create Functions
// ================================================================================================================

// create array of specified type from a string list of elements
// d - separator
// requires a set of pre-defined global arrays of matching types to pass as arr param
// create_any_array can be assigned to any array var (new undefined or existing with matching arr type), because res_arr is defined with/returns a matching arr param type
// this works:
// str_arr := create_any_array(str_arr, "", "", "string")
// arr = create_any_array(str_arr, "", "", "string")
// create_any_array(arr, list, d, type) =>
//     arr1 = array.new_int(0)
//     arr2 = array.new_float(0)
//     arr3 = array.new_string(0)
//     arr4 = array.new_color(0)
//     arr5 = array.new_bool(0)
//     arr6 = array.new_label(0)
//     arr7 = array.new_line(0)

//     // is defined with a matching arr type, can be assigned to an arr var with a matching arr type or to a new var with undefined type
//     res_arr = arr

//     type_ = type == "include" or type == "exclude" ? "string" : type

//     // string array
//     if type_ == "string" and list == "source"
//         array.push(arr3, source1)
//         array.push(arr3, source2)
//         array.push(arr3, source3)
//         array.push(arr3, source4)
//         array.push(arr3, source5)
//         array.push(arr3, source6)
//         array.push(arr3, source7)

//     if (list != "") and ( (type_ != "string") or (type_ == "string" and list != "source") )
//         // 0..n-1
//         list_ = d != " " ? str.replace_all(list, " ", "") : list

//         // can't use str.split - it ignores d sequences
//         // arr = str.split(list_, d)
//         // +10 local scopes
//         // arr = str_split(list_, d)
//         // +4 local scopes
//         arr = str_split2(list_, d)

//         // n
//         len = array.size(arr)

//         for i = 0 to len - 1
//             str = array.get(arr, i)
//             [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type_)

//             if type_ == "integer"
//                 array.push(arr1, val1)
//             if type_ == "float"
//                 array.push(arr2, val2)
//             if type_ == "string"
//                 array.push(arr3, val3)
//             if type_ == "color"
//                 array.push(arr4, val4)
//             if type_ == "bool"
//                 array.push(arr5, val5)
//             if type_ == "label"
//                 array.push(arr6, val6)
//             if type_ == "line"
//                 array.push(arr7, val7)


//     if type_ == "integer"
//         res_arr := arr1
//     if type_ == "float"
//         res_arr := arr2
//     if type_ == "string"
//         res_arr := arr3
//     if type_ == "color"
//         res_arr := arr4
//     if type_ == "bool"
//         res_arr := arr5
//     if type_ == "label"
//         res_arr := arr6
//     if type_ == "line"
//         res_arr := arr7

//     res_arr

// create array of specified type from a string list of elements
// d - separator
// requires a set of pre-defined global arrays of matching types to pass as arr param
// create_any_array can be assigned to any array var (new undefined or existing with matching arr type), because res_arr is defined with/returns a matching arr param type
// this works:
// str_arr := create_any_array(str_arr, "", "", "string")
// arr = create_any_array(str_arr, "", "", "string")
// reduces local scopes
create_any_array(arr, list, d, type) =>
    arr1 = array.new_int(0)
    arr2 = array.new_float(0)
    arr3 = array.new_string(0)
    arr4 = array.new_color(0)
    arr5 = array.new_bool(0)
    arr6 = array.new_label(0)
    arr7 = array.new_line(0)

    // is defined with a matching arr type, can be assigned to an arr var with a matching arr type or to a new var with undefined type
    // ensures that res_arr is still assigned an empty array of proper type when list = ""
    arr_ = array.copy(arr)
    array.clear(arr_)
    res_arr = arr_

    type_ = type == "include" or type == "exclude" ? "string" : type

    // string array
    // if type_ == "string" and list == "source"
    //     array.push(arr3, source1)
    //     array.push(arr3, source2)
    //     array.push(arr3, source3)
    //     array.push(arr3, source4)
    //     array.push(arr3, source5)
    //     array.push(arr3, source6)
    //     array.push(arr3, source7)
    //     res_arr := arr3

    if (list != "") and ( (type_ != "string") or (type_ == "string" and list != "source") )
        // 0..n-1
        list_ = d != " " ? str.replace_all(list, " ", "") : list
        // can't use str.split - it ignores d sequences
        // arr = str.split(list_, d)
        // +10 local scopes
        // arr = str_split(list_, d)
        // +4 local scopes
        arr = str_split2(list_, d)

        // n
        len = array.size(arr)

        for i = 0 to len - 1
            str = array.get(arr, i)
            [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type_)

            // assigning res_arr := inside if on each iteration probably increases execution time but reduces local scopes
            if type_ == "integer"
                array.push(arr1, val1)
                res_arr := arr1
            if type_ == "float"
                array.push(arr2, val2)
                res_arr := arr2
            if type_ == "string"
                array.push(arr3, val3)
                res_arr := arr3
            if type_ == "color"
                array.push(arr4, val4)
                res_arr := arr4
            if type_ == "bool"
                array.push(arr5, val5)
                res_arr := arr5
            if type_ == "label"
                array.push(arr6, val6)
                res_arr := arr6
            if type_ == "line"
                array.push(arr7, val7)
                res_arr := arr7


    // doesn't work - incompatible types
    // res_arr := type == "integer" ? arr1 : type == "float" ? arr2 : type == "string" ? arr3 : type == "color" ? arr4 : type == "bool" ? arr5 : type == "label" ? arr6 : arr7

    // +5 local scopes
    // if type_ == "integer"
    //     res_arr := arr1
    // if type_ == "float"
    //     res_arr := arr2
    // if type_ == "string"
    //     res_arr := arr3
    // if type_ == "color"
    //     res_arr := arr4
    // if type_ == "bool"
    //     res_arr := arr5
    // if type_ == "label"
    //     res_arr := arr6
    // if type_ == "line"
    //     res_arr := arr7

    res_arr

// create array of specified type from a string list of elements
// 1. requires a set of pre-defined global arrays of matching types to assign the result to
// create_any_array2 can only be assigned to an existing array var with matching type because res_arr is defined with int type/returns a non-matching arr type
// 2. this works because str_arr array type is pre-defined and matching the type param:
// str_arr := create_any_array2("", "", "string")
// 3. this will produce an error if arr is later used in str expression because create_any_array2 returns res_arr of int type that is incompatible with string type:
// arr = create_any_array2("", "", "string")
// res_arr int type arr can only be used as a temporary storage for the pointer of the resulting array of any type that must be passed/assigned to an arr with a pre-defined matching type:
// this will reassign the invalid arr pointer to a proper arr with matching type but only when the function returns a single result (doesn't work for tuples):
// str_arr := arr
create_any_array2(list, d, type) =>
    arr1 = array.new_int(0)
    arr2 = array.new_float(0)
    arr3 = array.new_string(0)
    arr4 = array.new_color(0)
    arr5 = array.new_bool(0)
    arr6 = array.new_label(0)
    arr7 = array.new_line(0)

    // temporary storage for res array pointer, must be assigned to a matching arr type or will result in an error
    res_arr = array.new_int(0)
    // res_arr = array.new_string(0)

    // this works
    // res_arr := arr3

    type_ = type == "include" or type == "exclude" ? "string" : type

    // string array
    // if type_ == "string" and list == "source"
    //     array.push(arr3, source1)
    //     array.push(arr3, source2)
    //     array.push(arr3, source3)
    //     array.push(arr3, source4)
    //     array.push(arr3, source5)
    //     array.push(arr3, source6)
    //     array.push(arr3, source7)

    if (list != "") and ( (type_ != "string") or (type_ == "string" and list != "source") )
        // 0..n-1
        list_ = d != " " ? str.replace_all(list, " ", "") : list

        // can't use str.split - it ignores d sequences
        // arr = str.split(list_, d)
        // +10 local scopes
        // arr = str_split(list_, d)
        // +4 local scopes
        arr = str_split2(list_, d)

        // n
        len = array.size(arr)

        for i = 0 to len - 1
            str = array.get(arr, i)
            [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type_)

            if type_ == "integer"
                array.push(arr1, val1)
            if type_ == "float"
                array.push(arr2, val2)
            if type_ == "string"
                array.push(arr3, val3)
            if type_ == "color"
                array.push(arr4, val4)
            if type_ == "bool"
                array.push(arr5, val5)
            if type_ == "label"
                array.push(arr6, val6)
            if type_ == "line"
                array.push(arr7, val7)


    // can't move this inside for - ensures that res_arr is still assigned an empty array of proper type when list = ""
    if type_ == "integer"
        res_arr := arr1
    if type_ == "float"
        res_arr := arr2
    if type_ == "string"
        res_arr := arr3
    if type_ == "color"
        res_arr := arr4
    if type_ == "bool"
        res_arr := arr5
    if type_ == "label"
        res_arr := arr6
    if type_ == "line"
        res_arr := arr7

    res_arr


// ================================================================================================================
// Any Type Array Join Functions
// ================================================================================================================

// join any array type into string using custom delimiter
// new base version - less code, more efficient, no label/line object array support
join_any_array3(arr, d, type) =>
    // this doesn't work => internal server error - can't join array of numbers, bool, color and convert it into string
    // res = array.join(arr, ", ")
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1

            str = any_to_str5(arr, i, type)

            // str := type == "string" ? "\"" + str + "\"" : str == "" ? "NaN" : str
            str := out_str(str, type)

            res := i > 0 ? res + d : res
            res := res + str

    res := "[" + res + "]"

// join any array with label/line object array support
join_any_array4(arr, d1, d2, type) =>
    // this doesn't work => internal server error - can't join array of numbers, bool, color and convert it into string
    // res = array.join(arr, ", ")
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1

            str = ""
            if type == "label"
                label_ = array.get(arr, i)
                str := join_label_object(label_, d1, d2)

            if type == "line"
                line_ = array.get(arr, i)
                str := join_line_object(line_, d1, d2)

            if type != "label" and type != "line"
                str := any_to_str5(arr, i, type)
                // str := type == "string" ? "\"" + str + "\"" : str == "" ? "NaN" : str
                str := out_str(str, type)

            res := i > 0 ? res + d2 : res
            res := res + str

    res := "[" + res + "]"

// join any array with label/line object array support
join_any_array5(arr, d, type) =>
    // this doesn't work => internal server error - can't join array of numbers, bool, color and convert it into string
    // res = array.join(arr, ", ")
    res = ""

    // supports any array type
    len = array.size(arr)

    if len > 0
        for i = 0 to len - 1

            str = any_to_str6(arr, i, type)

            // str := type == "string" ? "\"" + str + "\"" : str == "" ? "NaN" : str
            str := out_str(str, type)

            res := i > 0 ? res + d : res
            res := res + str

    res := "[" + res + "]"


// ================================================================================================================
// Label Object Array GET/SET Functions
// ================================================================================================================

// ================================================================================================================
// Label Object Array GET Functions
// ================================================================================================================

// property methods:
// label.get_text
// label.get_x
// label.get_y

label_array_get_text(arr, index) =>

    label label_ = na

    str = ""

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        str := label.get_text(label_)

    str


label_array_get_xy(arr, index) =>

    label label_ = na

    int x = na // UNIX time or bar index
    float y = na // price

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        x := label.get_x(label_)
        y := label.get_y(label_)

    [x, y]


// get x, y, text
label_array_get_fields(arr, index) =>

    label label_ = na

    int x = na // UNIX time or bar index
    float y = na // price
    str = ""

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        x := label.get_x(label_)
        y := label.get_y(label_)
        str := label.get_text(label_)

    [x, y, str]


// ================================================================================================================
// Label Object Array SET Functions
// ================================================================================================================

// property methods:
// label.set_color
// label.set_size
// label.set_style
// label.set_text
// label.set_textalign
// label.set_textcolor
// label.set_tooltip
// label.set_x
// label.set_xloc
// label.set_xy
// label.set_y
// label.set_yloc

label_array_set_text(arr, index, str) =>

    label label_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_text(label_, str)
        // array.set(arr, index, label_)

    arr

label_array_set_xy(arr, index, x, y) =>

    label label_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_xy(label_, x, y)
        // array.set(arr, index, label_)

    arr

label_array_set_color(arr, index, col) =>

    label label_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_color(label_, col)
        // array.set(arr, index, label_)

    arr

label_array_set_text_color(arr, index, col) =>

    label label_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_textcolor(label_, col)
        // array.set(arr, index, label_)

    arr

// set x, y, text
label_array_set_fields(arr, index, x, y, str) =>

    label label_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_xy(label_, x, y)
        label.set_text(label_, str)
        // array.set(arr, index, label_)

    arr

// label string params must contain expanded property names with proper values, "" will cause error
// x is time or abs bar index
// requires translated values, expanded property names
label_array_set_all_fields(arr, index, x, y, str, xloc, yloc, label_style, label_color, text_color, text_size, text_align, tooltip) =>

    label label_ = na

    len = array.size(arr)

    // no checks of params
    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_xloc(label_, x, xloc)
        label.set_yloc(label_, yloc)
        // set_x must remain after set_xloc
        // label.set_x(label_, x)
        label.set_y(label_, y)
        label.set_style(label_, label_style)
        label.set_color(label_, label_color)
        label.set_textcolor(label_, text_color)
        label.set_text(label_, str)
        label.set_size(label_, text_size)
        label.set_textalign(label_, text_align)
        label.set_tooltip(label_, tooltip)
        // array.set(arr, index, label_)

    arr

// label string params can be na/-1/empty/""/color_na - default global values are used
// x is time or relative bar index
// requires abs values or translated values with abs rel bar indexes swapped (xloc swap undone), expanded property names
label_array_set_all_fields2(arr, index, x, y, str, xloc, yloc, label_style, label_color, text_color, text_size, text_align, tooltip) =>

    // label label_ = na

    len = array.size(arr)

    // assign internal defaults when arg is missing
    x_ = na(x) or x == -1 ? na(xloc) or xloc == xloc.bar_time ? time : n : xloc == xloc.bar_time ? x : n - x
    y_ = na(y) or y == -1 ? close : y // only for yloc.price mode
    xloc_ = na(xloc) ? xloc.bar_time : xloc // def_label_xloc is xloc.bar_index
    yloc_ = na(yloc) ? def_label_yloc : yloc //  yloc.price, yloc.abovebar, yloc.belowbar

    label_style_ = na(label_style) ? def_label_style : label_style

    // this doesn't work
    // msg_color_ = na(msg_color) or color(msg_color) == na or msg_color == color.new(na, 0) or msg_color == #000000 or na(msg_color) == #000000 ? black : msg_color
    // if na(msg_color) or color(msg_color) == na or color.new(na, 0) == msg_color or msg_color == #000000 or na(msg_color) == #000000
    //     msg_color_ := black
    // this only works when color_na = na const is passed as msg_color
    label_color_ = na(label_color) ? def_label_color : label_color // label border and arrow color
    text_color_ = na(text_color) ? def_text_color : text_color // label text color

    text_size_ = na(text_size) ? def_text_size : text_size
    text_align_ = na(text_align) ? def_text_align : text_align // text.align_center, text.align_left, text.align_right

    if len > 0 and index >= 0 and index < len
        label_ = array.get(arr, index)
        label.set_xloc(label_, x_, xloc_)
        label.set_yloc(label_, yloc_)
        // set_x must remain after set_xloc
        // label.set_x(label_, x_)
        label.set_y(label_, y_)
        label.set_style(label_, label_style_)
        label.set_color(label_, label_color_)
        label.set_textcolor(label_, text_color_)
        label.set_text(label_, str)
        label.set_size(label_, text_size_)
        label.set_textalign(label_, text_align_)
        label.set_tooltip(label_, tooltip)
        // array.set(arr, index, label_)

    arr


// ================================================================================================================
// Line Object Array GET/SET Functions
// ================================================================================================================

// ================================================================================================================
// Line Object Array GET Functions
// ================================================================================================================

// line.get_price - function, not property
//
// property methods:
// line.get_x1
// line.get_x2
// line.get_y1
// line.get_y2

// uses get_price() function
line_array_get_price(arr, index, bar) =>

    line line_ = na
    float price = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        price := line.get_price(line_, bar)

    price

// get x1, y1, x2, y2 - same as get_fields
line_array_get_xy(arr, index) =>

    line line_ = na

    int x1 = na // UNIX time or bar index
    int x2 = na // UNIX time or bar index
    float y1 = na // price
    float y2 = na // price

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        x1 := line.get_x1(line_)
        x2 := line.get_x2(line_)
        y1 := line.get_y1(line_)
        y2 := line.get_y2(line_)

    [x1, y1, x2, y2]


// price is not a property, it's a function
// line_array_get_fields(arr, index, bar) =>
// get x1, y1, x2, y2
line_array_get_fields(arr, index) =>

    line line_ = na

    int x1 = na // UNIX time or bar index
    int x2 = na // UNIX time or bar index
    float y1 = na // price
    float y2 = na // price
    // float price = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        x1 := line.get_x1(line_)
        x2 := line.get_x2(line_)
        y1 := line.get_y1(line_)
        y2 := line.get_y2(line_)
        // price := line.get_price(line_, bar)

    // [x1, y1, x2, y2, price]
    [x1, y1, x2, y2]


// ================================================================================================================
// Line Object Array SET Functions
// ================================================================================================================

// property methods:
// line.set_color
// line.set_extend
// line.set_style
// line.set_width
// line.set_x1
// line.set_x2
// line.set_xloc
// line.set_xy1
// line.set_xy2
// line.set_y1
// line.set_y2

line_array_set_width(arr, index, width) =>

    line line_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_width(line_, width)
        // array.set(arr, index, line_)

    arr

line_array_set_xy(arr, index, x1, y1, x2, y2) =>

    line line_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_xy1(line_, x1, y1)
        line.set_xy2(line_, x2, y2)
        // array.set(arr, index, line_)

    arr

line_array_set_color(arr, index, col) =>

    line line_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_color(line_, col)
        // array.set(arr, index, line_)

    arr

// set x1, y1, x2, y2, width
line_array_set_fields(arr, index, x1, y1, x2, y2, width) =>

    line line_ = na

    len = array.size(arr)

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_xy1(line_, x1, y1)
        line.set_xy2(line_, x2, y2)
        line.set_width(line_, width)
        // array.set(arr, index, line_)

    arr


// unlike label - no yloc, text*, but has x2, y2, width, extend
// line string params must contain expanded property names with proper values, "" will cause error
// x1, x2 are times or abs bar indexes
// requires translated values, expanded property names
line_array_set_all_fields(arr, index, x1, y1, x2, y2, xloc, extend, line_style, line_color, width) =>

    line line_ = na

    len = array.size(arr)

    // no checks of params
    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_xloc(line_, x1, x2, xloc)
        // set_x* must remain after set_xloc
        // line.set_x1(line_, x1)
        // line.set_x2(line_, x2)
        line.set_y1(line_, y1)
        line.set_y2(line_, y2)
        line.set_extend(line_, extend)
        line.set_style(line_, line_style)
        line.set_color(line_, line_color)
        line.set_width(line_, width)
        // array.set(arr, index, line_)

    arr

// line string params can be na/-1/empty/""/color_na - default global values are used
// x1, x2 are times or relative bar indexes
// requires abs values or translated values with abs rel bar indexes swapped (xloc swap undone), expanded property names
line_array_set_all_fields2(arr, index, x1, y1, x2, y2, xloc, extend, line_style, line_color, width) =>

    // line line_ = na

    len = array.size(arr)

    // assign internal defaults when arg is missing
    x1_ = na(x1) or x1 == -1 ? na(xloc) or xloc == xloc.bar_time ? time : n : xloc == xloc.bar_time ? x1 : n - x1
    x2_ = na(x2) or x2 == -1 ? na(xloc) or xloc == xloc.bar_time ? time : n : xloc == xloc.bar_time ? x2 : n - x2
    y1_ = na(y1) or y1 == -1 ? close : y1
    y2_ = na(y2) or y2 == -1 ? close : y2
    xloc_ = na(xloc) ? xloc.bar_time : xloc // def_line_xloc is xloc.bar_index
    width_ = na(width) or width == -1 ? def_line_width : width
    extend_ = na(extend) ? def_line_extend : extend // extend.none, extend.left, extend.right, extend.both

    line_style_ = na(line_style) ? def_line_style : line_style // line.style_solid, line.style_dotted, line.style_dashed, line.style_arrow_left, line.style_arrow_right, line.style_arrow_both

    // this doesn't work
    // msg_color_ = na(msg_color) or color(msg_color) == na or msg_color == color.new(na, 0) or msg_color == #000000 or na(msg_color) == #000000 ? black : msg_color
    // if na(msg_color) or color(msg_color) == na or color.new(na, 0) == msg_color or msg_color == #000000 or na(msg_color) == #000000
    //     msg_color_ := black
    // this only works when color_na = na const is passed as msg_color
    line_color_ = na(line_color) ? def_line_color : line_color // line border and arrow color

    if len > 0 and index >= 0 and index < len
        line_ = array.get(arr, index)
        line.set_xloc(line_, x1_, x2_, xloc_)
        // set_x* must remain after set_xloc
        // line.set_x1(line_, x1_)
        // line.set_x2(line_, x2_)
        line.set_y1(line_, y1_)
        line.set_y2(line_, y2_)
        line.set_extend(line_, extend_)
        line.set_style(line_, line_style_)
        line.set_color(line_, line_color_)
        line.set_width(line_, width_)
        // array.set(arr, index, line_)

    arr


// ================================================================================================================
// Label Object Array Functions
// ================================================================================================================

// can't use array.clear - doesn't delete label objects
delete_label_array(label_arr) =>
    // n
    len = array.size(label_arr)

    if len > 0
        // delete label objects manually
        for i = 0 to len - 1
            label_ = array.get(label_arr, i)
            label.delete(label_)

        // doesn't delete label objects
        array.clear(label_arr)


// ================================================================================================================
// Label Object Array Create Functions - List Params
// ================================================================================================================

// Label Array Functions with List Params

// It's recommended to use:
// - create_label_array2 (simple lists, params),
// - create_label_array3 (cycle lists, simple params) or
// - create_label_array4 (cycle lists, params).
// Higher versions add unnecessary complexity and are included for illustration purposes.

// create label array from lists - x, y, str, label color, text color lists
// requires translated values
// uses global defaults
// uses simple direct calculation of lists, params
create_label_array(list1, list2, list3, list4, list5, d) =>
    label label_ = na
    num_lists = 5

    res_arr = array.new_label(0)

    // process lists

    // 0..n-1
    list1_ = d != " " ? str.replace_all(list1, " ", "") : list1
    list2_ = d != " " ? str.replace_all(list2, " ", "") : list2
    list3_ = d != " " ? str.replace_all(list3, " ", "") : list3
    list4_ = d != " " ? str.replace_all(list4, " ", "") : list4
    list5_ = d != " " ? str.replace_all(list5, " ", "") : list5

    // x_arr = str.split(list1_, d)
    // y_arr = str.split(list2_, d)
    // str_arr = str.split(list3_, d)
    // col1_arr = str.split(list4_, d)
    // col2_arr = str.split(list5_, d)

    x_arr = str_split2(list1_, d)
    y_arr = str_split2(list2_, d)
    str_arr = str_split2(list3_, d)
    col1_arr = str_split2(list4_, d)
    col2_arr = str_split2(list5_, d)

    // get base list length

    // use list with min length as base
    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(col1_arr)
    len5 = array.size(col2_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)

    // all lists can be empty
    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    // create label array

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x_str = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : ""
            y_str = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : ""
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            col1_str = len4 > 0 ? array.get(col1_arr, i < len4 ? i : 0) : ""
            col2_str = len5 > 0 ? array.get(col2_arr, i < len5 ? i : 0) : ""

            // convert param values to target types
            x = int(tonumber(x_str))
            y = tonumber(y_str)
            xloc_str = def_label_xloc
            label_style = def_label_style
            label_color = get_color(col1_str)
            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color
            text_color = get_color(col2_str)
            text_size = def_text_size
            text_align = def_text_align

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            // uses global defaults
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align)
            array.push(res_arr, label_)


    res_arr

// create label array from lists using all params
// requires translated values, shortened property names
// uses simple direct calculation of lists, params
create_label_array2(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    res_arr = array.new_label(0)

    // 0..n-1
    x_list_ = d != " " ? str.replace_all(x_list, " ", "") : x_list
    y_list_ = d != " " ? str.replace_all(y_list, " ", "") : y_list
    str_list_ = d != " " ? str.replace_all(str_list, " ", "") : str_list
    xloc_list_ = d != " " ? str.replace_all(xloc_list, " ", "") : xloc_list
    yloc_list_ = d != " " ? str.replace_all(yloc_list, " ", "") : yloc_list
    style_list_ = d != " " ? str.replace_all(style_list, " ", "") : style_list
    col1_list_ = d != " " ? str.replace_all(color1_list, " ", "") : color1_list
    col2_list_ = d != " " ? str.replace_all(color2_list, " ", "") : color2_list
    size_list_ = d != " " ? str.replace_all(size_list, " ", "") : size_list
    align_list_ = d != " " ? str.replace_all(align_list, " ", "") : align_list
    tooltip_list_ = d != " " ? str.replace_all(tooltip_list, " ", "") : tooltip_list

    // process lists
    x_arr = str_split2(x_list_, d)
    y_arr = str_split2(y_list_, d)
    str_arr = str_split2(str_list_, d)
    xloc_arr = str_split2(xloc_list_, d)
    yloc_arr = str_split2(yloc_list_, d)
    style_arr = str_split2(style_list_, d)
    col1_arr = str_split2(col1_list_, d)
    col2_arr = str_split2(col2_list_, d)
    size_arr = str_split2(size_list_, d)
    align_arr = str_split2(align_list_, d)
    tooltip_arr = str_split2(tooltip_list_, d)

    // use list with min length as base
    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(xloc_arr)
    len5 = array.size(yloc_arr)
    len6 = array.size(style_arr)
    len7 = array.size(col1_arr)
    len8 = array.size(col2_arr)
    len9 = array.size(size_arr)
    len10 = array.size(align_arr)
    len11 = array.size(tooltip_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)
    array.push(lengths, len10)
    array.push(lengths, len11)

    // all lists can be empty
    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x_str = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : ""
            y_str = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : ""
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            style_str = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            col1_str = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : ""
            col2_str = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : ""
            size_str = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            align_str = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // convert param values to target types
            x = int(tonumber(x_str))
            y = tonumber(y_str)
            xloc_str := get_xloc(xloc_str)
            yloc_str := get_yloc(yloc_str)
            label_style = get_label_style(style_str)
            label_color = get_color(col1_str)
            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color
            text_color = get_color(col2_str)
            text_size = get_size(size_str)
            text_align = get_text_align(align_str)

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr


// create label array from lists using all params
// uses lists array, cycle for lists to automate list processing
create_label_array3(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    x_arr = array.new_string(0)
    y_arr = array.new_string(0)
    str_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    yloc_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col1_arr = array.new_string(0)
    col2_arr = array.new_string(0)
    size_arr = array.new_string(0)
    align_arr = array.new_string(0)
    tooltip_arr = array.new_string(0)

    res_arr = array.new_label(0)

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x_list)
    array.push(lists, y_list)
    array.push(lists, str_list)
    array.push(lists, xloc_list)
    array.push(lists, yloc_list)
    array.push(lists, style_list)
    array.push(lists, color1_list)
    array.push(lists, color2_list)
    array.push(lists, size_list)
    array.push(lists, align_list)
    array.push(lists, tooltip_list)

    num_args = array.size(lists)

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // can't store arr in array - 2d arrays are not supported
            // if i == 0
            //     x_arr := arr
            // if i == 1
            //     y_arr := arr
            // if i == 2
            //     str_arr := arr
            // if i == 3
            //     xloc_arr := arr
            // if i == 4
            //     yloc_arr := arr
            // if i == 5
            //     style_arr := arr
            // if i == 6
            //     col1_arr := arr
            // if i == 7
            //     col2_arr := arr
            // if i == 8
            //     size_arr := arr
            // if i == 9
            //     align_arr := arr
            // if i == 10
            //     tooltip_arr := arr

            // reduces local scopes
            // this works because all arrays have the same type string
            x_arr := i == 0 ? arr : x_arr
            y_arr := i == 1 ? arr : y_arr
            str_arr := i == 2 ? arr : str_arr
            xloc_arr := i == 3 ? arr : xloc_arr
            yloc_arr := i == 4 ? arr : yloc_arr
            style_arr := i == 5 ? arr : style_arr
            col1_arr := i == 6 ? arr : col1_arr
            col2_arr := i == 7 ? arr : col2_arr
            size_arr := i == 8 ? arr : size_arr
            align_arr := i == 9 ? arr : align_arr
            tooltip_arr := i == 10 ? arr : tooltip_arr

        // store length in array
        array.push(lengths, length)


    len1 = array.get(lengths, 0)
    len2 = array.get(lengths, 1)
    len3 = array.get(lengths, 2)
    len4 = array.get(lengths, 3)
    len5 = array.get(lengths, 4)
    len6 = array.get(lengths, 5)
    len7 = array.get(lengths, 6)
    len8 = array.get(lengths, 7)
    len9 = array.get(lengths, 8)
    len10 = array.get(lengths, 9)
    len11 = array.get(lengths, 10)

    len := min(len, num_objects)

    // using simple direct calculation of params for each label - all lists must be already processed and contain proper values
    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x_str = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : ""
            y_str = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : ""
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            style_str = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            col1_str = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : ""
            col2_str = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : ""
            size_str = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            align_str = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // convert param values to target types
            x = int(tonumber(x_str))
            y = tonumber(y_str) // 60000 + 1000 * i
            xloc_str := get_xloc(xloc_str)
            yloc_str := get_yloc(yloc_str)
            label_style = get_label_style(style_str)
            label_color = get_color(col1_str)
            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color
            text_color = get_color(col2_str)
            text_size = get_size(size_str)
            text_align = get_text_align(align_str)

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr


// create label array from lists using all params
// uses lists array, cycles for lists, params to automate both lists, and params processing
create_label_array4(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    x_arr = array.new_string(0)
    y_arr = array.new_string(0)
    str_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    yloc_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col1_arr = array.new_string(0)
    col2_arr = array.new_string(0)
    size_arr = array.new_string(0)
    align_arr = array.new_string(0)
    tooltip_arr = array.new_string(0)

    res_arr = array.new_label(0)

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x_list)
    array.push(lists, y_list)
    array.push(lists, str_list)
    array.push(lists, xloc_list)
    array.push(lists, yloc_list)
    array.push(lists, style_list)
    array.push(lists, color1_list)
    array.push(lists, color2_list)
    array.push(lists, size_list)
    array.push(lists, align_list)
    array.push(lists, tooltip_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x_arr := i == 0 ? arr : x_arr
            y_arr := i == 1 ? arr : y_arr
            str_arr := i == 2 ? arr : str_arr
            xloc_arr := i == 3 ? arr : xloc_arr
            yloc_arr := i == 4 ? arr : yloc_arr
            style_arr := i == 5 ? arr : style_arr
            col1_arr := i == 6 ? arr : col1_arr
            col2_arr := i == 7 ? arr : col2_arr
            size_arr := i == 8 ? arr : size_arr
            align_arr := i == 9 ? arr : align_arr
            tooltip_arr := i == 10 ? arr : tooltip_arr

        // store length in array
        array.push(lengths, length)


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    // Method 1
    // x_str = "", y_str = "", text_str = "", xloc_str = "", yloc_str = "", style_str = "", col1_str = "", col2_str = "", size_str = "", align_str = "", tooltip_str = ""

    // Method 2
    int x = na
    float y = na
    string text_str = na
    string xloc_str = na
    string yloc_str = na
    string label_style = na
    color label_color = na
    color text_color = na
    string text_size = na
    string text_align = na
    string tooltip_str = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                // this works because all arrays have the same type string
                arr = j == 0 ? x_arr : j == 1 ? y_arr : j == 2 ? str_arr : j == 3 ? xloc_arr : j == 4 ? yloc_arr : j == 5 ? style_arr : j == 6 ? col1_arr : j == 7 ? col2_arr : j == 8 ? size_arr : j == 9 ? align_arr : tooltip_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // using ?: instead of if
                // reduces local scopes

                // Method 1
                // x_str := j == 0 ? str : x_str
                // y_str := j == 1 ? str : y_str
                // text_str := j == 2 ? str : text_str
                // xloc_str := j == 3 ? str : xloc_str
                // yloc_str := j == 4 ? str : yloc_str
                // style_str := j == 5 ? str : style_str
                // col1_str := j == 6 ? str : col1_str
                // col2_str := j == 7 ? str : col2_str
                // size_str := j == 8 ? str : size_str
                // align_str := j == 9 ? str : align_str
                // tooltip_str := j == 10 ? str : tooltip_str

                // Method 2

                val = tonumber(str)

                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x := j == 0 ? int(val) : x
                y := j == 1 ? val : y
                text_str := j == 2 ? str : text_str
                xloc_str := j == 3 ? get_xloc(str) : xloc_str
                yloc_str := j == 4 ? get_yloc(str) : yloc_str
                label_style := j == 5 ? get_label_style(str) : label_style
                label_color := j == 6 ? get_color(str) : label_color
                text_color := j == 7 ? get_color(str) : text_color
                text_size := j == 8 ? get_size(str) : text_size
                text_align := j == 9 ? get_text_align(str) : text_align
                tooltip_str := j == 10 ? str : tooltip_str


            // Method 1
            // convert param values to target types
            // x = int(tonumber(x_str))
            // y = tonumber(y_str)
            // xloc_str := get_xloc(xloc_str)
            // yloc_str := get_yloc(yloc_str)
            // label_style = get_label_style(style_str)
            // label_color = get_color(col1_str)
            // text_color = get_color(col2_str)
            // label_size = get_size(size_str)
            // text_align = get_text_align(align_str)

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr


// create label array from lists using all params
// uses lists, type arrays, cycles for lists, params, to automate both lists, and params processing
// uses str_to_any, increases local scopes
// similar to create_any_array, doesn't improve anything, but rather adds unnecessary complexity, illustrates that var type array/conversion functions can also be used if needed
create_label_array5(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    x_arr = array.new_string(0)
    y_arr = array.new_string(0)
    str_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    yloc_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col1_arr = array.new_string(0)
    col2_arr = array.new_string(0)
    size_arr = array.new_string(0)
    align_arr = array.new_string(0)
    tooltip_arr = array.new_string(0)

    res_arr = array.new_label(0)

    lengths = array.new_int(0)
    types = array.new_string(0)
    lists = array.new_string(0)

    // must specify types manually
    // can't use typeof reliably because the list can consist of * random values with undefined type
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "color")
    array.push(types, "color")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")

    // enables list processing in a cycle
    array.push(lists, x_list)
    array.push(lists, y_list)
    array.push(lists, str_list)
    array.push(lists, xloc_list)
    array.push(lists, yloc_list)
    array.push(lists, style_list)
    array.push(lists, color1_list)
    array.push(lists, color2_list)
    array.push(lists, size_list)
    array.push(lists, align_list)
    array.push(lists, tooltip_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        // item = ""
        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)
            // item := length > 0 ? array.get(arr, 0) : ""

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x_arr := i == 0 ? arr : x_arr
            y_arr := i == 1 ? arr : y_arr
            str_arr := i == 2 ? arr : str_arr
            xloc_arr := i == 3 ? arr : xloc_arr
            yloc_arr := i == 4 ? arr : yloc_arr
            style_arr := i == 5 ? arr : style_arr
            col1_arr := i == 6 ? arr : col1_arr
            col2_arr := i == 7 ? arr : col2_arr
            size_arr := i == 8 ? arr : size_arr
            align_arr := i == 9 ? arr : align_arr
            tooltip_arr := i == 10 ? arr : tooltip_arr

        // store length in array
        array.push(lengths, length)
        // can't use typeof reliably because the list can consist of * random values with undefined type
        // array.push(types, typeof(item))


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    int x = na
    float y = na
    string text_str = na
    string xloc_str = na
    string yloc_str = na
    string label_style = na
    color label_color = na
    color text_color = na
    string text_size = na
    string text_align = na
    string tooltip_str = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                type = array.get(types, j)

                // this works because all arrays have the same type string
                arr = j == 0 ? x_arr : j == 1 ? y_arr : j == 2 ? str_arr : j == 3 ? xloc_arr : j == 4 ? yloc_arr : j == 5 ? style_arr : j == 6 ? col1_arr : j == 7 ? col2_arr : j == 8 ? size_arr : j == 9 ? align_arr : tooltip_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // converts str to target type: int, float, string, color, bool...
                [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type)

                // using ?: instead of if since we don't need to push values into var type arrays
                // reduces local scopes
                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x := j == 0 ? val1 : x
                y := j == 1 ? val2 : y
                text_str := j == 2 ? str : text_str
                xloc_str := j == 3 ? get_xloc(str) : xloc_str
                yloc_str := j == 4 ? get_yloc(str) : yloc_str
                label_style := j == 5 ? get_label_style(str) : label_style
                label_color := j == 6 ? val4 : label_color
                text_color := j == 7 ? val4 : text_color
                text_size := j == 8 ? get_size(str) : text_size
                text_align := j == 9 ? get_text_align(str) : text_align
                tooltip_str := j == 10 ? str : tooltip_str

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr


// create label array from lists using all params
// uses lists, type arrays, cycles for lists, params, to automate both lists, and params processing
// uses str_to_any, increases local scopes
// similar to create_any_array, doesn't improve anything, but rather adds unnecessary complexity, illustrates that
// - complex var type list processing can be separated from label array creation cycle to make it more logical and simple
// - this requires var type array/conversion functions
create_label_array6(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    // arrays now have proper target types instead of the same type string
    x_arr = array.new_int(0)
    y_arr = array.new_float(0)
    str_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    yloc_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col1_arr = array.new_color(0)
    col2_arr = array.new_color(0)
    size_arr = array.new_string(0)
    align_arr = array.new_string(0)
    tooltip_arr = array.new_string(0)

    res_arr = array.new_label(0)

    lengths = array.new_int(0)
    types = array.new_string(0)
    lists = array.new_string(0)

    // must specify types manually
    // can't use typeof reliably because the list can consist of * random values with undefined type
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "color")
    array.push(types, "color")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")

    // enables list processing in a cycle
    array.push(lists, x_list)
    array.push(lists, y_list)
    array.push(lists, str_list)
    array.push(lists, xloc_list)
    array.push(lists, yloc_list)
    array.push(lists, style_list)
    array.push(lists, color1_list)
    array.push(lists, color2_list)
    array.push(lists, size_list)
    array.push(lists, align_list)
    array.push(lists, tooltip_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        type = array.get(types, i)
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        // item = ""
        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)
            // item := length > 0 ? array.get(arr, 0) : ""

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            if length > 0
                // doesn't work - incompatible types, arr must be converted to target type
                // x_arr := i == 0 ? arr : x_arr
                // y_arr := i == 1 ? arr : y_arr
                // str_arr := i == 2 ? arr : str_arr
                // xloc_arr := i == 3 ? arr : xloc_arr
                // yloc_arr := i == 4 ? arr : yloc_arr
                // style_arr := i == 5 ? arr : style_arr
                // col1_arr := i == 6 ? arr : col1_arr
                // col2_arr := i == 7 ? arr : col2_arr
                // size_arr := i == 8 ? arr : size_arr
                // align_arr := i == 9 ? arr : align_arr
                // tooltip_arr := i == 10 ? arr : tooltip_arr

                // convert arr to target type manually
                // get param values
                for j = 0 to length - 1
                    str = array.get(arr, j)

                    // converts str to target type: int, float, string, color, bool...
                    [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type)

                    // Method 1

                    // store values in respective arr type - process whole array of the same type at once - don't confuse i (lists) with j (list items)
                    // array.push can only be inside if - increases local scopes
                    // if i == 0
                    //     array.push(x_arr, val1)
                    // if i == 1
                    //     array.push(y_arr, val2)
                    // if i == 2
                    //     array.push(str_arr, val3)
                    // if i == 3
                    //     xloc = get_xloc(val3)
                    //     array.push(xloc_arr, xloc)
                    // if i == 4
                    //     yloc = get_yloc(val3)
                    //     array.push(yloc_arr, yloc)
                    // if i == 5
                    //     style = get_label_style(val3)
                    //     array.push(style_arr, style)
                    // if i == 6
                    //     array.push(col1_arr, val4)
                    // if i == 7
                    //     array.push(col2_arr, val4)
                    // if i == 8
                    //     size = get_size(val3)
                    //     array.push(size_arr, size)
                    // if i == 9
                    //     align = get_text_align(val3)
                    //     array.push(align_arr, align)
                    // if i == 10
                    //     array.push(tooltip_arr, val3)

                    // Method 2

                    // array.concat can be inside ?: - reduces local scopes
                    x_arr := i == 0 ? array.concat(x_arr, array.new_int(1, val1)) : x_arr
                    y_arr := i == 1 ? array.concat(y_arr, array.new_float(1, val2)) : y_arr
                    str_arr := i == 2 ? array.concat(str_arr, array.new_string(1, val3)) : str_arr
                    xloc_arr := i == 3 ? array.concat(xloc_arr, array.new_string(1, get_xloc(val3))) : xloc_arr
                    yloc_arr := i == 4 ? array.concat(yloc_arr, array.new_string(1, get_yloc(val3))) : yloc_arr
                    style_arr := i == 5 ? array.concat(style_arr, array.new_string(1, get_label_style(val3))) : style_arr
                    col1_arr := i == 6 ? array.concat(col1_arr, array.new_color(1, val4)) : col1_arr
                    col2_arr := i == 7 ? array.concat(col2_arr, array.new_color(1, val4)) : col2_arr
                    size_arr := i == 8 ? array.concat(size_arr, array.new_string(1, get_size(val3))) : size_arr
                    align_arr := i == 9 ? array.concat(align_arr, array.new_string(1, get_text_align(val3))) : align_arr
                    tooltip_arr := i == 10 ? array.concat(tooltip_arr, array.new_string(1, val3)) : tooltip_arr


        // store length in array
        array.push(lengths, length)
        // can't use typeof reliably because the list can consist of * random values with undefined type
        // array.push(types, typeof(item))


    len1 = array.get(lengths, 0)
    len2 = array.get(lengths, 1)
    len3 = array.get(lengths, 2)
    len4 = array.get(lengths, 3)
    len5 = array.get(lengths, 4)
    len6 = array.get(lengths, 5)
    len7 = array.get(lengths, 6)
    len8 = array.get(lengths, 7)
    len9 = array.get(lengths, 8)
    len10 = array.get(lengths, 9)
    len11 = array.get(lengths, 10)

    len := min(len, num_objects)

    // using simple direct calculation of params for each label - all lists must be already processed and contain proper values
    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // list params are expanded into arrays inside function, must assign proper def* values to label params, "" - causes error
            x = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : na
            y = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : na
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : def_label_xloc
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : def_label_yloc
            label_style = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : def_label_style
            label_color = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : color_na
            text_color = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : color_na
            text_size = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : def_text_size
            text_align = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : def_text_align
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr


// ================================================================================================================
// Label Object Array Update Functions - List Params
// ================================================================================================================

// Update Label Array from List Params Functions

// update label array from lists using all params
// based on create_label_array2
// uses simple direct calculation of lists, params
update_label_array2(label_arr, x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    res_arr = label_arr

    // 0..n-1
    x_list_ = d != " " ? str.replace_all(x_list, " ", "") : x_list
    y_list_ = d != " " ? str.replace_all(y_list, " ", "") : y_list
    str_list_ = d != " " ? str.replace_all(str_list, " ", "") : str_list
    xloc_list_ = d != " " ? str.replace_all(xloc_list, " ", "") : xloc_list
    yloc_list_ = d != " " ? str.replace_all(yloc_list, " ", "") : yloc_list
    style_list_ = d != " " ? str.replace_all(style_list, " ", "") : style_list
    col1_list_ = d != " " ? str.replace_all(color1_list, " ", "") : color1_list
    col2_list_ = d != " " ? str.replace_all(color2_list, " ", "") : color2_list
    size_list_ = d != " " ? str.replace_all(size_list, " ", "") : size_list
    align_list_ = d != " " ? str.replace_all(align_list, " ", "") : align_list
    tooltip_list_ = d != " " ? str.replace_all(tooltip_list, " ", "") : tooltip_list

    // process lists
    x_arr = str_split2(x_list_, d)
    y_arr = str_split2(y_list_, d)
    str_arr = str_split2(str_list_, d)
    xloc_arr = str_split2(xloc_list_, d)
    yloc_arr = str_split2(yloc_list_, d)
    style_arr = str_split2(style_list_, d)
    col1_arr = str_split2(col1_list_, d)
    col2_arr = str_split2(col2_list_, d)
    size_arr = str_split2(size_list_, d)
    align_arr = str_split2(align_list_, d)
    tooltip_arr = str_split2(tooltip_list_, d)

    // use list with min length as base
    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(xloc_arr)
    len5 = array.size(yloc_arr)
    len6 = array.size(style_arr)
    len7 = array.size(col1_arr)
    len8 = array.size(col2_arr)
    len9 = array.size(size_arr)
    len10 = array.size(align_arr)
    len11 = array.size(tooltip_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)
    array.push(lengths, len10)
    array.push(lengths, len11)

    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x_str = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : ""
            y_str = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : ""
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            style_str = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            col1_str = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : ""
            col2_str = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : ""
            size_str = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            align_str = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // convert param values to target types
            // xloc conversion is done inside set* function
            x = int(tonumber(x_str))
            y = tonumber(y_str)
            xloc_str := get_xloc(xloc_str)
            yloc_str := get_yloc(yloc_str)
            label_style = get_label_style(style_str)
            label_color = get_color(col1_str)
            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color
            text_color = get_color(col2_str)
            text_size = get_size(size_str)
            text_align = get_text_align(align_str)

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_array_set_all_fields(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)
            // label_array_set_all_fields2(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)


    res_arr

// update label array from lists using all params
// based on create_label_array4
// uses lists array, cycles for lists, params to automate both lists, and params processing
update_label_array4(label_arr, x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, d) =>

    label label_ = na
    num_lists = 11

    x_arr = array.new_string(0)
    y_arr = array.new_string(0)
    str_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    yloc_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col1_arr = array.new_string(0)
    col2_arr = array.new_string(0)
    size_arr = array.new_string(0)
    align_arr = array.new_string(0)
    tooltip_arr = array.new_string(0)

    res_arr = label_arr

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x_list)
    array.push(lists, y_list)
    array.push(lists, str_list)
    array.push(lists, xloc_list)
    array.push(lists, yloc_list)
    array.push(lists, style_list)
    array.push(lists, color1_list)
    array.push(lists, color2_list)
    array.push(lists, size_list)
    array.push(lists, align_list)
    array.push(lists, tooltip_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x_arr := i == 0 ? arr : x_arr
            y_arr := i == 1 ? arr : y_arr
            str_arr := i == 2 ? arr : str_arr
            xloc_arr := i == 3 ? arr : xloc_arr
            yloc_arr := i == 4 ? arr : yloc_arr
            style_arr := i == 5 ? arr : style_arr
            col1_arr := i == 6 ? arr : col1_arr
            col2_arr := i == 7 ? arr : col2_arr
            size_arr := i == 8 ? arr : size_arr
            align_arr := i == 9 ? arr : align_arr
            tooltip_arr := i == 10 ? arr : tooltip_arr

        // store length in array
        array.push(lengths, length)


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    int x = na
    float y = na
    string text_str = na
    string xloc_str = na
    string yloc_str = na
    string label_style = na
    color label_color = na
    color text_color = na
    string text_size = na
    string text_align = na
    string tooltip_str = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                // this works because all arrays have the same type string
                arr = j == 0 ? x_arr : j == 1 ? y_arr : j == 2 ? str_arr : j == 3 ? xloc_arr : j == 4 ? yloc_arr : j == 5 ? style_arr : j == 6 ? col1_arr : j == 7 ? col2_arr : j == 8 ? size_arr : j == 9 ? align_arr : tooltip_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // using ?: instead of if
                // reduces local scopes

                val = tonumber(str)

                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x := j == 0 ? int(val) : x
                y := j == 1 ? val : y
                text_str := j == 2 ? str : text_str
                xloc_str := j == 3 ? get_xloc(str) : xloc_str
                yloc_str := j == 4 ? get_yloc(str) : yloc_str
                label_style := j == 5 ? get_label_style(str) : label_style
                label_color := j == 6 ? get_color(str) : label_color
                text_color := j == 7 ? get_color(str) : text_color
                text_size := j == 8 ? get_size(str) : text_size
                text_align := j == 9 ? get_text_align(str) : text_align
                tooltip_str := j == 10 ? str : tooltip_str

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_array_set_all_fields(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)
            // label_array_set_all_fields2(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)

    res_arr


// ================================================================================================================
// Label Object Array Create/Update Functions - Array Params
// ================================================================================================================

// Label Array Functions with Array Params

// create label array from arrays of respective types using all params
// based on create_label_array2
// requires translated values, expanded property names
// uses simple direct calculation of arrays, params
create_label_array_from_arrays2(x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d) =>

    label label_ = na
    num_lists = 11

    res_arr = array.new_label(0)

    // process lists
    col1_arr = color1_arr
    col2_arr = color2_arr

    // use list with min length as base
    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(xloc_arr)
    len5 = array.size(yloc_arr)
    len6 = array.size(style_arr)
    len7 = array.size(col1_arr)
    len8 = array.size(col2_arr)
    len9 = array.size(size_arr)
    len10 = array.size(align_arr)
    len11 = array.size(tooltip_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)
    array.push(lengths, len10)
    array.push(lengths, len11)

    // all arrays can be empty
    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // array params are already expanded/filled with proper/default values, don't need to assign proper def* values
            x = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : na
            y = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : na
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            label_style = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            label_color = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : color_na
            text_color = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : color_na
            text_size = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            text_align = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr

// create label array from arrays of respective types using all params
// based on create_label_array4
// uses cycles for arrays, params to automate both arrays, and params processing
// this works but is pointless and doesn't improve anything
create_label_array_from_arrays4(x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d) =>

    label label_ = na
    num_args = 11

    res_arr = array.new_label(0)

    // process lists
    col1_arr = color1_arr
    col2_arr = color2_arr

    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(xloc_arr)
    len5 = array.size(yloc_arr)
    len6 = array.size(style_arr)
    len7 = array.size(col1_arr)
    len8 = array.size(col2_arr)
    len9 = array.size(size_arr)
    len10 = array.size(align_arr)
    len11 = array.size(tooltip_arr)

    lengths = array.new_int(0)

    // use list with min length as base
    len = 0

    // process all arrays
    for i = 0 to num_args - 1
        // doesn't work - incompatible types
        // arr = i == 0 ? x_arr : i == 1 ? y_arr : i == 2 ? str_arr : i == 3 ? xloc_arr : i == 4 ? yloc_arr : i == 5 ? style_arr : i == 6 ? col1_arr : i == 7 ? col2_arr : i == 8 ? size_arr : i == 9 ? align_arr : tooltip_arr
        // length = array.size(arr)

        // this works because array.size supports any array type and length has the same integer type regardless of array type
        length = i == 0 ? len1 : i == 1 ? len2 : i == 2 ? len3 : i == 3 ? len4 : i == 4 ? len5 : i == 5 ? len6 : i == 6 ? len7 : i == 7 ? len8 : i == 8 ? len9 : i == 9 ? len10 : len11

        // find min length > 1 (ignore length = 1 - single value, not a list)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

        // store length in array
        array.push(lengths, length)


    len := min(len, num_objects)

    // Method [A]
    // int x = na
    // float y = na
    // string text_str = na
    // string xloc_str = na
    // string yloc_str = na
    // string label_style = na
    // color label_color = na
    // color text_color = na
    // string text_size = na
    // string text_align = na
    // string tooltip_str = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // Method [A]
            // get param values
            // for j = 0 to num_args - 1

            //     // Method 1
            //     // // doesn't work - incompatible types
            //     // arr = j == 0 ? x_arr : j == 1 ? y_arr : j == 2 ? str_arr : j == 3 ? xloc_arr : j == 4 ? yloc_arr : j == 5 ? style_arr : j == 6 ? col1_arr : j == 7 ? col2_arr : j == 8 ? size_arr : j == 9 ? align_arr : tooltip_arr
            //     // // ensures correct processing of single item lists
            //     // val = array.get(arr, i < array.get(lengths, j) ? i : 0)

            //     // // using ?: instead of if
            //     // // reduces local scopes

            //     // x := j == 0 ? val : x
            //     // y := j == 1 ? val : y
            //     // text_str := j == 2 ? val : text_str
            //     // xloc_str := j == 3 ? val : xloc_str
            //     // yloc_str := j == 4 ? val : yloc_str
            //     // label_style := j == 5 ? val : label_style
            //     // label_color := j == 6 ? val : label_color
            //     // text_color := j == 7 ? val : text_color
            //     // text_size := j == 8 ? val : text_size
            //     // text_align := j == 9 ? val : text_align
            //     // tooltip_str := j == 10 ? val : tooltip_str

            //     // Method 2
            //     // this works but is pointless and doesn't improve anything
            //     x := j == 0 ? array.get(x_arr, i < array.get(lengths, j) ? i : 0) : x
            //     y := j == 1 ? array.get(y_arr, i < array.get(lengths, j) ? i : 0) : y
            //     text_str := j == 2 ? array.get(text_arr, i < array.get(lengths, j) ? i : 0) : text_str
            //     xloc_str := j == 3 ? array.get(xloc_arr, i < array.get(lengths, j) ? i : 0) : xloc_str
            //     yloc_str := j == 4 ? array.get(yloc_arr, i < array.get(lengths, j) ? i : 0) : yloc_str
            //     label_style := j == 5 ? array.get(style_arr, i < array.get(lengths, j) ? i : 0) : label_style
            //     label_color := j == 6 ? array.get(col1_arr, i < array.get(lengths, j) ? i : 0) : label_color
            //     text_color := j == 7 ? array.get(col2_arr, i < array.get(lengths, j) ? i : 0) : text_color
            //     text_size := j == 8 ? array.get(size_arr, i < array.get(lengths, j) ? i : 0) : text_size
            //     text_align := j == 9 ? array.get(align_arr, i < array.get(lengths, j) ? i : 0) : text_align
            //     tooltip_str := j == 10 ? array.get(tooltip_arr, i < array.get(lengths, j) ? i : 0) : tooltip_str

            // Method [B]
            // still need to populate len* - defeats the purpose of eliminating len* in the first place
            // get param values
            // this works but is not ideal and doesn't improve anything
            // array params are already expanded/filled with proper/default values, don't need to assign proper def* values
            x = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : na
            y = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : na
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            label_style = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            label_color = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : color_na
            text_color = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : color_na
            text_size = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            text_align = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str
            label_ = label.new(x, y, text=cur_str, xloc=xloc_str, yloc=yloc_str, style=label_style, color=label_color, textcolor=text_color, size=text_size, textalign=text_align, tooltip=tooltip_str)
            array.push(res_arr, label_)


    res_arr

// update label array from arrays of respective types using all params
// based on create_label_array2
// uses simple direct calculation of arrays, params
update_label_array_from_arrays2(label_arr, x_arr, y_arr, str_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, d) =>

    num_lists = 11

    res_arr = label_arr

    // process lists
    col1_arr = color1_arr
    col2_arr = color2_arr

    // use list with min length as base
    len1 = array.size(x_arr)
    len2 = array.size(y_arr)
    len3 = array.size(str_arr)
    len4 = array.size(xloc_arr)
    len5 = array.size(yloc_arr)
    len6 = array.size(style_arr)
    len7 = array.size(col1_arr)
    len8 = array.size(col2_arr)
    len9 = array.size(size_arr)
    len10 = array.size(align_arr)
    len11 = array.size(tooltip_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)
    array.push(lengths, len10)
    array.push(lengths, len11)

    // all arrays can be empty
    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // array params are already expanded/filled with proper/default values, don't need to assign proper def* values
            x = len1 > 0 ? array.get(x_arr, i < len1 ? i : 0) : na
            y = len2 > 0 ? array.get(y_arr, i < len2 ? i : 0) : na
            text_str = len3 > 0 ? array.get(str_arr, i < len3 ? i : 0) : ""
            xloc_str = len4 > 0 ? array.get(xloc_arr, i < len4 ? i : 0) : ""
            yloc_str = len5 > 0 ? array.get(yloc_arr, i < len5 ? i : 0) : ""
            label_style = len6 > 0 ? array.get(style_arr, i < len6 ? i : 0) : ""
            label_color = len7 > 0 ? array.get(col1_arr, i < len7 ? i : 0) : color_na
            text_color = len8 > 0 ? array.get(col2_arr, i < len8 ? i : 0) : color_na
            text_size = len9 > 0 ? array.get(size_arr, i < len9 ? i : 0) : ""
            text_align = len10 > 0 ? array.get(align_arr, i < len10 ? i : 0) : ""
            tooltip_str = len11 > 0 ? array.get(tooltip_arr, i < len11 ? i : 0) : ""

            // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
            // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
            label_color := na(label_color) ? color(na) : label_color

            // auto inc text_str when str_arr contains only a single item
            cur_str = len3 == 1 and len > 1 ? text_str + tostring(i + 1) : text_str
            tooltip_str := len3 == 1 and len > 1 ? tooltip_str + tostring(i + 1) : tooltip_str

            label_array_set_all_fields(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)
            // label_array_set_all_fields2(label_arr, i, x, y, cur_str, xloc_str, yloc_str, label_style, label_color, text_color, text_size, text_align, tooltip_str)

    res_arr

// update_label_array_from_array4
// can work but is pointless and doesn't improve anything just like create_label_array_from_array4


// ================================================================================================================
// Line Object Array Functions
// ================================================================================================================

// can't use array.clear - doesn't delete line objects
delete_line_array(line_arr) =>
    // n
    len = array.size(line_arr)

    if len > 0
        // delete label objects manually
        for i = 0 to len - 1
            line_ = array.get(line_arr, i)
            line.delete(line_)

        // doesn't delete label objects
        array.clear(line_arr)


// ================================================================================================================
// Line Object Array Create Functions - List Params
// ================================================================================================================

// Create Line Array Functions

// create line array from lists - x1, y1, x2, y2, width, line color lists
// requires translated values
// uses global defaults
// uses simple direct calculation of lists, params
create_line_array(list1, list2, list3, list4, list5, list6, d) =>
    label line_ = na
    num_lists = 6

    res_arr = array.new_line(0)

    // process lists

    // 0..n-1
    list1_ = d != " " ? str.replace_all(list1, " ", "") : list1
    list2_ = d != " " ? str.replace_all(list2, " ", "") : list2
    list3_ = d != " " ? str.replace_all(list3, " ", "") : list3
    list4_ = d != " " ? str.replace_all(list4, " ", "") : list4
    list5_ = d != " " ? str.replace_all(list5, " ", "") : list5
    list6_ = d != " " ? str.replace_all(list6, " ", "") : list6

    x1_arr = str_split2(list1_, d)
    y1_arr = str_split2(list2_, d)
    x2_arr = str_split2(list3_, d)
    y2_arr = str_split2(list4_, d)
    width_arr = str_split2(list5_, d)
    col_arr = str_split2(list6_, d)

    // get base list length

    // use list with min length as base
    len1 = array.size(x1_arr)
    len2 = array.size(y1_arr)
    len3 = array.size(x2_arr)
    len4 = array.size(y2_arr)
    len5 = array.size(width_arr)
    len6 = array.size(col_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)

    // all lists can be empty
    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    // create line array

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x1_str = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : ""
            y1_str = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : ""
            x2_str = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : ""
            y2_str = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : ""
            width_str = len5 > 0 ? array.get(width_arr, i < len5 ? i : 0) : ""
            col_str = len6 > 0 ? array.get(col_arr, i < len6 ? i : 0) : ""

            // convert param values to target types
            x1 = int(tonumber(x1_str))
            x2 = int(tonumber(x2_str))
            y1 = tonumber(y1_str)
            y2 = tonumber(y2_str)
            xloc_str = def_line_xloc
            line_extend = def_line_extend
            line_style = def_line_style
            line_color = get_color(col_str)
            line_width = int(tonumber(width_str))

            // uses global defaults
            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr


// create line array from lists using all params
// requires translated values, shortened property names
// uses simple direct calculation of lists, params
// unlike label, adds x2, y2, width, extend removes str, y_loc, color2, size, tooltip
create_line_array2(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    res_arr = array.new_line(0)

    // 0..n-1
    x1_list_ = d != " " ? str.replace_all(x1_list, " ", "") : x1_list
    y1_list_ = d != " " ? str.replace_all(y1_list, " ", "") : y1_list
    x2_list_ = d != " " ? str.replace_all(x2_list, " ", "") : x2_list
    y2_list_ = d != " " ? str.replace_all(y2_list, " ", "") : y2_list
    xloc_list_ = d != " " ? str.replace_all(xloc_list, " ", "") : xloc_list
    extend_list_ = d != " " ? str.replace_all(extend_list, " ", "") : extend_list
    style_list_ = d != " " ? str.replace_all(style_list, " ", "") : style_list
    col_list_ = d != " " ? str.replace_all(color_list, " ", "") : color_list
    width_list_ = d != " " ? str.replace_all(width_list, " ", "") : width_list

    // process lists
    x1_arr = str_split2(x1_list_, d)
    y1_arr = str_split2(y1_list_, d)
    x2_arr = str_split2(x2_list_, d)
    y2_arr = str_split2(y2_list_, d)
    xloc_arr = str_split2(xloc_list_, d)
    extend_arr = str_split2(extend_list_, d)
    style_arr = str_split2(style_list_, d)
    col_arr = str_split2(col_list_, d)
    width_arr = str_split2(width_list_, d)

    // use list with min length as base
    len1 = array.size(x1_arr)
    len2 = array.size(y1_arr)
    len3 = array.size(x2_arr)
    len4 = array.size(y2_arr)
    len5 = array.size(xloc_arr)
    len6 = array.size(extend_arr)
    len7 = array.size(style_arr)
    len8 = array.size(col_arr)
    len9 = array.size(width_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)

    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x1_str = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : ""
            y1_str = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : ""
            x2_str = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : ""
            y2_str = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : ""
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : ""
            extend_str = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : ""
            style_str = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : ""
            col_str = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : ""
            width_str = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : ""

            // convert param values to target types
            x1 = int(tonumber(x1_str))
            x2 = int(tonumber(x2_str))
            y1 = tonumber(y1_str)
            y2 = tonumber(y2_str)
            xloc_str := get_xloc(xloc_str)
            line_extend = get_line_extend(extend_str)
            line_style = get_line_style(style_str)
            line_color = get_color(col_str)
            line_width = int(tonumber(width_str))

            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr

// create line array from lists using all params
// uses lists array, cycle for lists to automate list processing
create_line_array3(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    x1_arr = array.new_string(0)
    y1_arr = array.new_string(0)
    x2_arr = array.new_string(0)
    y2_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    extend_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col_arr = array.new_string(0)
    width_arr = array.new_string(0)

    res_arr = array.new_line(0)

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x1_list)
    array.push(lists, y1_list)
    array.push(lists, x2_list)
    array.push(lists, y2_list)
    array.push(lists, xloc_list)
    array.push(lists, extend_list)
    array.push(lists, style_list)
    array.push(lists, color_list)
    array.push(lists, width_list)

    num_args = array.size(lists)

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // can't store arr in array - 2d arrays are not supported
            // if i == 0
            //     x1_arr := arr
            // if i == 1
            //     y1_arr := arr
            // if i == 2
            //     x2_arr := arr
            // if i == 3
            //     y2_arr := arr
            // if i == 4
            //     xloc_arr := arr
            // if i == 5
            //     extend_arr := arr
            // if i == 6
            //     style_arr := arr
            // if i == 7
            //     col_arr := arr
            // if i == 8
            //     width_arr := arr

            // reduces local scopes
            // this works because all arrays have the same type string
            x1_arr := i == 0 ? arr : x1_arr
            y1_arr := i == 1 ? arr : y1_arr
            x2_arr := i == 2 ? arr : x2_arr
            y2_arr := i == 3 ? arr : y2_arr
            xloc_arr := i == 4 ? arr : xloc_arr
            extend_arr := i == 5 ? arr : extend_arr
            style_arr := i == 6 ? arr : style_arr
            col_arr := i == 7 ? arr : col_arr
            width_arr := i == 8 ? arr : width_arr

        // store length in array
        array.push(lengths, length)


    len1 = array.get(lengths, 0)
    len2 = array.get(lengths, 1)
    len3 = array.get(lengths, 2)
    len4 = array.get(lengths, 3)
    len5 = array.get(lengths, 4)
    len6 = array.get(lengths, 5)
    len7 = array.get(lengths, 6)
    len8 = array.get(lengths, 7)
    len9 = array.get(lengths, 8)

    len := min(len, num_objects)

    // using simple direct calculation of params for each label - all lists must be already processed and contain proper values
    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x1_str = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : ""
            y1_str = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : ""
            x2_str = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : ""
            y2_str = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : ""
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : ""
            extend_str = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : ""
            style_str = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : ""
            col_str = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : ""
            width_str = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : ""

            // convert param values to target types
            x1 = int(tonumber(x1_str))
            x2 = int(tonumber(x2_str))
            y1 = tonumber(y1_str)
            y2 = tonumber(y2_str)
            xloc_str := get_xloc(xloc_str)
            line_extend = get_line_extend(extend_str)
            line_style = get_line_style(style_str)
            line_color = get_color(col_str)
            line_width = int(tonumber(width_str))

            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr

// create line array from lists using all params
// uses lists array, cycles for lists, params to automate both lists, and params processing
create_line_array4(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    x1_arr = array.new_string(0)
    y1_arr = array.new_string(0)
    x2_arr = array.new_string(0)
    y2_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    extend_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col_arr = array.new_string(0)
    width_arr = array.new_string(0)

    res_arr = array.new_line(0)

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x1_list)
    array.push(lists, y1_list)
    array.push(lists, x2_list)
    array.push(lists, y2_list)
    array.push(lists, xloc_list)
    array.push(lists, extend_list)
    array.push(lists, style_list)
    array.push(lists, color_list)
    array.push(lists, width_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x1_arr := i == 0 ? arr : x1_arr
            y1_arr := i == 1 ? arr : y1_arr
            x2_arr := i == 2 ? arr : x2_arr
            y2_arr := i == 3 ? arr : y2_arr
            xloc_arr := i == 4 ? arr : xloc_arr
            extend_arr := i == 5 ? arr : extend_arr
            style_arr := i == 6 ? arr : style_arr
            col_arr := i == 7 ? arr : col_arr
            width_arr := i == 8 ? arr : width_arr

        // store length in array
        array.push(lengths, length)


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    int x1 = na
    float y1 = na
    int x2 = na
    float y2 = na
    string xloc_str = na
    string line_extend = na
    string line_style = na
    color line_color = na
    int line_width = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                // this works because all arrays have the same type string
                arr = j == 0 ? x1_arr : j == 1 ? y1_arr : j == 2 ? x2_arr : j == 3 ? y2_arr : j == 4 ? xloc_arr : j == 5 ? extend_arr : j == 6 ? style_arr : j == 7 ? col_arr : width_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // using ?: instead of if
                // reduces local scopes

                val = tonumber(str)

                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x1 := j == 0 ? int(val) : x1
                y1 := j == 1 ? val : y1
                x2 := j == 2 ? int(val) : x2
                y2 := j == 3 ? val : y2
                xloc_str := j == 4 ? get_xloc(str) : xloc_str
                line_extend := j == 5 ? get_line_extend(str) : line_extend
                line_style := j == 6 ? get_line_style(str) : line_style
                line_color := j == 6 ? get_color(str) : line_color
                line_width := j == 8 ? int(val) : line_width


            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr


// create line array from lists using all params
// uses lists, type arrays, cycles for lists, params, to automate both lists, and params processing
// uses str_to_any, increases local scopes
// similar to create_any_array, doesn't improve anything, but rather adds unnecessary complexity, illustrates that var type array/conversion functions can also be used if needed
create_line_array5(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    x1_arr = array.new_string(0)
    y1_arr = array.new_string(0)
    x2_arr = array.new_string(0)
    y2_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    extend_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col_arr = array.new_string(0)
    width_arr = array.new_string(0)

    res_arr = array.new_line(0)

    lengths = array.new_int(0)
    types = array.new_string(0)
    lists = array.new_string(0)

    // must specify types manually
    // can't use typeof reliably because the list can consist of * random values with undefined type
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "color")
    array.push(types, "integer")

    // enables list processing in a cycle
    array.push(lists, x1_list)
    array.push(lists, y1_list)
    array.push(lists, x2_list)
    array.push(lists, y2_list)
    array.push(lists, xloc_list)
    array.push(lists, extend_list)
    array.push(lists, style_list)
    array.push(lists, color_list)
    array.push(lists, width_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x1_arr := i == 0 ? arr : x1_arr
            y1_arr := i == 1 ? arr : y1_arr
            x2_arr := i == 2 ? arr : x2_arr
            y2_arr := i == 3 ? arr : y2_arr
            xloc_arr := i == 4 ? arr : xloc_arr
            extend_arr := i == 5 ? arr : extend_arr
            style_arr := i == 6 ? arr : style_arr
            col_arr := i == 7 ? arr : col_arr
            width_arr := i == 8 ? arr : width_arr

        // store length in array
        array.push(lengths, length)


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    int x1 = na
    float y1 = na
    int x2 = na
    float y2 = na
    string xloc_str = na
    string line_extend = na
    string line_style = na
    color line_color = na
    int line_width = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                type = array.get(types, j)

                // this works because all arrays have the same type string
                arr = j == 0 ? x1_arr : j == 1 ? y1_arr : j == 2 ? x2_arr : j == 3 ? y2_arr : j == 4 ? xloc_arr : j == 5 ? extend_arr : j == 6 ? style_arr : j == 7 ? col_arr : width_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // converts str to target type: int, float, string, color, bool...
                [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type)

                // using ?: instead of if since we don't need to push values into var type arrays
                // reduces local scopes
                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x1 := j == 0 ? val1 : x1
                y1 := j == 1 ? val2 : y1
                x2 := j == 2 ? val1 : x2
                y2 := j == 3 ? val2 : y2
                xloc_str := j == 4 ? get_xloc(str) : xloc_str
                line_extend := j == 5 ? get_line_extend(str) : line_extend
                line_style := j == 6 ? get_line_style(str) : line_style
                line_color := j == 6 ? val4 : line_color
                line_width := j == 8 ? val1 : line_width


            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr

// create line array from lists using all params
// uses lists, type arrays, cycles for lists, params, to automate both lists, and params processing
// uses str_to_any, increases local scopes
// similar to create_any_array, doesn't improve anything, but rather adds unnecessary complexity, illustrates that
// - complex var type list processing can be separated from label array creation cycle to make it more logical and simple
// - this requires var type array/conversion functions and proper param array types
create_line_array6(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    // arrays now have proper target types instead of the same type string
    x1_arr = array.new_int(0)
    y1_arr = array.new_float(0)
    x2_arr = array.new_int(0)
    y2_arr = array.new_float(0)
    xloc_arr = array.new_string(0)
    extend_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col_arr = array.new_color(0)
    width_arr = array.new_int(0)

    res_arr = array.new_line(0)

    lengths = array.new_int(0)
    types = array.new_string(0)
    lists = array.new_string(0)

    // must specify types manually
    // can't use typeof reliably because the list can consist of * random values with undefined type
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "integer")
    array.push(types, "float")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "string")
    array.push(types, "color")
    array.push(types, "integer")

    // enables list processing in a cycle
    array.push(lists, x1_list)
    array.push(lists, y1_list)
    array.push(lists, x2_list)
    array.push(lists, y2_list)
    array.push(lists, xloc_list)
    array.push(lists, extend_list)
    array.push(lists, style_list)
    array.push(lists, color_list)
    array.push(lists, width_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        type = array.get(types, i)
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        // item = ""
        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)
            // item := length > 0 ? array.get(arr, 0) : ""

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            if length > 0

                // convert arr to target type manually
                // get param values
                for j = 0 to length - 1
                    str = array.get(arr, j)

                    // converts str to target type: int, float, string, color, bool...
                    [val1, val2, val3, val4, val5, val6, val7] = str_to_any2(str, type)

                    // array.concat can be inside ?: - reduces local scopes
                    x1_arr := i == 0 ? array.concat(x1_arr, array.new_int(1, val1)) : x1_arr
                    y1_arr := i == 1 ? array.concat(y1_arr, array.new_float(1, val2)) : y1_arr
                    x2_arr := i == 2 ? array.concat(x2_arr, array.new_int(1, val1)) : x2_arr
                    y2_arr := i == 3 ? array.concat(y2_arr, array.new_float(1, val2)) : y2_arr
                    xloc_arr := i == 4 ? array.concat(xloc_arr, array.new_string(1, get_xloc(val3))) : xloc_arr
                    extend_arr := i == 5 ? array.concat(extend_arr, array.new_string(1, get_line_extend(val3))) : extend_arr
                    style_arr := i == 6 ? array.concat(style_arr, array.new_string(1, get_line_style(val3))) : style_arr
                    col_arr := i == 7 ? array.concat(col_arr, array.new_color(1, val4)) : col_arr
                    width_arr := i == 8 ? array.concat(width_arr, array.new_int(1, val1)) : width_arr


        // store length in array
        array.push(lengths, length)
        // can't use typeof reliably because the list can consist of * random values with undefined type
        // array.push(types, typeof(item))


    len1 = array.get(lengths, 0)
    len2 = array.get(lengths, 1)
    len3 = array.get(lengths, 2)
    len4 = array.get(lengths, 3)
    len5 = array.get(lengths, 4)
    len6 = array.get(lengths, 5)
    len7 = array.get(lengths, 6)
    len8 = array.get(lengths, 7)
    len9 = array.get(lengths, 8)

    len := min(len, num_objects)

    // using simple direct calculation of params for each label - all lists must be already processed and contain proper values
    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // list params are expanded into arrays inside function, must assign proper def* values to line params, "" - causes error
            x1 = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : na
            y1 = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : na
            x2 = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : na
            y2 = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : na
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : def_line_xloc
            line_extend = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : def_line_extend
            line_style = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : def_line_style
            line_color = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : color_na
            line_width = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : na

            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr

// ================================================================================================================
// Line Object Array Update Functions - List Params
// ================================================================================================================

// Update Line Array from List Params Functions

// update line array from lists using all params
// requires translated values, shortened property names
// based on create_line_array2
// uses simple direct calculation of lists, params
// adds x2, y2, width, extend removes str, y_loc, color2, size, tooltip
update_line_array2(line_arr, x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    res_arr = line_arr

    // 0..n-1
    x1_list_ = d != " " ? str.replace_all(x1_list, " ", "") : x1_list
    y1_list_ = d != " " ? str.replace_all(y1_list, " ", "") : y1_list
    x2_list_ = d != " " ? str.replace_all(x2_list, " ", "") : x2_list
    y2_list_ = d != " " ? str.replace_all(y2_list, " ", "") : y2_list
    xloc_list_ = d != " " ? str.replace_all(xloc_list, " ", "") : xloc_list
    extend_list_ = d != " " ? str.replace_all(extend_list, " ", "") : extend_list
    style_list_ = d != " " ? str.replace_all(style_list, " ", "") : style_list
    col_list_ = d != " " ? str.replace_all(color_list, " ", "") : color_list
    width_list_ = d != " " ? str.replace_all(width_list, " ", "") : width_list

    // process lists
    x1_arr = str_split2(x1_list_, d)
    y1_arr = str_split2(y1_list_, d)
    x2_arr = str_split2(x2_list_, d)
    y2_arr = str_split2(y2_list_, d)
    xloc_arr = str_split2(xloc_list_, d)
    extend_arr = str_split2(extend_list_, d)
    style_arr = str_split2(style_list_, d)
    col_arr = str_split2(col_list_, d)
    width_arr = str_split2(width_list_, d)

    // use list with min length as base
    len1 = array.size(x1_arr)
    len2 = array.size(y1_arr)
    len3 = array.size(x2_arr)
    len4 = array.size(y2_arr)
    len5 = array.size(xloc_arr)
    len6 = array.size(extend_arr)
    len7 = array.size(style_arr)
    len8 = array.size(col_arr)
    len9 = array.size(width_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)

    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            x1_str = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : ""
            y1_str = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : ""
            x2_str = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : ""
            y2_str = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : ""
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : ""
            extend_str = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : ""
            style_str = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : ""
            col_str = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : ""
            width_str = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : ""

            // convert param values to target types
            x1 = int(tonumber(x1_str))
            x2 = int(tonumber(x2_str))
            y1 = tonumber(y1_str)
            y2 = tonumber(y2_str)
            xloc_str := get_xloc(xloc_str)
            line_extend = get_line_extend(extend_str)
            line_style = get_line_style(style_str)
            line_color = get_color(col_str)
            line_width = int(tonumber(width_str))

            line_array_set_all_fields(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)
            // line_array_set_all_fields2(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)


    res_arr


// update line array from lists using all params
// based on create_line_array4
// uses lists array, cycles for lists, params to automate both lists, and params processing
update_line_array4(line_arr, x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style_list, color_list, width_list, d) =>

    line line_ = na
    num_lists = 9

    x1_arr = array.new_string(0)
    y1_arr = array.new_string(0)
    x2_arr = array.new_string(0)
    y2_arr = array.new_string(0)
    xloc_arr = array.new_string(0)
    extend_arr = array.new_string(0)
    style_arr = array.new_string(0)
    col_arr = array.new_string(0)
    width_arr = array.new_string(0)

    res_arr = line_arr

    lengths = array.new_int(0)
    lists = array.new_string(0)

    // enables list processing in a cycle
    array.push(lists, x1_list)
    array.push(lists, y1_list)
    array.push(lists, x2_list)
    array.push(lists, y2_list)
    array.push(lists, xloc_list)
    array.push(lists, extend_list)
    array.push(lists, style_list)
    array.push(lists, color_list)
    array.push(lists, width_list)

    num_args = array.size(lists)

    // source_list = source1 + d + source2 + d + source3 + d + source4 + d + source5 + d + source6 + d + source7

    // use list with min length as base
    len = 0

    // process all lists
    for i = 0 to num_args - 1
        list = array.get(lists, i)

        // string array
        // list := list == "source" ? source_list : list

        length = 0

        if list != ""
            // 0..n-1
            list_ = d != " " ? str.replace_all(list, " ", "") : list

            arr = str_split2(list_, d)

            length := array.size(arr)

            // find min length > 1 (ignore length = 1 - single value, not a list)
            if (len == 0) or (length > 1 and (length < len or len == 1))
                len := length

            // reduces local scopes
            // this works because all arrays have the same type string
            x1_arr := i == 0 ? arr : x1_arr
            y1_arr := i == 1 ? arr : y1_arr
            x2_arr := i == 2 ? arr : x2_arr
            y2_arr := i == 3 ? arr : y2_arr
            xloc_arr := i == 4 ? arr : xloc_arr
            extend_arr := i == 5 ? arr : extend_arr
            style_arr := i == 6 ? arr : style_arr
            col_arr := i == 7 ? arr : col_arr
            width_arr := i == 8 ? arr : width_arr

        // store length in array
        array.push(lengths, length)


    len3 = array.get(lengths, 2)

    len := min(len, num_objects)


    int x1 = na
    float y1 = na
    int x2 = na
    float y2 = na
    string xloc_str = na
    string line_extend = na
    string line_style = na
    color line_color = na
    string line_width = na

    // can't merge list and param cycles - lists must be processed before params to calculate min base len of all lists
    if len > 0
        for i = 0 to len - 1
            // get param values
            for j = 0 to num_args - 1
                // this works because all arrays have the same type string
                arr = j == 0 ? x1_arr : j == 1 ? y1_arr : j == 2 ? x2_arr : j == 3 ? y2_arr : j == 4 ? xloc_arr : j == 5 ? extend_arr : j == 6 ? style_arr : j == 7 ? col_arr : width_arr
                // ensures correct processing of single item lists
                arr_len = array.get(lengths, j)
                str = arr_len > 0 ? array.get(arr, i < arr_len ? i : 0) : ""

                // using ?: instead of if
                // reduces local scopes

                val = tonumber(str)

                // x depends on xloc, so it must be resolved in 2 passes only after xloc is resolved
                // x 1st pass
                x1 := j == 0 ? int(val) : x1
                y1 := j == 1 ? val : y1
                x2 := j == 2 ? int(val) : x2
                y2 := j == 3 ? val : y2
                xloc_str := j == 4 ? get_xloc(str) : xloc_str
                line_extend := j == 5 ? get_line_extend(str) : line_extend
                line_style := j == 6 ? get_line_style(str) : line_style
                line_color := j == 6 ? get_color(str) : line_color
                line_width := j == 8 ? int(val) : line_width


            line_array_set_all_fields(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)
            // line_array_set_all_fields2(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)


    res_arr


// ================================================================================================================
// Line Object Array Create/Update Functions - Array Params
// ================================================================================================================

// Line Array Functions with Array Params

// create line array from arrays using all params
// requires translated values, expanded property names
// uses simple direct calculation of lists, params
// adds x2, y2, width, extend removes str, y_loc, color2, size, tooltip
create_line_array_from_arrays2(x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style_arr, color_arr, width_arr, d) =>

    line line_ = na
    num_lists = 9

    res_arr = array.new_line(0)

    // process lists
    col_arr = color_arr

    // use list with min length as base
    len1 = array.size(x1_arr)
    len2 = array.size(y1_arr)
    len3 = array.size(x2_arr)
    len4 = array.size(y2_arr)
    len5 = array.size(xloc_arr)
    len6 = array.size(extend_arr)
    len7 = array.size(style_arr)
    len8 = array.size(col_arr)
    len9 = array.size(width_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)

    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // array params are already expanded/filled with proper/default values, don't need to assign proper def* values
            x1 = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : na
            y1 = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : na
            x2 = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : na
            y2 = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : na
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : ""
            line_extend = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : ""
            line_style = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : ""
            line_color = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : color_na
            line_width = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : na

            line_ = line.new(x1, y1, x2, y2, xloc=xloc_str, extend=line_extend, style=line_style, color=line_color, width=line_width)
            array.push(res_arr, line_)


    res_arr

// update line array from arrays using all params
// uses simple direct calculation of lists, params
// adds x2, y2, width, extend removes str, y_loc, color2, size, tooltip
update_line_array_from_arrays2(line_arr, x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style_arr, color_arr, width_arr, d) =>

    line line_ = na
    num_lists = 9

    res_arr = line_arr

    // process lists
    col_arr = color_arr

    // use list with min length as base
    len1 = array.size(x1_arr)
    len2 = array.size(y1_arr)
    len3 = array.size(x2_arr)
    len4 = array.size(y2_arr)
    len5 = array.size(xloc_arr)
    len6 = array.size(extend_arr)
    len7 = array.size(style_arr)
    len8 = array.size(col_arr)
    len9 = array.size(width_arr)

    lengths = array.new_int(0)

    array.push(lengths, len1)
    array.push(lengths, len2)
    array.push(lengths, len3)
    array.push(lengths, len4)
    array.push(lengths, len5)
    array.push(lengths, len6)
    array.push(lengths, len7)
    array.push(lengths, len8)
    array.push(lengths, len9)

    // find min length that is > 1 (ignore length = 1 - single value, not a list)
    len = 0
    for i = 0 to num_lists - 1
        length = array.get(lengths, i)
        if (len == 0) or (length > 1 and (length < len or len == 1))
            len := length

    len := min(len, num_objects)

    if len > 0
        for i = 0 to len - 1
            // get param values
            // ensures correct processing of single item lists
            // array params are already expanded/filled with proper/default values, don't need to assign proper def* values
            x1 = len1 > 0 ? array.get(x1_arr, i < len1 ? i : 0) : na
            y1 = len2 > 0 ? array.get(y1_arr, i < len2 ? i : 0) : na
            x2 = len3 > 0 ? array.get(x2_arr, i < len3 ? i : 0) : na
            y2 = len4 > 0 ? array.get(y2_arr, i < len4 ? i : 0) : na
            xloc_str = len5 > 0 ? array.get(xloc_arr, i < len5 ? i : 0) : ""
            line_extend = len6 > 0 ? array.get(extend_arr, i < len6 ? i : 0) : ""
            line_style = len7 > 0 ? array.get(style_arr, i < len7 ? i : 0) : ""
            line_color = len8 > 0 ? array.get(col_arr, i < len8 ? i : 0) : color_na
            line_width = len9 > 0 ? array.get(width_arr, i < len9 ? i : 0) : na

            line_array_set_all_fields(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)
            // line_array_set_all_fields2(line_arr, i, x1, y1, x2, y2, xloc_str, line_extend, line_style, line_color, line_width)

    res_arr


// ================================================================================================================
// Console Output Helper Functions
// ================================================================================================================

echo5(x, y, con, str, label_style, label_color, text_color, text_size, text_align) =>
    // defaults - comment out to use global vars instead
    // important! float v_shift = 2 doesn't work, v_shift must be explicitly defined as 2.0 or v_shift/100 = 0 instead of 1.02, and y_ = close instead of 1.02 * close.
    // close[1] prevents constant label text redraw on cur bar
    v_shift = 0.0 // 2.0
    x_ = na(x) or x == -1 ? time : x
    y_ = na(y) or y == -1 ? close * (1 + v_shift/100) : y
    msg_xloc = xloc.bar_time
    label_style_ = na(label_style) ? label.style_none : label_style
    // label_color requires color(na) instead of color_na
    label_color_ = na(label_color) ? color(na) : label_color
    text_color_ = na(text_color) ? black : text_color
    text_size_ = na(text_size) ? size.large : text_size
    text_align_ = na(text_align) ? text.align_left : text_align

    label.delete(con)
    console = label.new(x_, y_, text=str, xloc=msg_xloc, style=label_style_, color=label_color_, textcolor=text_color_, size=text_size_, textalign=text_align_)

array_name(type, index) =>
    prefix = type == "integer" ? "int" : type == "string" ? "str" : type == "color" ? "col" : type
    res = prefix + "_arr"
    res := index > 1 ? res + tostring(index) : res


// ================================================================================================================
// Processing
// ================================================================================================================


// Create Label Array

// 1) Methods for creating a label array

// 1. using a single function create_label_array*
// 2. manually, using a for cycle with label.new()

// required for all methods - delete label objects from prev bar
// delete_label_array(label_arr)

// Method 1
// label_arr := create_label_array2(x_list, y_list, str_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

// Method 2
// num_objects = 5
// text_str = "Label"
// for i = 0 to num_objects - 1
//     index = num_objects - i
//     x = time
//     y = close * (1 + 0.03 + 0.02 * index)
//     cur_str = text_str + tostring(index + 1)
//     tooltip_str = cur_str
//     label_ = label.new(x, y, text=cur_str, xloc=def_label_xloc, style=def_label_style, color=def_label_color, textcolor=def_text_color, size=def_text_size, textalign=def_text_align, tooltip=tooltip_str)
//     array.push(label_arr, label_)

// len = array.size(label_arr)


// 2) Method 1 Implementation Templates

// We can perform all calculations on:
// 1. bar 0
//  - works for labels, won't work for lines, because at least n > line length bars must exist for line get/set to return proper x coords. You can't draw a line beyond 0 and n.
//         horiz lines created on bar 0 will have length 0 and will be invisible. For line to be visible it must have length >= 2 and both its ends visible on screen.
//     - to modify label/line objects inside if n == 0 label/line_arr must be persistent and declared with var!
//     - since only 1 set of label/line objects is created on bar 0, all x coords must be updated on each bar, otherwise all objects will remain on bar 0 and will not move to cur bar.
//     - this method requires also persistent params for update/set functions
//     - fastest

// 2. each bar
//     - works for both labels/lines.
//     - since a new set of label/line objects is created on each bar, we must manually delete old objects from prev bar and keep only the newest set from cur bar.
//     - to access/delete old label/line objects created on the prev bar label/line_arr must be persistent and declared with var, even without if!
//     - this method doesn't require a separate x coords update on each bar, because the whole object is recalculated.
//     - this method doesn't require persistent params for update/set functions, because the whole object is recalculated.
//     - slowest, can sometimes produce loop too long error

// 3. cur/last bar and each new bar after that
//     - works for both labels/lines.
//     - since a new set of label/line objects is created on cur bar and each next bar, we must manually delete old objects from prev bar and keep only the newest set from cur bar.
//     - to modify label/line objects inside if barstate.islast label/line_arr must be persistent and declared with var!
//     - this method doesn't require a separate x coords update on each bar, because the whole object is recalculated.
//     - this method doesn't require persistent params for update, because the whole object is recalculated.
//  - fast, but keeps recalculating on each new bar after cur bar

// var is required for all methods
// var label_arr = array.new_label(0)

// Method 1 Template
// create/modify label array on bar 0, update x coord on each bar

// x = n
// var text = ""
// if n == 0
//     label_arr := create_label_array2(...)
//     // calculations must also be done on bar 0
//     text := "New Label"
//     label_array_set_text(label_arr, 0, text) or update_label_array(label_arr, ...text)

// // either just x for set* or all update params must be persistent and declared with var, otherwise changes won't transfer to the next bar and become overriden by set/update with default values!
// label_array_set_x*(label_arr, x) or update_label_array(label_arr, x, ...text)

// Method 2 Template
// delete/create/modify label array on each bar - delete label objects from prev bar

// delete_label_array(label_arr)
// label_arr := create_label_array2(...)
// // calculations must also be done on each bar
// label_array_set*(label_arr, ...) or update_label_array(label_arr, ...)

// Method 3 Template
// delete/create/modify label array on cur bar and each new bar after that - delete label objects from prev bar

// if n == barstate.islast
//     delete_label_array(label_arr)
//     label_arr := create_label_array2(...)
//     // calculations must also be done on cur bar
//     label_array_set_text(label_arr, ...) or update_label_array(label_arr, ...)


// Using Method 3 Template

var x_base = label_x_base
var y_base = 0.0
var x_type = get_type(label_x_type_str)
var y_type = get_type(label_y_type_str)
var x_list = x1_list
var y_list = y1_list
var style_list = label_style_list
color1_list := show_labels ? color1_list : "color_na"
color2_list := show_labels ? color2_list : "color_na"

var x_base2 = line_x_base
var y_base2 = 0.0
var x_type2 = get_type(line_x_type_str)
var y_type2 = get_type(line_y_type_str)
var style2_list = line_style_list
var color_list = show_lines ? color3_list : "color_na"

var str = ""

// fill output str
if barstate.islast
    // Create Any Array - Method 2
    // create_any_array2 returns an int_arr pointer to a different array type and can only be used as temporary storage, it must be reassigned to a pre-defined matching array type that already exists
    // this works for int_arr pointer to int, float, color, and bool arrays regardless of whether the pre-defined matching arrays were defined with/without var because they are compatible with int_arr type
    x1_arr := create_any_array2(x1_list, del3, "integer")
    x2_arr := create_any_array2(x2_list, del3, "integer")
    y1_arr := create_any_array2(y1_list, del3, "float")
    y2_arr := create_any_array2(y2_list, del3, "float")
    width_arr := create_any_array2(width_list, del3, "integer")
    color1_arr := create_any_array2(color1_list, del3, "color")
    color2_arr := create_any_array2(color2_list, del3, "color")
    color3_arr := create_any_array2(color3_list, del3, "color")

    // this works when str_arr is defined using var because instead of an int_arr pointer to a string arr, create_any_array returns a 100% matching arr type (string) derived from the passed empty str_arr param that is modified directly
    xloc_arr := create_any_array(xloc_arr, xloc_list, del3, "string")
    yloc_arr := create_any_array(yloc_arr, yloc_list, del3, "string")
    style_arr := create_any_array(style_arr, label_style_list, del3, "string")
    style2_arr := create_any_array(style2_arr, line_style_list, del3, "string")
    text_arr := create_any_array(text_arr, text_list, del3, "string")
    tooltip_arr := create_any_array(tooltip_arr, tooltip_list, del3, "string")
    size_arr := create_any_array(size_arr, size_list, del3, "string")
    align_arr := create_any_array(align_arr, align_list, del3, "string")
    extend_arr := create_any_array(extend_arr, extend_list, del3, "string")

    exclude_arr := create_any_array(exclude_arr, exclude_str, del3, "exclude")
    include_arr := create_any_array(include_arr, include_str, del3, "include")

    var create_function1_str = ""
    var create_function2_str = ""

    // 1. Create/Update Label Array

    // 1.1 Init

    // Method 1
    x_arr = x1_arr
    y_arr = y1_arr
    // Method 2
    // x_arr = array.copy(x1_arr)
    // y_arr = array.copy(y1_arr)

    // hide labels
    if not show_labels
        array.clear(color1_arr)
        array.clear(color2_arr)

    // get max number of items in all arrays or use num_objects instead
    // lengths = array.new_int(0)
    // array.push(lengths, array.size(x_arr))
    // array.push(lengths, array.size(y_arr))
    // array.push(lengths, array.size(text_arr))
    // array.push(lengths, array.size(xloc_arr))
    // array.push(lengths, array.size(yloc_arr))
    // array.push(lengths, array.size(style_arr))
    // array.push(lengths, array.size(color1_arr))
    // array.push(lengths, array.size(color2_arr))
    // array.push(lengths, array.size(size_arr))
    // array.push(lengths, array.size(align_arr))
    // array.push(lengths, array.size(tooltip_arr))
    // max_len = array.max(lengths)
    max_len = num_objects

    // 1.2 Transform/Expand Arrays

    // transform created arrays - required for all create/update/set functions
    // must be done every time to get cur bar's source value
    y_base := get_src(label_y_base_str)
    y_base := na(y_base) ? 0.0 : y_base

    // expand string property names - required only for create/update from arrays and all set functions
    xloc_arr := expand_string_array(xloc_arr, "xloc")
    yloc_arr := expand_string_array(xloc_arr, "yloc")
    style_arr := expand_string_array(style_arr, "label_style")
    size_arr := expand_string_array(size_arr, "text_size")
    align_arr := expand_string_array(align_arr, "text_align")

    // requires expanded xloc_arr
    // Method 1
    // must assign to a new x_arr_, y_arr_ array vars, otherwise x1_arr, x2_arr will be overwritten causing double transform error in 2.2
    x_arr_ = transform_x_array(x_arr, x_type, x_base, xloc_arr, max_len)
    y_arr_ = transform_y_array(y_arr, y_type, y_base, max_len)
    // Method 2
    // x_arr := transform_x_array(x_arr, x_type, x_base, xloc_arr, max_len)
    // y_arr := transform_y_array(y_arr, y_type, y_base, max_len)

    // Method 3 - transform all coords only once
    // requires knowing x_type2, x_base2, max_len2 in advance
    // x1_arr := transform_x_array(x1_arr, x_type2, x_base2, xloc_arr, max_len2)
    // y1_arr := transform_y_array(y1_arr, y_type2, y_base2, max_len2)
    // x2_arr := transform_x_array(x2_arr, x_type2, x_base2, xloc_arr, max_len2)
    // y2_arr := transform_y_array(y2_arr, y_type2, y_base2, max_len2)
    // x_arr_ = x1_arr
    // y_arr_ = y1_arr

    // delete old label objects from prev bar
    delete_label_array(label_arr)

    // 1.3 Create/Update Label Array Using Arrays
    // pass transformed x,y and expanded strings

    if fc1_str == "create_label_array_from_arrays2"
        // create array
        label_arr := create_label_array_from_arrays2(x_arr_, y_arr_, text_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, del3)

        // update array - not required, enabled as proof of work, can be used after create
        label_arr := update_label_array_from_arrays2(label_arr, x_arr_, y_arr_, text_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, del3)

        create_function1_str := fc1_str + "(x_arr, y_arr, text_arr, xloc_arr, yloc_arr, style_arr, color1_arr, color2_arr, size_arr, align_arr, tooltip_arr, del3)"

    // 1.4 Create/Update Label Array Using Lists
    // pass transformed x,y and not expanded strings

    if fc1_str == "create_label_array2" or fc1_str == "create_label_array3" or fc1_str == "create_label_array4" or fc1_str == "create_label_array5" or fc1_str == "create_label_array6"
        // method a
        // x_list := join_number_array(x_arr, del3 + s)
        // y_list := join_number_array(y_arr, del3 + s)
        // x_list := remove_end_chars(x_list)
        // y_list := remove_end_chars(y_list)

        // method b
        // tostring and join_number_array wrap result in square brackets - use join_number_array2 instead or remove square brackets with remove_end_chars otherwise first/last x, y = na
        x_list := join_number_array2(x_arr_, del3 + s)
        y_list := join_number_array2(y_arr_, del3 + s)

        // create array
        if fc1_str == "create_label_array2"
            label_arr := create_label_array2(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

        // if fc1_str == "create_label_array3"
        //     label_arr := create_label_array3(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

        if fc1_str == "create_label_array4"
            label_arr := create_label_array4(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

        // disabled to reduce compiled size
        // if fc1_str == "create_label_array5"
        //     label_arr := create_label_array5(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

        // if fc1_str == "create_label_array6"
        //     label_arr := create_label_array6(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)


        // update array - not required, enabled as proof of work, can be used after create
        label_arr := update_label_array2(label_arr, x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)

        create_function1_str := fc1_str + "(x_list, y_list, text_list, xloc_list, yloc_list, style_list, color1_list, color2_list, size_list, align_list, tooltip_list, del3)"


    // 2. Create/Update Line Array

    // 2.1 Init

    color_arr = color3_arr

    // hide lines
    if not show_lines
        array.clear(color_arr)

    // get max number of items in all arrays or use num_lines instead
    // array.clear(lengths)
    // array.push(lengths, array.size(x1_arr))
    // array.push(lengths, array.size(y1_arr))
    // array.push(lengths, array.size(x2_arr))
    // array.push(lengths, array.size(y2_arr))
    // array.push(lengths, array.size(xloc_arr))
    // array.push(lengths, array.size(extend_arr))
    // array.push(lengths, array.size(style2_arr))
    // array.push(lengths, array.size(color_arr))
    // array.push(lengths, array.size(width_arr))
    // max_len2 = array.max(lengths)
    max_len2 = num_objects

    // 2.2 Transform/Expand Arrays

    // transform created arrays - required for all create/update/set functions
    // must be done every time to get cur bar's source value
    y_base2 := get_src(line_y_base_str)
    y_base2 := na(y_base2) ? 0.0 : y_base2

    // expand string property names - required only for create/update from arrays and all set functions
    extend_arr := expand_string_array(extend_arr, "line_extend")
    style2_arr := expand_string_array(style2_arr, "line_style")

    // requires expanded xloc_arr
    x1_arr := transform_x_array(x1_arr, x_type2, x_base2, xloc_arr, max_len2)
    y1_arr := transform_y_array(y1_arr, y_type2, y_base2, max_len2)
    x2_arr := transform_x_array(x2_arr, x_type2, x_base2, xloc_arr, max_len2)
    y2_arr := transform_y_array(y2_arr, y_type2, y_base2, max_len2)

    // delete old line objects from prev bar
    delete_line_array(line_arr)

    // 2.3 Create/Update Line Array Using Arrays
    // pass transformed x,y expanded strings

    if fc2_str == "create_line_array_from_arrays2"
        // create array
        line_arr := create_line_array_from_arrays2(x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style2_arr, color_arr, width_arr, del3)

        // update array - not required, enabled as proof of work, can be used after create
        line_arr := update_line_array_from_arrays2(line_arr, x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style2_arr, color_arr, width_arr, del3)

        create_function2_str := fc2_str + "(x1_arr, y1_arr, x2_arr, y2_arr, xloc_arr, extend_arr, style2_arr, color_arr, width_arr, del3)"

    // 2.4 Create/Update Line Array Using Lists
    // pass transformed x,y and non expanded strings

    if fc2_str == "create_line_array2" or fc2_str == "create_line_array3" or fc2_str == "create_line_array4" or fc2_str == "create_line_array5" or fc2_str == "create_line_array6"
        // method a
        // x1_list := join_number_array(x1_arr, del3 + s)
        // y1_list := join_number_array(y1_arr, del3 + s)
        // x2_list := join_number_array(x2_arr, del3 + s)
        // y2_list := join_number_array(y2_arr, del3 + s)
        // x1_list := remove_end_chars(x1_list)
        // y1_list := remove_end_chars(y1_list)
        // x2_list := remove_end_chars(x2_list)
        // y2_list := remove_end_chars(y2_list)

        // method b
        // tostring and join_number_array wrap result in square brackets - use join_number_array2 instead or remove square brackets with remove_end_chars otherwise first/last x, y = na
        x1_list := join_number_array2(x1_arr, del3 + s)
        y1_list := join_number_array2(y1_arr, del3 + s)
        x2_list := join_number_array2(x2_arr, del3 + s)
        y2_list := join_number_array2(y2_arr, del3 + s)

        // create array
        if fc2_str == "create_line_array2"
            line_arr := create_line_array2(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)

        // if fc2_str == "create_line_array3"
        //     line_arr := create_line_array3(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)

        if fc2_str == "create_line_array4"
            line_arr := create_line_array4(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)

        // disabled to reduce compiled size
        // if fc2_str == "create_line_array5"
        //     line_arr := create_line_array5(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)

        // if fc2_str == "create_line_array6"
        //     line_arr := create_line_array6(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)


        // update array - not required, enabled as proof of work, can be used after create
        line_arr := update_line_array2(line_arr, x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)

        create_function2_str := fc2_str + "(x1_list, y1_list, x2_list, y2_list, xloc_list, extend_list, style2_list, color_list, width_list, del3)"


    // 3. SET Label/Line Array Item

    // 3.1 SET Label Item

    // expand string properties
    label_xloc = get_xloc(label_xloc_str)
    label_yloc = get_yloc(label_yloc_str)
    label_style = get_label_style(label_style_str)
    // label_color := show_labels ? get_color(label_color_str) : color_na
    label_col = get_color(label_color_str)
    label_color = show_labels ? not na(label_col) ? label_col : def_label_color : color_na
    // there are 2 color na values: color color_na = na = #000000 = na(label_color) (without transparency) and color(na) = #00000000 (with transparency). Different functions require different types of na color
    // get_color returns color_na, label_color requires transparency and conversion to color(na), otherwise chart disappears with infinite loading loop
    label_color := na(label_color) ? color(na) : label_color
    // text_color := show_labels ? get_color(text_color_str) : color_na
    text_col = get_color(text_color_str)
    text_color = show_labels ? not na(text_col) ? text_col : def_text_color : color_na
    text_size = get_size(text_size_str)
    text_align = get_text_align(text_align_str)

    // transform x, y
    // requires expanded xloc
    label_x := transform_x(label_x, x_type, x_base, label_xloc, label_index)
    label_y := transform_y(label_y, y_type, y_base, label_index)

    // set label item index - now done inside the output cycle
    // label_array_set_all_fields(label_arr, label_index, label_x, label_y, label_text_str, label_xloc, label_yloc, label_style, label_color, text_color, text_size, text_align, tooltip_str)


    // 3.2 SET Line Item

    // expand string properties
    line_xloc = get_xloc(line_xloc_str)
    line_extend = get_line_extend(line_extend_str)
    line_style = get_line_style(line_style_str)
    // line_color := show_lines ? get_color(line_color_str) : color_na
    line_col = get_color(line_color_str)
    line_color = show_lines ? not na(line_col) ? line_col : def_line_color : color_na

    // requires expanded xloc
    line_x1 := transform_x(line_x1, x_type, x_base, line_xloc, line_index)
    line_y1 := transform_y(line_y1, y_type2, y_base2, line_index)
    line_x2 := transform_x(line_x2, x_type, x_base, line_xloc, line_index)
    line_y2 := transform_y(line_y2, y_type2, y_base2, line_index)

    // set line item index - now done inside the output cycle
    // line_array_set_all_fields(line_arr, line_index, line_x1, line_y1, line_x2, line_y2, line_xloc, line_extend, line_style, line_color, line_width)


    // Process UI Settings
    panel_style := panel_style_str != "" ? get_label_style(panel_style_str) : panel_style
    panel_color := show_panel ? use_native ? panel_color_native : get_color(panel_color_str) : color_na
    // label color requires color(na) instead of color_na
    panel_color := na(panel_color) ? color(na) : panel_color
    panel_text_color := show_panel ? use_native ? panel_text_color_native : get_color(panel_text_color_str) : color_na
    panel_text_size := get_size(panel_text_size_str)
    panel_text_align := get_text_align(panel_text_align_str)


    // Strings
    eol2 := repeat("\n", line_spacing + 1)

    str := "#, Function(User Input) = User Output\n"
    str := str + "__________________________________\n\n"
    header_str = str
    str := str + eol
    str := str + create_function1_str + eol2
    str := str + create_function2_str + eol2
    str := str + divider_line + eol2

    // total number of groups
    total_groups = 4
    // active group counter
    num_groups = 0

    // groups
    f1_group = "join_label_array, join_label_array2, label_array_get_text, label_array_get_xy, label_array_get_fields"
    f2_group = "label_array_set_text, label_array_set_xy, label_array_set_color, label_array_set_text_color, label_array_set_fields, label_array_set_all_fields, label_array_set_all_fields2"

    f3_group = "join_line_array, join_line_array2, line_array_get_price, line_array_get_xy, line_array_get_fields"
    f4_group = "line_array_set_width, line_array_set_xy, line_array_set_color, line_array_set_fields, line_array_set_all_fields, line_array_set_all_fields2"


    // calculate size of each group
    f1_arr = str.split(f1_group, c)
    f2_arr = str.split(f2_group, c)
    f3_arr = str.split(f3_group, c)
    f4_arr = str.split(f4_group, c)

    f1_len = array.size(f1_arr)
    f2_len = array.size(f2_arr)
    f3_len = array.size(f3_arr)
    f4_len = array.size(f4_arr)

    count = 0

    // process all groups
    for k = 1 to total_groups
        len = k == 1 ? f1_len : k == 2 ? f2_len : k == 3 ? f3_len : f4_len
        arr = k == 1 ? f1_arr : k == 2 ? f2_arr : k == 3 ? f3_arr : f4_arr
        f_str = k == 1 ? f1_str : k == 2 ? f2_str : k == 3 ? f3_str : f4_str

        if (f_str == "none")
            continue

        // number of processed groups
        num_groups := num_groups + 1
        old_count = count

        // process all functions in a group
        for i = 0 to len - 1
            name_str = array.get(arr, i)
            args_str = ""
            res_str = ""

            // skip function check
            // - process all functions only when explicitly specified, otherwise process only selected function
            // - don't process functions from excluded list
            // - process only functions in the allowed list
            if (f_str != "all" and f_str != name_str) or (exclude_str != "" and array.includes(exclude_arr, name_str) ) or ( include_str != "" and not array.includes(include_arr, name_str) )
                continue


            // Label & Line Array Functions

            // 1) GET

            // Label Array Functions

            if name_str == "label_array_get_text"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg1_str = arg1
                arg2_str = tostring(arg2)
                args_str := arg1_str + c + arg2_str

                res = label_array_get_text(label_arr, arg2)

                res_str := "\"" + res + "\""

            if name_str == "label_array_get_xy"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg1_str = arg1
                arg2_str = tostring(arg2)
                args_str := arg1_str + c + arg2_str

                [x, y] = label_array_get_xy(label_arr, arg2)

                res_str := "[" + tostring(x) + c + tostring(y, format) + "]"


            if name_str == "label_array_get_fields"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg1_str = arg1
                arg2_str = tostring(arg2)
                args_str := arg1_str + c + arg2_str

                [x, y, text] = label_array_get_fields(label_arr, arg2)

                res_str := "[" + tostring(x) + c + tostring(y, format) + c + "\"" + text + "\"" + "]"

            // Line Array Functions

            if name_str == "line_array_get_price"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg3 = line_price_bar
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                args_str := arg1_str + c + arg2_str + c + arg2_str

                res = line_array_get_price(line_arr, arg2, arg3)

                res_str := tostring(res, format)

            if name_str == "line_array_get_xy"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg1_str = arg1
                arg2_str = tostring(arg2)
                args_str := arg1_str + c + arg2_str

                [x1, y1, x2, y2] = line_array_get_xy(line_arr, arg2)

                res_str := "[" + tostring(x1) + c + tostring(y1, format) + c + tostring(x2) + c + tostring(y2, format) + "]"

            if name_str == "line_array_get_fields"
                arg1 = array_name("line", 1)
                arg2 = line_index
                // arg3 = line_price_bar
                arg1_str = arg1
                arg2_str = tostring(arg2)
                // arg3_str = tostring(arg3)
                // args_str := arg1_str + c + arg2_str + c + arg2_str
                args_str := arg1_str + c + arg2_str

                // [x1, y1, x2, y2, price] = line_array_get_fields(line_arr, arg2, arg3)
                [x1, y1, x2, y2] = line_array_get_fields(line_arr, arg2)

                // res_str := "[" + tostring(x1) + c + tostring(y1, format) + c + tostring(x2) + c + tostring(y2, format) + c + tostring(price, format) + "]"
                res_str := "[" + tostring(x1) + c + tostring(y1, format) + c + tostring(x2) + c + tostring(y2, format) + "]"


            // SET

            // Label Array Functions

            if name_str == "label_array_set_text"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg3 = label_text_str
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = "\"" + arg3 + "\""
                args_str := arg1_str + c + arg2_str + c + arg3_str

                // label_arr := label_array_set_text(arr, index, str)
                label_arr := label_array_set_text(label_arr, arg2, arg3)

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res


            if name_str == "label_array_set_xy"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg3 = label_x
                arg4 = label_y
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str

                // label_arr := label_array_set_xy(arr, index, x, y)
                label_arr := label_array_set_xy(label_arr, arg2, arg3, arg4)

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res


            if name_str == "label_array_set_color" or name_str == "label_array_set_text_color"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg3 = name_str == "label_array_set_color" ? label_color : text_color
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = name_str == "label_array_set_color" ? out_str(label_color_str, "color") : out_str(text_color_str, "color")
                args_str := arg1_str + c + arg2_str + c + arg3_str

                // label_arr := label_array_set_text(arr, index, str)
                label_arr := name_str == "label_array_set_color" ? label_array_set_color(label_arr, arg2, arg3) : label_array_set_text_color(label_arr, arg2, arg3)

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res


            if name_str == "label_array_set_fields"
                arg1 = array_name("label", 1)
                arg2 = label_index
                arg3 = label_x
                arg4 = label_y
                arg5 = label_text_str
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                arg5_str = "\""+ arg5 + "\""
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str + c + arg5_str

                // label_arr := label_array_set_fields(arr, index, x, y, str)
                label_arr := label_array_set_fields(label_arr, arg2, arg3, arg4, arg5)

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res


            if name_str == "label_array_set_all_fields" or name_str == "label_array_set_all_fields2"
                arg1 = array_name("label", 1)
                arg2 = label_index
                // label_x is already translated to abs bar index/time, label_array_set_all_fields expects abs bar index or time, label_array_set_all_fields2 - rel bar index or time and requires a backwards conversion for abs bar index (not time)
                arg3 = name_str == "label_array_set_all_fields" ? label_x : label_xloc == xloc.bar_time ? label_x : n - label_x
                arg4 = label_y
                arg5 = label_text_str
                arg6 = label_xloc
                arg7 = label_yloc
                arg8 = label_style
                arg9 = label_color
                arg10 = text_color
                arg11 = text_size
                arg12 = text_align
                arg13 = tooltip_str
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                arg5_str = "\""+ arg5 + "\""
                arg6_str = xloc_to_str(arg6)
                arg7_str = yloc_to_str(arg7)
                arg8_str = label_style_to_str(arg8)
                arg9_str = out_str(label_color_str, "color") // color_to_str(arg9)
                arg10_str = out_str(text_color_str, "color") // color_to_str(arg10)
                arg11_str = size_to_str(arg11)
                arg12_str = text_align_to_str(arg12)
                arg13_str = "\"" + arg13 + "\""
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str + c + arg5_str + c + arg6_str + c + arg7_str + c + arg8_str + c + arg9_str + c + arg10_str + c + arg11_str + c + arg12_str + c + arg13_str

                // label_array_set_all_fields(arr, index, x, y, str, xloc, yloc, label_style, label_color, text_color, text_size, text_align, tooltip)
                label_arr := name_str == "label_array_set_all_fields" ? label_array_set_all_fields(label_arr, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) :
                     label_array_set_all_fields2(label_arr, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res


            // Line Array Functions

            if name_str == "line_array_set_width"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg3 = line_width
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                args_str := arg1_str + c + arg2_str + c + arg3_str

                // line_arr := line_array_set_width(arr, index, width)
                line_arr := line_array_set_width(line_arr, arg2, arg3)

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            if name_str == "line_array_set_xy"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg3 = line_x1
                arg4 = line_y1
                arg5 = line_x2
                arg6 = line_y2
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                arg5_str = tostring(arg5)
                arg6_str = tostring(arg6)
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str + c + arg5_str + c + arg6_str

                // line_arr := line_array_set_xy(arr, index, x1, y1, x2, y2)
                line_arr := line_array_set_xy(line_arr, arg2, arg3, arg4, arg5, arg6)

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            if name_str == "line_array_set_color"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg3 = line_color
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = out_str(line_color_str, "color")
                args_str := arg1_str + c + arg2_str + c + arg3_str

                // line_arr := line_array_set_width(arr, index, width)
                line_arr := line_array_set_color(line_arr, arg2, arg3)

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            if name_str == "line_array_set_fields"
                arg1 = array_name("line", 1)
                arg2 = line_index
                arg3 = line_x1
                arg4 = line_y1
                arg5 = line_x2
                arg6 = line_y2
                arg7 = line_width
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                arg5_str = tostring(arg5)
                arg6_str = tostring(arg6)
                arg7_str = tostring(arg7)
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str + c + arg5_str + c + arg6_str + c + arg7_str

                // line_arr := line_array_set_fields(arr, index, x1, y1, x2, y2, width)
                line_arr := line_array_set_fields(line_arr, arg2, arg3, arg4, arg5, arg6, arg7)

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            if name_str == "line_array_set_all_fields" or name_str == "line_array_set_all_fields2"
                arg1 = array_name("line", 1)
                arg2 = line_index
                // label_x is already translated to abs bar index/time, line_array_set_all_fields expects abs bar index or time, line_array_set_all_fields2 - rel bar index or time and requires a backwards conversion for abs bar index (not time)
                arg3 = name_str == "line_array_set_all_fields" ? line_x1 : line_xloc == xloc.bar_time ? line_x1 : n - line_x1
                arg4 = line_y1
                arg5 = name_str == "line_array_set_all_fields" ? line_x2 : line_xloc == xloc.bar_time ? line_x2 : n - line_x2
                arg6 = line_y2
                arg7 = line_xloc
                arg8 = line_extend
                arg9 = line_style
                arg10 = line_color
                arg11 = line_width
                arg1_str = arg1
                arg2_str = tostring(arg2)
                arg3_str = tostring(arg3)
                arg4_str = tostring(arg4)
                arg5_str = tostring(arg5)
                arg6_str = tostring(arg6)
                arg7_str = xloc_to_str(arg7)
                arg8_str = line_extend_to_str(arg8)
                arg9_str = line_style_to_str(arg9)
                arg10_str = out_str(line_color_str, "color") // color_to_str(arg10)
                arg11_str = tostring(arg11)
                args_str := arg1_str + c + arg2_str + c + arg3_str + c + arg4_str + c + arg5_str + c + arg6_str + c + arg7_str + c + arg8_str + c + arg9_str + c + arg10_str + c + arg11_str

                // line_array_set_all_fields(arr, index, x1, y1, x2, y2, xloc, extend, line_style, line_color, width)
                line_arr := name_str == "line_array_set_all_fields" ? line_array_set_all_fields(line_arr, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) :
                     line_array_set_all_fields2(line_arr, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            // Return Strings

            if name_str == "join_label_array"
                arg1 = array_name("label", 1)
                arg2 = "\", \"" // only const str works, del3 var delimiter doesn't work
                arg1_str = arg1
                arg2_str = arg2
                args_str := arg1_str + c + arg2_str

                // this works for strings, but doesn't work for labels - internal server error - can't join array of labels and convert it into string
                // res_str := array.join(res, ", ")

                res = eol + join_label_array2(label_arr, d, c, c + eol)

                res_str := res

            if name_str == "join_line_array"
                arg1 = array_name("line", 1)
                arg2 = "\", \"" // only const str works, del3 var delimiter doesn't work
                arg1_str = arg1
                arg2_str = arg2
                args_str := arg1_str + c + arg2_str

                // this works for strings, but doesn't work for labels - internal server error - can't join array of labels and convert it into string
                // res_str := array.join(res, ", ")

                res = eol + join_line_array2(line_arr, d, c, c + eol)

                res_str := res


            // Output
            if res_str != ""
                count := count + 1
                line_str = tostring(count) + b + name_str + "(" + args_str + ") = " + res_str + eol2
                // array.push(str_arr, line_str)
                str := str + line_str

        // divide functions into groups, always show the last divider at the end
        // at least 1 active group must exist
        // don't show dividers after empty/disabled groups
        if num_groups > 0 and k < total_groups and count > old_count and show_divider
            str := str + divider_line + eol2



var label console = na

// output str on each bar
console := echo5(-1, -1, console, str, panel_style, panel_color, panel_text_color, panel_text_size, panel_text_align)

plot(show_bar_index ? n : na, title="Abs Bar Index")