//@version=5
strategy("Dskyz (DAFE) GENESIS", default_qty_type=strategy.fixed, initial_capital=10000, overlay=true, pyramiding=1, commission_type=strategy.commission.cash_per_contract, commission_value=12.5, slippage=3)

// === ðŸ“ˆ Main Signal Parameters ===
scoreMax        = input.int(2, title="ðŸ“Š Maximum Raw Score", minval=1, maxval=10, tooltip="Number of raw signal criteria that make up your trade confidence/regime score. Leave at 4 unless you expand system factors.")
rsiLen          = input.int(9, title="ðŸ”¢ RSI Length", minval=2, maxval=30, tooltip="Lookback window (in bars) for RSI calculation. Lower = more sensitive & choppy; higher = smoother, slower signals.")
rsiShortFloor   = input.int(67, title="ðŸ“‰ Min RSI for Shorts", minval=0, maxval=100, tooltip="Minimum RSI needed for SHORT entries. Raise to only short when market is more overbought.")
rsiLongCeil     = input.int(39, title="ðŸ“ˆ Max RSI for Longs", minval=0, maxval=100, tooltip="Maximum RSI allowed for LONG entries. Lower = only go long on deeper oversold conditions.")
momentumGate    = input.float(0, title="âš¡ Min Normed Momentum", minval=0, maxval=1, tooltip="Minimum normalized momentum (0-1) for new trades. Raise for more conviction (less 'chop'), lower for more trades.")
confGate        = input.float(0.3, title="ðŸŽ¯ Min Normed Score (Conf)", minval=0, maxval=1, tooltip="Minimum normalized regime confidence, 0-1. Higher means only strongest multi-factor confluence trades allowed.")
volLookback     = input.int(44, title="ðŸ” ATR Lookback Period", minval=5, maxval=1000, tooltip="How many bars to average for ATR (volatility). 120 best for 15m or 1hr bar. Increase for smoother volatility gating.")
lowVolPct       = input.int(60, title="ðŸ§Š ATR Low Vol Percentile", minval=1, maxval=99, tooltip="Below this ATR percentile, trading is suppressed as market is too dead/choppy. Increase if you want less trading in quiet.")
hiVolPct        = input.int(85, title="ðŸ”¥ ATR High Vol Percentile", minval=10, maxval=100, tooltip="Above this ATR percentile, system enters HiVol mode: position sizing and regime logic adjust. Lower to trigger HiVol more often.")
sessionHours    = input.session("0830-1500", title="ðŸ•°ï¸ Trading Session", tooltip="Hours during which the system can enter trades. Markets outside this period will NOT trigger entries. Use for US market hours, etc.")
maxDollarRisk   = input.int(750, title="ðŸ’° Max Dollar Risk Per Trade", tooltip="Maximum risk allowed per trade (across all contracts, not per contract). Lower for tighter, smaller trades/accounts. ATR will effect the total loss during volatility")
baseSize        = input.float(1, title="ðŸ› ï¸ Base Contracts", minval=1, tooltip="Minimum contract size used for any new trade. Raise for more aggression, lower for hands-off exposure.")
maxSize         = input.float(3, title="ðŸš€ Max Contracts", minval=1, tooltip="Maximum total contracts held by the strategy (including scaling up). This caps your maximum position size at all times.")
stopATRmult     = input.float(1.7, title="ðŸ›‘ Stop ATR Multiplier", minval=0.2, step=0.01, tooltip="Multiplies ATR for your stop level. Raise for wider stops (fewer whipsaws, bigger risk), lower for tighter stops.")
trailATRmult    = input.float(0.5, title="ðŸ¹ Trail Stop ATR Mult", minval=0.2, step=0.01, tooltip="Multiplier for trailing stop distance. Small = tight trailing, large = more breathing room.")
scaleOutATR     = input.float(0.85, title="ðŸ“ Scale Out at N x ATR", minval=0.4, step=0.01, tooltip="Price distance from entry (in ATR units) to take partial profits (scale out). Raise to target larger wins before scaling out.")

// ========== CORE LOGIC (SAME AS BEFORE; NO DCA) ==========

rolling_sum(src, len) =>
    s = 0.0
    for i = 0 to len - 1
        s += nz(src[i])
    s

percentile(arr, perc) =>
    len = array.size(arr)
    if len == 0
        na
    else
        sorted = array.copy(arr)
        array.sort(sorted, order.ascending)
        idx = math.round((perc / 100) * (len - 1))
        array.get(sorted, idx)

price_x_vol = close * volume
poc_sum   = rolling_sum(price_x_vol, 20)
poc_vol   = rolling_sum(volume, 20)
poc_price = poc_vol > 0 ? poc_sum / poc_vol : na
buy_vol   = rolling_sum(volume * (close > poc_price ? 1 : 0), 12)
sell_vol  = rolling_sum(volume * (close < poc_price ? 1 : 0), 12)
imbalance = (buy_vol - sell_vol) / (buy_vol + sell_vol + 1e-8)
trendUp   = ta.sma(close, 9) > ta.sma(close, 30)
trendDn   = ta.sma(close, 9) < ta.sma(close, 30)
strongImbLong  = imbalance > 0.22
strongImbShort = imbalance < -0.22
rsiVal    = ta.rsi(close, rsiLen)
rsiLong   = rsiVal > 55
rsiShort  = rsiVal < 45
atr       = ta.atr(14)
hiVol     = atr > ta.sma(atr, 60) * 0.8

rawScoreLong   = (trendUp ? 1 : 0) + (strongImbLong ? 1 : 0) + (rsiLong ? 1 : 0) + (hiVol ? 1 : 0)
rawScoreShort  = (trendDn ? 1 : 0) + (strongImbShort ? 1 : 0) + (rsiShort ? 1 : 0) + (hiVol ? 1 : 0)
confNormLong   = rawScoreLong / scoreMax
confNormShort  = rawScoreShort / scoreMax

emaFast = ta.ema(close, 8)
emaSlow = ta.ema(close, 21)
momentumLong  = emaFast - emaSlow
momentumShort = emaSlow - emaFast

var float[] momArrLong = na
if bar_index == 0
    momArrLong := array.new_float()
array.unshift(momArrLong, math.abs(momentumLong))
if array.size(momArrLong) > 100
    array.pop(momArrLong)
momPercLong = percentile(momArrLong, 90)
momNormLong = not na(momPercLong) and momPercLong != 0 ? math.abs(momentumLong) / momPercLong : 0
momNormLong := math.min(momNormLong, 1)

var float[] momArrShort = na
if bar_index == 0
    momArrShort := array.new_float()
array.unshift(momArrShort, math.abs(momentumShort))
if array.size(momArrShort) > 100
    array.pop(momArrShort)
momPercShort = percentile(momArrShort, 90)
momNormShort = not na(momPercShort) and momPercShort != 0 ? math.abs(momentumShort) / momPercShort : 0
momNormShort := math.min(momNormShort, 1)

var float[] atrArr = na
if bar_index == 0
    atrArr := array.new_float()
array.unshift(atrArr, atr)
if array.size(atrArr) > volLookback
    array.pop(atrArr)
lowVolThresh = percentile(atrArr, lowVolPct)
hiVolThresh  = percentile(atrArr, hiVolPct)
isLowVol = not na(lowVolThresh) and atr < lowVolThresh
isHiVol  = not na(hiVolThresh) and atr > hiVolThresh
volNorm = (not na(lowVolThresh) and not na(hiVolThresh)) ? math.max(math.min((atr - lowVolThresh) / (hiVolThresh - lowVolThresh), 1), 0) : 0.5

inSession = not na(time(timeframe.period, sessionHours))

momRevLong  = ta.crossunder(emaFast, emaSlow)
momRevShort = ta.crossover(emaFast, emaSlow)

riskPoints    = atr * stopATRmult
pointValue    = syminfo.pointvalue
maxContractsLong = math.max(1, math.floor(maxDollarRisk / (riskPoints * pointValue)))
maxContractsShort = math.max(1, math.floor(maxDollarRisk / (riskPoints * pointValue)))

canTradeLong  = inSession and not isLowVol and (confNormLong >= confGate) and (momNormLong > momentumGate) and not momRevLong and (rsiVal <= rsiLongCeil)
canTradeShort = inSession and not isLowVol and (confNormShort >= confGate) and (momNormShort > momentumGate) and not momRevShort and (rsiVal >= rsiShortFloor)

float sizeLong = na
float sizeShort = na
if canTradeLong
    regimeWeightLong = confNormLong * momNormLong * volNorm
    newSizeLong = baseSize + (maxSize - baseSize) * regimeWeightLong
    sizeLong := isHiVol ? math.max(1, math.floor(newSizeLong * 0.5)) : math.min(newSizeLong, maxContractsLong)
else
    sizeLong := na
if canTradeShort
    regimeWeightShort = confNormShort * momNormShort * volNorm
    newSizeShort = baseSize + (maxSize - baseSize) * regimeWeightShort
    sizeShort := isHiVol ? math.max(1, math.floor(newSizeShort * 0.5)) : math.min(newSizeShort, maxContractsShort)
else
    sizeShort := na

meanATR = ta.sma(atr, 200)
stdATR  = ta.stdev(atr, 200)
circuitBreaker = atr > (meanATR + 3 * stdATR)
if circuitBreaker
    strategy.close_all(comment="ATR Circuit Breaker")

if canTradeLong and not na(sizeLong) and sizeLong > 0 and strategy.position_size == 0 and not circuitBreaker
    strategy.entry("MMVI Long", strategy.long, qty=math.floor(sizeLong))
    strategy.exit("Long Stop", from_entry="MMVI Long", stop=close - riskPoints)
    strategy.exit("Long Trail", from_entry="MMVI Long", trail_offset=atr * trailATRmult, trail_price=close)
    strategy.exit("Long Scale", from_entry="MMVI Long", qty_percent=50, limit=strategy.position_avg_price + scaleOutATR * atr)

if canTradeShort and not na(sizeShort) and sizeShort > 0 and strategy.position_size == 0 and not circuitBreaker
    strategy.entry("MMVI Short", strategy.short, qty=math.floor(sizeShort))
    strategy.exit("Short Stop", from_entry="MMVI Short", stop=close + riskPoints)
    strategy.exit("Short Trail", from_entry="MMVI Short", trail_offset=atr * trailATRmult, trail_price=close)
    strategy.exit("Short Scale", from_entry="MMVI Short", qty_percent=50, limit=strategy.position_avg_price - scaleOutATR * atr)

if strategy.position_size > 0 and momRevLong
    strategy.close("MMVI Long", qty_percent=50, comment="ReduceLongReversal")
if strategy.position_size < 0 and momRevShort
    strategy.close("MMVI Short", qty_percent=50, comment="ReduceShortReversal")

closeOutTime = (hour == 15 and minute >= 50) or (hour == 16)
if (strategy.position_size != 0 and closeOutTime)
    strategy.close_all(comment="FlatBeforeClose")

// ========== DASHBOARD: Top Right ==========
var table dashboard = na
if na(dashboard)
    dashboard := table.new(position.top_right, 2, 3, bgcolor=color.new(color.black, 95), border_color=color.purple)
table.clear(dashboard, 0, 0)
table.cell(dashboard, 0, 0, '      âš¡Dskyz (DAFE) GENESIS      ', bgcolor=color.purple, text_color=color.black, text_size=size.large)
table.merge_cells(dashboard, 0, 0, 1, 0)

table.cell(dashboard, 0, 1,
     'Score L/S: ' + str.tostring(rawScoreLong) + '/' + str.tostring(rawScoreShort) +
     '\nStatus: ' + (strategy.position_size > 0 ? 'LONG' : strategy.position_size < 0 ? 'SHORT' : 'NEUTRAL') +
     ' | Size: ' + str.tostring(math.abs(strategy.position_size)),
     text_color=(strategy.position_size > 0 ? color.lime : strategy.position_size < 0 ? color.red : color.silver), text_size=size.normal)
table.merge_cells(dashboard, 0, 1, 1, 1)

var float avgWin = 0.0
var float avgLoss = 0.0
var float winLossRatio = 0.0
var float profitFactor = 0.0
if strategy.wintrades > 0
    avgWin := strategy.grossprofit / strategy.wintrades
if strategy.losstrades > 0
    avgLoss := math.abs(strategy.grossloss / strategy.losstrades)
if avgLoss > 0
    winLossRatio := avgWin / avgLoss
if math.abs(strategy.grossloss) > 0
    profitFactor := strategy.grossprofit / math.abs(strategy.grossloss)

var int streak = 0
if bar_index == 0
    streak := 0
won_last = strategy.closedtrades > nz(strategy.closedtrades[1]) and strategy.wintrades > nz(strategy.wintrades[1])
lost_last = strategy.closedtrades > nz(strategy.closedtrades[1]) and strategy.wintrades < nz(strategy.wintrades[1])
streak := won_last ? nz(streak[1]) + 1 : lost_last ? nz(streak[1]) - 1 : nz(streak[1])
string streak_emoji = streak >= 3 ? 'ðŸ”¥' : streak <= -3 ? 'â„ï¸' : 'â—'
win_pct = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades : na
win_pct_display = na(win_pct) ? 0 : win_pct * 100
win_color = win_pct_display > 50 ? color.lime : color.red

get_progress(pct) =>
    nBars = 10
    full = math.round(pct * 0.10)
    empty = nBars - full
    str.repeat('â–ˆ', full) + str.repeat('â–‘', empty)

table.cell(dashboard, 0, 2,
     'Total Trades: ' + str.tostring(strategy.closedtrades) +
     ' | Net P/L: ' + str.tostring(strategy.netprofit, '0.##') +
     '\nWin %: ' + (na(win_pct) ? 'N/A' : str.tostring(win_pct_display, '#.##') + '% ' + get_progress(win_pct_display)) +
     ' | # of Wins: ' + str.tostring(strategy.wintrades) +
     '\nStreak: ' + streak_emoji + str.tostring(streak),
     text_color=win_color, text_size=size.normal)
table.merge_cells(dashboard, 0, 2, 1, 2)


// ========== WATERMARK: Bottom Right ==========
var table infoTable = na
if na(infoTable)
    infoTable := table.new(position.bottom_right, 1, 2, bgcolor=color.new(color.black, 90), border_color=color.new(color.purple, 80), border_width=1)
table.clear(infoTable, 0, 0)
table.cell(infoTable, 0, 0, 'âš¡ Dskyz (DAFE) Trading Systems', text_color=color.rgb(200, 200, 255), text_size=size.normal)

float mLong = na(momNormLong) ? 0 : momNormLong
float mShort = na(momNormShort) ? 0 : momNormShort
regime = strategy.position_size > 0 ? 1 : strategy.position_size < 0 ? -1 : 0
float bar_momentum =
     regime == 1     ? mLong
   : regime == -1    ? mShort
   : math.max(mLong, mShort)
bar_momentum := math.max(0, math.min(1, bar_momentum))
int bar_length = 20
int full_bars = math.round(bar_momentum * bar_length)
int empty_bars = bar_length - full_bars
string momentum_bar_str = str.repeat('â–ˆ', full_bars) + str.repeat('â–‘', empty_bars)

color momentum_color = bar_momentum > 0.8 ? color.lime : bar_momentum > 0.6 ? color.green : bar_momentum > 0.3 ? color.yellow : bar_momentum > 0.1 ? color.orange : color.red
table.cell(infoTable, 0, 1, "Momentum [" + momentum_bar_str + "] " + str.tostring(bar_momentum, "#.##"), text_color=momentum_color, text_size=size.normal)