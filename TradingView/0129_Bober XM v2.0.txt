//@version=6
// ================================================================================================================
// ₿ober XM v2.0 - Dual Channel Trading Strategy for TradingView by Cryptobeat © buble_lab
// ================================================================================================================
//
// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//
// ===============================================================================================================

strategy('Bober XM v2.0', overlay = true, initial_capital = 1000, commission_type = strategy.commission.percent, commission_value = 0.075, default_qty_type = strategy.cash, default_qty_value = 100)


// Comment inputs for webhooks
enter_Long_Comment = input.string(defval = 'ENTER-LONG', tooltip = 'Your personal Enter Long signal bot settings for webhook integration', group = 'Webhook Configuration')
enter_Short_Comment = input.string(defval = 'ENTER-SHORT', tooltip = 'Your personal Enter Short signal bot settings for webhook integration', group = 'Webhook Configuration')
exit_All_Comment = input.string(defval = 'EXIT-ALL', tooltip = 'Your personal Exit All signal bot settings for webhook integration', group = 'Webhook Configuration')

// Webhook configuration inputs
leverage = input.float(1, title = 'Leverage', minval = 1.0, step = 0.1, tooltip = 'Multiplier for position size sent to the exchange via webhook', group = 'Webhook Configuration')
reduceOnly = input.bool(true, title = 'Reduce Only', tooltip = 'When enabled, orders can only reduce your position, not increase it', group = 'Webhook Configuration')
placeConditionalOrdersOnExchange = input.bool(false, title = 'Place Conditional Orders On Exchange', tooltip = 'When enabled, stop-loss and take-profit orders are placed on the exchange instead of locally', group = 'Webhook Configuration')

// INPUTS - General
showRiskReward = input(true, title = 'Show Risk/Reward Area', tooltip = 'Display visual areas for stop-loss and take-profit zones on the chart', group = 'General')
takeLong = input(true, title = 'Enter Long Position', tooltip = 'Enable or disable long positions', group = 'General')
takeShort = input(true, title = 'Enter Short Position', tooltip = 'Enable or disable short positions', group = 'General')

// Entry Condition Source Inputs
entryLongTimeframe = input.string("current", title = "Long Entry Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for long entry signals", group = "Entry Conditions")
entryLongPriceType = input.string("hl2", title = "Long Entry Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for long entry signals", group = "Entry Conditions")

entryShortTimeframe = input.string("current", title = "Short Entry Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for short entry signals", group = "Entry Conditions")
entryShortPriceType = input.string("hl2", title = "Short Entry Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for short entry signals", group = "Entry Conditions")

// Multi-Timeframe Settings
group_mtf = "Multi-Timeframe Settings"
mtfEnabled = input.bool(false, title = "Enable Multi-Timeframe Analysis", tooltip = "When enabled, allows using data from higher timeframes", group = group_mtf)
mtf1 = input.timeframe("15", title = "Timeframe 1", tooltip = "First higher timeframe (e.g., 15 for 15min)", group = group_mtf)
mtf2 = input.timeframe("240", title = "Timeframe 2", tooltip = "Second higher timeframe (e.g., 240 for 4h)", group = group_mtf)


// INPUTS - Backtest Period
testStartYear = input.int(2025, 'Backtest Start Year', minval = 2000, maxval = 2025, tooltip = 'Start year for backtesting period', group = 'Backtest')
testStartMonth = input.int(1, 'Backtest Start Month', minval = 1, maxval = 12, tooltip = 'Start month for backtesting period', group = 'Backtest')
testStartDay = input.int(1, 'Backtest Start Day', minval = 1, maxval = 31, tooltip = 'Start day for backtesting period', group = 'Backtest')
testEndYear = input.int(2026, 'Backtest End Year', minval = 2000, maxval = 2100, tooltip = 'End year for backtesting period', group = 'Backtest')
testEndMonth = input.int(12, 'Backtest End Month', minval = 1, maxval = 12, tooltip = 'End month for backtesting period', group = 'Backtest')
testEndDay = input.int(31, 'Backtest End Day', minval = 1, maxval = 31, tooltip = 'End day for backtesting period', group = 'Backtest')


// Risk Management Inputs
takeProfitPercent = input.float(2.4, title = 'Take Profit %', minval = 1.0, step = 0.1, tooltip = 'Percentage distance for take profit target (used only in webhook messages)', group = 'Risk Management')
trailActivationPercent = input.float(1.4, title = 'Trailing Stop Activation %', minval = 0.1, step = 0.1, tooltip = 'Profit percentage required before trailing stop activates', group = 'Risk Management')
stopLossPercent = input.float(1.5, title = 'Stop-Loss %', minval = 0.01, step = 0.1, tooltip = 'Percentage distance for stop loss from entry price', group = 'Risk Management')
trailingStopPercent = input.float(1, title = 'Trailing Stop %', minval = 0.01, step = 0.1, tooltip = 'Percentage distance for trailing stop from highest/lowest price', group = 'Risk Management')
riskPercent = input.float(50.0, title = 'Risk % of Equity', minval = 0.01, step = 0.1, tooltip = 'Percentage of account equity to risk per trade (controls position sizing)', group = 'Risk Management')
// Risk-Reward configuration
riskRewardRatio = input.float(1.9, title = 'Risk-Reward Ratio', minval = 0.1, step = 0.1, tooltip = 'Multiplier for take profit distance based on stop loss distance', group = 'Risk Management')

// Channel Type Selection
channelType = input.string('MLMA', title = 'Channel Type', options = ['Keltner', 'MLMA'], tooltip = 'Choose between traditional Keltner Channels or Machine Learning Moving Average for signal generation', group = 'Channel Selection')

// Entry Strategy Selection
// Choose between different Channel entry strategies
entryStrategy = input.string('Breakout', title = 'Entry Strategy', options = ['Breakout', 'Pullback', 'Mean Reversion'], tooltip = 'Breakout: Enter when price breaks channel; Pullback: Enter on pullback to middle band; Mean Reversion: Enter at channel extremes', group = 'Entry Strategy Selection')

// MLMA (Machine Learning Moving Average) Inputs - Long
ml_long_Window = input.int(16, title = 'Window Size', minval = 5, tooltip = 'Historical window size for MLMA calculation (long positions)', group = 'MLMA Settings - Long')
ml_long_Forecast = input.int(3, title = 'Forecast Length', minval = 1, tooltip = 'Number of bars to forecast ahead (long positions)', group = 'MLMA Settings - Long')
ml_long_Sigma = input.float(0.43, title = 'Noise Parameter', minval = 0.01, step = 0.01, tooltip = 'Controls smoothness of the MLMA prediction (long positions)', group = 'MLMA Settings - Long')
ml_long_Mult = input.float(0.6, title = 'Band Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for upper/lower band distance from MLMA (long positions)', group = 'MLMA Settings - Long')

// MLMA Source with Multi-Timeframe support - Long
ml_long_Timeframe = input.string("current", title = "MA Source Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for MLMA calculation (long positions)", group = "MLMA Settings - Long")
ml_long_PriceType = input.string("low", title = "MA Source Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for MLMA calculation (long positions)", group = "MLMA Settings - Long")

ml_long_trend_Timeframe = input.string("current", title = "Trend Source Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for trend determination (long positions)", group = "MLMA Settings - Long")
ml_long_trend_PriceType = input.string("close", title = "Trend Source Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for trend determination (long positions)", group = "MLMA Settings - Long")

ml_long_ma_type = input.string('SMA', title = 'Moving Average Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'HMA'], tooltip = 'Type of moving average to use for MLMA calculations (long positions)', group = 'MLMA Settings - Long')
ml_long_BullCss = input.color(color.green, title = 'Bullish Color', tooltip = 'Color for bullish MLMA line (long positions)', group = 'MLMA Settings - Long')
ml_long_UpCss = input.color(color.new(color.green, 80), title = 'Upper Band Color', tooltip = 'Color for upper MLMA band (long positions)', group = 'MLMA Settings - Long')
ml_long_DnCss = input.color(color.new(color.green, 80), title = 'Lower Band Color', tooltip = 'Color for lower MLMA band (long positions)', group = 'MLMA Settings - Long')

// MLMA (Machine Learning Moving Average) Inputs - Short
ml_short_Window = input.int(16, title = 'Window Size', minval = 5, tooltip = 'Historical window size for MLMA calculation (short positions)', group = 'MLMA Settings - Short')
ml_short_Forecast = input.int(3, title = 'Forecast Length', minval = 1, tooltip = 'Number of bars to forecast ahead (short positions)', group = 'MLMA Settings - Short')
ml_short_Sigma = input.float(0.44, title = 'Noise Parameter', minval = 0.01, step = 0.01, tooltip = 'Controls smoothness of the MLMA prediction (short positions)', group = 'MLMA Settings - Short')
ml_short_Mult = input.float(0.5, title = 'Band Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for upper/lower band distance from MLMA (short positions)', group = 'MLMA Settings - Short')

// MLMA Source with Multi-Timeframe support - Short
ml_short_Timeframe = input.string("current", title = "MA Source Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for MLMA calculation (short positions)", group = "MLMA Settings - Short")
ml_short_PriceType = input.string("high", title = "MA Source Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for MLMA calculation (short positions)", group = "MLMA Settings - Short")

ml_short_trend_Timeframe = input.string("current", title = "Trend Source Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for trend determination (short positions)", group = "MLMA Settings - Short")
ml_short_trend_PriceType = input.string("low", title = "Trend Source Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for trend determination (short positions)", group = "MLMA Settings - Short")

ml_short_ma_type = input.string('EMA', title = 'Moving Average Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'HMA'], tooltip = 'Type of moving average to use for MLMA calculations (short positions)', group = 'MLMA Settings - Short')
ml_short_BearCss = input.color(color.red, title = 'Bearish Color', tooltip = 'Color for bearish MLMA line (short positions)', group = 'MLMA Settings - Short')
ml_short_UpCss = input.color(color.new(color.red, 80), title = 'Upper Band Color', tooltip = 'Color for upper MLMA band (short positions)', group = 'MLMA Settings - Short')
ml_short_DnCss = input.color(color.new(color.red, 80), title = 'Lower Band Color', tooltip = 'Color for lower MLMA band (short positions)', group = 'MLMA Settings - Short')

// Additional Entry Filters
// These filters can be used to further refine entry conditions
useRsiFilter = input.bool(true, title = 'Use RSI Filter', tooltip = 'When enabled, only enters trades when RSI is not in overbought/oversold zones', group = 'Entry Filters')
rsiPeriod = input.int(15, title = 'RSI Period', minval = 1, tooltip = 'Number of bars used for RSI calculation', group = 'Entry Filters')
rsiOverbought = input.int(71, title = 'RSI Overbought Level', minval = 50, maxval = 100, tooltip = 'RSI level above which long entries are blocked', group = 'Entry Filters')
rsiOversold = input.int(23, title = 'RSI Oversold Level', minval = 0, maxval = 50, tooltip = 'RSI level below which short entries are blocked', group = 'Entry Filters')

// RSI Multi-Timeframe settings
rsiTimeframe = input.string("current", title = "RSI Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for RSI calculation", group = "Entry Filters")
rsiPriceType = input.string("ohlc4", title = "RSI Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for RSI calculation", group = "Entry Filters")

useVolatilityFilter = input.bool(false, title = 'Use Volatility Filter', tooltip = 'When enabled, only enters trades when volatility is below threshold', group = 'Entry Filters')
volatilityType = input.string('ATR', title = 'Volatility Measure', options = ['ATR', 'Standard Deviation'], tooltip = 'Method used to measure market volatility', group = 'Entry Filters')
volatilityPeriod = input.int(8, title = 'Volatility Period', minval = 1, tooltip = 'Number of bars used for volatility calculation', group = 'Entry Filters')
volatilityMaType = input.string('SMA', title = 'Volatility MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'HMA'], tooltip = 'Type of moving average to use for volatility average calculation', group = 'Entry Filters')
volatilityThreshold = input.float(1.3, title = 'Volatility Threshold', minval = 0.1, step = 0.1, tooltip = 'Maximum allowed volatility compared to average (ratio)', group = 'Entry Filters')

// Volatility multi-timeframe support
volatility_timeframe = input.string("current", title = "Volatility Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for volatility calculation", group = "Entry Filters")
volatility_price_type = input.string("ohlc4", title = "Volatility Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for volatility calculation", group = "Entry Filters")

useBollingerFilter = input.bool(false, title = 'Use Bollinger Band Filter', tooltip = 'When enabled, uses Bollinger Bands as additional filter for entries', group = 'Entry Filters')
bbLength = input.int(20, title = 'BB Length', minval = 1, tooltip = 'Number of bars used for Bollinger Bands calculation', group = 'Entry Filters')
bbMaType = input.string('SMA', title = 'Bollinger MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'HMA'], tooltip = 'Type of moving average to use for Bollinger Bands middle band', group = 'Entry Filters')
bbDeviation = input.float(2.0, title = 'Bollinger Deviation', minval = 0.1, step = 0.1, tooltip = 'Standard deviation multiplier for Bollinger Band width', group = 'Entry Filters')

// Bollinger Band source with multi-timeframe support
bb_timeframe = input.string("current", title = "BB Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for Bollinger Bands calculation", group = "Entry Filters")
bb_price_type = input.string("close", title = "BB Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for Bollinger Bands calculation", group = "Entry Filters")

// Volume Filter - Prevents trading during low activity periods
useVolumeFilter = input.bool(true, title = 'Use Volume Filter', tooltip = 'When enabled, only enters trades when volume is above threshold', group = 'Entry Filters')
volumeThreshold = input.float(0.4, title = 'Volume Threshold (x Average)', minval = 0.1, step = 0.1, tooltip = 'Minimum allowed volume compared to average (ratio)', group = 'Entry Filters')
volumePeriod = input.int(5, title = 'Volume Average Period', minval = 1, tooltip = 'Number of bars used for volume average calculation', group = 'Entry Filters')
volumeMaType = input.string('HMA', title = 'Volume MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'HMA'], tooltip = 'Type of moving average to use for volume average calculation', group = 'Entry Filters')
volumeSmoothing = input.int(18, title = 'Volume Smoothing Period', minval = 1, tooltip = 'Smoothing period for current volume to reduce noise', group = 'Entry Filters')

// KEMAD (Kalman EMA Distance) Filter
useKemadFilter = input.bool(true, title = 'Use KEMAD Filter', tooltip = 'When enabled, uses Kalman filtered EMA distance for entry filtering', group = 'Entry Filters')

// KEMAD multi-timeframe support
kemad_timeframe = input.string("current", title = "KEMAD Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for KEMAD filter calculation", group = "Entry Filters")
kemad_price_type = input.string("close", title = "KEMAD Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for KEMAD filter calculation", group = "Entry Filters")
kemadProcessNoise = input.float(0.35, title = 'Process Noise', step = 0.01, tooltip = 'Kalman filter process noise parameter (lower = smoother)', group = 'Entry Filters')
kemadMeasurementNoise = input.float(24, title = 'Measurement Noise', tooltip = 'Kalman filter measurement noise parameter (higher = less reactive to price changes)', group = 'Entry Filters')
kemadFilterOrder = input.int(6, title = 'Filter Order', minval = 1, tooltip = 'Kalman filter order (higher = more smoothing)', group = 'Entry Filters')
kemadAtrLength = input.int(8, title = 'ATR Length', minval = 1, tooltip = 'Length for ATR calculation in KEMAD', group = 'Entry Filters')
kemadSmaPeriod = input.int(14, title = 'SMA Period', minval = 1, tooltip = 'Period for SMA calculation in KEMAD', group = 'Entry Filters')
kemadUpperMult = input.float(2, title = 'Upper Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for upper band distance (long entry signal)', group = 'Entry Filters')
kemadLowerMult = input.float(2.7, title = 'Lower Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for lower band distance (short entry signal)', group = 'Entry Filters')
showKemadVisuals = input.bool(true, title = 'Show KEMAD Visuals', tooltip = 'When enabled, displays KEMAD visualization on the chart', group = 'Entry Filters')


// Entry Strategy Descriptions:
//
// Breakout (Momentum Strategy)
// - Enters long when price breaks above the upper Keltner Channel in an uptrend
// - Enters short when price breaks below the lower Keltner Channel in a downtrend
// - Advantages: Works well in strong trending markets, captures explosive moves
// - Disadvantages: Can lead to late entries after significant price movement, higher risk
// - Best market conditions: Strong trends, high volatility environments
//
// Pullback (Trend-Following with Better Entry)
// - Enters long when price pulls back to the middle band (EMA) in an established uptrend
// - Enters short when price pulls back to the middle band (EMA) in an established downtrend
// - Advantages: Better entry prices than breakout strategy, lower risk, higher probability
// - Disadvantages: May miss explosive moves, requires patience for pullbacks
// - Best market conditions: Established trends with regular pullbacks
//
// Mean Reversion (Counter-Trend Strategy)
// - Enters long when price touches the lower band in an overall uptrend
// - Enters short when price touches the upper band in an overall downtrend
// - Advantages: Best entry prices, highest probability setups, lowest risk
// - Disadvantages: Requires strong trend confirmation to avoid false signals
// - Best market conditions: Range-bound markets or established trends with clear support/resistance



// INPUTS - Debug Period
// showDebugLabels = input.bool(false, title="Show Debug Labels", tooltip="When enabled, displays debug information on the chart for troubleshooting", group="Debug")
// debugStartYear = input.int(2025, "Debug Start Year", minval=2000, maxval=2025, tooltip="Start year for debug period", group="Debug")
// debugStartMonth = input.int(1, "Debug Start Month", minval=1, maxval=12, tooltip="Start month for debug period", group="Debug")
// debugStartDay = input.int(1, "Debug Start Day", minval=1, maxval=31, tooltip="Start day for debug period", group="Debug")
// debugStartHour = input.int(0, "Debug Start Hour", minval=0, maxval=23, tooltip="Start hour for debug period", group="Debug")
// debugStartMinute = input.int(0, "Debug Start Minute", minval=0, maxval=59, tooltip="Start minute for debug period", group="Debug")
// debugEndYear = input.int(2025, "Debug End Year", minval=2000, maxval=2025, tooltip="End year for debug period", group="Debug")
// debugEndMonth = input.int(1, "Debug End Month", minval=1, maxval=12, tooltip="End month for debug period", group="Debug")
// debugEndDay = input.int(2, "Debug End Day", minval=1, maxval=31, tooltip="End day for debug period", group="Debug")
// debugEndHour = input.int(23, "Debug End Hour", minval=0, maxval=23, tooltip="End hour for debug period", group="Debug")
// debugEndMinute = input.int(59, "Debug End Minute", minval=0, maxval=59, tooltip="End minute for debug period", group="Debug")

// TP/SL Inputs
longSlType = input.string('Disabled', title = 'Stop-Loss Type:', options = ['ATR', '%', 'PIP', 'Disabled'], tooltip = 'Method to calculate stop loss for long positions', group = 'Keltner Stop-Loss / Long')
longTpType = input.string('Disabled', title = 'Take-Profit Type:', options = ['ATR', '%', 'PIP', 'Disabled'], tooltip = 'Method to calculate take profit for long positions', group = 'Keltner Take-Profit / Long')
longSlAtrMultip = input.float(2.0, step = 0.1, minval = 0.1, title = 'ATR Multiplier:', tooltip = 'Multiplier for ATR when using ATR-based stop loss (long)', group = 'Keltner Stop-Loss / Long')
longSlPerc = input.float(3.0, step = 0.1, minval = 0.01, title = 'Stop-Loss %:', tooltip = 'Percentage distance for stop loss from entry price (long)', group = 'Keltner Stop-Loss / Long') / 100
longTpPipSize = input.float(10.0, step = 0.1, minval = 0.01, title = 'PIP Size:', tooltip = 'Number of pips for take profit from entry price (long)', group = 'Keltner Take-Profit / Long') * syminfo.mintick * 10

shortSlType = input.string('Disabled', title = 'Stop-Loss Type:', options = ['ATR', '%', 'PIP', 'Disabled'], tooltip = 'Method to calculate stop loss for short positions', group = 'Keltner Stop-Loss / Short')
shortTpType = input.string('Disabled', title = 'Take-Profit Type:', options = ['ATR', '%', 'PIP', 'Disabled'], tooltip = 'Method to calculate take profit for short positions', group = 'Keltner Take-Profit / Short')
shortSlAtrMultip = input.float(2.0, step = 0.1, minval = 0.1, title = 'ATR Multiplier:', tooltip = 'Multiplier for ATR when using ATR-based stop loss (short)', group = 'Keltner Stop-Loss / Short')
shortSlPerc = input.float(3.0, step = 0.1, minval = 0.01, title = 'Stop-Loss %:', tooltip = 'Percentage distance for stop loss from entry price (short)', group = 'Keltner Stop-Loss / Short') / 100
shortSlPipSize = input.float(10.0, step = 0.1, minval = 0.01, title = 'PIP Size:', tooltip = 'Number of pips for stop loss from entry price (short)', group = 'Keltner Stop-Loss / Short') * syminfo.mintick * 10
shortTpAtrMultip = input.float(2.0, step = 0.1, minval = 0.1, title = 'ATR Multiplier:', tooltip = 'Multiplier for ATR when using ATR-based take profit (short)', group = 'Keltner Take-Profit / Short')
shortTpPerc = input.float(3.0, step = 0.1, minval = 0.01, title = 'Take-Profit %:', tooltip = 'Percentage distance for take profit from entry price (short)', group = 'Keltner Take-Profit / Short') / 100
shortTpPipSize = input.float(10.0, step = 0.1, minval = 0.01, title = 'PIP Size:', tooltip = 'Number of pips for take profit from entry price (short)', group = 'Keltner Take-Profit / Short') * syminfo.mintick * 10


// Keltner Channel Inputs - Long
kc_long_length_basis = input.int(20, title = 'Long Channel Basis EMA Length', minval = 1, tooltip = 'Number of bars used for middle line EMA calculation (long)', group = 'Main Entry Condition - Keltner Channel (Long)')
kc_long_length_atr = input.int(14, title = 'Long Channel ATR EMA Length (DI Length)', minval = 1, tooltip = 'Number of bars used for ATR calculation in Keltner Channel (long)', group = 'Main Entry Condition - Keltner Channel (Long)')
kc_long_mult = input.float(1.5, title = 'Long Channel Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for channel width - higher values create wider channels (long)', group = 'Main Entry Condition - Keltner Channel (Long)')
// Multi-timeframe long channel source
kc_long_timeframe = input.string("current", title = "Long Channel Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for Keltner Channel calculation (long)", group = "Main Entry Condition - Keltner Channel (Long)")
kc_long_price_type = input.string("close", title = "Long Channel Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for Keltner Channel calculation (long)", group = "Main Entry Condition - Keltner Channel (Long)")

// Keltner Channel Inputs - Short
kc_short_length_basis = input.int(20, title = 'Short Channel Basis EMA Length', minval = 1, tooltip = 'Number of bars used for middle line EMA calculation (short)', group = 'Main Entry Condition - Keltner Channel (Short)')
kc_short_length_atr = input.int(14, title = 'Short Channel ATR EMA Length (DI Length)', minval = 1, tooltip = 'Number of bars used for ATR calculation in Keltner Channel (short)', group = 'Main Entry Condition - Keltner Channel (Short)')
kc_short_mult = input.float(1.5, title = 'Short Channel Multiplier', minval = 0.1, step = 0.1, tooltip = 'Multiplier for channel width - higher values create wider channels (short)', group = 'Main Entry Condition - Keltner Channel (Short)')
// Multi-timeframe short channel source
kc_short_timeframe = input.string("current", title = "Short Channel Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for Keltner Channel calculation (short)", group = "Main Entry Condition - Keltner Channel (Short)")
kc_short_price_type = input.string("close", title = "Short Channel Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for Keltner Channel calculation (short)", group = "Main Entry Condition - Keltner Channel (Short)")

// Pivot Point SuperTrend Inputs
pivPo_timeframe = input.string("current", title = "SuperTrend Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for Pivot Point SuperTrend calculation", group = "Secondary Condition - Pivot Point SuperTrend")
pivPo_price_type = input.string("hl2", title = "SuperTrend Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for Pivot Point SuperTrend calculation", group = "Secondary Condition - Pivot Point SuperTrend")
pivPoPeriod1 = input.int(defval = 25, title = 'Pivot Point Period', minval = 1, maxval = 50, tooltip = 'Number of bars to look left/right for pivot points', group = 'Secondary Condition - Pivot Point SuperTrend')
pivPoFactor1 = input.float(defval = 2.2, title = 'ATR Factor', minval = 1, step = 0.1, tooltip = 'Multiplier for ATR in SuperTrend calculation', group = 'Secondary Condition - Pivot Point SuperTrend')
pivPoAtrPeriod1 = input.int(defval = 41, title = 'ATR Period', minval = 1, tooltip = 'Number of bars used for ATR calculation in SuperTrend', group = 'Secondary Condition - Pivot Point SuperTrend')


// Other Inputs
useWmaVisual = input.bool(false, title = 'Show WMA Line', tooltip = 'When enabled, displays the Entry Confirmation WMA line on the chart', group = 'General')
useEntConfWMA = input.bool(true, title = 'Activate Entry Confirmation', tooltip = 'When enabled, requires price to be on correct side of WMA for entry', group = 'Entry Confirmation - WMA')
wmaPeriod1 = input.int(15, title = 'Period', tooltip = 'Number of bars used for WMA calculation', group = 'Entry Confirmation - WMA')

// WMA with multi-timeframe support
wma_timeframe = input.string("current", title = "WMA Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for WMA calculation", group = "Entry Confirmation - WMA")
wma_price_type = input.string("ohlc4", title = "WMA Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for WMA calculation", group = "Entry Confirmation - WMA")

// OBV with multi-timeframe support
obv_timeframe = input.string("current", title = "OBV Timeframe", options = ["current", "mtf1", "mtf2"], tooltip = "Select timeframe for OBV calculation", group = "Main Exit Condition - OBV")
obv_price_type = input.string("ohlc4", title = "OBV Price Type", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4"], tooltip = "Select price type for OBV calculation", group = "Main Exit Condition - OBV")
obvMaType1 = input.string(title = 'MA Type', defval = 'HMA', options = ['SMA', 'EMA', 'WMA', 'RMA', 'VWMA', 'HMA'], tooltip = 'Type of moving average to apply to OBV', group = 'Main Exit Condition - OBV')
obvMaPeriod1 = input.int(title = 'Period', defval = 22, minval = 1, maxval = 3000, tooltip = 'Number of bars used for OBV moving average', group = 'Main Exit Condition - OBV')

useExtConfADX = input.bool(true, title = 'Activate Exit Confirmation', tooltip = 'When enabled, requires ADX confirmation for exits', group = 'Exit Confirmation - ADX')
adxTrendTh1 = input.int(35, title = 'ADX Threshold', minval = 1, tooltip = 'Minimum ADX value required for exit confirmation', group = 'Exit Confirmation - ADX')
adxLengthSig1 = input.int(60, title = 'ADX Smoothing', minval = 1, tooltip = 'Smoothing period for ADX calculation', group = 'Exit Confirmation - ADX')
adxLength1 = input.int(60, title = 'DI Length', minval = 1, tooltip = 'Period for +DI and -DI calculation', group = 'Exit Confirmation - ADX')

useAdxFilter = input.bool(true, title = 'Use Momentum Filter', tooltip = 'When enabled, requires ADX momentum confirmation for entries', group = 'ADX Based Momentum Filter')
applyDiFilter = input.bool(true, title = 'Apply D+/D- Check', tooltip = 'When enabled, requires appropriate DI line dominance for direction confirmation', group = 'ADX Based Momentum Filter')
lensigDmi = input.int(34, title = 'ADX Smoothing', minval = 1, maxval = 50, tooltip = 'Smoothing period for ADX calculation in momentum filter', group = 'ADX Based Momentum Filter')
lenDmi = input.int(28, minval = 1, title = 'DI Length', tooltip = 'Period for +DI and -DI calculation in momentum filter', group = 'ADX Based Momentum Filter')
adxTh = input.int(19, title = 'Minimum ADX Threshold', tooltip = 'Minimum ADX value required for momentum confirmation', group = 'ADX Based Momentum Filter')


// Declare multi-timeframe variables
var float mtf1_open = na
var float mtf1_high = na
var float mtf1_low = na
var float mtf1_close = na
var float mtf2_open = na
var float mtf2_high = na
var float mtf2_low = na
var float mtf2_close = na

// Helper function to get price data of any type from any timeframe
getTimeframePrice(timeframe, priceType) =>
    float o = timeframe == "mtf1" ? mtf1_open : timeframe == "mtf2" ? mtf2_open : open
    float h = timeframe == "mtf1" ? mtf1_high : timeframe == "mtf2" ? mtf2_high : high
    float l = timeframe == "mtf1" ? mtf1_low : timeframe == "mtf2" ? mtf2_low : low
    float c = timeframe == "mtf1" ? mtf1_close : timeframe == "mtf2" ? mtf2_close : close

    if priceType == "open"
        o
    else if priceType == "high"
        h
    else if priceType == "low"
        l
    else if priceType == "close"
        c
    else if priceType == "hl2"
        (h + l) / 2
    else if priceType == "hlc3"
        (h + l + c) / 3
    else if priceType == "ohlc4"
        (o + h + l + c) / 4
    else
        c // Default to close

// Create multi-timeframe price sources for all indicators
// Entry source variables
entrySourceLong = getTimeframePrice(entryLongTimeframe, entryLongPriceType)
entrySourceShort = getTimeframePrice(entryShortTimeframe, entryShortPriceType)

// MLMA source variables
ml_long_Src = getTimeframePrice(ml_long_Timeframe, ml_long_PriceType)
ml_long_trend_src = getTimeframePrice(ml_long_trend_Timeframe, ml_long_trend_PriceType)
ml_short_Src = getTimeframePrice(ml_short_Timeframe, ml_short_PriceType)
ml_short_trend_src = getTimeframePrice(ml_short_trend_Timeframe, ml_short_trend_PriceType)

// Keltner Channel source variables
kc_long_source = getTimeframePrice(kc_long_timeframe, kc_long_price_type)
kc_short_source = getTimeframePrice(kc_short_timeframe, kc_short_price_type)

// Pivot Point SuperTrend source
pivPoSource1 = getTimeframePrice(pivPo_timeframe, pivPo_price_type)

// WMA and OBV sources
wmaSource1 = getTimeframePrice(wma_timeframe, wma_price_type)
obvSource1 = getTimeframePrice(obv_timeframe, obv_price_type)

// Bollinger Bands source
bbSource = getTimeframePrice(bb_timeframe, bb_price_type)

// KEMAD source
kemadPriceSource = getTimeframePrice(kemad_timeframe, kemad_price_type)

// Volatility source
volatilitySource = getTimeframePrice(volatility_timeframe, volatility_price_type)

// VARIABLES
var float longEntryPrice = na
var float longTp = na
var float longStop = na
var float shortEntryPrice = na
var float shortTp = na
var float shortStop = na
var int persistent_position = 0 // 0 = no position, 1 = long, -1 = short
var float trackEnterPrice = na
var float accountEquity = strategy.equity
var float entry_amount = 0.0
var int trackedPivotTrend = 0 // Track pivot supertrend: 0 = initial, 1 = bullish, -1 = bearish
var bool pivotTrendChanged = false // Flag to track if the trend has changed
var float prevLongTrailOffset = na
var float prevShortTrailOffset = na
var float trailUpdateThreshold = 0.5  // Percentage change threshold to trigger update (0.5%)

// Multi-timeframe data cache - updated on each bar
mtf1_open := request.security(syminfo.tickerid, mtf1, open, barmerge.gaps_off, barmerge.lookahead_off)
mtf1_high := request.security(syminfo.tickerid, mtf1, high, barmerge.gaps_off, barmerge.lookahead_off)
mtf1_low := request.security(syminfo.tickerid, mtf1, low, barmerge.gaps_off, barmerge.lookahead_off)
mtf1_close := request.security(syminfo.tickerid, mtf1, close, barmerge.gaps_off, barmerge.lookahead_off)
mtf2_open := request.security(syminfo.tickerid, mtf2, open, barmerge.gaps_off, barmerge.lookahead_off)
mtf2_high := request.security(syminfo.tickerid, mtf2, high, barmerge.gaps_off, barmerge.lookahead_off)
mtf2_low := request.security(syminfo.tickerid, mtf2, low, barmerge.gaps_off, barmerge.lookahead_off)
mtf2_close := request.security(syminfo.tickerid, mtf2, close, barmerge.gaps_off, barmerge.lookahead_off)

// CALCULATIONS
// Backtest Period
testStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0)
testEnd = timestamp(testEndYear, testEndMonth, testEndDay, 23, 59)
inTestPeriod = time >= testStart and time <= testEnd

// Update multi-timeframe data cache
if mtfEnabled
    mtf1_open := request.security(syminfo.tickerid, mtf1, open, barmerge.gaps_off, barmerge.lookahead_off)
    mtf1_high := request.security(syminfo.tickerid, mtf1, high, barmerge.gaps_off, barmerge.lookahead_off)
    mtf1_low := request.security(syminfo.tickerid, mtf1, low, barmerge.gaps_off, barmerge.lookahead_off)
    mtf1_close := request.security(syminfo.tickerid, mtf1, close, barmerge.gaps_off, barmerge.lookahead_off)

    mtf2_open := request.security(syminfo.tickerid, mtf2, open, barmerge.gaps_off, barmerge.lookahead_off)
    mtf2_high := request.security(syminfo.tickerid, mtf2, high, barmerge.gaps_off, barmerge.lookahead_off)
    mtf2_low := request.security(syminfo.tickerid, mtf2, low, barmerge.gaps_off, barmerge.lookahead_off)
    mtf2_close := request.security(syminfo.tickerid, mtf2, close, barmerge.gaps_off, barmerge.lookahead_off)


// Debug Period
// debugStart = timestamp(debugStartYear, debugStartMonth, debugStartDay, debugStartHour, debugStartMinute)
// debugEnd = timestamp(debugEndYear, debugEndMonth, debugEndDay, debugEndHour, debugEndMinute)
// inDebugPeriod = time >= debugStart and time <= debugEnd

// ****************************************MLMA code***************************************************************
// Enhanced RBF kernel function with configurable scale factor
rbf(x1, x2, l, scale = 1.0) =>
    math.exp(-math.pow(x1 - x2, 2) / (2.0 * math.pow(l, 2))) * scale

// Improved Kernel matrix computation with distance weighting
kernel_matrix(X1, X2, l, distance_weight = true) =>
    km = matrix.new<float>(X1.size(), X2.size())

    i = 0
    for x1 in X1
        j = 0
        for x2 in X2
            // Apply distance-based weight scaling for better emphasis on recent data
            scale = distance_weight ? 1.0 + 0.5 * math.exp(-math.abs(i - j) / (X1.size() * 0.5)) : 1.0
            rbf_val = rbf(x1, x2, l, scale)
            km.set(i, j, rbf_val)
            j := j + 1
            j
        i := i + 1
        i

    km

// MLMA variables - Long
var float ml_long_out = na
var float ml_long_upper = na
var float ml_long_lower = na
var int ml_long_trend = 0
// Helper function to calculate moving average based on type
get_ma(source, length, ma_type) =>
    switch ma_type
        'SMA' => ta.sma(source, length)
        'EMA' => ta.ema(source, length)
        'WMA' => ta.wma(source, length)
        'VWMA' => ta.vwma(source, length)
        'RMA' => ta.rma(source, length)
        'HMA' => ta.hma(source, length)
        => ta.sma(source, length) // Default to SMA
var float ml_long_prev_error = 0.0  // Track prediction error for adaptive learning

// MLMA variables - Short
var float ml_short_out = na
var float ml_short_upper = na
var float ml_short_lower = na
var int ml_short_trend = 0
var float ml_short_prev_error = 0.0  // Track prediction error for adaptive learning

// Kernel Setup - Long
var identity_long = matrix.new<int>(ml_long_Window, ml_long_Window, 0)
var array<float> K_row_long = na

// Kernel Setup - Short
var identity_short = matrix.new<int>(ml_short_Window, ml_short_Window, 0)
var array<float> K_row_short = na

if barstate.isfirst
    // Long MLMA setup
    xtrain_long = array.new<int>(0)
    xtest_long = array.new<int>(0)

    // Build identity matrix and training array for long
    for i = 0 to ml_long_Window - 1 by 1
        for j = 0 to ml_long_Window - 1 by 1
            identity_long.set(i, j, i == j ? 1 : 0)

        xtrain_long.push(i)

    // Build testing array for long with expanded forecast horizon
    for i = 0 to ml_long_Window + ml_long_Forecast - 1 by 1
        xtest_long.push(i)

    // Compute kernel matrices for long with noise regularization
    s_long = identity_long.mult(ml_long_Sigma * ml_long_Sigma)
    Ktrain_long = kernel_matrix(xtrain_long, xtrain_long, ml_long_Window, true).sum(s_long)
    K_inv_long = Ktrain_long.pinv()
    K_star_long = kernel_matrix(xtrain_long, xtest_long, ml_long_Window, true)
    K_row_long := K_star_long.transpose().mult(K_inv_long).row(ml_long_Window + ml_long_Forecast - 1)

    // Short MLMA setup
    xtrain_short = array.new<int>(0)
    xtest_short = array.new<int>(0)

    // Build identity matrix and training array for short
    for i = 0 to ml_short_Window - 1 by 1
        for j = 0 to ml_short_Window - 1 by 1
            identity_short.set(i, j, i == j ? 1 : 0)

        xtrain_short.push(i)

    // Build testing array for short with expanded forecast horizon
    for i = 0 to ml_short_Window + ml_short_Forecast - 1 by 1
        xtest_short.push(i)

    // Compute kernel matrices for short with noise regularization
    s_short = identity_short.mult(ml_short_Sigma * ml_short_Sigma)
    Ktrain_short = kernel_matrix(xtrain_short, xtrain_short, ml_short_Window, true).sum(s_short)
    K_inv_short = Ktrain_short.pinv()
    K_star_short = kernel_matrix(xtrain_short, xtest_short, ml_short_Window, true)
    K_row_short := K_star_short.transpose().mult(K_inv_short).row(ml_short_Window + ml_short_Forecast - 1)
    K_row_short

// Moving Average calculation with selected type for adaptive weighting - Long
mean_long = get_ma(ml_long_Src, ml_long_Window, ml_long_ma_type)

// Moving Average calculation with selected type for adaptive weighting - Short
mean_short = get_ma(ml_short_Src, ml_short_Window, ml_short_ma_type)

// Adaptive volatility estimation with selected MA type
vol_weight_long = math.min(1.5, math.max(0.5, ta.atr(14) / get_ma(ta.atr(14), 50, ml_long_ma_type)))
vol_weight_short = math.min(1.5, math.max(0.5, ta.atr(14) / get_ma(ta.atr(14), 50, ml_short_ma_type)))

// Get end point estimate - Long with adaptive learning
if bar_index > ml_long_Window and channelType == 'MLMA'
    dotprod_long = 0.
    // Dot product between last K_row and training data with recency bias
    for i = 0 to ml_long_Window - 1 by 1
        // Apply recency weighting - more recent data has higher influence
        recency_weight = 1.0 + 0.5 * (ml_long_Window - 1 - i) / ml_long_Window
        dotprod_long := dotprod_long + K_row_long.get(i) * (ml_long_Src[ml_long_Window - 1 - i] - mean_long) * recency_weight
        dotprod_long

    // Apply adaptive correction based on previous prediction error
    error_correction = not na(ml_long_out[1]) ? (ml_long_Src[1] - ml_long_out[1]) * 0.2 : 0

    // Output with error correction
    ml_long_out := dotprod_long + mean_long + error_correction

    // Store current prediction error for next bar
    ml_long_prev_error := not na(ml_long_out) ? ml_long_Src - ml_long_out : 0

    // Calculate bands with volatility adaptation using selected MA type
    mae_long = get_ma(math.abs(ml_long_Src - ml_long_out), ml_long_Window, ml_long_ma_type) * ml_long_Mult * vol_weight_long
    ml_long_upper := ml_long_out + mae_long
    ml_long_lower := ml_long_out - mae_long

    // Improved trend determination with momentum consideration using selected source
    ml_long_trend := ml_long_trend_src > ml_long_upper and ml_long_out > ml_long_out[1] ? 1 :
                     ml_long_trend_src < ml_long_lower and ml_long_out < ml_long_out[1] ? 0 :
                     ml_long_trend
    ml_long_trend

// Get end point estimate - Short with adaptive learning
if bar_index > ml_short_Window and channelType == 'MLMA'
    dotprod_short = 0.
    // Dot product between last K_row and training data with recency bias
    for i = 0 to ml_short_Window - 1 by 1
        // Apply recency weighting - more recent data has higher influence
        recency_weight = 1.0 + 0.5 * (ml_short_Window - 1 - i) / ml_short_Window
        dotprod_short := dotprod_short + K_row_short.get(i) * (ml_short_Src[ml_short_Window - 1 - i] - mean_short) * recency_weight
        dotprod_short

    // Apply adaptive correction based on previous prediction error
    error_correction = not na(ml_short_out[1]) ? (ml_short_Src[1] - ml_short_out[1]) * 0.2 : 0

    // Output with error correction
    ml_short_out := dotprod_short + mean_short + error_correction

    // Store current prediction error for next bar
    ml_short_prev_error := not na(ml_short_out) ? ml_short_Src - ml_short_out : 0

    // Calculate bands with volatility adaptation using selected MA type
    mae_short = get_ma(math.abs(ml_short_Src - ml_short_out), ml_short_Window, ml_short_ma_type) * ml_short_Mult * vol_weight_short
    ml_short_upper := ml_short_out + mae_short
    ml_short_lower := ml_short_out - mae_short

    // Improved trend determination with momentum consideration using selected source
    ml_short_trend := ml_short_trend_src > ml_short_upper and ml_short_out > ml_short_out[1] ? 1 :
                      ml_short_trend_src < ml_short_lower and ml_short_out < ml_short_out[1] ? 0 :
                      ml_short_trend
    ml_short_trend

// Keltner Channel - Long
kc_long_basis = ta.ema(kc_long_source, kc_long_length_basis)
kc_long_tr = ta.tr(true)
kc_long_atr = ta.ema(kc_long_tr, kc_long_length_atr)
kc_long_upper = kc_long_basis + kc_long_atr * kc_long_mult
kc_long_lower = kc_long_basis - kc_long_atr * kc_long_mult

// Keltner Channel - Short
kc_short_basis = ta.ema(kc_short_source, kc_short_length_basis)
kc_short_tr = ta.tr(true)
kc_short_atr = ta.ema(kc_short_tr, kc_short_length_atr)
kc_short_upper = kc_short_basis + kc_short_atr * kc_short_mult
kc_short_lower = kc_short_basis - kc_short_atr * kc_short_mult

// Combined channel values based on selection
float channel_long_basis = channelType == 'Keltner' ? kc_long_basis : ml_long_out
float channel_long_upper = channelType == 'Keltner' ? kc_long_upper : ml_long_upper
float channel_long_lower = channelType == 'Keltner' ? kc_long_lower : ml_long_lower

float channel_short_basis = channelType == 'Keltner' ? kc_short_basis : ml_short_out
float channel_short_upper = channelType == 'Keltner' ? kc_short_upper : ml_short_upper
float channel_short_lower = channelType == 'Keltner' ? kc_short_lower : ml_short_lower

// Pivot Point SuperTrend with selectable source
float ph1 = ta.pivothigh(pivPoSource1, pivPoPeriod1, pivPoPeriod1)
float pl1 = ta.pivotlow(pivPoSource1, pivPoPeriod1, pivPoPeriod1)
var float pivPoCenter1 = na
float pivPoLastpp1 = not na(ph1) ? ph1 : not na(pl1) ? pl1 : na
if not na(pivPoLastpp1)
    if na(pivPoCenter1)
        pivPoCenter1 := pivPoLastpp1
        pivPoCenter1
    else
        pivPoCenter1 := (pivPoCenter1 * 2 + pivPoLastpp1) / 3
        pivPoCenter1
pivPoUp1 = pivPoCenter1 - pivPoFactor1 * ta.atr(pivPoAtrPeriod1)
pivPoDn1 = pivPoCenter1 + pivPoFactor1 * ta.atr(pivPoAtrPeriod1)
float pivPoTUp1 = na
float pivPoTDown1 = na
pivPoTrend1 = 0
pivPoTUp1 := close[1] > pivPoTUp1[1] ? math.max(pivPoUp1, pivPoTUp1[1]) : pivPoUp1
pivPoTDown1 := close[1] < pivPoTDown1[1] ? math.min(pivPoDn1, pivPoTDown1[1]) : pivPoDn1
pivPoTrend1 := close > pivPoTDown1[1] ? 1 : close < pivPoTUp1[1] ? -1 : nz(pivPoTrend1[1], 1)
ppstVal1 = pivPoTrend1 == 1 ? pivPoTUp1 : pivPoTDown1

// Update tracked pivot trend and detect changes
pivotTrendChanged := trackedPivotTrend != 0 and trackedPivotTrend != pivPoTrend1
if pivPoTrend1 != 0 // Only update if we have a valid trend
    trackedPivotTrend := pivPoTrend1
    trackedPivotTrend

// WMA, OBV, ADX
wmaValue1 = ta.wma(wmaSource1, wmaPeriod1)
// Original OBV calculation with configurable source
obvValue1 = ta.cum(math.sign(ta.change(obvSource1)) * volume)
// Calculate OBV MA based on selected MA type
obvMaValue1 = switch obvMaType1
    'SMA' => ta.sma(obvValue1, obvMaPeriod1)
    'EMA' => ta.ema(obvValue1, obvMaPeriod1)
    'WMA' => ta.wma(obvValue1, obvMaPeriod1)
    'RMA' => ta.rma(obvValue1, obvMaPeriod1)
    'VWMA' => ta.vwma(obvValue1, obvMaPeriod1)
    'HMA' => ta.hma(obvValue1, obvMaPeriod1)
    => ta.sma(obvValue1, obvMaPeriod1) // Default to HMA
upAdx1 = ta.change(high)
downAdx1 = -ta.change(low)
plusDM1 = na(upAdx1) ? na : upAdx1 > downAdx1 and upAdx1 > 0 ? upAdx1 : 0
minusDM1 = na(downAdx1) ? na : downAdx1 > upAdx1 and downAdx1 > 0 ? downAdx1 : 0
trurAdx1 = ta.rma(ta.tr, adxLength1)
plusAdx1 = fixnan(100 * ta.rma(plusDM1, adxLength1) / trurAdx1)
minusAdx1 = fixnan(100 * ta.rma(minusDM1, adxLength1) / trurAdx1)
sumAdx1 = plusAdx1 + minusAdx1
adxValue1 = 100 * ta.rma(math.abs(plusAdx1 - minusAdx1) / (sumAdx1 == 0 ? 1 : sumAdx1), adxLengthSig1)

// ADX Momentum Filter Variables
upDmi = ta.change(high)
downDmi = -ta.change(low)
plusDM = na(upDmi) ? na : upDmi > downDmi and upDmi > 0 ? upDmi : 0
minusDM = na(downDmi) ? na : downDmi > upDmi and downDmi > 0 ? downDmi : 0
trurDmi = ta.rma(ta.tr, lenDmi)
DIPlus = fixnan(100 * ta.rma(plusDM, lenDmi) / trurDmi)
DIMinus = fixnan(100 * ta.rma(minusDM, lenDmi) / trurDmi)
sumDmi = DIPlus + DIMinus
adxValue = 100 * ta.rma(math.abs(DIPlus - DIMinus) / (sumDmi == 0 ? 1 : sumDmi), lensigDmi)

// // Day Filters
// isInDayRange = (dayofweek == dayofweek.monday and tradeMonday) or (dayofweek == dayofweek.tuesday and tradeTuesday) or (dayofweek == dayofweek.wednesday and tradeWednesday) or (dayofweek == dayofweek.thursday and tradeThursday) or (dayofweek == dayofweek.friday and tradeFriday) or (dayofweek == dayofweek.saturday and tradeSaturday) or (dayofweek == dayofweek.sunday and tradeSunday)

// Webhook message creation
createWebhookMessage(comment, stopPrice, takeProfitPrice, positionSize, trailOffset = 0) =>
    // Convert trail offset in ticks to percentage for webhook
    float trailPercentage = trailOffset > 0 ? trailOffset * syminfo.mintick / close * 100 : trailingStopPercent
    '{"code":"' + comment + '","orderType":"market","amountPerTradeType":"quote","amountPerTrade":' + str.tostring(positionSize) + ',"leverage":' + str.tostring(leverage) + ',"takeProfits":[{"priceDeviation":' + str.tostring(takeProfitPercent / 100) + '}],"stopLoss":{"priceDeviation":' + str.tostring(stopLossPercent / 100) + '},"trailingStop":{"activation":' + str.tostring(trailActivationPercent / 100) + ',"execute":' + str.tostring(trailPercentage / 100) + '},"reduceOnly":' + (reduceOnly ? 'true' : 'false') + ',"placeConditionalOrdersOnExchange":' + (placeConditionalOrdersOnExchange ? 'true' : 'false') + '}'


// ADX Momentum Filter Results
diFilterLong = applyDiFilter ? DIPlus > DIMinus : true
longMomentumFilterResult = useAdxFilter ? diFilterLong and adxValue > adxTh : true
diFilterShort = applyDiFilter ? DIMinus > DIPlus : true
shortMomentumFilterResult = useAdxFilter ? diFilterShort and adxValue > adxTh : true

// RSI Calculation and Filter with multi-timeframe support
rsiValue = ta.rsi(mtfEnabled ? getTimeframePrice(rsiTimeframe, rsiPriceType) : getTimeframePrice("current", rsiPriceType), rsiPeriod)
rsiFilterLong = useRsiFilter ? rsiValue < rsiOverbought : true
rsiFilterShort = useRsiFilter ? rsiValue > rsiOversold : true

// Volatility Calculation and Filter with selectable MA type
volatilityValue = volatilityType == 'ATR' ? ta.atr(volatilityPeriod) : ta.stdev(volatilitySource, volatilityPeriod)
volatilityAvg = get_ma(volatilityValue, volatilityPeriod, volatilityMaType)
volatilityRatio = volatilityValue / volatilityAvg
volatilityFilterResult = useVolatilityFilter ? volatilityRatio < volatilityThreshold : true

// Bollinger Bands Calculation and Filter with selectable MA type
bbMiddle = get_ma(bbSource, bbLength, bbMaType)
bbDev = ta.stdev(bbSource, bbLength) * bbDeviation
bbUpper = bbMiddle + bbDev
bbLower = bbMiddle - bbDev
bbFilterLong = useBollingerFilter ? close < bbUpper : true
bbFilterShort = useBollingerFilter ? close > bbLower : true

// Volume Filter Calculation with selectable MA type
volumeValue = get_ma(volume, volumeSmoothing, volumeMaType)
volumeAvg = get_ma(volume, volumePeriod, volumeMaType)
volumeRatio = volumeValue / volumeAvg
volumeFilterResult = useVolumeFilter ? volumeRatio > volumeThreshold : true

// KEMAD (Kalman EMA Distance) Filter Implementation
// This implementation is derived from QuantumResearch's KEMAD indicator
// Credit to QuantumResearch for the original Kalman filter concept and implementation
// Kalman filter state variables
var float[] kemadStateEstimate = array.new_float(kemadFilterOrder, na)
var float[] kemadErrorCovariance = array.new_float(kemadFilterOrder, 100.0)

// Initialize Kalman filter arrays if first bar
if barstate.isfirst
    for i = 0 to kemadFilterOrder - 1
        array.set(kemadStateEstimate, i, kemadPriceSource)
        array.set(kemadErrorCovariance, i, 1.0)

// Kalman filter implementation
kemadFilteredPrice = float(na)
if useKemadFilter
    // Prediction Step
    predictedStateEstimate = array.new_float(kemadFilterOrder)
    predictedErrorCovariance = array.new_float(kemadFilterOrder)
    for i = 0 to kemadFilterOrder - 1
        array.set(predictedStateEstimate, i, array.get(kemadStateEstimate, i))
        array.set(predictedErrorCovariance, i, array.get(kemadErrorCovariance, i) + kemadProcessNoise)

    // Update Step
    kalmanGain = array.new_float(kemadFilterOrder)
    for i = 0 to kemadFilterOrder - 1
        kg = array.get(predictedErrorCovariance, i) / (array.get(predictedErrorCovariance, i) + kemadMeasurementNoise)
        array.set(kalmanGain, i, kg)
        array.set(kemadStateEstimate, i, array.get(predictedStateEstimate, i) + kg * (kemadPriceSource - array.get(predictedStateEstimate, i)))
        array.set(kemadErrorCovariance, i, (1 - kg) * array.get(predictedErrorCovariance, i))

    kemadFilteredPrice := array.get(kemadStateEstimate, 0)
    kemadFilteredPrice

// KEMAD bands calculation
kemadEma = ta.ema(not na(kemadFilteredPrice) ? kemadFilteredPrice : kemadPriceSource, kemadSmaPeriod)
kemadAtr = ta.atr(kemadAtrLength)
kemadUpperBand = kemadEma + kemadUpperMult * kemadAtr
kemadLowerBand = kemadEma - kemadLowerMult * kemadAtr

// KEMAD state tracking for visualization
var int kemadState = 0 // 1 = bullish (long), -1 = bearish (short), 0 = neutral
var color kemadTrendColor = na
color kemad_up_color = color.rgb(0, 255, 186)
color kemad_down_color = color.rgb(255, 0, 157)

if useKemadFilter
    // Determine KEMAD state
    if kemadPriceSource > kemadUpperBand
        kemadState := 1
        kemadTrendColor := kemad_up_color
    else if kemadPriceSource < kemadLowerBand
        kemadState := -1
        kemadTrendColor := kemad_down_color

// KEMAD filter results
kemadLongFilter = useKemadFilter ? kemadState == 1 : true
kemadShortFilter = useKemadFilter ? kemadState == -1 : true

// Combined Filter Results with KEMAD
longFilterResult = longMomentumFilterResult and rsiFilterLong and volatilityFilterResult and bbFilterLong and volumeFilterResult and kemadLongFilter
shortFilterResult = shortMomentumFilterResult and rsiFilterShort and volatilityFilterResult and bbFilterShort and volumeFilterResult and kemadShortFilter

// ENTRY CONDITIONS - Based on selected strategy and channel type
bool longCondBreakout = false
bool shortCondBreakout = false
bool longCondPullback = false
bool shortCondPullback = false
bool longCondMeanReversion = false
bool shortCondMeanReversion = false

if channelType == 'Keltner'
    // Breakout Strategy with Keltner
    longCondBreakout := ta.crossover(entrySourceLong, kc_long_upper) and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondBreakout := ta.crossunder(entrySourceShort, kc_short_lower) and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)

    // Pullback Strategy with Keltner
    longCondPullback := ta.crossover(entrySourceLong, kc_long_basis) and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondPullback := ta.crossunder(entrySourceShort, kc_short_basis) and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)

    // Mean Reversion Strategy with Keltner
    longCondMeanReversion := ta.crossover(entrySourceLong, kc_long_lower) and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondMeanReversion := ta.crossunder(entrySourceShort, kc_short_upper) and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)
    shortCondMeanReversion
    // MLMA-based conditions
else // Breakout Strategy with MLMA
    longCondBreakout := ta.crossover(entrySourceLong, ml_long_upper) and ml_long_trend == 1 and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondBreakout := ta.crossunder(entrySourceShort, ml_short_lower) and ml_short_trend == 0 and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)

    // Pullback Strategy with MLMA
    longCondPullback := ta.crossover(entrySourceLong, ml_long_out) and ml_long_trend == 1 and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondPullback := ta.crossunder(entrySourceShort, ml_short_out) and ml_short_trend == 0 and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)

    // Mean Reversion Strategy with MLMA
    longCondMeanReversion := ta.crossover(entrySourceLong, ml_long_lower) and ml_long_trend == 1 and trackedPivotTrend == 1 and (useEntConfWMA ? entrySourceLong > wmaValue1 : true)
    shortCondMeanReversion := ta.crossunder(entrySourceShort, ml_short_upper) and ml_short_trend == 0 and trackedPivotTrend == -1 and (useEntConfWMA ? entrySourceShort < wmaValue1 : true)
    shortCondMeanReversion

// Select the appropriate entry conditions based on the strategy
bool longCond = false
bool shortCond = false

if entryStrategy == 'Breakout'
    longCond := longCondBreakout
    shortCond := shortCondBreakout
    shortCond
else if entryStrategy == 'Pullback'
    longCond := longCondPullback
    shortCond := shortCondPullback
    shortCond
else // Mean Reversion
    longCond := longCondMeanReversion
    shortCond := shortCondMeanReversion
    shortCond

// Entry/Exit Hooks
var bool bull_enter = false
var bool bear_enter = false
bull_enter := longCond and takeLong and longFilterResult and strategy.equity > 0 and strategy.position_size <= 0
bear_enter := shortCond and takeShort and shortFilterResult and strategy.equity > 0 and strategy.position_size >= 0

// EXIT CONDITIONS
// Combine OBV-based exit conditions with pivot trend reversal
bool obvExitLong = ta.crossunder(obvValue1, obvMaValue1) and (useExtConfADX ? plusAdx1 < minusAdx1 : true)
bool obvExitShort = ta.crossover(obvValue1, obvMaValue1) and (useExtConfADX ? plusAdx1 > minusAdx1 : true)

// Pivot trend reversal exit conditions
bool pivotExitLong = pivPoTrend1 == -1 and pivPoTrend1[1] == 1
bool pivotExitShort = pivPoTrend1 == 1 and pivPoTrend1[1] == -1

// Combined exit conditions (either OBV or pivot trend reversal can trigger an exit)
exitLongCond = (obvExitLong or pivotExitLong) and strategy.position_size > 0
exitShortCond = (obvExitShort or pivotExitShort) and strategy.position_size < 0

// Track closed trades to detect trailing stop exits
var int lastCheckedTradeId = 0
var bool trailStopTriggered = false

// STRATEGY EXECUTION
if inTestPeriod
    // Check if new trades have been closed
    if strategy.closedtrades > lastCheckedTradeId
        // Loop through all new closed trades
        for i = lastCheckedTradeId to strategy.closedtrades - 1 by 1
            lastComment = strategy.closedtrades.exit_comment(i)
            // Check if the trade was closed by a trailing stop
            if str.contains(lastComment, 'Trail')
                trailStopTriggered := true
                trailStopTriggered
                // if showDebugLabels
                //     label.new(bar_index, high, "Exited via Trail Stop #" + str.tostring(i), color=color.red, style=label.style_label_down)

        // Update the last checked trade ID
        lastCheckedTradeId := strategy.closedtrades
        lastCheckedTradeId

    // Send EXIT-ALL alert if a trailing stop was triggered
    if trailStopTriggered
        // Calculate position size in base currency for webhook
        float exitPositionSizeInBaseCurrency = entry_amount * close

        string signal_alert_exit_all = createWebhookMessage(exit_All_Comment, 0, 0, exitPositionSizeInBaseCurrency)
        alert(signal_alert_exit_all, alert.freq_once_per_bar_close)
        trailStopTriggered := false
        trailStopTriggered

    if exitLongCond
        // Calculate position size in base currency for webhook
        float exitPositionSizeInBaseCurrency = entry_amount * close

        // Generate webhook alert message for exit all
        string signal_alert_exit_all = createWebhookMessage(exit_All_Comment, 0, 0, exitPositionSizeInBaseCurrency)
        alert(signal_alert_exit_all, alert.freq_once_per_bar_close)

        strategy.close('long', comment = 'CLOSE LONG')
        persistent_position := 0
        persistent_position

    if exitShortCond
        // Calculate position size in base currency for webhook
        float exitPositionSizeInBaseCurrency = entry_amount * close

        // Generate webhook alert message for exit all
        string signal_alert_exit_all = createWebhookMessage(exit_All_Comment, 0, 0, exitPositionSizeInBaseCurrency)
        alert(signal_alert_exit_all, alert.freq_once_per_bar_close)

        strategy.close('short', comment = 'CLOSE SHORT')
        persistent_position := 0
        persistent_position

    // Entry Logic with Risk-Based Position Sizing
    if bull_enter and inTestPeriod
        // Close any existing positions without sending an exit alert (the entry alert is sufficient)
        strategy.close('short', comment = 'Exit Short for Long Entry')
        trackEnterPrice := close[0]
        persistent_position := 1

        // Calculate risk amount based on account equity and risk percentage
        float riskAmount = accountEquity * (riskPercent / 100.0)

        // Calculate stop loss price
        float stopLossPrice = trackEnterPrice * (1 - stopLossPercent / 100.0)

        // Calculate risk distance - distance from entry to stop loss
        // Option 1: Fixed percentage-based stop loss
        float riskDistFixed = trackEnterPrice - stopLossPrice

        // Option 2: Dynamic stop loss based on selected channel
        float riskDistDynamic = trackEnterPrice - (channelType == 'Keltner' ? kc_long_lower : ml_long_lower)

        // Use the smaller of the two risk distances for safer position sizing
        float riskDistLong = math.min(riskDistFixed, riskDistDynamic)

        // Calculate position size based on risk
        float shares = 0.0
        if riskDistLong > 0
            shares := math.floor(riskAmount / riskDistLong) // Use floor instead of round to be more conservative
            shares

        // Limit position size to prevent excessive leverage
        float maxPositionValue = accountEquity * 0.95 // Maximum 95% of equity
        float positionValue = shares * trackEnterPrice

        if positionValue > maxPositionValue
            shares := math.floor(maxPositionValue / trackEnterPrice)
            shares

        // Ensure minimum position size of 1 if entering a trade
        if shares < 1 and shares > 0
            shares := 1
            shares

        entry_amount := shares

        // Calculate actual risk percentage based on final position size
        float actualRiskAmount = shares * riskDistLong
        float actualRiskPercent = actualRiskAmount / accountEquity * 100

// // Add debug label for position sizing calculations
// if showDebugLabels
//     label.new(bar_index, high + atrValue * 2,
//              "Long Entry Position Sizing:\nEquity: " + str.tostring(accountEquity, "#.##") +
//              "\nTarget Risk %: " + str.tostring(riskPercent, "#.##") +
//              "\nTarget Risk Amount: " + str.tostring(riskAmount, "#.##") +
//              "\nEntry Price: " + str.tostring(trackEnterPrice, "#.####") +
//              "\nStop Loss: " + str.tostring(stopLossPrice, "#.####") +
//              "\nKC Lower: " + str.tostring(kc_long_lower, "#.####") +
//              "\nRisk Distance: " + str.tostring(riskDistLong, "#.####") +
//              "\nShares: " + str.tostring(shares, "#") +
//              "\nPosition Value: " + str.tostring(shares * trackEnterPrice, "#.##") +
//              "\nActual Risk Amount: " + str.tostring(actualRiskAmount, "#.##") +
//              "\nActual Risk %: " + str.tostring(actualRiskPercent, "#.##"),
//              color=color.new(color.blue, 20), textcolor=color.white, size=size.normal)

        // Calculate take profit using the configurable risk-reward ratio
        float riskDistance = trackEnterPrice - stopLossPrice
        float takeProfitPrice = trackEnterPrice + riskDistance * riskRewardRatio // Configurable risk-reward ratio

        // Calculate trail offset for webhook
        float longOffsetInCurrency = close - (channelType == 'Keltner' ? kc_long_lower : ml_long_lower)
        if longOffsetInCurrency < 0
            longOffsetInCurrency := 0
            longOffsetInCurrency
        float longTrailOffsetInTicks = longOffsetInCurrency / syminfo.mintick

        // Calculate position size in base currency for webhook (amount to buy/sell)
        float positionSizeInBaseCurrency = shares * trackEnterPrice

        // Generate webhook alert message for long entry
        string signal_alert_long = createWebhookMessage(enter_Long_Comment, stopLossPrice, takeProfitPrice, positionSizeInBaseCurrency, longTrailOffsetInTicks)
        alert(signal_alert_long, alert.freq_once_per_bar_close)

        strategy.entry(id = 'long', direction = strategy.long, qty = shares, comment = 'Long Entry')

    if bear_enter and inTestPeriod
        // Close any existing positions without sending an exit alert (the entry alert is sufficient)
        strategy.close('long', comment = 'Exit Long for Short Entry')
        trackEnterPrice := close[0]
        persistent_position := -1

        // Calculate risk amount based on account equity and risk percentage
        float riskAmount = accountEquity * (riskPercent / 100.0)

        // Calculate stop loss price
        float stopLossPrice = trackEnterPrice * (1 + stopLossPercent / 100.0)

        // Calculate risk distance - distance from entry to stop loss
        // Option 1: Fixed percentage-based stop loss
        float riskDistFixed = stopLossPrice - trackEnterPrice

        // Option 2: Dynamic stop loss based on selected channel
        // Note: For shorts, we use the upper band
        float riskDistDynamic = (channelType == 'Keltner' ? kc_short_upper : ml_short_upper) - trackEnterPrice

        // Use the smaller of the two risk distances for safer position sizing
        float riskDistShort = math.min(riskDistFixed, riskDistDynamic)

        // Ensure minimum risk distance to prevent division by very small numbers
        float minRiskDist = trackEnterPrice * 0.001 // Minimum 0.1% risk distance
        riskDistShort := math.max(riskDistShort, minRiskDist)

        // Calculate position size based on risk
        float shares = 0.0
        if riskDistShort > 0
            shares := math.floor(riskAmount / riskDistShort) // Use floor instead of round to be more conservative
            shares

        // Limit position size to prevent excessive leverage
        float maxPositionValue = accountEquity * 0.95 // Maximum 95% of equity
        float positionValue = shares * trackEnterPrice

        if positionValue > maxPositionValue
            shares := math.floor(maxPositionValue / trackEnterPrice)
            shares

        // Ensure minimum position size of 1 if entering a trade
        if shares < 1 and shares > 0
            shares := 1
            shares

        entry_amount := shares

        // Calculate actual risk percentage based on final position size
        float actualRiskAmount = shares * riskDistShort
        float actualRiskPercent = actualRiskAmount / accountEquity * 100

// // Add debug label for position sizing calculations
// if showDebugLabels
//     label.new(bar_index, low - atrValue * 2,
//              "Short Entry Position Sizing:\nEquity: " + str.tostring(accountEquity, "#.##") +
//              "\nTarget Risk %: " + str.tostring(riskPercent, "#.##") +
//              "\nTarget Risk Amount: " + str.tostring(riskAmount, "#.##") +
//              "\nEntry Price: " + str.tostring(trackEnterPrice, "#.####") +
//              "\nStop Loss: " + str.tostring(stopLossPrice, "#.####") +
//              "\nKC Upper: " + str.tostring(kc_short_upper, "#.####") +
//              "\nRisk Distance: " + str.tostring(riskDistShort, "#.####") +
//              "\nShares: " + str.tostring(shares, "#") +
//              "\nPosition Value: " + str.tostring(shares * trackEnterPrice, "#.##") +
//              "\nActual Risk Amount: " + str.tostring(actualRiskAmount, "#.##") +
//              "\nActual Risk %: " + str.tostring(actualRiskPercent, "#.##"),
//              color=color.new(color.red, 20), textcolor=color.white, size=size.normal)

        // Calculate take profit using the configurable risk-reward ratio
        float riskDistance = stopLossPrice - trackEnterPrice
        float takeProfitPrice = trackEnterPrice - riskDistance * riskRewardRatio // Configurable risk-reward ratio

        // Calculate trail offset for webhook
        float shortOffsetInCurrency = (channelType == 'Keltner' ? kc_short_upper : ml_short_upper) - close
        if shortOffsetInCurrency < 0
            shortOffsetInCurrency := 0
            shortOffsetInCurrency
        float shortTrailOffsetInTicks = shortOffsetInCurrency / syminfo.mintick

        // Calculate position size in base currency for webhook (amount to buy/sell)
        float positionSizeInBaseCurrency = shares * trackEnterPrice

        // Generate webhook alert message for short entry
        string signal_alert_short = createWebhookMessage(enter_Short_Comment, stopLossPrice, takeProfitPrice, positionSizeInBaseCurrency, shortTrailOffsetInTicks)
        alert(signal_alert_short, alert.freq_once_per_bar_close)

        strategy.entry(id = 'short', direction = strategy.short, qty = shares, comment = 'Short Entry')

    // STOP/TRAILED STOP WITH TAKE PROFIT (Sync trail stop triggered by the strategy to webhook
    // LONG side
    if strategy.position_size > 0 and inTestPeriod
        float entryPrice = strategy.position_avg_price
        float stopLossPrice = entryPrice * (1 - stopLossPercent / 100.0)
        // Calculate take profit using the configurable risk-reward ratio
        float riskDistance = entryPrice - stopLossPrice
        float takeProfitPrice = entryPrice + riskDistance * riskRewardRatio

        float offsetInCurrency = close - (channelType == 'Keltner' ? kc_long_lower : ml_long_lower)
        if offsetInCurrency < 0
            offsetInCurrency := 0
            offsetInCurrency
        float trailOffsetInTicks = offsetInCurrency / syminfo.mintick


        // Update previous trail offset value
        prevLongTrailOffset := trailOffsetInTicks

        // Calculate trail points (activation) and trail offset (execution)
        float trailPoints = trailActivationPercent / 100 * close / syminfo.mintick // Convert activation percentage to ticks

        // Include take profit in the exit strategy to match JSON alert
        strategy.exit('Long SL/TP/Trail', 'long', limit = takeProfitPrice, stop = stopLossPrice, trail_points = trailPoints, trail_offset = trailOffsetInTicks)

    // SHORT side
    if strategy.position_size < 0 and inTestPeriod
        float entryPrice = strategy.position_avg_price
        float stopLossPrice = entryPrice * (1 + stopLossPercent / 100.0)
        // Calculate take profit using the configurable risk-reward ratio
        float riskDistance = stopLossPrice - entryPrice
        float takeProfitPrice = entryPrice - riskDistance * riskRewardRatio

        float offsetInCurrency = (channelType == 'Keltner' ? kc_short_upper : ml_short_upper) - close
        if offsetInCurrency < 0
            offsetInCurrency := 0
            offsetInCurrency
        float trailOffsetInTicks = offsetInCurrency / syminfo.mintick


        // Update previous trail offset value
        prevShortTrailOffset := trailOffsetInTicks

        // Calculate trail points (activation) and trail offset (execution)
        float trailPoints = trailActivationPercent / 100 * close / syminfo.mintick // Convert activation percentage to ticks

        // Include take profit in the exit strategy to match JSON alert
        strategy.exit('Short SL/TP/Trail', 'short', limit = takeProfitPrice, stop = stopLossPrice, trail_points = trailPoints, trail_offset = trailOffsetInTicks)

// Debug Labels
// if showDebugLabels and inDebugPeriod
//     // Entry condition components
//     string entryText = "Long Entry Source: " + str.tostring(entrySourceLong, "#.####") +
//                       "\nShort Entry Source: " + str.tostring(entrySourceShort, "#.####") +
//                       "\nKC Long Upper: " + str.tostring(kc_long_upper, "#.####") +
//                       "\nKC Short Lower: " + str.tostring(kc_short_lower, "#.####") +
//                       "\nPivot Trend: " + str.tostring(pivPoTrend1) +
//                       "\nPrev Pivot Trend: " + str.tostring(pivPoTrend1[1]) +
//                       "\nTracked Pivot Trend: " + str.tostring(trackedPivotTrend) +
//                       "\nPivot Trend Changed: " + str.tostring(pivotTrendChanged) +
//                       "\nWMA Value: " + str.tostring(wmaValue1, "#.####") +
//                       "\nLong Cond: " + str.tostring(longCond) +
//                       "\nShort Cond: " + str.tostring(shortCond) +
//                       "\nRSI: " + str.tostring(rsiValue, "#.##") +
//                       "\nVolatility Ratio: " + str.tostring(volatilityRatio, "#.##") +
//                       "\nBB Upper: " + str.tostring(bbUpper, "#.####") +
//                       "\nBB Lower: " + str.tostring(bbLower, "#.####") +
//                       "\nVolume: " + str.tostring(volume, "#") +
//                       "\nVolume MA: " + str.tostring(volumeMA, "#") +
//                       "\nVolume Ratio: " + str.tostring(volumeRatio, "#.##") +
//                       "\nVolume Filter: " + str.tostring(volumeFilterResult)

// label.new(bar_index, high, entryText, style=label.style_label_down, color=color.new(color.blue, 20), textcolor=color.white, size=size.normal)

// Exit condition components
// string exitText = "OBV: " + str.tostring(obvValue1, "#.####") +
//                  "\nOBV MA: " + str.tostring(obvMaValue1, "#.####") +
//                  "\nPlus DI: " + str.tostring(plusAdx1, "#.##") +
//                  "\nMinus DI: " + str.tostring(minusAdx1, "#.##") +
//                  "\nExit Long Cond: " + str.tostring(exitLongCond) +
//                  "\nExit Short Cond: " + str.tostring(exitShortCond)

// label.new(bar_index, low, exitText, style=label.style_label_up, color=color.new(color.purple, 20), textcolor=color.white, size=size.normal)

// Bar color for KEMAD visualization
barcolor(useKemadFilter and showKemadVisuals ? (kemadState == 1 ? kemad_up_color : kemadState == -1 ? kemad_down_color : na) : na)

// PLOTS
plot(ppstVal1, color = pivPoTrend1 == 1 and nz(pivPoTrend1[1]) == 1 ? #03f803 : pivPoTrend1 == -1 and nz(pivPoTrend1[1]) == -1 ? #e02fd8 : na, linewidth = 2, title = 'Pivot Point SuperTrend')

// Keltner Channel plots - only visible when Keltner is selected
plot(channelType == 'Keltner' ? kc_long_basis : na, color = #3e3e55, title = 'KC Long Basis')
p1_long = plot(channelType == 'Keltner' ? kc_long_upper : na, color = #8f6363, title = 'KC Long Upper')
p2_long = plot(channelType == 'Keltner' ? kc_long_lower : na, color = color.green, title = 'KC Long Lower')
plot(channelType == 'Keltner' ? kc_short_basis : na, color = #1f1f3f, style = plot.style_cross, title = 'KC Short Basis')
p1_short = plot(channelType == 'Keltner' ? kc_short_upper : na, color = #e98222, style = plot.style_cross, title = 'KC Short Upper')
p2_short = plot(channelType == 'Keltner' ? kc_short_lower : na, color = #2ee42e, style = plot.style_cross, title = 'KC Short Lower')

// Fill Keltner Channels
fill(p1_long, p2_long, color = channelType == 'Keltner' ? color.new(color.yellow, 90) : na, title = 'Long Keltner Channel Fill')
fill(p1_short, p2_short, color = channelType == 'Keltner' ? color.new(color.purple, 90) : na, title = 'Short Keltner Channel Fill')

// KEMAD visualization - moved to global scope
// Color pairs based on selected color mode
p_kemad_ema = plot(useKemadFilter and showKemadVisuals ? kemadEma : na, title = 'KEMAD EMA', color = kemadTrendColor, linewidth = 2, style = plot.style_line)
p_kemad_price = plot(useKemadFilter and showKemadVisuals ? hl2 : na, title = 'KEMAD Price Ref', display = display.none)
fill(p_kemad_ema, p_kemad_price, color = useKemadFilter and showKemadVisuals ? color.new(kemadTrendColor, 80) : na)

// MLMA plots - Long - only visible when MLMA is selected
plot_long_out = plot(channelType == 'MLMA' ? ml_long_out : na, 'MLMA Long', color = ml_long_BullCss, linewidth = 2)
plot(channelType == 'MLMA' and ml_long_trend != ml_long_trend[1] ? ml_long_out : na, 'MLMA Long Signal', ml_long_BullCss, 3, plot.style_circles)
plot_long_upper = plot(channelType == 'MLMA' ? ml_long_upper : na, 'MLMA Long Upper', color = color.new(ml_long_UpCss, 0), linewidth = 1)
plot_long_lower = plot(channelType == 'MLMA' ? ml_long_lower : na, 'MLMA Long Lower', color = color.new(ml_long_DnCss, 0), linewidth = 1)

// Fill MLMA Long bands
fill(plot_long_upper, plot_long_out, color = channelType == 'MLMA' ? color.new(ml_long_UpCss, 80) : na, title = 'MLMA Long Upper Band Fill')
fill(plot_long_out, plot_long_lower, color = channelType == 'MLMA' ? color.new(ml_long_DnCss, 80) : na, title = 'MLMA Long Lower Band Fill')

// MLMA plots - Short - only visible when MLMA is selected
plot_short_out = plot(channelType == 'MLMA' ? ml_short_out : na, 'MLMA Short', color = ml_short_BearCss, linewidth = 2, style = plot.style_cross)
plot(channelType == 'MLMA' and ml_short_trend != ml_short_trend[1] ? ml_short_out : na, 'MLMA Short Signal', ml_short_BearCss, 3, plot.style_circles)
plot_short_upper = plot(channelType == 'MLMA' ? ml_short_upper : na, 'MLMA Short Upper', color = color.new(ml_short_UpCss, 0), linewidth = 1, style = plot.style_cross)
plot_short_lower = plot(channelType == 'MLMA' ? ml_short_lower : na, 'MLMA Short Lower', color = color.new(ml_short_DnCss, 0), linewidth = 1, style = plot.style_cross)

// Fill MLMA Short bands
fill(plot_short_upper, plot_short_out, color = channelType == 'MLMA' ? color.new(ml_short_UpCss, 80) : na, title = 'MLMA Short Upper Band Fill')
fill(plot_short_out, plot_short_lower, color = channelType == 'MLMA' ? color.new(ml_short_DnCss, 80) : na, title = 'MLMA Short Lower Band Fill')

// Plot WMA
plot(useWmaVisual ? wmaValue1 : na, title = 'WMA Value #1', linewidth = 2, color = #2a143f)

L1 = plot(showRiskReward and strategy.position_size > 0 ? trackEnterPrice : na, color = color.green, linewidth = 1, style = plot.style_linebr, title = 'Long Entry Price')
L2 = plot(showRiskReward and strategy.position_size > 0 ? ta.highest(high, 3) * (1 - trailingStopPercent / 100.0) : na, color = color.green, linewidth = 1, style = plot.style_linebr, title = 'Long Trail Price')
L3 = plot(showRiskReward and strategy.position_size > 0 ? trackEnterPrice * (1 - stopLossPercent / 100.0) : na, color = color.red, linewidth = 1, style = plot.style_linebr, title = 'Long Stop-Loss Price')
fill(L1, L2, color = color.new(color.green, 90), title = 'Long Take-Profit Background Fill')
fill(L1, L3, color = color.new(color.red, 90), title = 'Long Stop-Loss Background Fill')

S1 = plot(showRiskReward and strategy.position_size < 0 ? trackEnterPrice : na, color = color.teal, linewidth = 1, style = plot.style_linebr, title = 'Short Entry Price')
S2 = plot(showRiskReward and strategy.position_size < 0 ? ta.lowest(low, 3) * (1 + trailingStopPercent / 100.0) : na, color = color.teal, linewidth = 1, style = plot.style_linebr, title = 'Short Trail Price')
S3 = plot(showRiskReward and strategy.position_size < 0 ? trackEnterPrice * (1 + stopLossPercent / 100.0) : na, color = color.maroon, linewidth = 1, style = plot.style_linebr, title = 'Short Stop-Loss Price')
fill(S1, S2, color = color.new(color.teal, 90), title = 'Short Take-Profit Background Fill')
fill(S1, S3, color = color.new(color.maroon, 90), title = 'Short Stop-Loss Background Fill')