//@version=5
strategy("Long/Short/Exit/Risk management Strategy ", overlay=true, process_orders_on_close=false)

// ##################
// General Settings
// ##################
g_general = "General Settings"
tradingDirection = input.string(defval="All", title="Trading Direction", options=["Long Only", "Short Only", "All"], group=g_general)
maxTradesPerDay = input.int(defval=3, title="Max Trades Per Day", minval=1, group=g_general)
barsToWait = input.int(defval=10, title="Bars Between Trades", minval=1, tooltip="Minimum number of bars to wait before taking another trade", group=g_general)

// ##################
// Session Settings
// ##################
g_session = "Session Settings"
x_cona_name = input.string('', 'Name', tooltip='The name added here will show up in the indicator\'s arguments on the chart.', group=g_session)
x_cona_tz = input.string('', 'Time Zone', tooltip='Leave blank for exchange time zone.', group=g_session)
x_cona_sess_use = input.bool(true, 'Session', inline='SESS', group=g_session)
x_cona_sess = input.session('0930-1300', '', inline='SESS', group=g_session)
x_cona_freq = input.string('Once Per Bar', 'Trigger', ['Once Per Bar', 'Once Per Bar Close', 'All'], group=g_session)
x_cona_expr_use = input.bool(false, 'Expiration', inline='EXPR', group=g_session)
x_cona_expr = input.time(timestamp('January 1, 2024'), '', inline='EXPR', group=g_session)

x_cona_mark_show = input.bool(true, 'Show Condition Markers', group='Design')
x_cona_conf_show = input.bool(true, 'Show Confluence Marker', group='Design')
x_cona_sess_show = input.bool(true, 'Highlight Session', group='Design')

// Session function
isWithinSession(sess) =>
    not na(sess) and na(x_cona_tz) ? time(timeframe.period, sess) : time(timeframe.period, sess, x_cona_tz)

// Check if current bar is within session
inValidSession = isWithinSession(x_cona_sess)

// ##################
// Table Settings
// ##################
g_table = "Table Settings"
tableSize = input.string("Medium", "Table Size", options=["Small", "Medium", "Large"], group=g_table)
tableLocation = input.string("Top-Right", "Table Location", options=["Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"], group=g_table)
tablePadding = input.int(5, "Text Padding Spaces", minval=1, maxval=10, group=g_table)
showPerfTable = input.bool(true, "Show Performance Table", group=g_table)
perfTableLocation = input.string("Bottom-Left", "Performance Table Location", options=["Top-Left", "Top-Right", "Bottom-Left", "Bottom-Right"], group=g_table)

// ##################
// Contract Settings
// ##################
g_contract = "Contract Settings"
contractType = input.string("MNQ", "Contract Type", options=["MNQ", "MES", "NQ", "ES", "Other"], tooltip="Select your futures contract for correct P&L calculation", group=g_contract)
pointValue = input.float(2.0, "Point Value ($)", minval=0.1, step=0.1, tooltip="Dollar value per point (MNQ=2, MES=5, NQ=20, ES=50)", group=g_contract)
tickSize = input.float(0.25, "Tick Size", minval=0.01, step=0.01, tooltip="Minimum price movement (MNQ/NQ=0.25, MES/ES=0.25)", group=g_contract)

// ##################
// Risk Management
// ##################
g_risk = "Risk Management"
riskType = input.string("Percentage", "Risk Type", options=["Percentage", "ATR", "Points"], group=g_risk)
stopLoss = input.float(2.0, "Stop Loss %", minval=0.1, step=0.1, group=g_risk)
takeProfit = input.float(3.0, "Take Profit %", minval=0.1, step=0.1, group=g_risk)
stopLossPoints = input.float(10.0, "Stop Loss (Points)", minval=0.1, step=0.1, group=g_risk)
takeProfitPoints = input.float(15.0, "Take Profit (Points)", minval=0.1, step=0.1, group=g_risk)
useTimeExit = input.bool(false, "Use Time Exit as Backup", group=g_risk)
exitBars = input.int(10, "Exit after N bars if no SL/TP hit", minval=1, group=g_risk)

// ATR Settings
atrPeriod = input.int(14, "ATR Period", minval=1, group=g_risk)
atrMultiplierSL = input.float(2.0, "ATR Multiplier for SL", minval=0.1, step=0.1, group=g_risk)
atrMultiplierTP = input.float(3.0, "ATR Multiplier for TP", minval=0.1, step=0.1, group=g_risk)

// Trailing Stop Settings
useTrailingStop = input.bool(false, "Use Trailing Stop", group=g_risk)
trailPoints = input.float(5.0, "Trailing Stop (Points)", minval=0.1, step=0.1, group=g_risk)
activateTrailAtPoints = input.float(10.0, "Activate Trailing at Points Profit", minval=0.1, step=0.1, group=g_risk)

// Break Even Settings
useBreakEven = input.bool(false, "Use Break Even", group=g_risk)
breakEvenAtPoints = input.float(10.0, "Move to Break Even at Points Profit", minval=0.1, step=0.1, group=g_risk)
breakEvenOffset = input.float(0.1, "Break Even Offset (Points)", minval=0.0, step=0.1, tooltip="Small offset beyond entry price to secure profit", group=g_risk)

// Partial Profit Taking
usePartialTP = input.bool(false, "Use Partial Profit Taking", group=g_risk)
partialTP1Points = input.float(5.0, "First Partial TP (Points)", minval=0.5, step=0.5, tooltip="Points distance from entry for first partial take profit", group=g_risk)
partialTP1Size = input.float(50.0, "First Partial TP Size (%)", minval=10.0, maxval=90.0, step=10.0, group=g_risk)
partialTP2Points = input.float(10.0, "Second Partial TP (Points)", minval=1.0, step=0.5, tooltip="Points distance from entry for second partial take profit", group=g_risk)
partialTP2Size = input.float(25.0, "Second Partial TP Size (%)", minval=10.0, maxval=80.0, step=10.0, group=g_risk)

// Streak Cutoff Settings
useStreakCutoff = input.bool(false, "Use Streak Cutoff", group=g_risk)
maxWinStreak = input.int(3, "Max Winning Streak", minval=1, maxval=10, tooltip="Stop trading after this many wins in lookback window", group=g_risk)
maxLossStreak = input.int(3, "Max Losing Streak", minval=1, maxval=10, tooltip="Stop trading after this many losses in lookback window", group=g_risk)
streakLookback = input.int(10, "Streak Lookback Bars", minval=1, maxval=100, tooltip="Number of closed trades to look back for streak counting", group=g_risk)
streakResetDaily = input.bool(true, "Reset Streak Daily", tooltip="Reset win/loss streak counters at start of each day", group=g_risk)

// ##################
// Trading Conditions
// ##################
g_cond1 = "Trading Conditions"
longSrc1 = input.source(close, "Long Source", group=g_cond1)
longValue1 = input.float(0, "Long Value", group=g_cond1)
longEvent1 = input.string("Equals", "Long Event", options=["Equals"], tooltip="Signal will trigger when source equals the value", group=g_cond1)
shortSrc1 = input.source(close, "Short Source", group=g_cond1)
shortValue1 = input.float(0, "Short Value", group=g_cond1)
shortEvent1 = input.string("Equals", "Short Event", options=["Equals"], tooltip="Signal will trigger when source equals the value", group=g_cond1)

// ##################
// Variable Initialization
// ##################
var int tradesToday = 0
var int barsSinceLastTrade = barsToWait
var float entryPrice = na
var int tradeBarCount = 0
var string exitType = na
var bool isExiting = false
var float trailStopPrice = na
var float bestPrice = na
var bool trailingActive = false
var bool partialTP1Hit = false
var bool partialTP2Hit = false
var bool breakEvenSet = false

// Performance tracking variables
var int totalTrades = 0
var int winningTrades = 0
var int losingTrades = 0
var float totalPnL = 0.0
var float grossProfit = 0.0
var float grossLoss = 0.0
var float largestWin = 0.0
var float largestLoss = 0.0
var float currentTradePnL = 0.0

// Streak tracking variables
var int[] tradeResults = array.new_int()  // 1 for win, -1 for loss
var bool streakCutoffActive = false

// Calculate ATR
atr = ta.atr(atrPeriod)

// Signal timing variables
var string displaySignal = "NONE"
var int signalStartTime = 0
var bool signalActive = false
var bool longSignal = false
var bool shortSignal = false
float signalDuration = 5000  // 5 seconds in milliseconds

// Reset trade counter and streaks at day start
if dayofweek != dayofweek[1]
    tradesToday := 0
    if streakResetDaily
        array.clear(tradeResults)
        streakCutoffActive := false

// Table position mapping
tablePosition = switch tableLocation
    "Top-Left" => position.top_left
    "Top-Right" => position.top_right
    "Bottom-Left" => position.bottom_left
    "Bottom-Right" => position.bottom_right

perfTablePosition = switch perfTableLocation
    "Top-Left" => position.top_left
    "Top-Right" => position.top_right
    "Bottom-Left" => position.bottom_left
    "Bottom-Right" => position.bottom_right

// Set contract specifications based on selection
contractPointValue = switch contractType
    "MNQ" => 2.0
    "MES" => 5.0
    "NQ" => 20.0
    "ES" => 50.0
    => pointValue

// Table text size mapping
textSize = switch tableSize
    "Small" => size.small
    "Medium" => size.normal
    "Large" => size.huge

// Function to create padding string
f_getPadding(n) => str.repeat(" ", n)

// Get padding at initialization
var string paddingSpaces = f_getPadding(tablePadding)

// Table initialization
var signalTable = table.new(tablePosition, 2, 1, border_width = 2, frame_color = color.black, bgcolor = color.white)
var perfTable = table.new(perfTablePosition, 2, 8, border_width = 2, frame_color = color.black, bgcolor = color.white)

// Initialize table cells with padding
if barstate.isfirst
    table.cell(signalTable, 0, 0, "\n" + paddingSpaces + "SIGNAL" + paddingSpaces + "\n", text_color = color.white, text_size = textSize, bgcolor = color.gray)
    table.cell(signalTable, 1, 0, "\n" + paddingSpaces + "NONE" + paddingSpaces + "\n", text_color = color.black, text_size = textSize, bgcolor = color.white)
      // Initialize performance table
    if showPerfTable
        table.cell(perfTable, 0, 0, "PERFORMANCE", text_color = color.white, text_size = textSize, bgcolor = color.gray)
        table.cell(perfTable, 1, 0, contractType, text_color = color.white, text_size = textSize, bgcolor = color.gray)
        table.cell(perfTable, 0, 1, "Total Trades", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 1, "0", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 2, "Win Rate %", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 2, "0.00", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 3, "Total P&L $", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 3, "$0.00", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 4, "Gross Profit $", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 4, "$0.00", text_color = color.green, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 5, "Gross Loss $", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 5, "$0.00", text_color = color.red, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 6, "Largest Win $", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 6, "$0.00", text_color = color.green, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 0, 7, "Largest Loss $", text_color = color.black, text_size = textSize, bgcolor = color.white)
        table.cell(perfTable, 1, 7, "$0.00", text_color = color.red, text_size = textSize, bgcolor = color.white)

// Calculate conditions
longCondition = longSrc1 == longValue1

shortCondition = shortSrc1 == shortValue1

// Update bars since last trade counter
if strategy.position_size == 0
    barsSinceLastTrade += 1

// Track position changes to detect exits
isExitBar = strategy.position_size == 0 and strategy.position_size[1] != 0

// Check if trading is allowed
bool streakAllowsTrading = not useStreakCutoff or not streakCutoffActive
bool canTrade = tradesToday < maxTradesPerDay and barsSinceLastTrade >= barsToWait and (not x_cona_sess_use or inValidSession) and streakAllowsTrading

// Reset variables on new trades
if (strategy.position_size != 0 and strategy.position_size[1] == 0)
    entryPrice := close
    tradeBarCount := 0
    exitType := na
    tradesToday += 1
    bestPrice := na
    trailingActive := false
    partialTP1Hit := false
    partialTP2Hit := false
    breakEvenSet := false
    currentTradePnL := 0.0
    if useTrailingStop
        trailStopPrice := na

// Update bar count for active trades
if strategy.position_size != 0
    tradeBarCount += 1

// Calculate SL/TP levels
float stopLevel = 0.0
float profitLevel = 0.0
float partialTP1Price = 0.0
float partialTP2Price = 0.0

if strategy.position_size != 0
    if riskType == "Percentage"
        stopLevel := strategy.position_size > 0 ? entryPrice * (1 - stopLoss/100) : entryPrice * (1 + stopLoss/100)
        profitLevel := strategy.position_size > 0 ? entryPrice * (1 + takeProfit/100) : entryPrice * (1 - takeProfit/100)
    else if riskType == "ATR"
        stopLevel := strategy.position_size > 0 ? entryPrice - (atr * atrMultiplierSL) : entryPrice + (atr * atrMultiplierSL)
        profitLevel := strategy.position_size > 0 ? entryPrice + (atr * atrMultiplierTP) : entryPrice - (atr * atrMultiplierTP)
    else // Points
        stopLevel := strategy.position_size > 0 ? entryPrice - stopLossPoints : entryPrice + stopLossPoints
        profitLevel := strategy.position_size > 0 ? entryPrice + takeProfitPoints : entryPrice - takeProfitPoints    // Calculate partial TP levels if enabled
    if usePartialTP
        if strategy.position_size > 0
            partialTP1Price := entryPrice + partialTP1Points
            partialTP2Price := entryPrice + partialTP2Points
        else
            partialTP1Price := entryPrice - partialTP1Points
            partialTP2Price := entryPrice - partialTP2Points

    // Update best price achieved
    if strategy.position_size > 0
        bestPrice := na(bestPrice) ? high : math.max(bestPrice, high)
    else
        bestPrice := na(bestPrice) ? low : math.min(bestPrice, low)    // Calculate profit percentage achieved
    float currentProfit = 0.0
    float currentProfitPoints = 0.0
    if strategy.position_size > 0
        currentProfit := ((close - entryPrice) / entryPrice) * 100
        currentProfitPoints := (close - entryPrice)
    else
        currentProfit := ((entryPrice - close) / entryPrice) * 100
        currentProfitPoints := (entryPrice - close)

    // Move stop to break-even when points profit threshold is reached
    if useBreakEven and not breakEvenSet and currentProfitPoints >= breakEvenAtPoints
        breakEvenSet := true
        if strategy.position_size > 0
            stopLevel := entryPrice + breakEvenOffset
        else
            stopLevel := entryPrice - breakEvenOffset
        displaySignal := "BREAK EVEN"
        signalStartTime := timenow
        signalActive := true

    // Activate trailing stop when points profit threshold is reached
    if useTrailingStop and not trailingActive and currentProfitPoints >= activateTrailAtPoints
        trailingActive := true
        if strategy.position_size > 0
            trailStopPrice := high - trailPoints
        else
            trailStopPrice := low + trailPoints
        displaySignal := "TRAILING STARTED"
        signalStartTime := timenow
        signalActive := true

    // Update trailing stop if active (but don't override break-even unless trailing is better)
    if useTrailingStop and trailingActive
        if strategy.position_size > 0  // Long position
            newTrailStop = high - trailPoints
            trailStopPrice := math.max(trailStopPrice, newTrailStop)
            if not breakEvenSet or trailStopPrice > stopLevel
                stopLevel := trailStopPrice
        else  // Short position
            newTrailStop = low + trailPoints
            trailStopPrice := math.min(trailStopPrice, newTrailStop)
            if not breakEvenSet or trailStopPrice < stopLevel
                stopLevel := trailStopPrice

// Check for different exit types
if (strategy.position_size != 0)
    bool slHit = false
    bool tpHit = false

    if strategy.position_size > 0  // Long position
        slHit := low <= stopLevel
        tpHit := high >= profitLevel
    else  // Short position
        slHit := high >= stopLevel
        tpHit := low <= profitLevel

    // Handle partial profit taking
    if usePartialTP and not partialTP1Hit
        bool partialTP1Reached = false
        if strategy.position_size > 0
            partialTP1Reached := high >= partialTP1Price
        else
            partialTP1Reached := low <= partialTP1Price

        if partialTP1Reached
            strategy.close("Long", qty_percent=partialTP1Size, comment="Partial TP1")
            strategy.close("Short", qty_percent=partialTP1Size, comment="Partial TP1")
            partialTP1Hit := true
            displaySignal := "PARTIAL EXIT"
            signalStartTime := timenow
            signalActive := true

    if usePartialTP and partialTP1Hit and not partialTP2Hit
        bool partialTP2Reached = false
        if strategy.position_size > 0
            partialTP2Reached := high >= partialTP2Price
        else
            partialTP2Reached := low <= partialTP2Price

        if partialTP2Reached
            strategy.close("Long", qty_percent=partialTP2Size, comment="Partial TP2")
            strategy.close("Short", qty_percent=partialTP2Size, comment="Partial TP2")
            partialTP2Hit := true
            displaySignal := "PARTIAL EXIT"
            signalStartTime := timenow
            signalActive := true

    if slHit
        strategy.close_all("SL Exit")
        exitType := "SL EXIT"
        displaySignal := "EXIT"
        signalStartTime := timenow
        signalActive := true
    else if tpHit
        strategy.close_all("TP Exit")
        exitType := "TP EXIT"
        displaySignal := "EXIT"
        signalStartTime := timenow
        signalActive := true

// Time exit condition
timeExitCondition = useTimeExit and tradeBarCount >= exitBars

if (useTimeExit and timeExitCondition)
    strategy.close_all("Time Exit")
    exitType := "TIME EXIT"
    displaySignal := "EXIT"
    signalStartTime := timenow
    signalActive := true

// Detect any other type of exit
if isExitBar and na(exitType)
    exitType := "POSITION CLOSED"
    displaySignal := "EXIT"
    signalStartTime := timenow
    signalActive := true

// Reset trailing stop when position closes
if strategy.position_size == 0
    trailStopPrice := na
    bestPrice := na
    trailingActive := false
    partialTP1Hit := false
    partialTP2Hit := false
    breakEvenSet := false

// Track completed trades for performance stats
if isExitBar and not na(entryPrice)
    // Calculate trade P&L in points
    float tradePoints = 0.0
    if strategy.position_size[1] > 0  // Was long position
        tradePoints := close - entryPrice
    else  // Was short position
        tradePoints := entryPrice - close

    // Convert to dollars
    float tradePnLDollars = tradePoints * contractPointValue
      // Update statistics
    totalTrades += 1
    totalPnL += tradePnLDollars

    if tradePnLDollars > 0
        winningTrades += 1
        grossProfit += tradePnLDollars
        largestWin := math.max(largestWin, tradePnLDollars)
        // Update trade results array for win
        if useStreakCutoff
            array.unshift(tradeResults, 1)
    else
        losingTrades += 1
        grossLoss += math.abs(tradePnLDollars)
        largestLoss := math.min(largestLoss, tradePnLDollars)
        // Update trade results array for loss
        if useStreakCutoff
            array.unshift(tradeResults, -1)
    // Keep only lookback number of results
    if useStreakCutoff and array.size(tradeResults) > streakLookback
        array.pop(tradeResults)
    // Count wins/losses in lookback window
    if useStreakCutoff
        winCount = 0
        lossCount = 0
        for i = 0 to array.size(tradeResults) - 1
            val = array.get(tradeResults, i)
            if val == 1
                winCount += 1
            if val == -1
                lossCount += 1
        streakCutoffActive := (winCount >= maxWinStreak) or (lossCount >= maxLossStreak)

// First detect signals on close with trading direction filter
if barstate.isconfirmed
    longSignal := longCondition and canTrade and (tradingDirection != "Short Only")
    shortSignal := shortCondition and canTrade and (tradingDirection != "Long Only")

    int currentTime = timenow
    if signalActive and (currentTime - signalStartTime >= signalDuration)
        displaySignal := "NONE"
        signalActive := false

// Then execute trades on the next bar's open with trading direction filter
if barstate.isconfirmed[1]
    if (strategy.position_size == 0)
        if (longSignal[1] and tradingDirection != "Short Only")
            strategy.entry("Long", strategy.long)
            displaySignal := "BUY"
            signalStartTime := timenow
            signalActive := true
            barsSinceLastTrade := 0
        else if (shortSignal[1] and tradingDirection != "Long Only")
            strategy.entry("Short", strategy.short)
            displaySignal := "SELL"
            signalStartTime := timenow
            signalActive := true
            barsSinceLastTrade := 0

// Exit logic
if (strategy.position_size != 0)
    if strategy.position_size > 0
        strategy.exit("Long Exit", "Long", stop=stopLevel, limit=profitLevel)
    else
        strategy.exit("Short Exit", "Short", stop=stopLevel, limit=profitLevel)

// Debug label
if barstate.islast
    var label debugLabel = label.new(bar_index, high, text="", color=color.white, textcolor=color.black, style=label.style_label_lower_left)

    // Calculate current trade P&L if in position
    currentTradeText = ""
    if strategy.position_size != 0 and not na(entryPrice)
        float currentPoints = strategy.position_size > 0 ? close - entryPrice : entryPrice - close
        float currentPnLDollars = currentPoints * contractPointValue
        currentTradeText := "\nCurrent Trade: $" + str.tostring(currentPnLDollars, "#.##")

    label.set_text(debugLabel, "Signal: " + displaySignal + "\nExit Type: " + (na(exitType) ? "" : exitType) + currentTradeText)
    label.set_x(debugLabel, bar_index)
    label.set_y(debugLabel, high)

// Update signal table with padding
signalColor = switch displaySignal
    "BUY" => color.green
    "SELL" => color.red
    "EXIT" => color.orange
    "PARTIAL EXIT" => color.yellow
    "BREAK EVEN" => color.blue
    => color.white

signalTextColor = displaySignal == "NONE" ? color.black : color.white

table.cell(signalTable, 1, 0, "\n" + paddingSpaces + displaySignal + paddingSpaces + "\n", text_color = signalTextColor, text_size = textSize, bgcolor = signalColor)

// Update performance table
if showPerfTable
    winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0.0

    table.cell(perfTable, 1, 1, str.tostring(totalTrades), text_color = color.black, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 2, str.tostring(winRate, "#.##") + "%", text_color = winRate >= 50 ? color.green : color.red, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 3, "$" + str.tostring(totalPnL, "#.##"), text_color = totalPnL >= 0 ? color.green : color.red, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 4, "$" + str.tostring(grossProfit, "#.##"), text_color = color.green, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 5, "$" + str.tostring(grossLoss, "#.##"), text_color = color.red, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 6, "$" + str.tostring(largestWin, "#.##"), text_color = color.green, text_size = textSize, bgcolor = color.white)
    table.cell(perfTable, 1, 7, "$" + str.tostring(largestLoss, "#.##"), text_color = color.red, text_size = textSize, bgcolor = color.white)

// Plot signals
plotshape(longSignal, "Long Signal", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(shortSignal, "Short Signal", shape.triangledown, location.abovebar, color.red, size=size.small)
plotshape(barstate.isconfirmed and timeExitCondition, "Time Exit Signal", shape.xcross, location.abovebar, color.blue, size=size.small)
plotshape(useBreakEven and breakEvenSet and breakEvenSet[1] == false, "Break Even Set", shape.diamond, location.abovebar, color.blue, size=size.tiny)

// Plot SL/TP levels
plot(strategy.position_size != 0 ? stopLevel : na, "Stop Level", color.red, style=plot.style_linebr)
plot(strategy.position_size != 0 ? profitLevel : na, "Profit Level", color.green, style=plot.style_linebr)
plot(strategy.position_size != 0 ? entryPrice : na, "Entry Price", color.white, style=plot.style_linebr)
plot(strategy.position_size != 0 and useTrailingStop ? trailStopPrice : na, "Trailing Stop", color.yellow, style=plot.style_linebr)
plot(strategy.position_size != 0 and useBreakEven and breakEvenSet ? entryPrice + (entryPrice * breakEvenOffset / 100 * (strategy.position_size > 0 ? 1 : -1)) : na, "Break Even Level", color.new(color.blue, 30), style=plot.style_linebr)

// Plot partial TP levels
plot(strategy.position_size != 0 and usePartialTP and not partialTP1Hit ? partialTP1Price : na, "Partial TP1", color.new(color.lime, 50), style=plot.style_linebr)
plot(strategy.position_size != 0 and usePartialTP and not partialTP2Hit ? partialTP2Price : na, "Partial TP2", color.new(color.aqua, 50), style=plot.style_linebr)

// Plot best price tracking
plot(strategy.position_size != 0 ? bestPrice : na, "Best Price", color.new(color.orange, 70), style=plot.style_stepline)

// Highlight trading session
bgcolor(x_cona_sess_show and x_cona_sess_use and inValidSession ? color.new(color.blue, 90) : na)