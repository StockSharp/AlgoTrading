//@version=5
strategy(title = "hamster-bot MRS 2", overlay = true, default_qty_type = strategy.percent_of_equity, initial_capital = 100, default_qty_value = 30, pyramiding = 1, commission_value = 0.1, backtest_fill_limits_assumption = 1)
import TradingView/ta/7
info_options = "Options"

on_close = input(false, title = "Entry on close", inline=info_options, group=info_options)
OFFS = input.int(0, minval = 0, maxval = 1, title = "| Offset View", inline=info_options, group=info_options)
trade_offset = input.int(0, minval = 0, maxval = 1, title = "Trade", inline=info_options, group=info_options)
use_kalman_filter = input.bool(false, title="Use Kalman filter", group=info_options, tooltip = "Дополнительное сглаживание МА")

//MA Opening
info_opening = "MA Opening Long"
maopeningtyp_l = input.string("SMA", options=["SMA", "EMA", "GMA", "Harmonic_Mean", "TEMA", "DEMA", "ZLEMA", "WMA", "Hma", "Thma", "Ehma", "H", "L", "DMA", "ATR"], title = "", inline=info_opening, group=info_opening)
maopeningsrc_l = input.string("ohlc4", title = "", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"], inline=info_opening, group=info_opening)
maopeninglen_l = input.int(3, minval = 1, title = "", inline=info_opening, group=info_opening)
long1on    = input(true, title = "", inline = "long1")
long1shift = input.float(0.96, step = 0.005, title = "Long", inline = "long1")
long1lot   = input.int(100, minval = 0, maxval = 10000, step = 10, title = "Lot, %", inline = "long1")

info_opening_s = "MA Opening Short"
maopeningtyp_s = input.string("SMA", options=["SMA", "EMA", "GMA", "Harmonic_Mean", "TEMA", "DEMA", "ZLEMA", "WMA", "Hma", "Thma", "Ehma", "H", "L", "DMA", "ATR"], title = "", inline=info_opening_s, group=info_opening_s)
maopeningsrc_s = input.string("ohlc4", title = "", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"], inline=info_opening_s, group=info_opening_s)
maopeninglen_s = input.int(3, minval = 1, title = "", inline=info_opening_s, group=info_opening_s)
short1on    = input(true, title = "", inline = "short1")
short1shift = input.float(1.04, step = 0.005, title = "short", inline = "short1")
short1lot   = input.int(100, minval = 0, maxval = 10000, step = 10, title = "Lot, %", inline = "short1")


//MA Closing
info_closing = "MA Closing"
maclosingtyp = input.string("SMA", title="Type", options=["SMA", "EMA", "GMA", "Harmonic_Mean", "TEMA", "DEMA", "ZLEMA", "WMA", "Hma", "Thma", "Ehma", "H", "L", "DMA", "ATR"], title = "", inline=info_closing, group=info_closing)
maclosingsrc = input.string("ohlc4", title = "", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"], inline=info_closing, group=info_closing)
maclosinglen = input.int(3, minval = 1, maxval = 200, title = "", inline=info_closing, group=info_closing)
maclosingmul = input.float(1, step = 0.005, title = "mul", inline=info_closing, group=info_closing)

info_closing_sl = "MA SL"
maclosingSLuse = input.bool(false,"Use for LONG", group=info_closing_sl)
maclosingSLtyp = input.string("SMA", title="Type", options=["SMA", "EMA", "GMA", "Harmonic_Mean", "TEMA", "DEMA", "ZLEMA", "WMA", "Hma", "Thma", "Ehma", "H", "L", "DMA", "ATR"], title = "", inline=info_closing, group=info_closing_sl)
maclosingSLsrc = input.string("ohlc4", title = "", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"], inline=info_closing, group=info_closing_sl)
maclosingSLlen = input.int(3, minval = 1, maxval = 200, title = "", inline=info_closing, group=info_closing_sl)
maclosingSLmul = input.float(0.90, step = 0.005, title = "mul", inline=info_closing, group=info_closing_sl)
info_closing_sl_short = "MA SL short"
maclosingSL_short_use = input.bool(false,"Use for SHORT", group=info_closing_sl)
maclosingSL_short_typ = input.string("SMA", title="Type", options=["SMA", "EMA", "GMA", "Harmonic_Mean", "TEMA", "DEMA", "ZLEMA", "WMA", "Hma", "Thma", "Ehma", "H", "L", "DMA", "ATR"], title = "", inline=info_closing_sl_short, group=info_closing_sl)
maclosingSL_short_src = input.string("ohlc4", title = "", options = ["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"], inline=info_closing_sl_short, group=info_closing_sl)
maclosingSL_short_len = input.int(3, minval = 1, maxval = 200, title = "", inline=info_closing_sl_short, group=info_closing_sl)
maclosingSL_short_mul = input.float(1.10, step = 0.005, title = "mul", inline=info_closing_sl_short, group=info_closing_sl)

startTime = input.time(timestamp("01 Jan 2010 00:00 +0000"), "Start date", inline = "period")
finalTime = input.time(timestamp("31 Dec 2030 23:59 +0000"), "Final date", inline = "period")

distance_filter = input.float(0, step = 0.005, title = "distance_filter")
pump_filter = input.bool(false, title = "pump_filter 1", inline = "pump_filter", tooltip = "Экспериментальная функция")
pump_filter_src = input.source(ohlc4, title = "", inline = "pump_filter")
pump_filter_offset = input.int(1, minval=0,title="offset", inline = "pump_filter")
pump_filter_2 = input.bool(false, title = "pump_filter 2", inline = "pump_filter2", tooltip = "Экспериментальная функция. Если Максимум за N свечей назад более чем на X больше минимума")
pump_filter_2_count = input.int(100, minval=0,title="count candles", inline = "pump_filter2")
pump_filter_2_value = input.float(1.5, minval=0,title="value mul (1.5 = 50%)", inline = "pump_filter2")

pine_gma(x, y) =>
    mum = 1.0
    for i = 0 to y - 1
        mum := mum * x[i]
    gma = math.pow(mum,1/y)
    gma
pine_Harmonic_Mean(x, y) =>
    sum = 0.0
    for i = 0 to y - 1
        sum := sum + 1/x[i]
    harm = y/sum
    harm
HMA(_src, _length) =>  ta.wma(2 * ta.wma(_src, _length / 2) - ta.wma(_src, _length), math.round(math.sqrt(_length)))
EHMA(_src, _length) =>  ta.ema(2 * ta.ema(_src, _length / 2) - ta.ema(_src, _length), math.round(math.sqrt(_length)))
THMA(_src, _length) =>  ta.wma(ta.wma(_src,_length / 3) * 3 - ta.wma(_src, _length / 2) - ta.wma(_src, _length), _length)
tema(sec, length)=>
    tema1= ta.ema(sec, length)
    tema2= ta.ema(tema1, length)
    tema3= ta.ema(tema2, length)
    tema_r = 3*tema1-3*tema2+tema3
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
ATR_func(_src, _len)=>
    atrLow = low - ta.atr(_len)
    trailAtrLow = atrLow
    trailAtrLow := na(trailAtrLow[1]) ? trailAtrLow : atrLow >= trailAtrLow[1] ? atrLow : trailAtrLow[1]
    supportHit = _src <= trailAtrLow
    trailAtrLow := supportHit ? atrLow : trailAtrLow
    trailAtrLow
f_dema(src, len)=>
    EMA1 = ta.ema(src, len)
    EMA2 = ta.ema(EMA1, len)
    DEMA = (2*EMA1)-EMA2
f_zlema(src, period) =>
    lag = math.round((period - 1) / 2)
    ema_data = src + (src - src[lag])
    zl= ta.ema(ema_data, period)
f_kalman_filter(src) =>
    float value1= na
    float value2 = na
    value1 := 0.2 * (src - src[1]) + 0.8 * nz(value1[1])
    value2 := 0.1 * (ta.tr) + 0.8 * nz(value2[1])
    lambda = math.abs(value1 / value2)
    alpha = (-math.pow(lambda, 2) + math.sqrt(math.pow(lambda, 4) + 16 * math.pow(lambda, 2)))/8
    value3 = float(na)
    value3 := alpha * src + (1 - alpha) * nz(value3[1])
//SWITCH
//"open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4", "oc2"
get_src(src) =>
      src == "open" ? open :
      src == "high" ? high :
      src == "low" ? low :
      src == "close" ? close :
      src == "hl2" ? hl2 :
      src == "hlc3" ? hlc3 :
      src == "ohlc4" ? ohlc4 :
      src == "hlcc4" ? hlcc4 :
      src == "oc2" ? (open + close) / 2 : na


ma_func(modeSwitch, src, len, use_k_f=true) =>
      modeSwitch == "SMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.sma(src, len))  : ta.sma(src, len) :
      modeSwitch == "Harmonic_Mean"   ? use_kalman_filter and use_k_f ? f_kalman_filter(pine_Harmonic_Mean(src, len))  : pine_Harmonic_Mean(src, len) :
      modeSwitch == "GMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(pine_gma(src, len))  : pine_gma(src, len) :
      modeSwitch == "RMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.rma(src, len))  : ta.rma(src, len) :
      modeSwitch == "EMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.ema(src, len))  : ta.ema(src, len) :
      modeSwitch == "TEMA"  ? use_kalman_filter and use_k_f ? f_kalman_filter(tema(src, len))    : tema(src, len):
      modeSwitch == "DEMA"  ? use_kalman_filter and use_k_f ? f_kalman_filter(f_dema(src, len))  : f_dema(src, len):
      modeSwitch == "ZLEMA" ? use_kalman_filter and use_k_f ? f_kalman_filter(f_zlema(src, len)) : f_zlema(src, len):
      modeSwitch == "WMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.wma(src, len))  : ta.wma(src, len):
      modeSwitch == "VWMA"  ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.vwma(src, len)) : ta.vwma(src, len):
      modeSwitch == "Hma"   ? use_kalman_filter and use_k_f ? f_kalman_filter(HMA(src, len))     : HMA(src, len):
      modeSwitch == "Ehma"  ? use_kalman_filter and use_k_f ? f_kalman_filter(EHMA(src, len))    : EHMA(src, len):
      modeSwitch == "Thma"  ? use_kalman_filter and use_k_f ? f_kalman_filter(THMA(src, len/2))  : THMA(src, len/2):
      modeSwitch == "ATR"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ATR_func(src, len)): ATR_func(src, len) :
      modeSwitch == "L"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.lowest(len)): ta.lowest(len) :
      modeSwitch == "H"   ? use_kalman_filter and use_k_f ? f_kalman_filter(ta.highest(len)): ta.highest(len) :
      modeSwitch == "DMA"   ? use_kalman_filter and use_k_f ? f_kalman_filter(donchian(len)) : donchian(len) :
      modeSwitch == "ATR" ? use_kalman_filter and use_k_f ? f_kalman_filter(ATR_func(src, len)) : ATR_func(src, len) : na

//Var
sum = 0.0
maopening_l = 0.0
maopening_s = 0.0
maclosing = 0.0
maclosingSL_long = 0.0
maclosingSL_short = 0.0
pos = strategy.position_size
p = 0.0
p := pos == 0 ? (strategy.equity / 100) / close : p[1]
truetime = time > startTime and time < finalTime

//MA Opening
maopening_l := ma_func(maopeningtyp_l, get_src(maopeningsrc_l), maopeninglen_l)
maopening_s := ma_func(maopeningtyp_s, get_src(maopeningsrc_s), maopeninglen_s)

//MA Closing
maclosing := ma_func(maclosingtyp, get_src(maclosingsrc), maclosinglen) * maclosingmul
maclosingSL_long := ma_func(maclosingSLtyp, get_src(maclosingSLsrc), maclosingSLlen) * maclosingSLmul
maclosingSL_short := ma_func(maclosingSL_short_typ, get_src(maclosingSL_short_src), maclosingSL_short_len) * maclosingSL_short_mul

long1 = long1on == false ? 0 : long1shift == 0 ? 0 : long1lot == 0 ? 0 : maopening_l == 0 ? 0 : maopening_l * long1shift
short1 = short1on == false ? 0 : short1shift == 0 ? 0 : short1lot == 0 ? 0 : maopening_s == 0 ? 0 : maopening_s * short1shift
//Colors
long1col = long1 == 0 ? na : color.green
short1col = short1 == 0 ? na : color.red
//Lines
// plot(maopening_l, offset = OFFS, color = color.new(color.green, 50))
// plot(maopening_s, offset = OFFS, color = color.new(color.red, 50))
plot(maclosing, offset = OFFS, color = color.fuchsia)
plot(maclosingSL_long, offset = OFFS, color = color.fuchsia, display=maclosingSLuse ? display.all : display.none)
plot(maclosingSL_short, offset = OFFS, color = color.fuchsia, display=maclosingSL_short_use ? display.all : display.none)
long1line = long1 == 0 ? close : long1
short1line = short1 == 0 ? close : short1
plot(long1line, offset = OFFS, color = long1col)
plot(short1line, offset = OFFS, color = short1col)

//Lots
lotlong1 = p * long1lot
lotshort1 = p * short1lot

FILTER_DISABLE_TRADING = false
if distance_filter != 0 and long1 != 0 and math.abs(ta.changePercent(long1, maclosing)) < math.abs(distance_filter)
    FILTER_DISABLE_TRADING := true
if distance_filter != 0 and short1 != 0 and math.abs(ta.changePercent(maclosing, short1)) < math.abs(distance_filter)
    FILTER_DISABLE_TRADING := true

var float line_pump_filter = 0.0
line_pump_filter := ta.crossover(pump_filter_src, maclosing) ? maclosing[pump_filter_offset] : line_pump_filter[1]
plot(line_pump_filter, "line_pump_filter", color = pump_filter ? color.new(color.orange, 50) : color.new(color.orange, 100))


pump_filter_2_res = pump_filter_2 ? ta.lowest(pump_filter_2_count) * pump_filter_2_value < ta.highest(pump_filter_2_count) : false
barcolor(pump_filter_2_res ? color.white : na)

if (pump_filter and long1line > line_pump_filter) or (pump_filter_2 and pump_filter_2_res)
    FILTER_DISABLE_TRADING := true

//Entry
if truetime and not FILTER_DISABLE_TRADING
    //Long
    sum := 0
    strategy.entry("L", strategy.long, lotlong1, limit = on_close ? na : long1, when = long1 > 0 and pos <= sum and (on_close ? close <= long1[trade_offset] : true))
    sum := lotlong1

    //Short
    sum := 0
    pos := -1 * pos
    strategy.entry("S", strategy.short, lotshort1, limit = on_close ? na : short1, when = short1 > 0 and pos <= sum and (on_close ? close >= short1[trade_offset] : true))
    sum := lotshort1

if maclosingSLuse
    strategy.exit("Exit", "L", limit = maclosing, stop = maclosingSL_long)
else
    strategy.exit("Exit", "L", limit = maclosing)

if maclosingSL_short_use
    strategy.exit("Exit", "S", limit = maclosing, stop = maclosingSL_short)
else
    strategy.exit("Exit", "S", limit = maclosing)

if time > finalTime or FILTER_DISABLE_TRADING
    strategy.close_all()
    strategy.cancel_all()