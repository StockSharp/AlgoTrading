// Â© IkkeOmar

//@version=5

strategy(title='Trend Deviation strategy - BTC [IkkeOmar]', overlay=true, default_qty_type  = strategy.percent_of_equity , pyramiding=1 , initial_capital = 1000 , default_qty_value = 100)

src = input(close, title="Source")

// INPUTS: ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//DMI input

len2 = input.int(15, minval=1, title="DI Length", group="DMI - Confluence 1")

// BB inputs
BB_Length = input.int(13, minval=1, group="BBANDS - Confluence 2")
mult = input.float(2.3, title="BB Mult",minval=0.001, maxval=50, group="BBANDS - Confluence 2")

//STC Inputs
EEEEEE = input(14, 'LengthSTC', group="STC")
BBBB = input(25, 'FastLengthSTC', group="STC")
BBBBB = input(60, 'SlowLengthSTC', group="STC")


// MACD inputs:
MACD_Fast_Length = input(15, group="MACD")
MACD_Slow_Length = input(200, group="MACD")
MACD_Length = input(25, group="MACD")

// Momentum input
length4 = input.int(10, title="Momentum Length", minval=1, group="Momentum Indicator")

//AROON Input
AROON_Length = input.int(5, minval=1, group="AROON")

//Trend inputs
atrPeriod = input(200, "Trendline Length", group="Trendline Indicator")
factor = input.float(2, "Trendline Factor", step = 0.01, group="Trendline Indicator")


// CALCULATIONS: ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// DMI
lensig2 = 34
up2 = ta.change(high)
down2 = -ta.change(low)
plusDM2 = na(up2) ? na : (up2 > down2 and up2 > 0 ? up2 : 0)
minusDM2 = na(down2) ? na : (down2 > up2 and down2 > 0 ? down2 : 0)
trur2 = ta.rma(ta.tr, len2)
plus2 = fixnan(100 * ta.rma(plusDM2, len2) / trur2)
minus2 = fixnan(100 * ta.rma(minusDM2, len2) / trur2)
sum2 = plus2 + minus2
adx2 = 100 * ta.rma(math.abs(plus2 - minus2) / (sum2 == 0 ? 1 : sum2), lensig2)

dmi_long =  ((plus2 > adx2) and (adx2 > 20) and (plus2 > 20))   or (((adx2 > adx2[1]) and (adx2[1] > adx2[2])) and (plus2 > adx2) and (adx2 >20)) or ((ta.crossover(plus2, minus2) and adx2 > 40)) or ((adx2 > 30) and (minus2 < plus2) and (plus2 > 25))
dmi_up = ((plus2[0] > plus2[1]) and (plus2[0] > plus2[2]) and (plus2[0] > plus2[3])) and ((adx2 > adx2[1]) and (adx2[1] > adx2[2]) and (adx2[2] > adx2[3]))
dmi_cross_up = ta.crossover(plus2, minus2)
dmi_bottom = (adx2 > 55) and (minus2 > 40) and (plus2 <15)
dmi_short = ((ta.crossover(minus2, plus2) and adx2 > 20)) or ((adx2 > 32) and (minus2 > plus2)) or ((minus2 > adx2) and (adx2 > 40) and (minus2 > 25))  or (((adx2 > adx2[1]) and (adx2[1] > adx2[2])) and (minus2 > adx2) and (adx2 > 25)) or ((minus2 > plus2) and (adx2 >30))
dmi_down = ((minus2[0] > minus2[1]) and (minus2[0] > minus2[2]) and (minus2[0] > minus2[3])) and ((adx2 > adx2[1]) and (adx2[1] > adx2[2]) and (adx2[2] > adx2[3]))
dmi_cross_down = ta.crossover(minus2, plus2)
dmi_top = (adx2 > 55) and (plus2 > 40) and (minus2 <15)


//Bolinger Bands
source = hlc3
basis = ta.sma(source, BB_Length)
dev = mult * ta.stdev(source, BB_Length)
upper = basis + dev
lower = basis - dev
bblong = source < upper
bbshort = source > lower


// Aroon
AROONupper = 100 * (ta.highestbars(high, AROON_Length+1) + AROON_Length)/AROON_Length
AROONlower = 100 * (ta.lowestbars(low, AROON_Length+1) + AROON_Length)/AROON_Length

aroon_bull = ta.crossover(AROONupper, AROONlower)
aroon_bear = ta.crossunder(AROONupper, AROONlower)
aroon_long = AROONlower > AROONupper
aroon_short = AROONlower < AROONupper

// STC
AAAA(BBB, BBBB, BBBBB) =>
    fastMA = ta.ema(BBB, BBBB)
    slowMA = ta.ema(BBB, BBBBB)
    AAAA = fastMA - slowMA
    AAAA

AAAAA(EEEEEE, BBBB, BBBBB) =>
    AAA = input(1.5, title="STC Factor", group="STC")
    var CCCCC = 0.0
    var DDD = 0.0
    var DDDDDD = 0.0
    var EEEEE = 0.0
    BBBBBB = AAAA(close, BBBB, BBBBB)
    CCC = ta.lowest(BBBBBB, EEEEEE)
    CCCC = ta.highest(BBBBBB, EEEEEE) - CCC
    CCCCC := CCCC > 0 ? (BBBBBB - CCC) / CCCC * 100 : nz(CCCCC[1])
    DDD := na(DDD[1]) ? CCCCC : DDD[1] + AAA * (CCCCC - DDD[1])
    DDDD = ta.lowest(DDD, EEEEEE)
    DDDDD = ta.highest(DDD, EEEEEE) - DDDD
    DDDDDD := DDDDD > 0 ? (DDD - DDDD) / DDDDD * 100 : nz(DDDDDD[1])
    EEEEE := na(EEEEE[1]) ? DDDDDD : EEEEE[1] + AAA * (DDDDDD - EEEEE[1])
    EEEEE

mAAAAA = AAAAA(EEEEEE, BBBB, BBBBB)


stc_short = (mAAAAA[3] <= mAAAAA[2]) and (mAAAAA[2] >= mAAAAA[1]) and (mAAAAA > 40)
stc_long = (mAAAAA[3] >= mAAAAA[2]) and (mAAAAA[2] <= mAAAAA[1]) and (mAAAAA < 60)

stc_low = mAAAAA < 25
stc_high = mAAAAA > 75



// MACD
MACD = ta.ema(close, MACD_Fast_Length) - ta.ema(close, MACD_Slow_Length)
aMACD = ta.ema(MACD, MACD_Length)
delta = MACD - aMACD

macd_long = MACD > aMACD
macd_short = MACD < aMACD


// Momentum
price = close
momentum(seria, length4) =>
    mom = seria - seria[length4]
    mom
mom0 = momentum(price, length4)
mom1 = momentum( mom0, 1)
mom_long = (mom0 > 0 and mom1 > 0)


mom_short = (mom0 < 0 and mom1 < 0)


// Trend
[_, direction] = ta.supertrend(factor, atrPeriod)

trendlong = ta.change(direction) < 0


trendshort = ta.change(direction) > 0

//RSI
//RSI_Length = input.int(14, minval=1, group="RSI - Confluence 3")
rsi = ta.rsi(close, 14)
rsi_over_sold = rsi < 37
rsi_over_bought = rsi > 60
rsi_high = rsi > 50
rsi_low = rsi < 50

//EMA
fastEMA = ta.ema(close, 26)
slowEMA = ta.ema(hlc3, 200)
ema_long = fastEMA > slowEMA
ema_short = fastEMA < slowEMA
slow_ema_long = slowEMA > src
slow_ema_short = slowEMA < src

//VWAP
vwap = ta.vwap(close)
vwap_long = vwap > src
vwap_short = vwap < src














// CONDITIONS: ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// Options that configure the backtest start date
startDate = input.time(title='Start Date', defval=timestamp('01 Jan 2018 00:00'))


// Option to select trade directions
tradeDirection = input.string(title='Trade Direction', options=['Long', 'Short', 'Both'], defval='Long')

// Translate input into trading conditions
longOK = tradeDirection == 'Long' or tradeDirection == 'Both'
shortOK = tradeDirection == 'Short' or tradeDirection == 'Both'


// Check if the close time of the current bar falls inside the date range
inDateRange = time >= startDate


longCondition = dmi_cross_up and bblong and (mom_long or macd_long or trendlong or stc_long or stc_low or aroon_long or aroon_bull)


shortCondition = dmi_cross_down and bbshort and (mom_short or macd_short or trendshort or stc_short or stc_high or aroon_short or aroon_bear)



if time >= startDate and longCondition
    strategy.entry("long", strategy.long, when = longCondition)

if time >= startDate and shortCondition
    strategy.entry("short", strategy.short, when = shortCondition)